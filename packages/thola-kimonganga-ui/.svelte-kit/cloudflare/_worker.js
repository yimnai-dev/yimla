var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .svelte-kit/output/server/chunks/stringify.js
function is_primitive(thing) {
  return Object(thing) !== thing;
}
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i2 = 0; i2 < len; i2 += 1) {
    const char = str[i2];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i2) + replacement;
      last_pos = i2 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  for (const key2 in reducers) {
    custom2.push({ key: key2, fn: reducers[key2] });
  }
  const keys = [];
  let p2 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (indexes.has(thing))
      return indexes.get(thing);
    if (thing === void 0)
      return UNDEFINED;
    if (Number.isNaN(thing))
      return NAN;
    if (thing === Infinity)
      return POSITIVE_INFINITY;
    if (thing === -Infinity)
      return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0)
      return NEGATIVE_ZERO;
    const index22 = p2++;
    indexes.set(thing, index22);
    for (const { key: key2, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index22] = `["${key2}",${flatten(value2)}]`;
        return index22;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "RegExp":
          const { source: source2, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source2)},"${flags}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str = "[";
          for (let i2 = 0; i2 < thing.length; i2 += 1) {
            if (i2 > 0)
              str += ",";
            if (i2 in thing) {
              keys.push(`[${i2}]`);
              str += flatten(thing[i2]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            str += `,${flatten(key2)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(`.${key2}`);
              str += `,${stringify_string(key2)},${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started)
                str += ",";
              started = true;
              keys.push(`.${key2}`);
              str += `${stringify_string(key2)}:${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index22] = str;
    return index22;
  }
  const index21 = flatten(value);
  if (index21 < 0)
    return `${index21}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string")
    return stringify_string(thing);
  if (thing instanceof String)
    return stringify_string(thing.toString());
  if (thing === void 0)
    return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0)
    return NEGATIVE_ZERO.toString();
  if (type === "bigint")
    return `["BigInt","${thing}"]`;
  return String(thing);
}
var BROWSER, DEV, escaped, DevalueError, object_proto_names, UNDEFINED, HOLE, NAN, POSITIVE_INFINITY, NEGATIVE_INFINITY, NEGATIVE_ZERO;
var init_stringify = __esm({
  ".svelte-kit/output/server/chunks/stringify.js"() {
    BROWSER = false;
    DEV = false;
    escaped = {
      "<": "\\u003C",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    DevalueError = class extends Error {
      /**
       * @param {string} message
       * @param {string[]} keys
       */
      constructor(message, keys) {
        super(message);
        this.name = "DevalueError";
        this.path = keys.join("");
      }
    };
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
    UNDEFINED = -1;
    HOLE = -2;
    NAN = -3;
    POSITIVE_INFINITY = -4;
    NEGATIVE_INFINITY = -5;
    NEGATIVE_ZERO = -6;
  }
});

// .svelte-kit/output/server/chunks/index3.js
function run_all(arr) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    arr[i2]();
  }
}
function subscribe_to_store(store, run, invalidate) {
  if (store == null) {
    run(void 0);
    if (invalidate)
      invalidate(void 0);
    return noop;
  }
  const unsub = store.subscribe(
    run,
    // @ts-expect-error
    invalidate
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function lifecycle_outside_component(name2) {
  {
    throw new Error("lifecycle_outside_component");
  }
}
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last2 = 0;
  while (pattern2.test(str)) {
    const i2 = pattern2.lastIndex - 1;
    const ch = str[i2];
    escaped2 += str.substring(last2, i2) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last2 = i2 + 1;
  }
  return escaped2 + str.substring(last2);
}
function getContext(key2) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext(key2, context) {
  get_or_init_context_map().set(key2, context);
  return context;
}
function hasContext(key2) {
  return get_or_init_context_map().has(key2);
}
function get_or_init_context_map(name2) {
  if (current_component === null) {
    lifecycle_outside_component();
  }
  return current_component.c ??= new Map(get_parent_context(current_component) || void 0);
}
function push(fn) {
  current_component = { p: current_component, c: null, d: null };
}
function pop() {
  var component21 = (
    /** @type {import('#server').Component} */
    current_component
  );
  var ondestroy = component21.d;
  if (ondestroy) {
    on_destroy.push(...ondestroy);
  }
  current_component = component21.p;
}
function get_parent_context(component_context) {
  let parent2 = component_context.p;
  while (parent2 !== null) {
    const context_map = parent2.c;
    if (context_map !== null) {
      return context_map;
    }
    parent2 = parent2.p;
  }
  return null;
}
function create_payload() {
  return { out: "", head: { title: "", out: "", anchor: 0 }, anchor: 0 };
}
function copy_payload(to_copy) {
  return {
    ...to_copy,
    head: { ...to_copy.head }
  };
}
function assign_payload(p1, p2) {
  p1.out = p2.out;
  p1.head = p2.head;
  p1.anchor = p2.anchor;
}
function element(payload, tag, attributes_fn, children_fn) {
  payload.out += `<${tag} `;
  attributes_fn();
  payload.out += `>`;
  if (!VoidElements.has(tag)) {
    if (!RawTextElements.includes(tag)) {
      payload.out += BLOCK_OPEN;
    }
    children_fn();
    if (!RawTextElements.includes(tag)) {
      payload.out += BLOCK_CLOSE;
    }
    payload.out += `</${tag}>`;
  }
}
function render(component21, options2) {
  const payload = create_payload();
  const prev_on_destroy = on_destroy;
  on_destroy = [];
  payload.out += BLOCK_OPEN;
  if (options2.context) {
    push();
    current_component.c = options2.context;
  }
  component21(payload, options2.props, {}, {});
  if (options2.context) {
    pop();
  }
  payload.out += BLOCK_CLOSE;
  for (const cleanup of on_destroy)
    cleanup();
  on_destroy = prev_on_destroy;
  return {
    head: payload.head.out || payload.head.title ? payload.head.out + payload.head.title : "",
    html: payload.out
  };
}
function head(payload, fn) {
  const head_payload = payload.head;
  payload.head.out += BLOCK_OPEN;
  fn(head_payload);
  payload.head.out += BLOCK_CLOSE;
}
function attr(name2, value, boolean) {
  if (value == null || !value && boolean || value === "" && name2 === "class")
    return "";
  const assignment = boolean ? "" : `="${escape_html(value, true)}"`;
  return ` ${name2}${assignment}`;
}
function spread_attributes(attrs, classes, styles, flags = 0) {
  if (styles) {
    attrs.style = attrs.style ? style_object_to_string(merge_styles(
      /** @type {string} */
      attrs.style,
      styles
    )) : style_object_to_string(styles);
  }
  if (classes) {
    const classlist = attrs.class ? [attrs.class] : [];
    for (const key2 in classes) {
      if (classes[key2]) {
        classlist.push(key2);
      }
    }
    attrs.class = classlist.join(" ");
  }
  let attr_str = "";
  let name2;
  const is_html = (flags & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  for (name2 in attrs) {
    if (typeof attrs[name2] === "function")
      continue;
    if (name2[0] === "$" && name2[1] === "$")
      continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name2))
      continue;
    if (lowercase) {
      name2 = name2.toLowerCase();
    }
    const is_boolean = is_html && DOMBooleanAttributes.includes(name2);
    attr_str += attr(name2, attrs[name2], is_boolean);
  }
  return attr_str;
}
function spread_props(props) {
  const merged_props = {};
  let key2;
  for (let i2 = 0; i2 < props.length; i2++) {
    const obj = props[i2];
    for (key2 in obj) {
      merged_props[key2] = obj[key2];
    }
  }
  return merged_props;
}
function stringify2(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter(
    /** @param {any} key */
    (key2) => style_object[key2] != null && style_object[key2] !== ""
  ).map(
    /** @param {any} key */
    (key2) => `${key2}: ${escape_html(style_object[key2], true)};`
  ).join(" ");
}
function merge_styles(style_attribute, style_directive) {
  const style_object = {};
  for (const individual_style of style_attribute.split(";")) {
    const colon_index = individual_style.indexOf(":");
    const name2 = individual_style.slice(0, colon_index).trim();
    const value = individual_style.slice(colon_index + 1).trim();
    if (!name2)
      continue;
    style_object[name2] = value;
  }
  for (const name2 in style_directive) {
    const value = style_directive[name2];
    if (value) {
      style_object[name2] = value;
    } else {
      delete style_object[name2];
    }
  }
  return style_object;
}
function store_get(store_values, store_name, store) {
  if (store_name in store_values && store_values[store_name][0] === store) {
    return store_values[store_name][2];
  }
  store_values[store_name]?.[1]();
  store_values[store_name] = [store, null, void 0];
  const unsub = subscribe_to_store(
    store,
    /** @param {any} v */
    (v2) => store_values[store_name][2] = v2
  );
  store_values[store_name][1] = unsub;
  return store_values[store_name][2];
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function mutate_store(store_values, store_name, store, expression) {
  store_set(store, store_get(store_values, store_name, store));
  return expression;
}
function unsubscribe_stores(store_values) {
  for (const store_name in store_values) {
    store_values[store_name][1]();
  }
}
function value_or_fallback(value, fallback) {
  return value === void 0 ? fallback() : value;
}
function slot(payload, slot_fn, slot_props, fallback_fn) {
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn();
    }
  } else {
    slot_fn(payload, slot_props);
  }
}
function rest_props(props, rest) {
  const rest_props2 = {};
  let key2;
  for (key2 in props) {
    if (!rest.includes(key2)) {
      rest_props2[key2] = props[key2];
    }
  }
  return rest_props2;
}
function sanitize_props(props) {
  const { children, $$slots, ...sanitized } = props;
  return sanitized;
}
function bind_props(props_parent, props_now) {
  for (const key2 in props_now) {
    const initial_value = props_parent[key2];
    const value = props_now[key2];
    if (initial_value === void 0 && value !== void 0 && Object.getOwnPropertyDescriptor(props_parent, key2)?.set) {
      props_parent[key2] = value;
    }
  }
}
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
var noop, HYDRATION_START, HYDRATION_END, HYDRATION_ERROR, ELEMENT_IS_NAMESPACED, ELEMENT_PRESERVE_ATTRIBUTE_CASE, UNINITIALIZED, RawTextElements, PassiveDelegatedEvents, DOMBooleanAttributes, ATTR_REGEX, CONTENT_REGEX, current_component, BLOCK_OPEN, BLOCK_CLOSE, INVALID_ATTR_NAME_CHAR_REGEX, VoidElements, on_destroy;
var init_index3 = __esm({
  ".svelte-kit/output/server/chunks/index3.js"() {
    noop = () => {
    };
    HYDRATION_START = "[";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_IS_NAMESPACED = 1;
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    UNINITIALIZED = Symbol();
    RawTextElements = ["textarea", "script", "style", "title"];
    PassiveDelegatedEvents = ["touchstart", "touchmove", "touchend"];
    DOMBooleanAttributes = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "hidden",
      "indeterminate",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory"
    ];
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
    current_component = null;
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    VoidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    on_destroy = [];
  }
});

// .svelte-kit/output/server/chunks/urls.js
var COOKIE_KEYS, post, get, deleteRequest;
var init_urls = __esm({
  ".svelte-kit/output/server/chunks/urls.js"() {
    COOKIE_KEYS = {
      SESSION_KEY: "thola-kimonganga-67f58259-2871-40f8-b127-129b1b415f61",
      SIGNUP_EMAIL: "thola-kimonganga-52f3ee6d-3f58-46c8-872b-78205c535044",
      FORGOT_PASSWORD_EMAIL: "thola-kimonganga-6237fdf2-8995-494e-9c80-36bc67fa1904"
    };
    post = async ({ url, input, fetcher = fetch, baseURL, options: options2 }) => {
      const reqURL = `${baseURL}/${url}`;
      const response = await fetcher(reqURL, {
        ...options2,
        method: "POST",
        body: JSON.stringify(input)
      });
      const json2 = await response.json();
      return json2;
    };
    get = async ({ url, fetcher = fetch, baseURL, options: options2 }) => {
      const reqURL = `${baseURL}/${url}`;
      const response = await fetcher(reqURL, {
        ...options2
      });
      const json2 = await response.json();
      return json2;
    };
    deleteRequest = async ({ url, fetcher = fetch, baseURL, options: options2 }) => {
      const reqURL = `${baseURL}/${url}`;
      const response = await fetcher(reqURL, {
        ...options2,
        method: "DELETE"
      });
      const json2 = await response.json();
      return json2;
    };
  }
});

// .svelte-kit/output/server/chunks/index.js
function error(status, body2) {
  if (isNaN(status) || status < 400 || status > 599) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body2);
}
function redirect(status, location2) {
  if (isNaN(status) || status < 300 || status > 308) {
    throw new Error("Invalid status code");
  }
  throw new Redirect(
    // @ts-ignore
    status,
    location2.toString()
  );
}
function json(data, init2) {
  const body2 = JSON.stringify(data);
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
function text(body2, init2) {
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    const encoded = encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init2,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
function fail(status, data) {
  return new ActionFailure(status, data);
}
var HttpError, Redirect, SvelteKitError, ActionFailure, encoder;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location2) {
        this.status = status;
        this.location = location2;
      }
    };
    SvelteKitError = class extends Error {
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message) {
        super(message);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
    encoder = new TextEncoder();
  }
});

// .svelte-kit/output/server/chunks/hooks.server.js
var hooks_server_exports = {};
__export(hooks_server_exports, {
  handle: () => handle
});
function sequence(...handlers) {
  const length = handlers.length;
  if (!length)
    return ({ event, resolve: resolve2 }) => resolve2(event);
  return ({ event, resolve: resolve2 }) => {
    return apply_handle(0, event, {});
    function apply_handle(i2, event2, parent_options) {
      const handle2 = handlers[i2];
      return handle2({
        event: event2,
        resolve: (event3, options2) => {
          const transformPageChunk = async ({ html, done }) => {
            if (options2?.transformPageChunk) {
              html = await options2.transformPageChunk({ html, done }) ?? "";
            }
            if (parent_options?.transformPageChunk) {
              html = await parent_options.transformPageChunk({ html, done }) ?? "";
            }
            return html;
          };
          const filterSerializedResponseHeaders = parent_options?.filterSerializedResponseHeaders ?? options2?.filterSerializedResponseHeaders;
          const preload = parent_options?.preload ?? options2?.preload;
          return i2 < length - 1 ? apply_handle(i2 + 1, event3, {
            transformPageChunk,
            filterSerializedResponseHeaders,
            preload
          }) : resolve2(event3, { transformPageChunk, filterSerializedResponseHeaders, preload });
        }
      });
    }
  };
}
var handleApp, handleAppHome, setAuthorizationHeaderForProtectedRoutesHandler, handle;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    init_urls();
    init_chunks();
    handleApp = async ({ event, resolve: resolve2 }) => {
      const [subdomain] = event.url.host.split(".");
      if (subdomain === "thola-client" || subdomain === "thola-org" || subdomain === "thola-pharmacy") {
        event.locals.tholaApp = subdomain;
        event.locals.userRole = subdomain === "thola-client" ? "user" : subdomain === "thola-org" ? "organisation" : "pharmacy";
        event.locals.baseURL = `https://thola-kimonganga-api.yimnai.dev/api/v1/${subdomain === "thola-client" ? "users" : subdomain === "thola-org" ? "org" : "pharmacy"}`;
      }
      return await resolve2(event);
    };
    handleAppHome = async ({ event, resolve: resolve2 }) => {
      if (event.url.pathname === "/") {
        redirect(302, "/app");
      }
      return await resolve2(event);
    };
    setAuthorizationHeaderForProtectedRoutesHandler = async ({ event, resolve: resolve2 }) => {
      const sessionKey = event.cookies.get(COOKIE_KEYS.SESSION_KEY);
      if (event.url.pathname.startsWith("/app")) {
        if (!sessionKey) {
          redirect(302, "/auth/login?redirectTo=" + event.url.pathname);
        }
        const verifySessionResponse = await post({
          url: "verify-session",
          input: {
            sessionKey
          },
          fetcher: event.fetch,
          baseURL: event.locals.baseURL
        });
        if (!verifySessionResponse.ok) {
          redirect(302, "/auth/login?redirectTo=" + event.url.pathname);
        }
        return await resolve2(event);
      }
      return await resolve2(event);
    };
    handle = sequence(handleApp, handleAppHome, setAuthorizationHeaderForProtectedRoutesHandler);
  }
});

// .svelte-kit/output/server/chunks/exports.js
function resolve(base2, path) {
  if (path[0] === "/" && path[1] === "/")
    return path;
  let url = new URL(base2, internal);
  url = new URL(path, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
function make_trackable(url, callback, search_params_callback) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key2) {
        if (key2 === "get" || key2 === "getAll" || key2 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key2](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key2);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
  }
  {
    disable_hash(tracked);
  }
  return tracked;
}
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
function has_data_suffix(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
function add_data_suffix(pathname) {
  if (pathname.endsWith(".html"))
    return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function strip_data_suffix(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
function validator(expected) {
  function validate2(module, file) {
    if (!module)
      return;
    for (const key2 in module) {
      if (key2[0] === "_" || expected.has(key2))
        continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key2, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  return validate2;
}
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var internal, tracked_url_properties, DATA_SUFFIX, HTML_DATA_SUFFIX, valid_layout_exports, valid_page_exports, valid_layout_server_exports, valid_page_server_exports, valid_server_exports, validate_layout_exports, validate_page_exports, validate_layout_server_exports, validate_page_server_exports, validate_server_exports;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    internal = new URL("sveltekit-internal://");
    tracked_url_properties = /** @type {const} */
    [
      "href",
      "pathname",
      "search",
      "toString",
      "toJSON"
    ];
    DATA_SUFFIX = "/__data.json";
    HTML_DATA_SUFFIX = ".html__data.json";
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});

// .svelte-kit/output/server/chunks/index2.js
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function safe_not_equal2(a2, b) {
  return a2 != a2 ? b == b : a2 !== b || a2 && typeof a2 === "object" || typeof a2 === "function";
}
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run, invalidate = noop) {
    const subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update) || noop;
    }
    run(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update, subscribe };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update);
      if (auto) {
        set2(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i2) => subscribe_to_store(
        store,
        (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function readonly(store) {
  return {
    // @ts-expect-error TODO i suspect the bind is unnecessary
    subscribe: store.subscribe.bind(store)
  };
}
function get_store_value(store) {
  let value;
  subscribe_to_store(store, (_2) => value = _2)();
  return value;
}
var subscriber_queue;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_index3();
    subscriber_queue = [];
  }
});

// .svelte-kit/output/server/chunks/query.js
function noop2() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options2) {
  const hashFn = options2?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_2, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key2) => {
      result[key2] = val[key2];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (a2 && b && typeof a2 === "object" && typeof b === "object") {
    return !Object.keys(b).some((key2) => !partialMatchKey(a2[key2], b[key2]));
  }
  return false;
}
function replaceEqualDeep(a2, b) {
  if (a2 === b) {
    return a2;
  }
  const array2 = isPlainArray(a2) && isPlainArray(b);
  if (array2 || isPlainObject(a2) && isPlainObject(b)) {
    const aItems = array2 ? a2 : Object.keys(a2);
    const aSize = aItems.length;
    const bItems = array2 ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy = array2 ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key2 = array2 ? i2 : bItems[i2];
      if ((!array2 && aItems.includes(key2) || array2) && a2[key2] === void 0 && b[key2] === void 0) {
        copy[key2] = void 0;
        equalItems++;
      } else {
        copy[key2] = replaceEqualDeep(a2[key2], b[key2]);
        if (copy[key2] === a2[key2] && a2[key2] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy;
  }
  return b;
}
function shallowEqualObjects(a2, b) {
  if (!b || Object.keys(a2).length !== Object.keys(b).length) {
    return false;
  }
  for (const key2 in a2) {
    if (a2[key2] !== b[key2]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o2) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function sleep(ms) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, ms);
  });
}
function replaceData(prevData, data, options2) {
  if (typeof options2.structuralSharing === "function") {
    return options2.structuralSharing(prevData, data);
  } else if (options2.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config.abort?.();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve2 = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onSuccess?.(value);
      continueFn?.();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onError?.(value);
      continueFn?.();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      config.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config.fn();
    } catch (error2) {
      promiseOrValue = Promise.reject(error2);
    }
    Promise.resolve(promiseOrValue).then(resolve2).catch((error2) => {
      if (isResolved) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay3 = typeof retryDelay === "function" ? retryDelay(failureCount, error2) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error2);
      if (isRetryCancelled || !shouldRetry) {
        reject(error2);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error2);
      sleep(delay3).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error2);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise,
    cancel,
    continue: () => {
      continueFn?.();
      return promise;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return promise;
    }
  };
}
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb) => setTimeout(cb, 0);
  const setScheduler = (fn) => {
    scheduleFn = fn;
  };
  const batch = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn) => {
    notifyFn = fn;
  };
  const setBatchNotifyFunction = (fn) => {
    batchNotifyFn = fn;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction,
    setScheduler
  };
}
function fetchState(data, options2) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options2.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState(options2) {
  const data = typeof options2.initialData === "function" ? options2.initialData() : options2.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options2.initialDataUpdatedAt === "function" ? options2.initialDataUpdatedAt() : options2.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Subscribable, isServer, skipToken, FocusManager, focusManager, OnlineManager, onlineManager, CancelledError, notifyManager, Removable, Query;
var init_query = __esm({
  ".svelte-kit/output/server/chunks/query.js"() {
    Subscribable = class {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        this.listeners.add(listener);
        this.onSubscribe();
        return () => {
          this.listeners.delete(listener);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.size > 0;
      }
      onSubscribe() {
      }
      onUnsubscribe() {
      }
    };
    isServer = typeof window === "undefined" || "Deno" in globalThis;
    skipToken = Symbol();
    FocusManager = class extends Subscribable {
      #focused;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onFocus) => {
          if (!isServer && window.addEventListener) {
            const listener = () => onFocus();
            window.addEventListener("visibilitychange", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup) {
        this.#setup = setup;
        this.#cleanup?.();
        this.#cleanup = setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        const changed = this.#focused !== focused;
        if (changed) {
          this.#focused = focused;
          this.onFocus();
        }
      }
      onFocus() {
        const isFocused = this.isFocused();
        this.listeners.forEach((listener) => {
          listener(isFocused);
        });
      }
      isFocused() {
        if (typeof this.#focused === "boolean") {
          return this.#focused;
        }
        return globalThis.document?.visibilityState !== "hidden";
      }
    };
    focusManager = new FocusManager();
    OnlineManager = class extends Subscribable {
      #online = true;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onOnline) => {
          if (!isServer && window.addEventListener) {
            const onlineListener = () => onOnline(true);
            const offlineListener = () => onOnline(false);
            window.addEventListener("online", onlineListener, false);
            window.addEventListener("offline", offlineListener, false);
            return () => {
              window.removeEventListener("online", onlineListener);
              window.removeEventListener("offline", offlineListener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup) {
        this.#setup = setup;
        this.#cleanup?.();
        this.#cleanup = setup(this.setOnline.bind(this));
      }
      setOnline(online) {
        const changed = this.#online !== online;
        if (changed) {
          this.#online = online;
          this.listeners.forEach((listener) => {
            listener(online);
          });
        }
      }
      isOnline() {
        return this.#online;
      }
    };
    onlineManager = new OnlineManager();
    CancelledError = class {
      constructor(options2) {
        this.revert = options2?.revert;
        this.silent = options2?.silent;
      }
    };
    notifyManager = createNotifyManager();
    Removable = class {
      #gcTimeout;
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (isValidTimeout(this.gcTime)) {
          this.#gcTimeout = setTimeout(() => {
            this.optionalRemove();
          }, this.gcTime);
        }
      }
      updateGcTime(newGcTime) {
        this.gcTime = Math.max(
          this.gcTime || 0,
          newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
        );
      }
      clearGcTimeout() {
        if (this.#gcTimeout) {
          clearTimeout(this.#gcTimeout);
          this.#gcTimeout = void 0;
        }
      }
    };
    Query = class extends Removable {
      #initialState;
      #revertState;
      #cache;
      #retryer;
      #defaultOptions;
      #abortSignalConsumed;
      constructor(config) {
        super();
        this.#abortSignalConsumed = false;
        this.#defaultOptions = config.defaultOptions;
        this.setOptions(config.options);
        this.observers = [];
        this.#cache = config.cache;
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.#initialState = config.state || getDefaultState(this.options);
        this.state = this.#initialState;
        this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      setOptions(options2) {
        this.options = { ...this.#defaultOptions, ...options2 };
        this.updateGcTime(this.options.gcTime);
      }
      optionalRemove() {
        if (!this.observers.length && this.state.fetchStatus === "idle") {
          this.#cache.remove(this);
        }
      }
      setData(newData, options2) {
        const data = replaceData(this.state.data, newData, this.options);
        this.#dispatch({
          data,
          type: "success",
          dataUpdatedAt: options2?.updatedAt,
          manual: options2?.manual
        });
        return data;
      }
      setState(state, setStateOptions) {
        this.#dispatch({ type: "setState", state, setStateOptions });
      }
      cancel(options2) {
        const promise = this.#retryer?.promise;
        this.#retryer?.cancel(options2);
        return promise ? promise.then(noop2).catch(noop2) : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({ silent: true });
      }
      reset() {
        this.destroy();
        this.setState(this.#initialState);
      }
      isActive() {
        return this.observers.some((observer) => observer.options.enabled !== false);
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive();
      }
      isStale() {
        if (this.state.isInvalidated) {
          return true;
        }
        if (this.getObserversCount() > 0) {
          return this.observers.some(
            (observer) => observer.getCurrentResult().isStale
          );
        }
        return this.state.data === void 0;
      }
      isStaleByTime(staleTime = 0) {
        return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
        observer?.refetch({ cancelRefetch: false });
        this.#retryer?.continue();
      }
      onOnline() {
        const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
        observer?.refetch({ cancelRefetch: false });
        this.#retryer?.continue();
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.#cache.notify({ type: "observerAdded", query: this, observer });
        }
      }
      removeObserver(observer) {
        if (this.observers.includes(observer)) {
          this.observers = this.observers.filter((x2) => x2 !== observer);
          if (!this.observers.length) {
            if (this.#retryer) {
              if (this.#abortSignalConsumed) {
                this.#retryer.cancel({ revert: true });
              } else {
                this.#retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.#cache.notify({ type: "observerRemoved", query: this, observer });
        }
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.#dispatch({ type: "invalidate" });
        }
      }
      fetch(options2, fetchOptions) {
        if (this.state.fetchStatus !== "idle") {
          if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
            this.cancel({ silent: true });
          } else if (this.#retryer) {
            this.#retryer.continueRetry();
            return this.#retryer.promise;
          }
        }
        if (options2) {
          this.setOptions(options2);
        }
        if (!this.options.queryFn) {
          const observer = this.observers.find((x2) => x2.options.queryFn);
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        if (true) {
          if (!Array.isArray(this.options.queryKey)) {
            console.error(
              `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
            );
          }
        }
        const abortController = new AbortController();
        const queryFnContext = {
          queryKey: this.queryKey,
          meta: this.meta
        };
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              this.#abortSignalConsumed = true;
              return abortController.signal;
            }
          });
        };
        addSignalProperty(queryFnContext);
        const fetchFn = () => {
          if (true) {
            if (this.options.queryFn === skipToken) {
              console.error(
                `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`
              );
            }
          }
          if (!this.options.queryFn || this.options.queryFn === skipToken) {
            return Promise.reject(
              new Error(`Missing queryFn: '${this.options.queryHash}'`)
            );
          }
          this.#abortSignalConsumed = false;
          if (this.options.persister) {
            return this.options.persister(
              this.options.queryFn,
              queryFnContext,
              this
            );
          }
          return this.options.queryFn(
            queryFnContext
          );
        };
        const context = {
          fetchOptions,
          options: this.options,
          queryKey: this.queryKey,
          state: this.state,
          fetchFn
        };
        addSignalProperty(context);
        this.options.behavior?.onFetch(
          context,
          this
        );
        this.#revertState = this.state;
        if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
          this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
        }
        const onError = (error2) => {
          if (!(isCancelledError(error2) && error2.silent)) {
            this.#dispatch({
              type: "error",
              error: error2
            });
          }
          if (!isCancelledError(error2)) {
            this.#cache.config.onError?.(
              error2,
              this
            );
            this.#cache.config.onSettled?.(
              this.state.data,
              error2,
              this
            );
          }
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        };
        this.#retryer = createRetryer({
          fn: context.fetchFn,
          abort: abortController.abort.bind(abortController),
          onSuccess: (data) => {
            if (data === void 0) {
              if (true) {
                console.error(
                  `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
                );
              }
              onError(new Error(`${this.queryHash} data is undefined`));
              return;
            }
            this.setData(data);
            this.#cache.config.onSuccess?.(data, this);
            this.#cache.config.onSettled?.(
              data,
              this.state.error,
              this
            );
            if (!this.isFetchingOptimistic) {
              this.scheduleGc();
            }
            this.isFetchingOptimistic = false;
          },
          onError,
          onFail: (failureCount, error2) => {
            this.#dispatch({ type: "failed", failureCount, error: error2 });
          },
          onPause: () => {
            this.#dispatch({ type: "pause" });
          },
          onContinue: () => {
            this.#dispatch({ type: "continue" });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode,
          canRun: () => true
        });
        return this.#retryer.start();
      }
      #dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error
              };
            case "pause":
              return {
                ...state,
                fetchStatus: "paused"
              };
            case "continue":
              return {
                ...state,
                fetchStatus: "fetching"
              };
            case "fetch":
              return {
                ...state,
                ...fetchState(state.data, this.options),
                fetchMeta: action.meta ?? null
              };
            case "success":
              return {
                ...state,
                data: action.data,
                dataUpdateCount: state.dataUpdateCount + 1,
                dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: false,
                status: "success",
                ...!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null
                }
              };
            case "error":
              const error2 = action.error;
              if (isCancelledError(error2) && error2.revert && this.#revertState) {
                return { ...this.#revertState, fetchStatus: "idle" };
              }
              return {
                ...state,
                error: error2,
                errorUpdateCount: state.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state.fetchFailureCount + 1,
                fetchFailureReason: error2,
                fetchStatus: "idle",
                status: "error"
              };
            case "invalidate":
              return {
                ...state,
                isInvalidated: true
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onQueryUpdate();
          });
          this.#cache.notify({ query: this, type: "updated", action });
        });
      }
    };
  }
});

// .svelte-kit/output/server/chunks/queryClient.js
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
function scopeFor(mutation) {
  return mutation.options.scope?.id ?? String(mutation.mutationId);
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const fetchFn = async () => {
        const options2 = context.options;
        const direction = context.fetchOptions?.meta?.fetchMore?.direction;
        const oldPages = context.state.data?.pages || [];
        const oldPageParams = context.state.data?.pageParams || [];
        const empty2 = { pages: [], pageParams: [] };
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = context.options.queryFn && context.options.queryFn !== skipToken ? context.options.queryFn : () => {
          if (true) {
            if (context.options.queryFn === skipToken) {
              console.error(
                `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${context.options.queryHash}'`
              );
            }
          }
          return Promise.reject(
            new Error(`Missing queryFn: '${context.options.queryHash}'`)
          );
        };
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page2 = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page2, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        let result;
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options2, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          result = await fetchPage(
            empty2,
            oldPageParams[0] ?? options2.initialPageParam
          );
          const remainingPages = pages ?? oldPages.length;
          for (let i2 = 1; i2 < remainingPages; i2++) {
            const param = getNextPageParam(options2, result);
            result = await fetchPage(result, param);
          }
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options2, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return options2.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  );
}
function getPreviousPageParam(options2, { pages, pageParams }) {
  return options2.getPreviousPageParam?.(
    pages[0],
    pages,
    pageParams[0],
    pageParams
  );
}
var QueryCache, Mutation, MutationCache, QueryClient;
var init_queryClient = __esm({
  ".svelte-kit/output/server/chunks/queryClient.js"() {
    init_query();
    QueryCache = class extends Subscribable {
      constructor(config = {}) {
        super();
        this.config = config;
        this.#queries = /* @__PURE__ */ new Map();
      }
      #queries;
      build(client, options2, state) {
        const queryKey = options2.queryKey;
        const queryHash = options2.queryHash ?? hashQueryKeyByOptions(queryKey, options2);
        let query = this.get(queryHash);
        if (!query) {
          query = new Query({
            cache: this,
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options2),
            state,
            defaultOptions: client.getQueryDefaults(queryKey)
          });
          this.add(query);
        }
        return query;
      }
      add(query) {
        if (!this.#queries.has(query.queryHash)) {
          this.#queries.set(query.queryHash, query);
          this.notify({
            type: "added",
            query
          });
        }
      }
      remove(query) {
        const queryInMap = this.#queries.get(query.queryHash);
        if (queryInMap) {
          query.destroy();
          if (queryInMap === query) {
            this.#queries.delete(query.queryHash);
          }
          this.notify({ type: "removed", query });
        }
      }
      clear() {
        notifyManager.batch(() => {
          this.getAll().forEach((query) => {
            this.remove(query);
          });
        });
      }
      get(queryHash) {
        return this.#queries.get(queryHash);
      }
      getAll() {
        return [...this.#queries.values()];
      }
      find(filters) {
        const defaultedFilters = { exact: true, ...filters };
        return this.getAll().find(
          (query) => matchQuery(defaultedFilters, query)
        );
      }
      findAll(filters = {}) {
        const queries = this.getAll();
        return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      onFocus() {
        notifyManager.batch(() => {
          this.getAll().forEach((query) => {
            query.onFocus();
          });
        });
      }
      onOnline() {
        notifyManager.batch(() => {
          this.getAll().forEach((query) => {
            query.onOnline();
          });
        });
      }
    };
    Mutation = class extends Removable {
      #observers;
      #mutationCache;
      #retryer;
      constructor(config) {
        super();
        this.mutationId = config.mutationId;
        this.#mutationCache = config.mutationCache;
        this.#observers = [];
        this.state = config.state || getDefaultState2();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      setOptions(options2) {
        this.options = options2;
        this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(observer) {
        if (!this.#observers.includes(observer)) {
          this.#observers.push(observer);
          this.clearGcTimeout();
          this.#mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        this.#observers = this.#observers.filter((x2) => x2 !== observer);
        this.scheduleGc();
        this.#mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer
        });
      }
      optionalRemove() {
        if (!this.#observers.length) {
          if (this.state.status === "pending") {
            this.scheduleGc();
          } else {
            this.#mutationCache.remove(this);
          }
        }
      }
      continue() {
        return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
        this.execute(this.state.variables);
      }
      async execute(variables) {
        this.#retryer = createRetryer({
          fn: () => {
            if (!this.options.mutationFn) {
              return Promise.reject(new Error("No mutationFn found"));
            }
            return this.options.mutationFn(variables);
          },
          onFail: (failureCount, error2) => {
            this.#dispatch({ type: "failed", failureCount, error: error2 });
          },
          onPause: () => {
            this.#dispatch({ type: "pause" });
          },
          onContinue: () => {
            this.#dispatch({ type: "continue" });
          },
          retry: this.options.retry ?? 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode,
          canRun: () => this.#mutationCache.canRun(this)
        });
        const restored = this.state.status === "pending";
        const isPaused = !this.#retryer.canStart();
        try {
          if (!restored) {
            this.#dispatch({ type: "pending", variables, isPaused });
            await this.#mutationCache.config.onMutate?.(
              variables,
              this
            );
            const context = await this.options.onMutate?.(variables);
            if (context !== this.state.context) {
              this.#dispatch({
                type: "pending",
                context,
                variables,
                isPaused
              });
            }
          }
          const data = await this.#retryer.start();
          await this.#mutationCache.config.onSuccess?.(
            data,
            variables,
            this.state.context,
            this
          );
          await this.options.onSuccess?.(data, variables, this.state.context);
          await this.#mutationCache.config.onSettled?.(
            data,
            null,
            this.state.variables,
            this.state.context,
            this
          );
          await this.options.onSettled?.(data, null, variables, this.state.context);
          this.#dispatch({ type: "success", data });
          return data;
        } catch (error2) {
          try {
            await this.#mutationCache.config.onError?.(
              error2,
              variables,
              this.state.context,
              this
            );
            await this.options.onError?.(
              error2,
              variables,
              this.state.context
            );
            await this.#mutationCache.config.onSettled?.(
              void 0,
              error2,
              this.state.variables,
              this.state.context,
              this
            );
            await this.options.onSettled?.(
              void 0,
              error2,
              variables,
              this.state.context
            );
            throw error2;
          } finally {
            this.#dispatch({ type: "error", error: error2 });
          }
        } finally {
          this.#mutationCache.runNext(this);
        }
      }
      #dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                failureCount: action.failureCount,
                failureReason: action.error
              };
            case "pause":
              return {
                ...state,
                isPaused: true
              };
            case "continue":
              return {
                ...state,
                isPaused: false
              };
            case "pending":
              return {
                ...state,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: action.isPaused,
                status: "pending",
                variables: action.variables,
                submittedAt: Date.now()
              };
            case "success":
              return {
                ...state,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false
              };
            case "error":
              return {
                ...state,
                data: void 0,
                error: action.error,
                failureCount: state.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error"
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.#observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.#mutationCache.notify({
            mutation: this,
            type: "updated",
            action
          });
        });
      }
    };
    MutationCache = class extends Subscribable {
      constructor(config = {}) {
        super();
        this.config = config;
        this.#mutations = /* @__PURE__ */ new Map();
        this.#mutationId = Date.now();
      }
      #mutations;
      #mutationId;
      build(client, options2, state) {
        const mutation = new Mutation({
          mutationCache: this,
          mutationId: ++this.#mutationId,
          options: client.defaultMutationOptions(options2),
          state
        });
        this.add(mutation);
        return mutation;
      }
      add(mutation) {
        const scope = scopeFor(mutation);
        const mutations = this.#mutations.get(scope) ?? [];
        mutations.push(mutation);
        this.#mutations.set(scope, mutations);
        this.notify({ type: "added", mutation });
      }
      remove(mutation) {
        const scope = scopeFor(mutation);
        if (this.#mutations.has(scope)) {
          const mutations = this.#mutations.get(scope)?.filter((x2) => x2 !== mutation);
          if (mutations) {
            if (mutations.length === 0) {
              this.#mutations.delete(scope);
            } else {
              this.#mutations.set(scope, mutations);
            }
          }
        }
        this.notify({ type: "removed", mutation });
      }
      canRun(mutation) {
        const firstPendingMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m.state.status === "pending");
        return !firstPendingMutation || firstPendingMutation === mutation;
      }
      runNext(mutation) {
        const foundMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m !== mutation && m.state.isPaused);
        return foundMutation?.continue() ?? Promise.resolve();
      }
      clear() {
        notifyManager.batch(() => {
          this.getAll().forEach((mutation) => {
            this.remove(mutation);
          });
        });
      }
      getAll() {
        return [...this.#mutations.values()].flat();
      }
      find(filters) {
        const defaultedFilters = { exact: true, ...filters };
        return this.getAll().find(
          (mutation) => matchMutation(defaultedFilters, mutation)
        );
      }
      findAll(filters = {}) {
        return this.getAll().filter((mutation) => matchMutation(filters, mutation));
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
        return notifyManager.batch(
          () => Promise.all(
            pausedMutations.map((mutation) => mutation.continue().catch(noop2))
          )
        );
      }
    };
    QueryClient = class {
      #queryCache;
      #mutationCache;
      #defaultOptions;
      #queryDefaults;
      #mutationDefaults;
      #mountCount;
      #unsubscribeFocus;
      #unsubscribeOnline;
      constructor(config = {}) {
        this.#queryCache = config.queryCache || new QueryCache();
        this.#mutationCache = config.mutationCache || new MutationCache();
        this.#defaultOptions = config.defaultOptions || {};
        this.#queryDefaults = /* @__PURE__ */ new Map();
        this.#mutationDefaults = /* @__PURE__ */ new Map();
        this.#mountCount = 0;
      }
      mount() {
        this.#mountCount++;
        if (this.#mountCount !== 1)
          return;
        this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
          if (focused) {
            await this.resumePausedMutations();
            this.#queryCache.onFocus();
          }
        });
        this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
          if (online) {
            await this.resumePausedMutations();
            this.#queryCache.onOnline();
          }
        });
      }
      unmount() {
        this.#mountCount--;
        if (this.#mountCount !== 0)
          return;
        this.#unsubscribeFocus?.();
        this.#unsubscribeFocus = void 0;
        this.#unsubscribeOnline?.();
        this.#unsubscribeOnline = void 0;
      }
      isFetching(filters) {
        return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
      }
      isMutating(filters) {
        return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
      }
      getQueryData(queryKey) {
        const options2 = this.defaultQueryOptions({ queryKey });
        return this.#queryCache.get(options2.queryHash)?.state.data;
      }
      ensureQueryData(options2) {
        const cachedData = this.getQueryData(options2.queryKey);
        if (cachedData === void 0)
          return this.fetchQuery(options2);
        else {
          const defaultedOptions = this.defaultQueryOptions(options2);
          const query = this.#queryCache.build(this, defaultedOptions);
          if (options2.revalidateIfStale && query.isStaleByTime(defaultedOptions.staleTime)) {
            void this.prefetchQuery(defaultedOptions);
          }
          return Promise.resolve(cachedData);
        }
      }
      getQueriesData(filters) {
        return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
          const data = state.data;
          return [queryKey, data];
        });
      }
      setQueryData(queryKey, updater, options2) {
        const defaultedOptions = this.defaultQueryOptions({ queryKey });
        const query = this.#queryCache.get(
          defaultedOptions.queryHash
        );
        const prevData = query?.state.data;
        const data = functionalUpdate(updater, prevData);
        if (data === void 0) {
          return void 0;
        }
        return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options2, manual: true });
      }
      setQueriesData(filters, updater, options2) {
        return notifyManager.batch(
          () => this.#queryCache.findAll(filters).map(({ queryKey }) => [
            queryKey,
            this.setQueryData(queryKey, updater, options2)
          ])
        );
      }
      getQueryState(queryKey) {
        const options2 = this.defaultQueryOptions({ queryKey });
        return this.#queryCache.get(options2.queryHash)?.state;
      }
      removeQueries(filters) {
        const queryCache = this.#queryCache;
        notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            queryCache.remove(query);
          });
        });
      }
      resetQueries(filters, options2) {
        const queryCache = this.#queryCache;
        const refetchFilters = {
          type: "active",
          ...filters
        };
        return notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            query.reset();
          });
          return this.refetchQueries(refetchFilters, options2);
        });
      }
      cancelQueries(filters = {}, cancelOptions = {}) {
        const defaultedCancelOptions = { revert: true, ...cancelOptions };
        const promises = notifyManager.batch(
          () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
        );
        return Promise.all(promises).then(noop2).catch(noop2);
      }
      invalidateQueries(filters = {}, options2 = {}) {
        return notifyManager.batch(() => {
          this.#queryCache.findAll(filters).forEach((query) => {
            query.invalidate();
          });
          if (filters.refetchType === "none") {
            return Promise.resolve();
          }
          const refetchFilters = {
            ...filters,
            type: filters.refetchType ?? filters.type ?? "active"
          };
          return this.refetchQueries(refetchFilters, options2);
        });
      }
      refetchQueries(filters = {}, options2) {
        const fetchOptions = {
          ...options2,
          cancelRefetch: options2?.cancelRefetch ?? true
        };
        const promises = notifyManager.batch(
          () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
            let promise = query.fetch(void 0, fetchOptions);
            if (!fetchOptions.throwOnError) {
              promise = promise.catch(noop2);
            }
            return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
          })
        );
        return Promise.all(promises).then(noop2);
      }
      fetchQuery(options2) {
        const defaultedOptions = this.defaultQueryOptions(options2);
        if (defaultedOptions.retry === void 0) {
          defaultedOptions.retry = false;
        }
        const query = this.#queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
      }
      prefetchQuery(options2) {
        return this.fetchQuery(options2).then(noop2).catch(noop2);
      }
      fetchInfiniteQuery(options2) {
        options2.behavior = infiniteQueryBehavior(options2.pages);
        return this.fetchQuery(options2);
      }
      prefetchInfiniteQuery(options2) {
        return this.fetchInfiniteQuery(options2).then(noop2).catch(noop2);
      }
      resumePausedMutations() {
        if (onlineManager.isOnline()) {
          return this.#mutationCache.resumePausedMutations();
        }
        return Promise.resolve();
      }
      getQueryCache() {
        return this.#queryCache;
      }
      getMutationCache() {
        return this.#mutationCache;
      }
      getDefaultOptions() {
        return this.#defaultOptions;
      }
      setDefaultOptions(options2) {
        this.#defaultOptions = options2;
      }
      setQueryDefaults(queryKey, options2) {
        this.#queryDefaults.set(hashKey(queryKey), {
          queryKey,
          defaultOptions: options2
        });
      }
      getQueryDefaults(queryKey) {
        const defaults6 = [...this.#queryDefaults.values()];
        let result = {};
        defaults6.forEach((queryDefault) => {
          if (partialMatchKey(queryKey, queryDefault.queryKey)) {
            result = { ...result, ...queryDefault.defaultOptions };
          }
        });
        return result;
      }
      setMutationDefaults(mutationKey, options2) {
        this.#mutationDefaults.set(hashKey(mutationKey), {
          mutationKey,
          defaultOptions: options2
        });
      }
      getMutationDefaults(mutationKey) {
        const defaults6 = [...this.#mutationDefaults.values()];
        let result = {};
        defaults6.forEach((queryDefault) => {
          if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
            result = { ...result, ...queryDefault.defaultOptions };
          }
        });
        return result;
      }
      defaultQueryOptions(options2) {
        if (options2._defaulted) {
          return options2;
        }
        const defaultedOptions = {
          ...this.#defaultOptions.queries,
          ...this.getQueryDefaults(options2.queryKey),
          ...options2,
          _defaulted: true
        };
        if (!defaultedOptions.queryHash) {
          defaultedOptions.queryHash = hashQueryKeyByOptions(
            defaultedOptions.queryKey,
            defaultedOptions
          );
        }
        if (defaultedOptions.refetchOnReconnect === void 0) {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (defaultedOptions.throwOnError === void 0) {
          defaultedOptions.throwOnError = !!defaultedOptions.suspense;
        }
        if (!defaultedOptions.networkMode && defaultedOptions.persister) {
          defaultedOptions.networkMode = "offlineFirst";
        }
        if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
          defaultedOptions.enabled = false;
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options2) {
        if (options2?._defaulted) {
          return options2;
        }
        return {
          ...this.#defaultOptions.mutations,
          ...options2?.mutationKey && this.getMutationDefaults(options2.mutationKey),
          ...options2,
          _defaulted: true
        };
      }
      clear() {
        this.#queryCache.clear();
        this.#mutationCache.clear();
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/_layout.ts.js
var layout_ts_exports = {};
__export(layout_ts_exports, {
  load: () => load
});
var load;
var init_layout_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.ts.js"() {
    init_queryClient();
    load = ({ data }) => {
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: {
            refetchOnWindowFocus: false,
            refetchOnMount: true,
            refetchOnReconnect: true,
            refetchInterval: 1e3 * 60 * 60,
            retry: (failureCount, error2) => {
              if (error2 instanceof TypeError) {
                return false;
              } else {
                return failureCount < 3;
              }
            },
            staleTime: 1e3 * 60 * 60
          }
        }
      });
      return {
        ...data,
        queryClient
      };
    };
  }
});

// .svelte-kit/output/server/entries/pages/_layout.server.ts.js
var layout_server_ts_exports = {};
__export(layout_server_ts_exports, {
  load: () => load2
});
var load2;
var init_layout_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.server.ts.js"() {
    load2 = async ({ locals }) => {
      const tholaApp = locals.tholaApp;
      const baseURL = locals.baseURL;
      const userRole = locals.userRole;
      return {
        tholaApp,
        baseURL,
        userRole
      };
    };
  }
});

// .svelte-kit/output/server/chunks/context-keys.js
var CONTEXT_KEYS;
var init_context_keys = __esm({
  ".svelte-kit/output/server/chunks/context-keys.js"() {
    CONTEXT_KEYS = {
      TOAST: "toastState",
      PHARMACY_LIST_STREAM: "pharmacyListStream",
      ORGANISATION_PHARMACIST_LIST_STREAM: "organisationPharmacistListStream",
      DELETE_PHARMACIST_FORM: "deletePharmacistForm"
    };
  }
});

// .svelte-kit/output/server/chunks/misc.js
function default_slot($$props) {
  var children = $$props.$$slots?.default;
  if (children === true) {
    return $$props.children;
  } else {
    return children;
  }
}
var init_misc = __esm({
  ".svelte-kit/output/server/chunks/misc.js"() {
  }
});

// .svelte-kit/output/server/chunks/Icon.js
function Icon($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "mergeClasses",
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode"
  ]);
  push();
  let name2 = value_or_fallback($$props["name"], () => void 0);
  let color = value_or_fallback($$props["color"], () => "currentColor");
  let size2 = value_or_fallback($$props["size"], () => 24);
  let strokeWidth = value_or_fallback($$props["strokeWidth"], () => 2);
  let absoluteStrokeWidth = value_or_fallback($$props["absoluteStrokeWidth"], () => false);
  let iconNode = $$props["iconNode"];
  const mergeClasses = (...classes) => classes.filter((className, index21, array2) => {
    return Boolean(className) && array2.indexOf(className) === index21;
  }).join(" ");
  const each_array = ensure_array_like(iconNode);
  $$payload.out += `<svg${spread_attributes(
    {
      ...defaultAttributes,
      ...$$restProps,
      width: size2,
      height: size2,
      stroke: color,
      "stroke-width": absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      class: mergeClasses("lucide-icon", "lucide", name2 ? `lucide-${name2}` : "", $$sanitized_props.class)
    },
    void 0,
    void 0,
    3
  )}><!--[-->`;
  for (let $$index = 0; $$index < each_array.length; $$index++) {
    const $$item = each_array[$$index];
    const [tag, attrs] = $$item;
    $$payload.out += "<!--[-->";
    $$payload.out += `<!--[-->`;
    if (tag)
      element(
        $$payload,
        tag,
        () => {
          $$payload.out += `${spread_attributes({ ...attrs }, void 0, void 0, 3)}`;
        },
        () => {
        }
      );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  }
  $$payload.out += "<!--]-->";
  $$payload.out += `<!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></svg>`;
  bind_props($$props, {
    name: name2,
    color,
    size: size2,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    mergeClasses
  });
  pop();
}
var defaultAttributes;
var init_Icon = __esm({
  ".svelte-kit/output/server/chunks/Icon.js"() {
    init_index3();
    init_misc();
    defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    };
  }
});

// .svelte-kit/output/server/chunks/stores.js
function withoutTransition(action) {
  if (typeof document === "undefined")
    return;
  clearTimeout(timeoutAction);
  clearTimeout(timeoutEnable);
  const style = document.createElement("style");
  const css = document.createTextNode(`* {
     -webkit-transition: none !important;
     -moz-transition: none !important;
     -o-transition: none !important;
     -ms-transition: none !important;
     transition: none !important;
  }`);
  style.appendChild(css);
  const disable = () => document.head.appendChild(style);
  const enable = () => document.head.removeChild(style);
  if (typeof window.getComputedStyle !== "undefined") {
    disable();
    action();
    window.getComputedStyle(style).opacity;
    enable();
    return;
  }
  if (typeof window.requestAnimationFrame !== "undefined") {
    disable();
    action();
    window.requestAnimationFrame(enable);
    return;
  }
  disable();
  timeoutAction = window.setTimeout(() => {
    action();
    timeoutEnable = window.setTimeout(enable, 120);
  }, 120);
}
function createUserPrefersMode() {
  const defaultValue2 = "system";
  const storage = isBrowser ? localStorage : noopStorage;
  const initialValue = storage.getItem(localStorageKey);
  let value = isValidMode(initialValue) ? initialValue : defaultValue2;
  const { subscribe, set: _set } = writable(value, () => {
    if (!isBrowser)
      return;
    const handler = (e3) => {
      if (e3.key !== localStorageKey)
        return;
      const newValue = e3.newValue;
      if (isValidMode(newValue)) {
        _set(value = newValue);
      } else {
        _set(value = defaultValue2);
      }
    };
    addEventListener("storage", handler);
    return () => removeEventListener("storage", handler);
  });
  function set2(v2) {
    _set(value = v2);
    storage.setItem(localStorageKey, value);
  }
  return {
    subscribe,
    set: set2
  };
}
function createSystemMode() {
  const defaultValue2 = void 0;
  let track = true;
  const { subscribe, set: set2 } = writable(defaultValue2, () => {
    if (!isBrowser)
      return;
    const handler = (e3) => {
      if (!track)
        return;
      set2(e3.matches ? "light" : "dark");
    };
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    mediaQueryState.addEventListener("change", handler);
    return () => mediaQueryState.removeEventListener("change", handler);
  });
  function query() {
    if (!isBrowser)
      return;
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    set2(mediaQueryState.matches ? "light" : "dark");
  }
  function tracking(active) {
    track = active;
  }
  return {
    subscribe,
    query,
    tracking
  };
}
function createDerivedMode() {
  const { subscribe } = derived([userPrefersMode, systemPrefersMode, themeColors, disableTransitions], ([$userPrefersMode, $systemPrefersMode, $themeColors, $disableTransitions]) => {
    if (!isBrowser)
      return void 0;
    const derivedMode2 = $userPrefersMode === "system" ? $systemPrefersMode : $userPrefersMode;
    function update() {
      const htmlEl = document.documentElement;
      const themeColorEl = document.querySelector('meta[name="theme-color"]');
      if (derivedMode2 === "light") {
        htmlEl.classList.remove("dark");
        htmlEl.style.colorScheme = "light";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.light);
        }
      } else {
        htmlEl.classList.add("dark");
        htmlEl.style.colorScheme = "dark";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.dark);
        }
      }
    }
    if ($disableTransitions) {
      withoutTransition(update);
    } else {
      update();
    }
    return derivedMode2;
  });
  return {
    subscribe
  };
}
function isValidMode(value) {
  if (typeof value !== "string")
    return false;
  return modes.includes(value);
}
var timeoutAction, timeoutEnable, noopStorage, isBrowser, modes, localStorageKey, userPrefersMode, systemPrefersMode, themeColors, disableTransitions, derivedMode;
var init_stores = __esm({
  ".svelte-kit/output/server/chunks/stores.js"() {
    init_index2();
    noopStorage = {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getItem: (_key) => null,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setItem: (_key, _value) => {
      }
    };
    isBrowser = typeof document !== "undefined";
    modes = ["dark", "light", "system"];
    localStorageKey = "mode-watcher-mode";
    userPrefersMode = createUserPrefersMode();
    systemPrefersMode = createSystemMode();
    themeColors = writable(void 0);
    disableTransitions = writable(true);
    derivedMode = createDerivedMode();
  }
});

// .svelte-kit/output/server/chunks/client.js
function get3(key2, parse3 = JSON.parse) {
  try {
    return parse3(sessionStorage[key2]);
  } catch {
  }
}
function goto(url, opts = {}) {
  {
    throw new Error("Cannot call goto(...) on the server");
  }
}
function invalidateAll() {
  {
    throw new Error("Cannot call invalidateAll() on the server");
  }
}
async function applyAction(result) {
  {
    throw new Error("Cannot call applyAction(...) on the server");
  }
}
var SNAPSHOT_KEY, SCROLL_KEY;
var init_client = __esm({
  ".svelte-kit/output/server/chunks/client.js"() {
    init_exports();
    SNAPSHOT_KEY = "sveltekit:snapshot";
    SCROLL_KEY = "sveltekit:scroll";
    get3(SCROLL_KEY) ?? {};
    get3(SNAPSHOT_KEY) ?? {};
  }
});

// .svelte-kit/output/server/chunks/index-server.js
function onDestroy(fn) {
  var context = (
    /** @type {import('#server').Component} */
    current_component
  );
  (context.d ??= []).push(fn);
}
async function tick() {
}
var init_index_server = __esm({
  ".svelte-kit/output/server/chunks/index-server.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/chunks/context.js
var _contextKey, getQueryClientContext, setQueryClientContext, _isRestoringContextKey, getIsRestoringContext;
var init_context = __esm({
  ".svelte-kit/output/server/chunks/context.js"() {
    init_index3();
    init_index2();
    _contextKey = "$$_queryClient";
    getQueryClientContext = () => {
      const client = getContext(_contextKey);
      if (!client) {
        throw new Error("No QueryClient was found in Svelte context. Did you forget to wrap your component with QueryClientProvider?");
      }
      return client;
    };
    setQueryClientContext = (client) => {
      setContext(_contextKey, client);
    };
    _isRestoringContextKey = "$$_isRestoring";
    getIsRestoringContext = () => {
      try {
        const isRestoring = getContext(_isRestoringContextKey);
        return isRestoring ? isRestoring : readable(false);
      } catch (error2) {
        return readable(false);
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
function Circle_x($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "10" }
    ],
    ["path", { "d": "m15 9-6 6" }],
    ["path", { "d": "m9 9 6 6" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "circle-x" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Toast($$payload, $$props) {
  push();
  let toastState = getContext(CONTEXT_KEYS.TOAST);
  let { toast } = $$props;
  let toastActive = toastState.toasts.find((t2) => t2.key == toast.key);
  setTimeout(
    () => {
      toastState.removeToast(toast.key);
    },
    (toast.duration || 3) * 1e3
  );
  $$payload.out += `<!--[-->`;
  if (toastActive) {
    $$payload.out += `<div${attr(
      "class",
      `min-w-[100px] rounded-sm px-2 py-4 shadow-md z-50 ${stringify2([
        toast.type === "error" ? "bg-red-500" : "",
        toast.type === "success" ? "bg-green-500" : "",
        toast.type === "info" ? "bg-blue-500" : "",
        toast.type === "warning" ? "bg-yellow-500" : ""
      ].filter(Boolean).join(" "))}`,
      false
    )}><div class="flex w-full items-center justify-between pb-3"><h1 class="font-bold">${escape_html(toast.title || "Notice!")}</h1></div> <div class="flex w-full items-center justify-between gap-2"><p>${escape_html(toast.message)}</p> <!--[-->`;
    Circle_x($$payload, {
      class: "cursor-pointer",
      onclick: () => toastState.removeToast(toast.key)
    });
    $$payload.out += `<!--]--></div></div>`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += "<!--]!-->";
  }
  pop();
}
function ToastContainer($$payload, $$props) {
  push();
  const toastState = getContext(CONTEXT_KEYS.TOAST);
  let { toasts } = toastState;
  const each_array = ensure_array_like(toasts);
  $$payload.out += `<div class="absolute right-2 top-2 z-50 flex flex-col gap-2"><!--[-->`;
  for (let $$index = 0; $$index < each_array.length; $$index++) {
    const toast = each_array[$$index];
    $$payload.out += "<!--[-->";
    $$payload.out += `<!--[-->`;
    Toast($$payload, { toast });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  }
  $$payload.out += "<!--]-->";
  $$payload.out += `</div>`;
  pop();
}
function setInitialMode(defaultMode, themeColors2) {
  const rootEl = document.documentElement;
  const mode = localStorage.getItem("mode-watcher-mode") || defaultMode;
  const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
  rootEl.classList[light ? "remove" : "add"]("dark");
  rootEl.style.colorScheme = light ? "light" : "dark";
  if (themeColors2) {
    const themeMetaEl = document.querySelector('meta[name="theme-color"]');
    if (themeMetaEl) {
      themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
    }
  }
  localStorage.setItem("mode-watcher-mode", mode);
}
function Mode_watcher($$payload, $$props) {
  push();
  let track = value_or_fallback($$props["track"], () => true);
  let defaultMode = value_or_fallback($$props["defaultMode"], () => "system");
  let themeColors$1 = value_or_fallback($$props["themeColors"], () => void 0);
  let disableTransitions$1 = value_or_fallback($$props["disableTransitions"], () => true);
  themeColors.set(themeColors$1);
  disableTransitions.set(disableTransitions$1);
  const args = `"${defaultMode}"${themeColors$1 ? `, ${JSON.stringify(themeColors$1)}` : ""}`;
  head($$payload, ($$payload2) => {
    $$payload2.out += `<!--[-->`;
    if (themeColors$1) {
      $$payload2.out += `<meta name="theme-color"${attr("content", themeColors$1.dark, false)}>`;
      $$payload2.out += "<!--]-->";
    } else {
      $$payload2.out += "<!--]!-->";
    }
    $$payload2.out += ` <!--[-->${`<script nonce="%sveltekit.nonce%">(` + setInitialMode.toString() + `)(` + args + `);<\/script>`}<!--]-->`;
  });
  bind_props($$props, {
    track,
    defaultMode,
    themeColors: themeColors$1,
    disableTransitions: disableTransitions$1
  });
  pop();
}
function createToastState() {
  let toasts = [];
  function addToast(toast) {
    const key2 = `${Date.now()}-${Math.random()}`;
    toasts = [
      ...toasts,
      { ...toast, key: key2, duration: toast.duration ?? 3 }
    ];
  }
  function removeToast(key2) {
    toasts = toasts.filter((toast) => toast.key !== key2);
  }
  return {
    get toasts() {
      return toasts;
    },
    addToast,
    removeToast
  };
}
function QueryClientProvider($$payload, $$props) {
  push();
  let client = value_or_fallback($$props["client"], () => new QueryClient());
  setQueryClientContext(client);
  onDestroy(() => {
    client.unmount();
  });
  $$payload.out += `<!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]-->`;
  bind_props($$props, { client });
  pop();
}
function _layout($$payload, $$props) {
  push();
  let { children, data } = $$props;
  let toastState = createToastState();
  setContext(CONTEXT_KEYS.TOAST, toastState);
  $$payload.out += `<!--[-->`;
  QueryClientProvider($$payload, {
    client: data.queryClient,
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Mode_watcher($$payload2, {});
      $$payload2.out += `<!--]--> <!--[-->`;
      ToastContainer($$payload2);
      $$payload2.out += `<!--]--> <!--[-->`;
      children($$payload2);
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]-->`;
  pop();
}
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_index3();
    init_context_keys();
    init_Icon();
    init_misc();
    init_stores();
    init_client();
    init_index_server();
    init_queryClient();
    init_context();
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  server: () => layout_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets,
  universal: () => layout_ts_exports,
  universal_id: () => universal_id
});
var index, component_cache, component, universal_id, server_id, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_ts();
    init_layout_server_ts();
    index = 0;
    component = async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default;
    universal_id = "src/routes/+layout.ts";
    server_id = "src/routes/+layout.server.ts";
    imports = ["_app/immutable/nodes/0.Bolo-tAV.js", "_app/immutable/chunks/context.C9dpIilQ.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/snippet.CBj7fh4M.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/transitions.Bmz1fhPf.js", "_app/immutable/chunks/index.DkWdW2MU.js", "_app/immutable/chunks/Icon.JZj92Q4v.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/mode.Cq9Pf7ez.js"];
    stylesheets = ["_app/immutable/assets/0.CzswupaQ.css"];
    fonts = [];
  }
});

// .svelte-kit/output/server/chunks/stores2.js
var getStores, page, navigating;
var init_stores2 = __esm({
  ".svelte-kit/output/server/chunks/stores2.js"() {
    init_index3();
    init_client();
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        /** @type {typeof page} */
        page: {
          subscribe: stores.page.subscribe
        },
        /** @type {typeof navigating} */
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        /** @type {typeof updated} */
        updated: stores.updated
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
    navigating = {
      subscribe(fn) {
        const store = getStores().navigating;
        return store.subscribe(fn);
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/_error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => _error
});
function _error($$payload, $$props) {
  push();
  var $$store_subs;
  $$payload.out += `<h1>Default Error page: ${escape_html(store_get($$store_subs ??= {}, "$page", page).error?.message)}</h1>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_error.svelte.js"() {
    init_index3();
    init_stores2();
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default;
    imports2 = ["_app/immutable/nodes/1.CqM_qkd6.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index21 = 0; index21 < a2.length; index21++) {
      const itemA = a2[index21];
      const itemB = b[index21];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY2, OK, isAborted, isDirty, isValid, isAsync, errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv6Regex, base64Regex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z;
var init_lib = __esm({
  "node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs"() {
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e3) {
          return obj[e3];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key2 in object) {
          if (Object.prototype.hasOwnProperty.call(object, key2)) {
            keys.push(key2);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_2, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class _ZodError extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error2) => {
          for (const issue of error2.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i2 = 0;
              while (i2 < issue.path.length) {
                const el = issue.path[i2];
                const terminal = i2 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i2++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error2 = new ZodError(issues);
      return error2;
    };
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    overrideErrorMap = errorMap;
    makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s3 of results) {
          if (s3.status === "aborted")
            return INVALID;
          if (s3.status === "dirty")
            status.dirty();
          arrayValue.push(s3.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key2,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key: key2, value } = pair;
          if (key2.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key2.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key2.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY2 = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x2) => x2.status === "aborted";
    isDirty = (x2) => x2.status === "dirty";
    isValid = (x2) => x2.status === "valid";
    isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      constructor(parent2, value, path, key2) {
        this._cachedPath = [];
        this.parent = parent2;
        this.data = value;
        this._path = path;
        this._key = key2;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error2 = new ZodError(ctx.common.issues);
            this._error = error2;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      ip(options2) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
      }
      datetime(options2) {
        var _a, _b;
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options2
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
          offset: (_a = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a !== void 0 ? _a : false,
          local: (_b = options2 === null || options2 === void 0 ? void 0 : options2.local) !== null && _b !== void 0 ? _b : false,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options2) {
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options2
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options2) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options2 === null || options2 === void 0 ? void 0 : options2.position,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get minLength() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max2 = null, min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          } else if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i2) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i2) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key2 in ctx.data) {
            if (!shapeKeys.includes(key2)) {
              extraKeys.push(key2);
            }
          }
        }
        const pairs = [];
        for (const key2 of shapeKeys) {
          const keyValidator = shape[key2];
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
            alwaysSet: key2 in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key2 of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key2 },
                value: { status: "valid", value: ctx.data[key2] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key2 of extraKeys) {
            const value = ctx.data[key2];
            pairs.push({
              key: { status: "valid", value: key2 },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key2)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key2 in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key2 = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key: key2,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key2, schema) {
        return this.augment({ [key2]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index21) {
        return new _ZodObject({
          ...this._def,
          catchall: index21
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key2) => {
          if (mask[key2] && this.shape[key2]) {
            shape[key2] = this.shape[key2];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          if (!mask[key2]) {
            shape[key2] = this.shape[key2];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          const fieldSchema = this.shape[key2];
          if (mask && !mask[key2]) {
            newShape[key2] = fieldSchema;
          } else {
            newShape[key2] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          if (mask && !mask[key2]) {
            newShape[key2] = this.shape[key2];
          } else {
            const fieldSchema = this.shape[key2];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key2] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options2 = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options2.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options2) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options2, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options2) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options: options2,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x2) => !!x2);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key2 in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
            alwaysSet: key2 in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key2, value], index21) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index21, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index21, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key2 = await pair.key;
              const value = await pair.value;
              if (key2.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key2.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key2.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key2 = pair.key;
            const value = pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element2 of elements2) {
            if (element2.status === "aborted")
              return INVALID;
            if (element2.status === "dirty")
              status.dirty();
            parsedSet.add(element2.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size2, message) {
        return this.min(size2, message).max(size2, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error2) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error2
            }
          });
        }
        function makeReturnsIssue(returns, error2) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error2
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error2 = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e3) => {
              error2.addIssue(makeArgsIssue(args, e3));
              throw error2;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e3) => {
              error2.addIssue(makeReturnsIssue(result, e3));
              throw error2;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect3 = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect3.type === "preprocess") {
          const processed = effect3.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY2(result.value);
              if (status.value === "dirty")
                return DIRTY2(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY2(result.value);
            if (status.value === "dirty")
              return DIRTY2(result.value);
            return result;
          }
        }
        if (effect3.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect3.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect3.type === "transform") {
          if (ctx.common.async === false) {
            const base2 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base2))
              return base2;
            const result = effect3.transform(base2.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
              if (!isValid(base2))
                return base2;
              return Promise.resolve(effect3.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect3);
      }
    };
    ZodEffects.create = (schema, effect3, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: effect3,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY2(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a2, b) {
        return new _ZodPipeline({
          in: a2,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY: DIRTY2,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      datetimeRegex,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});

// .svelte-kit/output/server/chunks/pharmacist.form.js
var createPharmacistSchema, deletePharmacistSchema;
var init_pharmacist_form = __esm({
  ".svelte-kit/output/server/chunks/pharmacist.form.js"() {
    init_lib();
    createPharmacistSchema = z.object({
      pharmacyId: z.string({ required_error: "Pharmacy ID is required" }),
      firstName: z.string({ required_error: "First name is required" }).min(1, { message: "First name is required" }),
      lastName: z.string({ required_error: "Last name is required" }).min(1, { message: "Last name is required" }),
      username: z.string({ required_error: "Username is required" }).min(1, { message: "Username is required" }),
      email: z.string({ required_error: "Email is required" }).email({ message: "Invalid email address" }).min(1, { message: "Email is required" }),
      phoneNumber: z.string({ required_error: "Phone number is required" }).min(1, { message: "Phone number is required" })
    });
    deletePharmacistSchema = z.object({
      pharmacistId: z.string({ required_error: "Pharmacist ID is required" })
    });
  }
});

// .svelte-kit/output/server/chunks/compile.js
function parse2(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number")
    return hydrate2(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate2(index21, standalone = false) {
    if (index21 === UNDEFINED)
      return void 0;
    if (index21 === NAN)
      return NaN;
    if (index21 === POSITIVE_INFINITY)
      return Infinity;
    if (index21 === NEGATIVE_INFINITY)
      return -Infinity;
    if (index21 === NEGATIVE_ZERO)
      return -0;
    if (standalone)
      throw new Error(`Invalid input`);
    if (index21 in hydrated)
      return hydrated[index21];
    const value = values[index21];
    if (!value || typeof value !== "object") {
      hydrated[index21] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          return hydrated[index21] = reviver(hydrate2(value[1]));
        }
        switch (type) {
          case "Date":
            hydrated[index21] = new Date(value[1]);
            break;
          case "Set":
            const set2 = /* @__PURE__ */ new Set();
            hydrated[index21] = set2;
            for (let i2 = 1; i2 < value.length; i2 += 1) {
              set2.add(hydrate2(value[i2]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index21] = map;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              map.set(hydrate2(value[i2]), hydrate2(value[i2 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index21] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index21] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index21] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index21] = obj;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              obj[value[i2]] = hydrate2(value[i2 + 1]);
            }
            break;
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array2 = new Array(value.length);
        hydrated[index21] = array2;
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          const n2 = value[i2];
          if (n2 === HOLE)
            continue;
          array2[i2] = hydrate2(n2);
        }
      }
    } else {
      const object = {};
      hydrated[index21] = object;
      for (const key2 in value) {
        const n2 = value[key2];
        object[key2] = hydrate2(n2);
      }
    }
    return hydrated[index21];
  }
  return hydrate2(0);
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function deserialize(result) {
  const parsed = JSON.parse(result);
  if (parsed.data) {
    parsed.data = parse2(parsed.data);
  }
  return parsed;
}
function clone$2(element2) {
  return (
    /** @type {T} */
    HTMLElement.prototype.cloneNode.call(element2)
  );
}
function enhance(form_element, submit = () => {
}) {
  const fallback_callback = async ({
    action,
    result,
    reset: reset2 = true,
    invalidateAll: shouldInvalidateAll = true
  }) => {
    if (result.type === "success") {
      if (reset2) {
        HTMLFormElement.prototype.reset.call(form_element);
      }
      if (shouldInvalidateAll) {
        await invalidateAll();
      }
    }
    if (location.origin + location.pathname === action.origin + action.pathname || result.type === "redirect" || result.type === "error") {
      applyAction();
    }
  };
  async function handle_submit(event) {
    const method = event.submitter?.hasAttribute("formmethod") ? (
      /** @type {HTMLButtonElement | HTMLInputElement} */
      event.submitter.formMethod
    ) : clone$2(form_element).method;
    if (method !== "post")
      return;
    event.preventDefault();
    const action = new URL(
      // We can't do submitter.formAction directly because that property is always set
      event.submitter?.hasAttribute("formaction") ? (
        /** @type {HTMLButtonElement | HTMLInputElement} */
        event.submitter.formAction
      ) : clone$2(form_element).action
    );
    const form_data = new FormData(form_element);
    const submitter_name = event.submitter?.getAttribute("name");
    if (submitter_name) {
      form_data.append(submitter_name, event.submitter?.getAttribute("value") ?? "");
    }
    const controller = new AbortController();
    let cancelled = false;
    const cancel = () => cancelled = true;
    const callback = await submit({
      action,
      cancel,
      controller,
      formData: form_data,
      formElement: form_element,
      submitter: event.submitter
    }) ?? fallback_callback;
    if (cancelled)
      return;
    let result;
    try {
      const response = await fetch(action, {
        method: "POST",
        headers: {
          accept: "application/json",
          "x-sveltekit-action": "true"
        },
        cache: "no-store",
        body: form_data,
        signal: controller.signal
      });
      result = deserialize(await response.text());
      if (result.type === "error")
        result.status = response.status;
    } catch (error2) {
      if (
        /** @type {any} */
        error2?.name === "AbortError"
      )
        return;
      result = { type: "error", error: error2 };
    }
    callback({
      action,
      formData: form_data,
      formElement: form_element,
      update: (opts) => fallback_callback({
        action,
        result,
        reset: opts?.reset,
        invalidateAll: opts?.invalidateAll
      }),
      // @ts-expect-error generic constraints stuff we don't care about
      result
    });
  }
  HTMLFormElement.prototype.addEventListener.call(form_element, "submit", handle_submit);
  return {
    destroy() {
      HTMLFormElement.prototype.removeEventListener.call(form_element, "submit", handle_submit);
    }
  };
}
function setPath(parent2, key2, value) {
  parent2[key2] = value;
  return "skip";
}
function isInvalidPath(originalPath, pathData) {
  return pathData.value !== void 0 && typeof pathData.value !== "object" && pathData.path.length < originalPath.length;
}
function pathExists(obj, path, options2 = {}) {
  if (!options2.modifier) {
    options2.modifier = (pathData) => isInvalidPath(path, pathData) ? void 0 : pathData.value;
  }
  const exists = traversePath(obj, path, options2.modifier);
  if (!exists)
    return void 0;
  if (options2.value === void 0)
    return exists;
  return options2.value(exists.value) ? exists : void 0;
}
function traversePath(obj, realPath, modifier) {
  if (!realPath.length)
    return void 0;
  const path = [realPath[0]];
  let parent2 = obj;
  while (parent2 && path.length < realPath.length) {
    const key22 = path[path.length - 1];
    const value = modifier ? modifier({
      parent: parent2,
      key: String(key22),
      value: parent2[key22],
      path: path.map((p2) => String(p2)),
      isLeaf: false,
      set: (v2) => setPath(parent2, key22, v2)
    }) : parent2[key22];
    if (value === void 0)
      return void 0;
    else
      parent2 = value;
    path.push(realPath[path.length]);
  }
  if (!parent2)
    return void 0;
  const key2 = realPath[realPath.length - 1];
  return {
    parent: parent2,
    key: String(key2),
    value: parent2[key2],
    path: realPath.map((p2) => String(p2)),
    isLeaf: true,
    set: (v2) => setPath(parent2, key2, v2)
  };
}
function traversePaths(parent2, modifier, path = []) {
  for (const key2 in parent2) {
    const value = parent2[key2];
    const isLeaf = value === null || typeof value !== "object";
    const pathData = {
      parent: parent2,
      key: key2,
      value,
      path: path.concat([key2]),
      // path.map(String).concat([key])
      isLeaf,
      set: (v2) => setPath(parent2, key2, v2)
    };
    const status = modifier(pathData);
    if (status === "abort")
      return status;
    else if (status === "skip")
      continue;
    else if (!isLeaf) {
      const status2 = traversePaths(value, modifier, pathData.path);
      if (status2 === "abort")
        return status2;
    }
  }
}
function eqSet(xs, ys) {
  return xs === ys || xs.size === ys.size && [...xs].every((x2) => ys.has(x2));
}
function comparePaths(newObj, oldObj) {
  const diffPaths = /* @__PURE__ */ new Map();
  function builtInDiff(one, other) {
    if (one instanceof Date && other instanceof Date && one.getTime() !== other.getTime())
      return true;
    if (one instanceof Set && other instanceof Set && !eqSet(one, other))
      return true;
    if (one instanceof File && other instanceof File && one !== other)
      return true;
    return false;
  }
  function isBuiltin(data) {
    return data instanceof Date || data instanceof Set || data instanceof File;
  }
  function checkPath(data, compareTo) {
    const otherData = compareTo ? traversePath(compareTo, data.path) : void 0;
    function addDiff() {
      diffPaths.set(data.path.join(" "), data.path);
      return "skip";
    }
    if (isBuiltin(data.value)) {
      if (!isBuiltin(otherData?.value) || builtInDiff(data.value, otherData.value)) {
        return addDiff();
      }
    }
    if (data.isLeaf) {
      if (!otherData || data.value !== otherData.value) {
        addDiff();
      }
    }
  }
  traversePaths(newObj, (data) => checkPath(data, oldObj));
  traversePaths(oldObj, (data) => checkPath(data, newObj));
  return Array.from(diffPaths.values());
}
function setPaths(obj, paths, value) {
  const isFunction2 = typeof value === "function";
  for (const path of paths) {
    const leaf = traversePath(obj, path, ({ parent: parent2, key: key2, value: value2 }) => {
      if (value2 === void 0 || typeof value2 !== "object") {
        parent2[key2] = {};
      }
      return parent2[key2];
    });
    if (leaf)
      leaf.parent[leaf.key] = isFunction2 ? value(path, leaf) : value;
  }
}
function splitPath(path) {
  return path.toString().split(/[[\].]+/).filter((p2) => p2);
}
function mergePath(path) {
  return path.reduce((acc, next2) => {
    const key2 = String(next2);
    if (typeof next2 === "number" || /^\d+$/.test(key2))
      acc += `[${key2}]`;
    else if (!acc)
      acc += key2;
    else
      acc += `.${key2}`;
    return acc;
  }, "");
}
function clone$1(obj) {
  let result = obj;
  var type = {}.toString.call(obj).slice(8, -1);
  if (type == "Set") {
    return new Set([...obj].map((value) => clone$1(value)));
  }
  if (type == "Map") {
    return new Map([...obj].map((kv) => [clone$1(kv[0]), clone$1(kv[1])]));
  }
  if (type == "Date") {
    return new Date(obj.getTime());
  }
  if (type == "RegExp") {
    return RegExp(obj.source, getRegExpFlags(obj));
  }
  if (type == "Array" || type == "Object") {
    result = Array.isArray(obj) ? [] : {};
    for (var key2 in obj) {
      result[key2] = clone$1(obj[key2]);
    }
  }
  return result;
}
function getRegExpFlags(regExp) {
  if (typeof regExp.source.flags == "string") {
    return regExp.source.flags;
  } else {
    var flags = [];
    regExp.global && flags.push("g");
    regExp.ignoreCase && flags.push("i");
    regExp.multiline && flags.push("m");
    regExp.sticky && flags.push("y");
    regExp.unicode && flags.push("u");
    return flags.join("");
  }
}
function clone(data) {
  return data && typeof data === "object" ? collectionClone(data) : data;
}
function assertSchema(schema, path) {
  if (typeof schema === "boolean") {
    throw new SchemaError("Schema property cannot be defined as boolean.", path);
  }
}
function schemaInfo(schema, isOptional, path) {
  assertSchema(schema, path);
  if (schema.allOf && schema.allOf.length) {
    return {
      ...merge$1.withOptions({ allowUndefinedOverrides: false }, ...schema.allOf.map((s3) => schemaInfo(s3, false, []))),
      schema
    };
  }
  const types = schemaTypes$1(schema, path);
  const array2 = schema.items && types.includes("array") ? (Array.isArray(schema.items) ? schema.items : [schema.items]).filter((s3) => typeof s3 !== "boolean") : void 0;
  const properties = schema.properties && types.includes("object") ? Object.fromEntries(Object.entries(schema.properties).filter(([, value]) => typeof value !== "boolean")) : void 0;
  const union = unionInfo(schema)?.filter((u2) => u2.type !== "null" && u2.const !== null);
  return {
    types: types.filter((s3) => s3 !== "null"),
    isOptional,
    isNullable: types.includes("null"),
    schema,
    union: union?.length ? union : void 0,
    array: array2,
    properties,
    required: schema.required
  };
}
function schemaTypes$1(schema, path) {
  assertSchema(schema, path);
  let types = schema.const === null ? ["null"] : [];
  if (schema.type) {
    types = Array.isArray(schema.type) ? schema.type : [schema.type];
  }
  if (schema.anyOf) {
    types = schema.anyOf.flatMap((s3) => schemaTypes$1(s3, path));
  }
  if (types.includes("array") && schema.uniqueItems) {
    const i2 = types.findIndex((t2) => t2 != "array");
    types[i2] = "set";
  } else if (schema.format && conversionFormatTypes.includes(schema.format)) {
    types.unshift(schema.format);
    if (schema.format == "unix-time") {
      const i2 = types.findIndex((t2) => t2 == "integer");
      types.splice(i2, 1);
    }
  }
  if (schema.const && schema.const !== null && typeof schema.const !== "function") {
    types.push(typeof schema.const);
  }
  return Array.from(new Set(types));
}
function unionInfo(schema) {
  if (!schema.anyOf || !schema.anyOf.length)
    return void 0;
  return schema.anyOf.filter((s3) => typeof s3 !== "boolean");
}
function defaultValues(schema, isOptional = false, path = []) {
  return _defaultValues(schema, isOptional, path);
}
function _defaultValues(schema, isOptional, path) {
  if (!schema) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema, isOptional, path);
  if (!info)
    return void 0;
  let objectDefaults = void 0;
  if ("default" in schema) {
    if (info.types.includes("object") && schema.default && typeof schema.default == "object" && !Array.isArray(schema.default)) {
      objectDefaults = schema.default;
    } else {
      if (info.types.length > 1) {
        if (info.types.includes("unix-time") && (info.types.includes("integer") || info.types.includes("number")))
          throw new SchemaError("Cannot resolve a default value with a union that includes a date and a number/integer.", path);
      }
      const [type] = info.types;
      return formatDefaultValue(type, schema.default);
    }
  }
  let _multiType;
  const isMultiTypeUnion = () => {
    if (!info.union || info.union.length < 2)
      return false;
    if (info.union.some((i2) => i2.enum))
      return true;
    if (!_multiType) {
      _multiType = new Set(info.types.map((i2) => {
        return ["integer", "unix-time"].includes(i2) ? "number" : i2;
      }));
    }
    return _multiType.size > 1;
  };
  let output = {};
  if (!objectDefaults && info.union) {
    const singleDefault = info.union.filter((s3) => typeof s3 !== "boolean" && s3.default !== void 0);
    if (singleDefault.length == 1) {
      return _defaultValues(singleDefault[0], isOptional, path);
    } else if (singleDefault.length > 1) {
      throw new SchemaError("Only one default value can exist in a union, or set a default value for the whole union.", path);
    } else {
      if (info.isNullable)
        return null;
      if (info.isOptional)
        return void 0;
      if (isMultiTypeUnion()) {
        throw new SchemaError("Multi-type unions must have a default value, or exactly one of the union types must have.", path);
      }
      if (info.union.length && info.types[0] == "object") {
        output = info.union.length > 1 ? merge$1.withOptions({ allowUndefinedOverrides: true }, ...info.union.map((s3) => _defaultValues(s3, isOptional, path))) : _defaultValues(info.union[0], isOptional, path);
      }
    }
  }
  if (!objectDefaults) {
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  if (info.properties) {
    for (const [key2, value] of Object.entries(info.properties)) {
      assertSchema(value, [...path, key2]);
      const def = objectDefaults && objectDefaults[key2] !== void 0 ? objectDefaults[key2] : _defaultValues(value, !info.required?.includes(key2), [...path, key2]);
      output[key2] = def;
    }
    return output;
  } else if (objectDefaults) {
    return objectDefaults;
  }
  if (schema.enum) {
    return schema.enum[0];
  }
  if (isMultiTypeUnion()) {
    throw new SchemaError("Default values cannot have more than one type.", path);
  } else if (info.types.length == 0) {
    return void 0;
  }
  const [formatType] = info.types;
  return defaultValue(formatType, schema.enum);
}
function formatDefaultValue(type, value) {
  switch (type) {
    case "set":
      return Array.isArray(value) ? new Set(value) : value;
    case "Date":
    case "date":
    case "unix-time":
      if (typeof value === "string" || typeof value === "number")
        return new Date(value);
      break;
    case "bigint":
      if (typeof value === "string" || typeof value === "number")
        return BigInt(value);
      break;
    case "symbol":
      if (typeof value === "string" || typeof value === "number")
        return Symbol(value);
      break;
  }
  return value;
}
function defaultValue(type, enumType2) {
  switch (type) {
    case "string":
      return enumType2 && enumType2.length > 0 ? enumType2[0] : "";
    case "number":
    case "integer":
      return enumType2 && enumType2.length > 0 ? enumType2[0] : 0;
    case "boolean":
      return false;
    case "array":
      return [];
    case "object":
      return {};
    case "null":
      return null;
    case "Date":
    case "date":
    case "unix-time":
      return void 0;
    case "bigint":
      return BigInt(0);
    case "set":
      return /* @__PURE__ */ new Set();
    case "symbol":
      return Symbol();
    case "undefined":
    case "any":
      return void 0;
    default:
      throw new SchemaError("Schema type or format not supported, requires explicit default value: " + type);
  }
}
function defaultTypes(schema, path = []) {
  return _defaultTypes(schema, false, path);
}
function _defaultTypes(schema, isOptional, path) {
  if (!schema) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema, isOptional, path);
  const output = {
    __types: info.types
  };
  if (info.schema.items && typeof info.schema.items == "object" && !Array.isArray(info.schema.items)) {
    output.__items = _defaultTypes(info.schema.items, info.isOptional, path);
  }
  if (info.properties) {
    for (const [key2, value] of Object.entries(info.properties)) {
      assertSchema(value, [...path, key2]);
      output[key2] = _defaultTypes(info.properties[key2], !info.required?.includes(key2), [
        ...path,
        key2
      ]);
    }
  }
  if (info.isNullable && !output.__types.includes("null")) {
    output.__types.push("null");
  }
  if (info.isOptional && !output.__types.includes("undefined")) {
    output.__types.push("undefined");
  }
  return output;
}
function mapErrors(errors, shape) {
  const output = {};
  function addFormLevelError(error2) {
    if (!("_errors" in output))
      output._errors = [];
    if (!Array.isArray(output._errors)) {
      if (typeof output._errors === "string")
        output._errors = [output._errors];
      else
        throw new SuperFormError("Form-level error was not an array.");
    }
    output._errors.push(error2.message);
  }
  for (const error2 of errors) {
    if (!error2.path || error2.path.length == 1 && !error2.path[0]) {
      addFormLevelError(error2);
      continue;
    }
    const isLastIndexNumeric = /^\d$/.test(String(error2.path[error2.path.length - 1]));
    const objectError = !isLastIndexNumeric && pathExists(shape, error2.path.filter((p2) => /\D/.test(String(p2))))?.value;
    const leaf = traversePath(output, error2.path, ({ value, parent: parent22, key: key22 }) => {
      if (value === void 0)
        parent22[key22] = {};
      return parent22[key22];
    });
    if (!leaf) {
      addFormLevelError(error2);
      continue;
    }
    const { parent: parent2, key: key2 } = leaf;
    if (objectError) {
      if (!(key2 in parent2))
        parent2[key2] = {};
      if (!("_errors" in parent2[key2]))
        parent2[key2]._errors = [error2.message];
      else
        parent2[key2]._errors.push(error2.message);
    } else {
      if (!(key2 in parent2))
        parent2[key2] = [error2.message];
      else
        parent2[key2].push(error2.message);
    }
  }
  return output;
}
function updateErrors(New, Previous, force) {
  if (force)
    return New;
  traversePaths(Previous, (errors) => {
    if (!Array.isArray(errors.value))
      return;
    errors.set(void 0);
  });
  traversePaths(New, (error2) => {
    if (!Array.isArray(error2.value) && error2.value !== void 0)
      return;
    setPaths(Previous, [error2.path], error2.value);
  });
  return Previous;
}
function flattenErrors(errors) {
  return _flattenErrors(errors, []);
}
function _flattenErrors(errors, path) {
  const entries = Object.entries(errors);
  return entries.filter(([, value]) => value !== void 0).flatMap(([key2, messages]) => {
    if (Array.isArray(messages) && messages.length > 0) {
      const currPath = path.concat([key2]);
      return { path: mergePath(currPath), messages };
    } else {
      return _flattenErrors(errors[key2], path.concat([key2]));
    }
  });
}
function mergeDefaults(parsedData, defaults6) {
  if (!parsedData)
    return clone(defaults6);
  return merge$1.withOptions({ mergeArrays: false }, defaults6, parsedData);
}
function replaceInvalidDefaults(Data, Defaults, _schema, Errors, preprocessed) {
  const defaultType = _schema.additionalProperties && typeof _schema.additionalProperties == "object" ? { __types: schemaInfo(_schema.additionalProperties, false, []).types } : void 0;
  const Types = defaultTypes(_schema);
  function Types_correctValue(dataValue, defValue, type) {
    const types = type.__types;
    if (!types.length || types.every((t2) => t2 == "undefined" || t2 == "null" || t2 == "any")) {
      return dataValue;
    } else if (types.length == 1 && types[0] == "array" && !type.__items) {
      return dataValue;
    }
    const dateTypes = ["unix-time", "Date", "date"];
    for (const schemaType of types) {
      const defaultTypeValue = defaultValue(schemaType, void 0);
      const sameType = typeof dataValue === typeof defaultTypeValue || dateTypes.includes(schemaType) && dataValue instanceof Date;
      const sameExistance = sameType && dataValue === null === (defaultTypeValue === null);
      if (sameType && sameExistance) {
        return dataValue;
      } else if (type.__items) {
        return Types_correctValue(dataValue, defValue, type.__items);
      }
    }
    if (defValue === void 0 && types.includes("null")) {
      return null;
    }
    return defValue;
  }
  function Data_traverse() {
    traversePaths(Defaults, Defaults_traverseAndReplace);
    Errors_traverseAndReplace();
    return Data;
  }
  function Data_setValue(currentPath, newValue) {
    setPaths(Data, [currentPath], newValue);
  }
  function Errors_traverseAndReplace() {
    for (const error2 of Errors) {
      if (!error2.path)
        continue;
      Defaults_traverseAndReplace({
        path: error2.path,
        value: pathExists(Defaults, error2.path)?.value
      });
    }
  }
  function Defaults_traverseAndReplace(defaultPath) {
    const currentPath = defaultPath.path;
    if (!currentPath || !currentPath[0])
      return;
    if (typeof currentPath[0] === "string" && preprocessed?.includes(currentPath[0]))
      return;
    const dataPath = pathExists(Data, currentPath);
    if (!dataPath && defaultPath.value !== void 0 || dataPath && dataPath.value === void 0) {
      Data_setValue(currentPath, defaultPath.value);
    } else if (dataPath) {
      const defValue = defaultPath.value;
      const dataValue = dataPath.value;
      if (defValue !== void 0 && typeof dataValue === typeof defValue && dataValue === null === (defValue === null)) {
        return;
      }
      const typePath = currentPath.filter((p2) => /\D/.test(String(p2)));
      const pathTypes = traversePath(Types, typePath, (path) => {
        return "__items" in path.value ? path.value.__items : path.value;
      });
      if (!pathTypes) {
        throw new SchemaError("No types found for defaults", currentPath);
      }
      const fieldType = pathTypes.value ?? defaultType;
      if (!fieldType) {
        throw new SchemaError("No default value specified for field (can be undefined, but must be explicit)", currentPath);
      }
      Data_setValue(currentPath, Types_correctValue(dataValue, defValue, fieldType));
    }
  }
  {
    return Data_traverse();
  }
}
function cancelFlash(options2) {
  if (!options2.flashMessage || !browser)
    return;
  if (!shouldSyncFlash(options2))
    return;
  document.cookie = `flash=; Max-Age=0; Path=${options2.flashMessage.cookiePath ?? "/"};`;
}
function shouldSyncFlash(options2) {
  if (!options2.flashMessage || !browser)
    return false;
  return options2.syncFlashMessage;
}
async function updateCustomValidity(validityEl, errors) {
  if ("setCustomValidity" in validityEl) {
    validityEl.setCustomValidity("");
  }
  if (noCustomValidityDataAttribute in validityEl.dataset)
    return;
  setCustomValidity(validityEl, errors);
}
function setCustomValidityForm(formElement, errors) {
  for (const el of formElement.querySelectorAll("input,select,textarea,button")) {
    if (noCustomValidityDataAttribute in el.dataset) {
      continue;
    }
    const error2 = traversePath(errors, splitPath(el.name));
    setCustomValidity(el, error2?.value);
    if (error2?.value)
      return;
  }
}
function setCustomValidity(el, errors) {
  const message = errors && errors.length ? errors.join("\n") : "";
  el.setCustomValidity(message);
  if (message)
    el.reportValidity();
}
function inputInfo(el) {
  const immediate = !!el && (el instanceof HTMLSelectElement || el instanceof HTMLInputElement && immediateInputTypes.includes(el.type));
  const multiple = !!el && el instanceof HTMLSelectElement && el.multiple;
  const file = !!el && el instanceof HTMLInputElement && el.type == "file";
  return { immediate, multiple, file };
}
function Form(formElement, timers, options2) {
  let state = FetchStatus.Idle;
  let delayedTimeout, timeoutTimeout;
  const Timers = activeTimers;
  function Timers_start() {
    Timers_clear();
    Timers_setState(state != FetchStatus.Delayed ? FetchStatus.Submitting : FetchStatus.Delayed);
    delayedTimeout = window.setTimeout(() => {
      if (delayedTimeout && state == FetchStatus.Submitting)
        Timers_setState(FetchStatus.Delayed);
    }, options2.delayMs);
    timeoutTimeout = window.setTimeout(() => {
      if (timeoutTimeout && state == FetchStatus.Delayed)
        Timers_setState(FetchStatus.Timeout);
    }, options2.timeoutMs);
    Timers.add(Timers_clear);
  }
  function Timers_clear() {
    clearTimeout(delayedTimeout);
    clearTimeout(timeoutTimeout);
    delayedTimeout = timeoutTimeout = 0;
    Timers.delete(Timers_clear);
    Timers_setState(FetchStatus.Idle);
  }
  function Timers_clearAll() {
    Timers.forEach((t2) => t2());
    Timers.clear();
  }
  function Timers_setState(s3) {
    state = s3;
    timers.submitting.set(state >= FetchStatus.Submitting);
    timers.delayed.set(state >= FetchStatus.Delayed);
    timers.timeout.set(state >= FetchStatus.Timeout);
  }
  const ErrorTextEvents = formElement;
  function ErrorTextEvents__selectText(e3) {
    const target = e3.target;
    if (options2.selectErrorText)
      target.select();
  }
  function ErrorTextEvents_addErrorTextListeners() {
    if (!options2.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => {
      el.addEventListener("invalid", ErrorTextEvents__selectText);
    });
  }
  function ErrorTextEvents_removeErrorTextListeners() {
    if (!options2.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => el.removeEventListener("invalid", ErrorTextEvents__selectText));
  }
  const Form2 = formElement;
  {
    ErrorTextEvents_addErrorTextListeners();
    const completed = (opts) => {
      if (!opts.clearAll)
        Timers_clear();
      else
        Timers_clearAll();
      if (!opts.cancelled)
        setTimeout(() => scrollToFirstError(Form2, options2), 1);
    };
    onDestroy(() => {
      ErrorTextEvents_removeErrorTextListeners();
      completed({ cancelled: true });
    });
    return {
      submitting() {
        Timers_start();
      },
      completed,
      scrollToFirstError() {
        setTimeout(() => scrollToFirstError(Form2, options2), 1);
      },
      isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed
    };
  }
}
function updateProxyField(obj, path, updater) {
  const output = traversePath(obj, path, ({ parent: parent2, key: key2, value }) => {
    if (value === void 0)
      parent2[key2] = /\D/.test(key2) ? {} : [];
    return parent2[key2];
  });
  if (output) {
    const newValue = updater(output.value);
    output.parent[output.key] = newValue;
  }
  return obj;
}
function superFieldProxy(superForm2, path, baseOptions) {
  const form = superForm2.form;
  const path2 = splitPath(path);
  const proxy2 = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data?.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy2.subscribe(...params);
      return () => unsub();
    },
    update(upd, options2) {
      form.update((data) => updateProxyField(data, path2, upd), options2 ?? baseOptions);
    },
    set(value, options2) {
      form.update((data) => updateProxyField(data, path2, () => value), options2 ?? baseOptions);
    }
  };
}
function isSuperForm(form, options2) {
  const isSuperForm2 = "form" in form;
  if (!isSuperForm2 && options2?.taint !== void 0) {
    throw new SuperFormError("If options.taint is set, the whole superForm object must be used as a proxy.");
  }
  return isSuperForm2;
}
function fieldProxy(form, path, options2) {
  const path2 = splitPath(path);
  if (isSuperForm(form, options2)) {
    return superFieldProxy(form, path, options2);
  }
  const proxy2 = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data?.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy2.subscribe(...params);
      return () => unsub();
    },
    update(upd) {
      form.update((data) => updateProxyField(data, path2, upd));
    },
    set(value) {
      form.update((data) => updateProxyField(data, path2, () => value));
    }
  };
}
function schemaShape(schema, path = []) {
  const output = _schemaShape(schema, path);
  if (!output)
    throw new SchemaError("No shape could be created for schema.", path);
  return output;
}
function _schemaShape(schema, path) {
  assertSchema(schema, path);
  const info = schemaInfo(schema, false, path);
  if (info.array || info.union) {
    const arr = info.array || [];
    const union = info.union || [];
    return arr.concat(union).reduce((shape, next2) => {
      const nextShape = _schemaShape(next2, path);
      if (nextShape)
        shape = { ...shape ?? {}, ...nextShape };
      return shape;
    }, arr.length ? {} : void 0);
  }
  if (info.properties) {
    const output = {};
    for (const [key2, prop] of Object.entries(info.properties)) {
      const shape = _schemaShape(prop, [...path, key2]);
      if (shape)
        output[key2] = shape;
    }
    return output;
  }
  return info.types.includes("array") || info.types.includes("object") ? {} : void 0;
}
function shapeFromObject(obj) {
  let output = {};
  const isArray = Array.isArray(obj);
  for (const [key2, value] of Object.entries(obj)) {
    if (!value || typeof value !== "object")
      continue;
    if (isArray)
      output = { ...output, ...shapeFromObject(value) };
    else
      output[key2] = shapeFromObject(value);
  }
  return output;
}
function superForm(form, formOptions) {
  let initialForm;
  let options2 = formOptions ?? {};
  let initialValidator = void 0;
  {
    if (options2.legacy ?? LEGACY_MODE) {
      if (options2.resetForm === void 0)
        options2.resetForm = false;
      if (options2.taintedMessage === void 0)
        options2.taintedMessage = true;
    }
    if (STORYBOOK_MODE) {
      if (options2.applyAction === void 0)
        options2.applyAction = false;
    }
    if (typeof options2.SPA === "string") {
      if (options2.invalidateAll === void 0)
        options2.invalidateAll = false;
      if (options2.applyAction === void 0)
        options2.applyAction = false;
    }
    initialValidator = options2.validators;
    options2 = {
      ...defaultFormOptions,
      ...options2
    };
    if ((options2.SPA === true || typeof options2.SPA === "object") && options2.validators === void 0) {
      console.warn("No validators set for superForm in SPA mode. Add a validation adapter to the validators option, or set it to false to disable this warning.");
    }
    if (!form) {
      throw new SuperFormError("No form data sent to superForm. Make sure the output from superValidate is used (usually data.form) and that it's not null or undefined. Alternatively, an object with default values for the form can also be used, but then constraints won't be available.");
    }
    if (Context_isValidationObject(form) === false) {
      form = {
        id: options2.id ?? Math.random().toString(36).slice(2, 10),
        valid: false,
        posted: false,
        errors: {},
        data: form,
        shape: shapeFromObject(form)
      };
    }
    form = form;
    const _initialFormId = form.id = options2.id ?? form.id;
    const _currentPage = get_store_value(page) ?? (STORYBOOK_MODE ? {} : void 0);
    if (!initialForms.has(form)) {
      initialForms.set(form, form);
    }
    initialForm = initialForms.get(form);
    if (_currentPage.form && typeof _currentPage.form === "object") {
      const postedData = _currentPage.form;
      for (const postedForm of Context_findValidationForms(postedData).reverse()) {
        if (postedForm.id == _initialFormId && !initialForms.has(postedForm)) {
          initialForms.set(postedData, postedData);
          const pageDataForm = form;
          form = postedForm;
          form.constraints = pageDataForm.constraints;
          form.shape = pageDataForm.shape;
          if (form.valid && options2.resetForm && (options2.resetForm === true || options2.resetForm())) {
            form = clone(pageDataForm);
            form.message = clone(postedForm.message);
          }
          break;
        }
      }
    } else {
      form = clone(initialForm);
    }
    onDestroy(() => {
      Unsubscriptions_unsubscribe();
      NextChange_clear();
      EnhancedForm_destroy();
      for (const events of Object.values(formEvents)) {
        events.length = 0;
      }
      formIds.get(_currentPage)?.delete(_initialFormId);
    });
    if (options2.dataType !== "json") {
      const checkForNestedData = (key2, value) => {
        if (!value || typeof value !== "object")
          return;
        if (Array.isArray(value)) {
          if (value.length > 0)
            checkForNestedData(key2, value[0]);
        } else if (!(value instanceof Date) && !(value instanceof File) && !browser) {
          throw new SuperFormError(`Object found in form field "${key2}". Set the dataType option to "json" and add use:enhance to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`);
        }
      };
      for (const [key2, value] of Object.entries(form.data)) {
        checkForNestedData(key2, value);
      }
    }
  }
  const __data = {
    formId: form.id,
    form: clone(form.data),
    constraints: form.constraints ?? {},
    posted: form.posted,
    errors: clone(form.errors),
    message: clone(form.message),
    tainted: void 0,
    valid: form.valid,
    submitting: false,
    shape: form.shape
  };
  const Data = __data;
  const FormId = writable(options2.id ?? form.id);
  function Context_findValidationForms(data) {
    const forms = Object.values(data).filter((v2) => Context_isValidationObject(v2) !== false);
    return forms;
  }
  function Context_isValidationObject(object) {
    if (!object || typeof object !== "object")
      return false;
    if (!("valid" in object && "errors" in object && typeof object.valid === "boolean")) {
      return false;
    }
    return "id" in object && typeof object.id === "string" ? object.id : false;
  }
  const _formData = writable(form.data);
  const Form$1 = {
    subscribe: _formData.subscribe,
    set: (value, options22 = {}) => {
      const newData = clone(value);
      Tainted_update(newData, options22.taint ?? true);
      return _formData.set(newData);
    },
    update: (updater, options22 = {}) => {
      return _formData.update((value) => {
        const newData = updater(value);
        Tainted_update(newData, options22.taint ?? true);
        return newData;
      });
    }
  };
  function Form_isSPA() {
    return options2.SPA === true || typeof options2.SPA === "object";
  }
  async function Form_validate(opts = {}) {
    const dataToValidate = opts.formData ?? Data.form;
    let errors = {};
    let status;
    const validator2 = opts.adapter ?? options2.validators;
    if (typeof validator2 == "object") {
      if (validator2 != initialValidator && !("jsonSchema" in validator2)) {
        throw new SuperFormError('Client validation adapter found in options.validators. A full adapter must be used when changing validators dynamically, for example "zod" instead of "zodClient".');
      }
      status = await /* @__PURE__ */ validator2.validate(dataToValidate);
      if (!status.success) {
        errors = mapErrors(status.issues, validator2.shape ?? Data.shape ?? {});
      } else if (opts.recheckValidData !== false) {
        return Form_validate({ ...opts, recheckValidData: false });
      }
    } else {
      status = { success: true, data: {} };
    }
    const data = { ...Data.form, ...dataToValidate, ...status.success ? status.data : {} };
    return {
      valid: status.success,
      posted: false,
      errors,
      data,
      constraints: Data.constraints,
      message: void 0,
      id: Data.formId,
      shape: Data.shape
    };
  }
  function Form__changeEvent(event) {
    if (!options2.onChange || !event.paths.length || event.type == "blur")
      return;
    let changeEvent;
    const paths = event.paths.map(mergePath);
    if (event.type && event.paths.length == 1 && event.formElement && event.target instanceof Element) {
      changeEvent = {
        path: paths[0],
        paths,
        formElement: event.formElement,
        target: event.target,
        set(path, value, options22) {
          fieldProxy({ form: Form$1 }, path, options22).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form$1, path));
        }
      };
    } else {
      changeEvent = {
        paths,
        target: void 0,
        set(path, value, options22) {
          fieldProxy({ form: Form$1 }, path, options22).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form$1, path));
        }
      };
    }
    options2.onChange(changeEvent);
  }
  async function Form_clientValidation(event, force = false, adapter) {
    if (event) {
      if (options2.validators == "clear") {
        Errors.update(($errors) => {
          setPaths($errors, event.paths, void 0);
          return $errors;
        });
      }
      setTimeout(() => Form__changeEvent(event));
    }
    let skipValidation = false;
    if (!force) {
      if (options2.validationMethod == "onsubmit" || options2.validationMethod == "submit-only") {
        skipValidation = true;
      } else if (options2.validationMethod == "onblur" && event?.type == "input")
        skipValidation = true;
      else if (options2.validationMethod == "oninput" && event?.type == "blur")
        skipValidation = true;
    }
    if (skipValidation || !event || !options2.validators || options2.validators == "clear") {
      if (event?.paths) {
        const formElement = event?.formElement ?? EnhancedForm_get();
        if (formElement)
          Form__clearCustomValidity(formElement, event.paths);
      }
      return;
    }
    const result = await Form_validate({ adapter });
    if (result.valid && (event.immediate || event.type != "input")) {
      Form$1.set(result.data, { taint: "ignore" });
    }
    await tick();
    Form__displayNewErrors(result.errors, event, force);
    return result;
  }
  function Form__clearCustomValidity(formElement, paths) {
    const validity = /* @__PURE__ */ new Map();
    if (options2.customValidity && formElement) {
      for (const path of paths) {
        const name2 = CSS.escape(mergePath(path));
        const el = formElement.querySelector(`[name="${name2}"]`);
        if (el) {
          const message = "validationMessage" in el ? String(el.validationMessage) : "";
          validity.set(path.join("."), { el, message });
          updateCustomValidity(el, void 0);
        }
      }
    }
    return validity;
  }
  async function Form__displayNewErrors(errors, event, force) {
    const { type, immediate, multiple, paths } = event;
    const previous = Data.errors;
    const output = {};
    let validity = /* @__PURE__ */ new Map();
    const formElement = event.formElement ?? EnhancedForm_get();
    if (formElement)
      validity = Form__clearCustomValidity(formElement, event.paths);
    traversePaths(errors, (error2) => {
      if (!Array.isArray(error2.value))
        return;
      const currentPath = [...error2.path];
      if (currentPath[currentPath.length - 1] == "_errors") {
        currentPath.pop();
      }
      const joinedPath = currentPath.join(".");
      function addError() {
        setPaths(output, [error2.path], error2.value);
        if (options2.customValidity && isEventError && validity.has(joinedPath)) {
          const { el, message } = validity.get(joinedPath);
          if (message != error2.value) {
            updateCustomValidity(el, error2.value);
            validity.clear();
          }
        }
      }
      if (force)
        return addError();
      const lastPath = error2.path[error2.path.length - 1];
      const isObjectError = lastPath == "_errors";
      const isEventError = error2.value && paths.some((path) => {
        return isObjectError ? currentPath && path && currentPath.length > 0 && currentPath[0] == path[0] : joinedPath == path.join(".");
      });
      if (isEventError && options2.validationMethod == "oninput")
        return addError();
      if (immediate && !multiple && isEventError)
        return addError();
      if (multiple) {
        const errorPath = pathExists(get_store_value(Errors), error2.path.slice(0, -1));
        if (errorPath?.value && typeof errorPath?.value == "object") {
          for (const errors2 of Object.values(errorPath.value)) {
            if (Array.isArray(errors2)) {
              return addError();
            }
          }
        }
      }
      const previousError = pathExists(previous, error2.path);
      if (previousError && previousError.key in previousError.parent) {
        return addError();
      }
      if (isObjectError) {
        if (options2.validationMethod == "oninput" || type == "blur" && Tainted_hasBeenTainted(mergePath(error2.path.slice(0, -1)))) {
          return addError();
        }
      } else {
        if (type == "blur" && isEventError) {
          return addError();
        }
      }
    });
    Errors.set(output);
  }
  function Form_set(data, options22 = {}) {
    if (options22.keepFiles) {
      traversePaths(Data.form, (info) => {
        if (info.value instanceof File || browser) {
          const dataPath = pathExists(data, info.path);
          if (!dataPath || !(dataPath.key in dataPath.parent)) {
            setPaths(data, [info.path], info.value);
          }
        }
      });
    }
    return Form$1.set(data, options22);
  }
  function Form_shouldReset(validForm, successActionResult) {
    return validForm && successActionResult && options2.resetForm && (options2.resetForm === true || options2.resetForm());
  }
  async function Form_updateFromValidation(form2, successResult) {
    if (form2.valid && successResult && Form_shouldReset(form2.valid, successResult)) {
      Form_reset({ message: form2.message, posted: true });
    } else {
      rebind({
        form: form2,
        untaint: successResult,
        keepFiles: true,
        // Check if the form data should be used for updating, or if the invalidateAll load function should be used:
        skipFormData: options2.invalidateAll == "force"
      });
    }
    if (formEvents.onUpdated.length) {
      await tick();
    }
    for (const event of formEvents.onUpdated) {
      event({ form: form2 });
    }
  }
  function Form_reset(opts = {}) {
    if (opts.newState)
      initialForm.data = { ...initialForm.data, ...opts.newState };
    const resetData = clone(initialForm);
    resetData.data = { ...resetData.data, ...opts.data };
    if (opts.id !== void 0)
      resetData.id = opts.id;
    rebind({
      form: resetData,
      untaint: true,
      message: opts.message,
      keepFiles: false,
      posted: opts.posted,
      resetted: true
    });
  }
  async function Form_updateFromActionResult(result) {
    if (result.type == "error") {
      throw new SuperFormError(`ActionResult of type "${result.type}" cannot be passed to update function.`);
    }
    if (result.type == "redirect") {
      if (Form_shouldReset(true, true))
        Form_reset({ posted: true });
      return;
    }
    if (typeof result.data !== "object") {
      throw new SuperFormError("Non-object validation data returned from ActionResult.");
    }
    const forms = Context_findValidationForms(result.data);
    if (!forms.length) {
      throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
    }
    for (const newForm of forms) {
      if (newForm.id !== Data.formId)
        continue;
      await Form_updateFromValidation(newForm, result.status >= 200 && result.status < 300);
    }
  }
  const Message = writable(__data.message);
  const Constraints = writable(__data.constraints);
  const Posted = writable(__data.posted);
  const Shape = writable(__data.shape);
  const _errors = writable(form.errors);
  const Errors = {
    subscribe: _errors.subscribe,
    set(value, options22) {
      return _errors.set(updateErrors(value, Data.errors, options22?.force));
    },
    update(updater, options22) {
      return _errors.update((value) => {
        return updateErrors(updater(value), Data.errors, options22?.force);
      });
    },
    /**
     * To work with client-side validation, errors cannot be deleted but must
     * be set to undefined, to know where they existed before (tainted+error check in oninput)
     */
    clear: () => Errors.set({})
  };
  let NextChange = null;
  function NextChange_setHtmlEvent(event) {
    if (NextChange && event && Object.keys(event).length == 1 && event.paths?.length && NextChange.target && NextChange.target instanceof HTMLInputElement && NextChange.target.type.toLowerCase() == "file") {
      NextChange.paths = event.paths;
    } else {
      NextChange = event;
    }
    setTimeout(() => {
      Form_clientValidation(NextChange);
    }, 0);
  }
  function NextChange_additionalEventInformation(event, immediate, multiple, formElement, target) {
    if (NextChange === null) {
      NextChange = { paths: [] };
    }
    NextChange.type = event;
    NextChange.immediate = immediate;
    NextChange.multiple = multiple;
    NextChange.formElement = formElement;
    NextChange.target = target;
  }
  function NextChange_paths() {
    return NextChange?.paths ?? [];
  }
  function NextChange_clear() {
    NextChange = null;
  }
  const Tainted = {
    defaultMessage: "Leave page? Changes that you made may not be saved.",
    state: writable(),
    message: options2.taintedMessage,
    clean: clone(form.data),
    // Important to clone form.data, so it's not comparing the same object,
    forceRedirection: false
  };
  function Tainted_enable() {
    options2.taintedMessage = Tainted.message;
  }
  function Tainted_currentState() {
    return Tainted.state;
  }
  function Tainted_hasBeenTainted(path) {
    if (!Data.tainted)
      return false;
    if (!path)
      return !!Data.tainted;
    const field = pathExists(Data.tainted, splitPath(path));
    return !!field && field.key in field.parent;
  }
  function Tainted_isTainted(path) {
    if (typeof path === "boolean")
      return path;
    if (typeof path === "object")
      return Tainted__isObjectTainted(path);
    if (!Data.tainted)
      return false;
    if (!path)
      return Tainted__isObjectTainted(Data.tainted);
    const field = pathExists(Data.tainted, splitPath(path));
    return Tainted__isObjectTainted(field?.value);
  }
  function Tainted__isObjectTainted(obj) {
    if (!obj)
      return false;
    if (typeof obj === "object") {
      for (const obj2 of Object.values(obj)) {
        if (Tainted__isObjectTainted(obj2))
          return true;
      }
    }
    return obj === true;
  }
  function Tainted_update(newData, taintOptions) {
    if (taintOptions == "ignore")
      return;
    const paths = comparePaths(newData, Data.form);
    const newTainted = comparePaths(newData, Tainted.clean).map((path) => path.join());
    if (paths.length) {
      if (taintOptions == "untaint-all" || taintOptions == "untaint-form") {
        Tainted.state.set(void 0);
      } else {
        Tainted.state.update((currentlyTainted) => {
          if (!currentlyTainted)
            currentlyTainted = {};
          setPaths(currentlyTainted, paths, (path, data) => {
            if (!newTainted.includes(path.join()))
              return void 0;
            const currentValue = traversePath(newData, path);
            const cleanPath = traversePath(Tainted.clean, path);
            return currentValue && cleanPath && currentValue.value === cleanPath.value ? void 0 : taintOptions === true ? true : taintOptions === "untaint" ? void 0 : data.value;
          });
          return currentlyTainted;
        });
      }
    }
    NextChange_setHtmlEvent({ paths });
  }
  function Tainted_set(tainted, newClean) {
    Tainted.state.set(tainted);
    if (newClean)
      Tainted.clean = newClean;
  }
  const Submitting = writable(false);
  const Delayed = writable(false);
  const Timeout = writable(false);
  const Unsubscriptions = [
    // eslint-disable-next-line dci-lint/private-role-access
    Tainted.state.subscribe((tainted) => __data.tainted = clone(tainted)),
    // eslint-disable-next-line dci-lint/private-role-access
    Form$1.subscribe((form2) => __data.form = clone(form2)),
    // eslint-disable-next-line dci-lint/private-role-access
    Errors.subscribe((errors) => __data.errors = clone(errors)),
    FormId.subscribe((id) => __data.formId = id),
    Constraints.subscribe((constraints2) => __data.constraints = constraints2),
    Posted.subscribe((posted) => __data.posted = posted),
    Message.subscribe((message) => __data.message = message),
    Submitting.subscribe((submitting) => __data.submitting = submitting),
    Shape.subscribe((shape) => __data.shape = shape)
  ];
  function Unsubscriptions_unsubscribe() {
    Unsubscriptions.forEach((unsub) => unsub());
  }
  let EnhancedForm;
  function EnhancedForm_get() {
    return EnhancedForm;
  }
  function EnhancedForm_setAction(action) {
    if (EnhancedForm)
      EnhancedForm.action = action;
  }
  function EnhancedForm_destroy() {
    if (EnhancedForm?.parentElement) {
      EnhancedForm.remove();
    }
    EnhancedForm = void 0;
  }
  const AllErrors = derived(Errors, ($errors) => $errors ? flattenErrors($errors) : []);
  options2.taintedMessage = void 0;
  function rebind(opts) {
    const form2 = opts.form;
    const message = opts.message ?? form2.message;
    if (opts.untaint || opts.resetted) {
      Tainted_set(typeof opts.untaint === "boolean" ? void 0 : opts.untaint, form2.data);
    }
    if (opts.skipFormData !== true) {
      Form_set(form2.data, {
        taint: "ignore",
        keepFiles: opts.keepFiles
      });
    }
    Message.set(message);
    if (opts.resetted)
      Errors.update(() => ({}), { force: true });
    else
      Errors.set(form2.errors);
    FormId.set(form2.id);
    Posted.set(opts.posted ?? form2.posted);
    if (form2.constraints)
      Constraints.set(form2.constraints);
    if (form2.shape)
      Shape.set(form2.shape);
    __data.valid = form2.valid;
    if (options2.flashMessage && shouldSyncFlash(options2)) {
      const flash = options2.flashMessage.module.getFlash(page);
      if (message && get_store_value(flash) === void 0) {
        flash.set(message);
      }
    }
  }
  const formEvents = {
    onSubmit: options2.onSubmit ? [options2.onSubmit] : [],
    onResult: options2.onResult ? [options2.onResult] : [],
    onUpdate: options2.onUpdate ? [options2.onUpdate] : [],
    onUpdated: options2.onUpdated ? [options2.onUpdated] : [],
    onError: options2.onError ? [options2.onError] : []
  };
  function superFormEnhance(FormElement, events) {
    if (options2.SPA !== void 0 && FormElement.method == "get")
      FormElement.method = "post";
    if (typeof options2.SPA === "string") {
      if (options2.SPA.length && FormElement.action == document.location.href) {
        FormElement.action = options2.SPA;
      }
    } else {
      EnhancedForm = FormElement;
    }
    if (events) {
      if (events.onError) {
        if (options2.onError === "apply") {
          throw new SuperFormError('options.onError is set to "apply", cannot add any onError events.');
        } else if (events.onError === "apply") {
          throw new SuperFormError('Cannot add "apply" as onError event in use:enhance.');
        }
        formEvents.onError.push(events.onError);
      }
      if (events.onResult)
        formEvents.onResult.push(events.onResult);
      if (events.onSubmit)
        formEvents.onSubmit.push(events.onSubmit);
      if (events.onUpdate)
        formEvents.onUpdate.push(events.onUpdate);
      if (events.onUpdated)
        formEvents.onUpdated.push(events.onUpdated);
    }
    Tainted_enable();
    let lastInputChange;
    async function onInput(e3) {
      const info = inputInfo(e3.target);
      if (info.immediate && !info.file)
        await new Promise((r3) => setTimeout(r3, 0));
      lastInputChange = NextChange_paths();
      NextChange_additionalEventInformation("input", info.immediate, info.multiple, FormElement, e3.target ?? void 0);
    }
    async function onBlur(e3) {
      if (Data.submitting)
        return;
      if (!lastInputChange || NextChange_paths() != lastInputChange) {
        return;
      }
      const info = inputInfo(e3.target);
      if (info.immediate && !info.file)
        await new Promise((r3) => setTimeout(r3, 0));
      Form_clientValidation({
        paths: lastInputChange,
        immediate: info.multiple,
        multiple: info.multiple,
        type: "blur",
        formElement: FormElement,
        target: e3.target ?? void 0
      });
      lastInputChange = void 0;
    }
    FormElement.addEventListener("focusout", onBlur);
    FormElement.addEventListener("input", onInput);
    onDestroy(() => {
      FormElement.removeEventListener("focusout", onBlur);
      FormElement.removeEventListener("input", onInput);
    });
    const htmlForm = Form(FormElement, { submitting: Submitting, delayed: Delayed, timeout: Timeout }, options2);
    let currentRequest;
    return enhance(FormElement, async (submitParams) => {
      let jsonData = void 0;
      let validationAdapter = options2.validators;
      const submit = {
        ...submitParams,
        jsonData(data) {
          if (options2.dataType !== "json") {
            throw new SuperFormError("options.dataType must be set to 'json' to use jsonData.");
          }
          jsonData = data;
        },
        validators(adapter) {
          validationAdapter = adapter;
        }
      };
      const _submitCancel = submit.cancel;
      let cancelled = false;
      function clientValidationResult(validation) {
        const validationResult = { ...validation, posted: true };
        const status = validationResult.valid ? 200 : (typeof options2.SPA === "boolean" || typeof options2.SPA === "string" ? void 0 : options2.SPA?.failStatus) ?? 400;
        const data = { form: validationResult };
        const result = validationResult.valid ? { type: "success", status, data } : { type: "failure", status, data };
        setTimeout(() => validationResponse({ result }), 0);
      }
      function clearOnSubmit() {
        switch (options2.clearOnSubmit) {
          case "errors-and-message":
            Errors.clear();
            Message.set(void 0);
            break;
          case "errors":
            Errors.clear();
            break;
          case "message":
            Message.set(void 0);
            break;
        }
      }
      function cancel(opts = {
        resetTimers: true
      }) {
        cancelled = true;
        if (opts.resetTimers && htmlForm.isSubmitting()) {
          htmlForm.completed({ cancelled });
        }
        return _submitCancel();
      }
      submit.cancel = cancel;
      if (htmlForm.isSubmitting() && options2.multipleSubmits == "prevent") {
        cancel({ resetTimers: false });
      } else {
        if (htmlForm.isSubmitting() && options2.multipleSubmits == "abort") {
          if (currentRequest)
            currentRequest.abort();
        }
        htmlForm.submitting();
        currentRequest = submit.controller;
        for (const event of formEvents.onSubmit) {
          await event(submit);
        }
      }
      if (cancelled && options2.flashMessage)
        cancelFlash(options2);
      if (!cancelled) {
        const noValidate = !Form_isSPA() && (FormElement.noValidate || (submit.submitter instanceof HTMLButtonElement || submit.submitter instanceof HTMLInputElement) && submit.submitter.formNoValidate);
        let validation = void 0;
        const validateForm = async () => {
          return await Form_validate({ adapter: validationAdapter });
        };
        clearOnSubmit();
        if (!noValidate) {
          validation = await validateForm();
          if (!validation.valid) {
            cancel({ resetTimers: false });
            clientValidationResult(validation);
          }
        }
        if (!cancelled) {
          if (options2.flashMessage && (options2.clearOnSubmit == "errors-and-message" || options2.clearOnSubmit == "message") && shouldSyncFlash(options2)) {
            options2.flashMessage.module.getFlash(page).set(void 0);
          }
          const submitData = "formData" in submit ? submit.formData : submit.data;
          lastInputChange = void 0;
          if (Form_isSPA()) {
            if (!validation)
              validation = await validateForm();
            cancel({ resetTimers: false });
            clientValidationResult(validation);
          } else if (options2.dataType === "json") {
            if (!validation)
              validation = await validateForm();
            const postData = clone(jsonData ?? validation.data);
            traversePaths(postData, (data) => {
              if (data.value instanceof File) {
                const key2 = "__superform_file_" + mergePath(data.path);
                submitData.append(key2, data.value);
                return data.set(void 0);
              } else if (Array.isArray(data.value) && data.value.length && data.value.every((v2) => v2 instanceof File)) {
                const key2 = "__superform_files_" + mergePath(data.path);
                for (const file of data.value) {
                  submitData.append(key2, file);
                }
                return data.set(void 0);
              }
            });
            Object.keys(postData).forEach((key2) => {
              if (typeof submitData.get(key2) === "string") {
                submitData.delete(key2);
              }
            });
            const chunks = chunkSubstr(stringify(postData), options2.jsonChunkSize ?? 5e5);
            for (const chunk of chunks) {
              submitData.append("__superform_json", chunk);
            }
          }
          if (!submitData.has("__superform_id")) {
            const id = Data.formId;
            if (id !== void 0)
              submitData.set("__superform_id", id);
          }
          if (typeof options2.SPA === "string") {
            EnhancedForm_setAction(options2.SPA);
          }
        }
      }
      function chunkSubstr(str, size2) {
        const numChunks = Math.ceil(str.length / size2);
        const chunks = new Array(numChunks);
        for (let i2 = 0, o2 = 0; i2 < numChunks; ++i2, o2 += size2) {
          chunks[i2] = str.substring(o2, o2 + size2);
        }
        return chunks;
      }
      async function validationResponse(event) {
        let cancelled2 = false;
        currentRequest = null;
        let result = "type" in event.result && "status" in event.result ? event.result : {
          type: "error",
          status: parseInt(String(event.result.status)) || 500,
          error: event.result.error instanceof Error ? event.result.error : event.result
        };
        const cancel2 = () => cancelled2 = true;
        const data = {
          result,
          formEl: FormElement,
          formElement: FormElement,
          cancel: cancel2
        };
        const unsubCheckforNav = STORYBOOK_MODE || !Form_isSPA() ? () => {
        } : navigating.subscribe(($nav) => {
          if (!$nav || $nav.from?.route.id === $nav.to?.route.id)
            return;
          cancel2();
        });
        for (const event2 of formEvents.onResult) {
          await event2(data);
        }
        result = data.result;
        if (!cancelled2) {
          if ((result.type === "success" || result.type == "failure") && result.data) {
            const forms = Context_findValidationForms(result.data);
            if (!forms.length) {
              throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
            }
            for (const newForm of forms) {
              if (newForm.id !== Data.formId)
                continue;
              const data2 = {
                form: newForm,
                formEl: FormElement,
                formElement: FormElement,
                cancel: () => cancelled2 = true,
                result
              };
              for (const event2 of formEvents.onUpdate) {
                await event2(data2);
              }
              result = data2.result;
              if (!cancelled2) {
                if (options2.customValidity) {
                  setCustomValidityForm(FormElement, data2.form.errors);
                }
                if (Form_shouldReset(data2.form.valid, result.type == "success")) {
                  data2.formElement.querySelectorAll('input[type="file"]').forEach((e3) => e3.value = "");
                }
              }
            }
          }
          if (!cancelled2) {
            if (result.type !== "error") {
              if (result.type === "success" && options2.invalidateAll) {
                await invalidateAll();
              }
              if (options2.applyAction) {
                await applyAction();
              } else {
                await Form_updateFromActionResult(result);
              }
            } else {
              if (options2.applyAction) {
                if (options2.onError == "apply") {
                  await applyAction();
                } else {
                  ({
                    type: "failure",
                    status: Math.floor(result.status || 500),
                    data: result
                  });
                  await applyAction();
                }
              }
              if (options2.onError !== "apply") {
                const data2 = { result, message: Message };
                for (const onErrorEvent of formEvents.onError) {
                  if (onErrorEvent !== "apply" && (onErrorEvent != defaultOnError || !options2.flashMessage?.onError)) {
                    await onErrorEvent(data2);
                  }
                }
              }
            }
            if (options2.flashMessage) {
              if (result.type == "error" && options2.flashMessage.onError) {
                await options2.flashMessage.onError({
                  result,
                  flashMessage: options2.flashMessage.module.getFlash(page)
                });
              }
            }
          }
        }
        if (cancelled2 && options2.flashMessage) {
          cancelFlash(options2);
        }
        if (cancelled2 || result.type != "redirect") {
          htmlForm.completed({ cancelled: cancelled2 });
        } else if (STORYBOOK_MODE) {
          htmlForm.completed({ cancelled: cancelled2, clearAll: true });
        } else {
          const unsub = navigating.subscribe(($nav) => {
            if ($nav)
              return;
            setTimeout(() => {
              try {
                if (unsub)
                  unsub();
              } catch {
              }
            });
            if (htmlForm.isSubmitting()) {
              htmlForm.completed({ cancelled: cancelled2, clearAll: true });
            }
          });
        }
        unsubCheckforNav();
      }
      return validationResponse;
    });
  }
  function removeFiles2(formData) {
    const paths = [];
    traversePaths(formData, (data2) => {
      if (data2.value instanceof File) {
        paths.push(data2.path);
        return "skip";
      } else if (Array.isArray(data2.value) && data2.value.length && data2.value.every((d) => d instanceof File)) {
        paths.push(data2.path);
        return "skip";
      }
    });
    if (!paths.length)
      return { data: formData, paths };
    const data = clone(formData);
    setPaths(data, paths, (path) => pathExists(initialForm.data, path)?.value);
    return { data, paths };
  }
  return {
    form: Form$1,
    formId: FormId,
    errors: Errors,
    message: Message,
    constraints: Constraints,
    tainted: Tainted_currentState(),
    submitting: readonly(Submitting),
    delayed: readonly(Delayed),
    timeout: readonly(Timeout),
    options: options2,
    capture() {
      const { data, paths } = removeFiles2(Data.form);
      let tainted = Data.tainted;
      if (paths.length) {
        tainted = clone(tainted) ?? {};
        setPaths(tainted, paths, false);
      }
      return {
        valid: Data.valid,
        posted: Data.posted,
        errors: Data.errors,
        data,
        constraints: Data.constraints,
        message: Data.message,
        id: Data.formId,
        tainted,
        shape: Data.shape
      };
    },
    restore: (snapshot) => {
      rebind({ form: snapshot, untaint: snapshot.tainted ?? true });
    },
    async validate(path, opts = {}) {
      if (!options2.validators) {
        throw new SuperFormError("options.validators must be set to use the validate method.");
      }
      if (opts.update === void 0)
        opts.update = true;
      if (opts.taint === void 0)
        opts.taint = false;
      if (typeof opts.errors == "string")
        opts.errors = [opts.errors];
      let data;
      const splittedPath = splitPath(path);
      if ("value" in opts) {
        if (opts.update === true || opts.update === "value") {
          Form$1.update(($form) => {
            setPaths($form, [splittedPath], opts.value);
            return $form;
          }, { taint: opts.taint });
          data = Data.form;
        } else {
          data = clone(Data.form);
          setPaths(data, [splittedPath], opts.value);
        }
      } else {
        data = Data.form;
      }
      const result = await Form_validate({ formData: data });
      const error2 = pathExists(result.errors, splittedPath);
      if (error2 && error2.value && opts.errors) {
        error2.value = opts.errors;
      }
      if (opts.update === true || opts.update == "errors") {
        Errors.update(($errors) => {
          setPaths($errors, [splittedPath], error2?.value);
          return $errors;
        });
      }
      return error2?.value;
    },
    async validateForm(opts = {}) {
      if (!options2.validators && !opts.schema) {
        throw new SuperFormError("options.validators or the schema option must be set to use the validateForm method.");
      }
      const result = opts.update ? await Form_clientValidation({ paths: [] }, true, opts.schema) : Form_validate({ adapter: opts.schema });
      const enhancedForm = EnhancedForm_get();
      if (opts.update && enhancedForm) {
        setTimeout(() => {
          if (!enhancedForm)
            return;
          scrollToFirstError(enhancedForm, {
            ...options2,
            scrollToError: opts.focusOnError === false ? "off" : options2.scrollToError
          });
        }, 1);
      }
      return result || Form_validate({ adapter: opts.schema });
    },
    allErrors: AllErrors,
    posted: Posted,
    reset(options22) {
      return Form_reset({
        message: options22?.keepMessage ? Data.message : void 0,
        data: options22?.data,
        id: options22?.id,
        newState: options22?.newState
      });
    },
    submit(submitter) {
      const form2 = EnhancedForm_get() ? EnhancedForm_get() : submitter && submitter instanceof HTMLElement ? submitter.closest("form") : void 0;
      if (!form2) {
        throw new SuperFormError("use:enhance must be added to the form to use submit, or pass a HTMLElement inside the form (or the form itself) as an argument.");
      }
      if (!form2.requestSubmit) {
        return form2.submit();
      }
      const isSubmitButton = submitter && (submitter instanceof HTMLButtonElement && submitter.type == "submit" || submitter instanceof HTMLInputElement && ["submit", "image"].includes(submitter.type));
      form2.requestSubmit(isSubmitButton ? submitter : void 0);
    },
    isTainted: Tainted_isTainted,
    enhance: superFormEnhance
  };
}
function constraints(schema) {
  return _constraints(schemaInfo(schema, false, []), []);
}
function merge(...constraints2) {
  const filtered = constraints2.filter((c2) => !!c2);
  if (!filtered.length)
    return void 0;
  if (filtered.length == 1)
    return filtered[0];
  return merge$1(...filtered);
}
function _constraints(info, path) {
  if (!info)
    return void 0;
  let output = void 0;
  if (info.union && info.union.length) {
    const infos = info.union.map((s3) => schemaInfo(s3, info.isOptional, path));
    const merged = infos.map((i2) => _constraints(i2, path));
    output = merge(output, ...merged);
    if (output && (info.isNullable || info.isOptional || infos.some((i2) => i2?.isNullable || i2?.isOptional))) {
      delete output.required;
    }
  }
  if (info.array) {
    output = merge(output, ...info.array.map((i2) => _constraints(schemaInfo(i2, info.isOptional, path), path)));
  }
  if (info.properties) {
    const obj = {};
    for (const [key2, prop] of Object.entries(info.properties)) {
      const propInfo = schemaInfo(prop, !info.required?.includes(key2) || prop.default !== void 0, [key2]);
      const propConstraint = _constraints(propInfo, [...path, key2]);
      if (typeof propConstraint === "object" && Object.values(propConstraint).length > 0) {
        obj[key2] = propConstraint;
      }
    }
    output = merge(output, obj);
  }
  return output ?? constraint(info);
}
function constraint(info) {
  const output = {};
  const schema = info.schema;
  const type = schema.type;
  const format2 = schema.format;
  if (type == "integer" && format2 == "unix-time") {
    const date = schema;
    if (date.minimum !== void 0)
      output.min = new Date(date.minimum).toISOString();
    if (date.maximum !== void 0)
      output.max = new Date(date.maximum).toISOString();
  } else if (type == "string") {
    const str = schema;
    const patterns = [
      str.pattern,
      ...str.allOf ? str.allOf.map((s3) => typeof s3 == "boolean" ? void 0 : s3.pattern) : []
    ].filter((s3) => s3 !== void 0);
    if (patterns.length > 0)
      output.pattern = patterns[0];
    if (str.minLength !== void 0)
      output.minlength = str.minLength;
    if (str.maxLength !== void 0)
      output.maxlength = str.maxLength;
  } else if (type == "number" || type == "integer") {
    const num = schema;
    if (num.minimum !== void 0)
      output.min = num.minimum;
    else if (num.exclusiveMinimum !== void 0)
      output.min = num.exclusiveMinimum + (type == "integer" ? 1 : Number.MIN_VALUE);
    if (num.maximum !== void 0)
      output.max = num.maximum;
    else if (num.exclusiveMaximum !== void 0)
      output.max = num.exclusiveMaximum - (type == "integer" ? 1 : Number.MIN_VALUE);
    if (num.multipleOf !== void 0)
      output.step = num.multipleOf;
  } else if (type == "array") {
    const arr = schema;
    if (arr.minItems !== void 0)
      output.min = arr.minItems;
    if (arr.maxItems !== void 0)
      output.max = arr.maxItems;
  }
  if (!info.isNullable && !info.isOptional) {
    output.required = true;
  }
  return Object.keys(output).length > 0 ? output : void 0;
}
function schemaHash(schema) {
  return hashCode(_schemaHash(schemaInfo(schema, false, []), 0, []));
}
function _schemaHash(info, depth, path) {
  if (!info)
    return "";
  function tab() {
    return "  ".repeat(depth);
  }
  function mapSchemas(schemas) {
    return schemas.map((s3) => _schemaHash(schemaInfo(s3, info?.isOptional ?? false, path), depth + 1, path)).filter((s3) => s3).join("|");
  }
  function nullish() {
    const output = [];
    if (info?.isNullable)
      output.push("null");
    if (info?.isOptional)
      output.push("undefined");
    return !output.length ? "" : "|" + output.join("|");
  }
  if (info.union) {
    return "Union {\n  " + tab() + mapSchemas(info.union) + "\n" + tab() + "}" + nullish();
  }
  if (info.properties) {
    const output = [];
    for (const [key2, prop] of Object.entries(info.properties)) {
      const propInfo = schemaInfo(prop, !info.required?.includes(key2) || prop.default !== void 0, [key2]);
      output.push(key2 + ": " + _schemaHash(propInfo, depth + 1, path));
    }
    return "Object {\n  " + tab() + output.join(",\n  ") + "\n" + tab() + "}" + nullish();
  }
  if (info.array) {
    return "Array[" + mapSchemas(info.array) + "]" + nullish();
  }
  return info.types.join("|") + nullish();
}
function hashCode(str) {
  let hash2 = 0;
  for (let i2 = 0, len = str.length; i2 < len; i2++) {
    const chr = str.charCodeAt(i2);
    hash2 = (hash2 << 5) - hash2 + chr;
    hash2 |= 0;
  }
  if (hash2 < 0)
    hash2 = hash2 >>> 0;
  return hash2.toString(36);
}
// @__NO_SIDE_EFFECTS__
function createAdapter(adapter, jsonSchema) {
  if (!adapter || !("superFormValidationLibrary" in adapter)) {
    throw new SuperFormError('Superforms v2 requires a validation adapter for the schema. Import one of your choice from "sveltekit-superforms/adapters" and wrap the schema with it.');
  }
  if (!jsonSchema)
    jsonSchema = adapter.jsonSchema;
  return {
    ...adapter,
    constraints: adapter.constraints ?? constraints(jsonSchema),
    defaults: adapter.defaults ?? defaultValues(jsonSchema),
    shape: schemaShape(jsonSchema),
    id: schemaHash(jsonSchema)
  };
}
async function parseRequest(data, schemaData, options2) {
  let parsed;
  if (data instanceof FormData) {
    parsed = parseFormData(data, schemaData, options2);
  } else if (data instanceof URL || data instanceof URLSearchParams) {
    parsed = parseSearchParams(data, schemaData, options2);
  } else if (data instanceof Request) {
    parsed = await tryParseFormData(data, schemaData, options2);
  } else if (
    // RequestEvent
    data && typeof data === "object" && "request" in data && data.request instanceof Request
  ) {
    parsed = await tryParseFormData(data.request, schemaData, options2);
  } else {
    parsed = {
      id: void 0,
      data,
      posted: false
    };
  }
  return parsed;
}
async function tryParseFormData(request, schemaData, options2) {
  let formData = void 0;
  try {
    formData = await request.formData();
  } catch (e3) {
    if (e3 instanceof TypeError && e3.message.includes("already been consumed")) {
      throw e3;
    }
    return { id: void 0, data: void 0, posted: false };
  }
  return parseFormData(formData, schemaData, options2);
}
function parseSearchParams(data, schemaData, options2) {
  if (data instanceof URL)
    data = data.searchParams;
  const convert = new FormData();
  for (const [key2, value] of data.entries()) {
    convert.append(key2, value);
  }
  const output = parseFormData(convert, schemaData, options2);
  output.posted = false;
  return output;
}
function parseFormData(formData, schemaData, options2) {
  function tryParseSuperJson() {
    if (formData.has("__superform_json")) {
      try {
        const output = parse2(formData.getAll("__superform_json").join("") ?? "");
        if (typeof output === "object") {
          const filePaths = Array.from(formData.keys());
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_file_"))) {
            const realPath = splitPath(path.substring(17));
            setPaths(output, [realPath], formData.get(path));
          }
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_files_"))) {
            const realPath = splitPath(path.substring(18));
            const allFiles = formData.getAll(path);
            setPaths(output, [realPath], Array.from(allFiles));
          }
          return output;
        }
      } catch {
      }
    }
    return null;
  }
  const data = tryParseSuperJson();
  const id = formData.get("__superform_id")?.toString();
  return data ? { id, data, posted: true } : {
    id,
    data: _parseFormData(formData, schemaData, options2),
    posted: true
  };
}
function _parseFormData(formData, schema, options2) {
  const output = {};
  let schemaKeys;
  if (options2?.strict) {
    schemaKeys = new Set([...formData.keys()].filter((key2) => !key2.startsWith("__superform_")));
  } else {
    let unionKeys = [];
    if (schema.anyOf) {
      const info = schemaInfo(schema, false, []);
      if (info.union?.some((s3) => s3.type !== "object")) {
        throw new SchemaError("All form types must be an object if schema is a union.");
      }
      unionKeys = info.union?.flatMap((s3) => Object.keys(s3.properties ?? {})) ?? [];
    }
    schemaKeys = new Set([
      ...unionKeys,
      ...Object.keys(schema.properties ?? {}),
      ...schema.additionalProperties ? formData.keys() : []
    ].filter((key2) => !key2.startsWith("__superform_")));
  }
  function parseSingleEntry(key2, entry, info) {
    if (options2?.preprocessed && options2.preprocessed.includes(key2)) {
      return entry;
    }
    if (entry && typeof entry !== "string") {
      const allowFiles = legacyMode ? options2?.allowFiles === true : options2?.allowFiles !== false;
      return !allowFiles ? void 0 : entry.size ? entry : info.isNullable ? null : void 0;
    }
    if (info.types.length > 1) {
      throw new SchemaError(unionError, key2);
    }
    const [type] = info.types;
    return parseFormDataEntry(key2, entry, type ?? "any", info);
  }
  const defaultPropertyType = typeof schema.additionalProperties == "object" ? schema.additionalProperties : { type: "string" };
  for (const key2 of schemaKeys) {
    const property = schema.properties ? schema.properties[key2] : defaultPropertyType;
    assertSchema(property, key2);
    const info = schemaInfo(property ?? defaultPropertyType, !schema.required?.includes(key2), [
      key2
    ]);
    if (!info)
      continue;
    if (!info.types.includes("boolean") && !schema.additionalProperties && !formData.has(key2)) {
      continue;
    }
    const entries = formData.getAll(key2);
    if (info.union && info.union.length > 1) {
      throw new SchemaError(unionError, key2);
    }
    if (info.types.includes("array") || info.types.includes("set")) {
      const items = property.items ?? (info.union?.length == 1 ? info.union[0] : void 0);
      if (!items || typeof items == "boolean" || Array.isArray(items) && items.length != 1) {
        throw new SchemaError('Arrays must have a single "items" property that defines its type.', key2);
      }
      const arrayType2 = Array.isArray(items) ? items[0] : items;
      assertSchema(arrayType2, key2);
      const arrayInfo = schemaInfo(arrayType2, info.isOptional, [key2]);
      if (!arrayInfo)
        continue;
      const isFileArray = entries.length && entries.some((e3) => e3 && typeof e3 !== "string");
      const arrayData = entries.map((e3) => parseSingleEntry(key2, e3, arrayInfo));
      if (isFileArray && arrayData.every((file) => !file))
        arrayData.length = 0;
      output[key2] = info.types.includes("set") ? new Set(arrayData) : arrayData;
    } else {
      output[key2] = parseSingleEntry(key2, entries[entries.length - 1], info);
    }
  }
  return output;
}
function parseFormDataEntry(key2, value, type, info) {
  if (!value) {
    if (type == "boolean" && info.isOptional && info.schema.default === true) {
      return false;
    }
    const defaultValue2 = defaultValues(info.schema, info.isOptional, [key2]);
    if (info.schema.enum && defaultValue2 !== null && defaultValue2 !== void 0) {
      return value;
    }
    if (defaultValue2 !== void 0)
      return defaultValue2;
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  function typeError() {
    throw new SchemaError(type[0].toUpperCase() + type.slice(1) + ` type found. Set the dataType option to "json" and add use:enhance on the client to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`, key2);
  }
  switch (type) {
    case "string":
    case "any":
      return value;
    case "integer":
      return parseInt(value ?? "", 10);
    case "number":
      return parseFloat(value ?? "");
    case "boolean":
      return Boolean(value == "false" ? "" : value).valueOf();
    case "unix-time": {
      const date = new Date(value ?? "");
      return !isNaN(date) ? date : void 0;
    }
    case "bigint":
      return BigInt(value ?? ".");
    case "symbol":
      return Symbol(String(value));
    case "set":
    case "array":
    case "object":
      return typeError();
    default:
      throw new SuperFormError("Unsupported schema type for FormData: " + type);
  }
}
function isPrimitive(value) {
  return typeof value !== "object" && typeof value !== "function" || value === null;
}
function MapTree() {
  this.childBranches = /* @__PURE__ */ new WeakMap();
  this.primitiveKeys = /* @__PURE__ */ new Map();
  this.hasValue = false;
  this.value = void 0;
}
function addErrorMessage(res, key2, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key2]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key2, value, errorMessage, refs) {
  res[key2] = value;
  addErrorMessage(res, key2, errorMessage, refs);
}
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x2) => !!x2);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex.source, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, "^" + processPattern(check.value), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, processPattern(check.value) + "$", check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, processPattern(check.value), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function parseRecordDef(def, refs) {
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key2) => ({
        ...acc,
        [key2]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key2]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key2, value]) => key2 === "type" ? acc : { ...acc, [key2]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key2) => {
    return typeof object[object[key2]] !== "number";
  });
  const actualValues = actualKeys.map((key2) => object[key2]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef() {
  return {
    not: {}
  };
}
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options2 = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options2.every((x2) => x2._def.typeName in primitiveMappings && (!x2._def.checks || !x2._def.checks.length))) {
    const types = options2.reduce((types2, x2) => {
      const type = primitiveMappings[x2._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options2.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
    const types = options2.reduce((acc, x2) => {
      const type = typeof x2._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x2._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options2.length) {
      const uniqueTypes = types.filter((x2, i2, a2) => a2.indexOf(x2) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options2.reduce((acc, x2) => {
          return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
        }, [])
      };
    }
  } else if (options2.every((x2) => x2._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options2.reduce((acc, x2) => [
        ...acc,
        ...x2._def.values.filter((x22) => !acc.includes(x22))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base22 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base22 && "$ref" in base22)
      return { allOf: [base22], nullable: true };
    return base22 && { ...base22, nullable: true };
  }
  const base2 = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base2 && { anyOf: [base2, { type: "null" }] };
}
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function decideAdditionalProperties(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  } else {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  }
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0)
        return acc;
      return {
        properties: { ...acc.properties, [propName]: parsedDef },
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: decideAdditionalProperties(def, refs)
  };
  if (!result.required.length)
    delete result.required;
  return result;
}
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], [])
    };
  }
}
function parseUndefinedDef() {
  return {
    not: {}
  };
}
function parseUnknownDef() {
  return {};
}
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
async function validate(schema, data) {
  const result = await schema.safeParseAsync(data);
  if (result.success) {
    return {
      data: result.data,
      success: true
    };
  }
  return {
    issues: result.error.issues.map(({ message, path }) => ({ message, path })),
    success: false
  };
}
function _zod(schema, options2) {
  return /* @__PURE__ */ createAdapter({
    superFormValidationLibrary: "zod",
    validate: async (data) => validate(schema, data),
    jsonSchema: options2?.jsonSchema ?? /* @__PURE__ */ zodToJSONSchema(schema, options2?.config),
    defaults: options2?.defaults
  });
}
function _zodClient(schema) {
  return {
    superFormValidationLibrary: "zod",
    validate: async (data) => validate(schema, data)
  };
}
var browser, collectionClone, isObject, merge$1, defaultOptions$2, conversionFormatTypes, SuperFormError, SchemaError, noCustomValidityDataAttribute, isElementInViewport, scrollToAndCenter, immediateInputTypes, FetchStatus, activeTimers, scrollToFirstError, formIds, initialForms, defaultOnError, defaultFormOptions, LEGACY_MODE, STORYBOOK_MODE, legacyMode, unionError, memoize$1, memoizeWeak, baseMemoize, memoize2, ignoreOverride, defaultOptions$1, getDefaultOptions, getRefs, parseCatchDef, integerDateParser, isJsonSchema7AllOfType, zodPatterns, escapeNonAlphaNumeric, addFormat, addPattern, primitiveMappings, asAnyOf, parseOptionalDef, parsePipelineDef, parseReadonlyDef, get$ref, getRelativePath, selectParser, addMeta, zodToJsonSchema, defaultOptions, zodToJSONSchema, zod, zodClient, SafeString, compares, escapeCode, jsval, format$1, safe$1, safewrap, safepriority, safeor, safeand, safenot, safenotor, safeFormat, stringLength, isMultipleOf, deepEqual, unique, deBase64, hasOwn, pointerPart, toPointer$1, errorMerge, propertyIn, dynamicResolve, extraUtils, scopeFunctions, format, safe, core, toPointer, functions, schemaTypes;
var init_compile = __esm({
  ".svelte-kit/output/server/chunks/compile.js"() {
    init_index2();
    init_stores2();
    init_stringify();
    init_index_server();
    init_client();
    init_lib();
    browser = BROWSER;
    collectionClone = clone$1;
    isObject = (obj) => {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          const prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    };
    merge$1 = (...objects) => objects.reduce((result, current) => {
      if (Array.isArray(current)) {
        throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
      }
      Object.keys(current).forEach((key2) => {
        if (["__proto__", "constructor", "prototype"].includes(key2)) {
          return;
        }
        if (Array.isArray(result[key2]) && Array.isArray(current[key2])) {
          result[key2] = merge$1.options.mergeArrays ? merge$1.options.uniqueArrayItems ? Array.from(new Set(result[key2].concat(current[key2]))) : [...result[key2], ...current[key2]] : current[key2];
        } else if (isObject(result[key2]) && isObject(current[key2])) {
          result[key2] = merge$1(result[key2], current[key2]);
        } else {
          result[key2] = current[key2] === void 0 ? merge$1.options.allowUndefinedOverrides ? current[key2] : result[key2] : current[key2];
        }
      });
      return result;
    }, {});
    defaultOptions$2 = {
      allowUndefinedOverrides: true,
      mergeArrays: true,
      uniqueArrayItems: true
    };
    merge$1.options = defaultOptions$2;
    merge$1.withOptions = (options2, ...objects) => {
      merge$1.options = Object.assign(Object.assign({}, defaultOptions$2), options2);
      const result = merge$1(...objects);
      merge$1.options = defaultOptions$2;
      return result;
    };
    conversionFormatTypes = ["unix-time", "bigint", "any", "symbol", "set"];
    SuperFormError = class _SuperFormError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _SuperFormError.prototype);
      }
    };
    SchemaError = class _SchemaError extends SuperFormError {
      path;
      constructor(message, path) {
        super((path && path.length ? `[${Array.isArray(path) ? path.join(".") : path}] ` : "") + message);
        this.path = Array.isArray(path) ? path.join(".") : path;
        Object.setPrototypeOf(this, _SchemaError.prototype);
      }
    };
    noCustomValidityDataAttribute = "noCustomValidity";
    isElementInViewport = (el, topOffset = 0) => {
      const rect = el.getBoundingClientRect();
      return rect.top >= topOffset && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
    };
    scrollToAndCenter = (el, offset2 = 1.125, behavior = "smooth") => {
      const elementRect = el.getBoundingClientRect();
      const absoluteElementTop = elementRect.top + window.pageYOffset;
      const top = absoluteElementTop - window.innerHeight / (2 * offset2);
      window.scrollTo({ left: 0, top, behavior });
    };
    immediateInputTypes = ["checkbox", "radio", "range", "file"];
    (function(FetchStatus2) {
      FetchStatus2[FetchStatus2["Idle"] = 0] = "Idle";
      FetchStatus2[FetchStatus2["Submitting"] = 1] = "Submitting";
      FetchStatus2[FetchStatus2["Delayed"] = 2] = "Delayed";
      FetchStatus2[FetchStatus2["Timeout"] = 3] = "Timeout";
    })(FetchStatus || (FetchStatus = {}));
    activeTimers = /* @__PURE__ */ new Set();
    scrollToFirstError = async (Form2, options2) => {
      if (options2.scrollToError == "off")
        return;
      const selector = options2.errorSelector;
      if (!selector)
        return;
      await tick();
      let el;
      el = Form2.querySelector(selector);
      if (!el)
        return;
      el = el.querySelector(selector) ?? el;
      const nav = options2.stickyNavbar ? document.querySelector(options2.stickyNavbar) : null;
      if (typeof options2.scrollToError != "string") {
        el.scrollIntoView(options2.scrollToError);
      } else if (!isElementInViewport(el, nav?.offsetHeight ?? 0)) {
        scrollToAndCenter(el, void 0, options2.scrollToError);
      }
      function Form_shouldAutoFocus(userAgent) {
        if (typeof options2.autoFocusOnError === "boolean")
          return options2.autoFocusOnError;
        else
          return !/iPhone|iPad|iPod|Android/i.test(userAgent);
      }
      if (!Form_shouldAutoFocus(navigator.userAgent))
        return;
      let focusEl;
      focusEl = el;
      if (!["INPUT", "SELECT", "BUTTON", "TEXTAREA"].includes(focusEl.tagName)) {
        focusEl = focusEl.querySelector('input:not([type="hidden"]):not(.flatpickr-input), select, textarea');
      }
      if (focusEl) {
        try {
          focusEl.focus({ preventScroll: true });
          if (options2.selectErrorText && focusEl.tagName == "INPUT") {
            focusEl.select();
          }
        } catch (err) {
        }
      }
    };
    formIds = /* @__PURE__ */ new WeakMap();
    initialForms = /* @__PURE__ */ new WeakMap();
    defaultOnError = (event) => {
      console.warn("Unhandled error caught by Superforms, use onError event to handle it:", event.result.error);
    };
    defaultFormOptions = {
      applyAction: true,
      invalidateAll: true,
      resetForm: true,
      autoFocusOnError: "detect",
      scrollToError: "smooth",
      errorSelector: '[aria-invalid="true"],[data-invalid]',
      selectErrorText: false,
      stickyNavbar: void 0,
      taintedMessage: false,
      onSubmit: void 0,
      onResult: void 0,
      onUpdate: void 0,
      onUpdated: void 0,
      onError: defaultOnError,
      dataType: "form",
      validators: void 0,
      customValidity: false,
      clearOnSubmit: "message",
      delayMs: 500,
      timeoutMs: 8e3,
      multipleSubmits: "prevent",
      SPA: void 0,
      validationMethod: "auto"
    };
    LEGACY_MODE = false;
    try {
      if (SUPERFORMS_LEGACY)
        LEGACY_MODE = true;
    } catch {
    }
    STORYBOOK_MODE = false;
    try {
      if (globalThis.STORIES)
        STORYBOOK_MODE = true;
    } catch {
    }
    legacyMode = false;
    try {
      if (SUPERFORMS_LEGACY)
        legacyMode = true;
    } catch {
    }
    unionError = 'FormData parsing failed: Unions are only supported when the dataType option for superForm is set to "json".';
    MapTree.prototype.has = function has(key2) {
      var keyObject = isPrimitive(key2) ? this.primitiveKeys.get(key2) : key2;
      return keyObject ? this.childBranches.has(keyObject) : false;
    };
    MapTree.prototype.get = function get4(key2) {
      var keyObject = isPrimitive(key2) ? this.primitiveKeys.get(key2) : key2;
      return keyObject ? this.childBranches.get(keyObject) : void 0;
    };
    MapTree.prototype.resolveBranch = function resolveBranch(key2) {
      if (this.has(key2)) {
        return this.get(key2);
      }
      var newBranch = new MapTree();
      var keyObject = this.createKey(key2);
      this.childBranches.set(keyObject, newBranch);
      return newBranch;
    };
    MapTree.prototype.setValue = function setValue(value) {
      this.hasValue = true;
      return this.value = value;
    };
    MapTree.prototype.createKey = function createKey(key2) {
      if (isPrimitive(key2)) {
        var keyObject = {};
        this.primitiveKeys.set(key2, keyObject);
        return keyObject;
      }
      return key2;
    };
    MapTree.prototype.clear = function clear() {
      if (arguments.length === 0) {
        this.childBranches = /* @__PURE__ */ new WeakMap();
        this.primitiveKeys.clear();
        this.hasValue = false;
        this.value = void 0;
      } else if (arguments.length === 1) {
        var key2 = arguments[0];
        if (isPrimitive(key2)) {
          var keyObject = this.primitiveKeys.get(key2);
          if (keyObject) {
            this.childBranches.delete(keyObject);
            this.primitiveKeys.delete(key2);
          }
        } else {
          this.childBranches.delete(key2);
        }
      } else {
        var childKey = arguments[0];
        if (this.has(childKey)) {
          var childBranch = this.get(childKey);
          childBranch.clear.apply(childBranch, Array.prototype.slice.call(arguments, 1));
        }
      }
    };
    memoize$1 = function memoize(fn) {
      var argsTree = new MapTree();
      function memoized() {
        var args = Array.prototype.slice.call(arguments);
        var argNode = args.reduce(function getBranch(parentBranch, arg) {
          return parentBranch.resolveBranch(arg);
        }, argsTree);
        if (argNode.hasValue) {
          return argNode.value;
        }
        var value = fn.apply(null, args);
        return argNode.setValue(value);
      }
      memoized.clear = argsTree.clear.bind(argsTree);
      return memoized;
    };
    memoizeWeak = memoize$1;
    baseMemoize = /* @__PURE__ */ getDefaultExportFromCjs(memoizeWeak);
    memoize2 = baseMemoize;
    ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
    defaultOptions$1 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      markdownDescription: false,
      patternStrategy: "escape",
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64"
    };
    getDefaultOptions = (options2) => typeof options2 === "string" ? {
      ...defaultOptions$1,
      name: options2
    } : {
      ...defaultOptions$1,
      ...options2
    };
    getRefs = (options2) => {
      const _options = getDefaultOptions(options2);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name2, def]) => [
          def._def,
          {
            def: def._def,
            path: [..._options.basePath, _options.definitionPath, name2],
            // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
            jsonSchema: void 0
          }
        ]))
      };
    };
    parseCatchDef = (def, refs) => {
      return parseDef(def.innerType._def, refs);
    };
    integerDateParser = (def, refs) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      if (refs.target === "openApi3") {
        return res;
      }
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors(
              res,
              "minimum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
          case "max":
            setResponseValueAndErrors(
              res,
              "maximum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
        }
      }
      return res;
    };
    isJsonSchema7AllOfType = (type) => {
      if ("type" in type && type.type === "string")
        return false;
      return "allOf" in type;
    };
    zodPatterns = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: "^[cC][^\\s-]{8,}$",
      cuid2: "^[a-z][a-z0-9]*$",
      ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
      /**
       * `a-z` was added to replicate /i flag
       */
      email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
      emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
      /**
       * Unused
       */
      uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
      /**
       * Unused
       */
      ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
      /**
       * Unused
       */
      ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$",
      base64: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$",
      nanoid: "^[a-zA-Z0-9_-]{21}$"
    };
    escapeNonAlphaNumeric = (value) => Array.from(value).map((c2) => /[a-zA-Z0-9]/.test(c2) ? c2 : `\\${c2}`).join("");
    addFormat = (schema, value, message, refs) => {
      if (schema.format || schema.anyOf?.some((x2) => x2.format)) {
        if (!schema.anyOf) {
          schema.anyOf = [];
        }
        if (schema.format) {
          schema.anyOf.push({
            format: schema.format,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { format: schema.errorMessage.format }
            }
          });
          delete schema.format;
          if (schema.errorMessage) {
            delete schema.errorMessage.format;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.anyOf.push({
          format: value,
          ...message && refs.errorMessages && { errorMessage: { format: message } }
        });
      } else {
        setResponseValueAndErrors(schema, "format", value, message, refs);
      }
    };
    addPattern = (schema, value, message, refs) => {
      if (schema.pattern || schema.allOf?.some((x2) => x2.pattern)) {
        if (!schema.allOf) {
          schema.allOf = [];
        }
        if (schema.pattern) {
          schema.allOf.push({
            pattern: schema.pattern,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { pattern: schema.errorMessage.pattern }
            }
          });
          delete schema.pattern;
          if (schema.errorMessage) {
            delete schema.errorMessage.pattern;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.allOf.push({
          pattern: value,
          ...message && refs.errorMessages && { errorMessage: { pattern: message } }
        });
      } else {
        setResponseValueAndErrors(schema, "pattern", value, message, refs);
      }
    };
    primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    asAnyOf = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i2}`]
      })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    };
    parseOptionalDef = (def, refs) => {
      if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
      }
      const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? {
        anyOf: [
          {
            not: {}
          },
          innerSchema
        ]
      } : {};
    };
    parsePipelineDef = (def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
      }
      const a2 = parseDef(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
      });
      return {
        allOf: [a2, b].filter((x2) => x2 !== void 0)
      };
    };
    parseReadonlyDef = (def, refs) => {
      return parseDef(def.innerType._def, refs);
    };
    get$ref = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index21) => refs.currentPath[index21] === value)) {
            console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
            return {};
          }
          return refs.$refStrategy === "seen" ? {} : void 0;
        }
      }
    };
    getRelativePath = (pathA, pathB) => {
      let i2 = 0;
      for (; i2 < pathA.length && i2 < pathB.length; i2++) {
        if (pathA[i2] !== pathB[i2])
          break;
      }
      return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
    };
    selectParser = (def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef(def, refs);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef();
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef(refs);
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef(def, refs);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return parseDef(def.getter()._def, refs);
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef();
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef();
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef();
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_2) => void 0)();
      }
    };
    addMeta = (def, refs, jsonSchema) => {
      if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
          jsonSchema.markdownDescription = def.description;
        }
      }
      return jsonSchema;
    };
    zodToJsonSchema = (schema, options2) => {
      const refs = getRefs(options2);
      const definitions = typeof options2 === "object" && options2.definitions ? Object.entries(options2.definitions).reduce((acc, [name22, schema2]) => ({
        ...acc,
        [name22]: parseDef(schema2._def, {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name22]
        }, true) ?? {}
      }), {}) : void 0;
      const name2 = typeof options2 === "string" ? options2 : options2?.name;
      const main = parseDef(schema._def, name2 === void 0 ? refs : {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name2]
      }, false) ?? {};
      const combined = name2 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name2
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name2]: main
        }
      };
      if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
      } else if (refs.target === "jsonSchema2019-09") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
      }
      return combined;
    };
    defaultOptions = {
      dateStrategy: "integer",
      pipeStrategy: "output",
      $refStrategy: "none"
    };
    zodToJSONSchema = /* @__NO_SIDE_EFFECTS__ */ (...params) => {
      params[1] = typeof params[1] == "object" ? { ...defaultOptions, ...params[1] } : defaultOptions;
      return zodToJsonSchema(...params);
    };
    zod = /* @__PURE__ */ memoize2(_zod);
    zodClient = /* @__PURE__ */ memoize2(_zodClient);
    SafeString = class extends String {
    };
    compares = /* @__PURE__ */ new Set(["<", ">", "<=", ">="]);
    escapeCode = (code) => `\\u${code.toString(16).padStart(4, "0")}`;
    jsval = (val) => {
      if ([Infinity, -Infinity, NaN, void 0, null].includes(val))
        return `${val}`;
      const primitive = ["string", "boolean", "number"].includes(typeof val);
      if (!primitive) {
        if (typeof val !== "object")
          throw new Error("Unexpected value type");
        const proto = Object.getPrototypeOf(val);
        const ok = proto === Array.prototype && Array.isArray(val) || proto === Object.prototype;
        if (!ok)
          throw new Error("Unexpected object given as value");
      }
      return JSON.stringify(val).replace(/([{,])"__proto__":/g, '$1["__proto__"]:').replace(/[^\\]"__proto__":/g, () => {
        throw new Error("Unreachable");
      }).replace(/[\u2028\u2029]/g, (char) => escapeCode(char.charCodeAt(0)));
    };
    format$1 = (fmt, ...args) => {
      const res = fmt.replace(/%[%drscjw]/g, (match) => {
        if (match === "%%")
          return "%";
        if (args.length === 0)
          throw new Error("Unexpected arguments count");
        const val = args.shift();
        switch (match) {
          case "%d":
            if (typeof val === "number")
              return val;
            throw new Error("Expected a number");
          case "%r":
            if (val instanceof RegExp)
              return format$1("new RegExp(%j, %j)", val.source, val.flags);
            throw new Error("Expected a RegExp instance");
          case "%s":
            if (val instanceof SafeString)
              return val;
            throw new Error("Expected a safe string");
          case "%c":
            if (compares.has(val))
              return val;
            throw new Error("Expected a compare op");
          case "%j":
            return jsval(val);
          case "%w":
            if (Number.isInteger(val) && val >= 0)
              return " ".repeat(val);
            throw new Error("Expected a non-negative integer for indentation");
        }
        throw new Error("Unreachable");
      });
      if (args.length !== 0)
        throw new Error("Unexpected arguments count");
      return new SafeString(res);
    };
    safe$1 = (string) => {
      if (!/^[a-z][a-z0-9_]*$/i.test(string))
        throw new Error("Does not look like a safe id");
      return new SafeString(string);
    };
    safewrap = (fun) => (...args) => {
      if (!args.every((arg) => arg instanceof SafeString))
        throw new Error("Unsafe arguments");
      return new SafeString(fun(...args));
    };
    safepriority = (arg) => (
      // simple expression and single brackets can not break priority
      /^[a-z][a-z0-9_().]*$/i.test(arg) || /^\([^()]+\)$/i.test(arg) ? arg : format$1("(%s)", arg)
    );
    safeor = safewrap(
      (...args) => args.some((arg) => `${arg}` === "true") ? "true" : args.join(" || ") || "false"
    );
    safeand = safewrap(
      (...args) => args.some((arg) => `${arg}` === "false") ? "false" : args.join(" && ") || "true"
    );
    safenot = (arg) => {
      if (`${arg}` === "true")
        return safe$1("false");
      if (`${arg}` === "false")
        return safe$1("true");
      return format$1("!%s", safepriority(arg));
    };
    safenotor = (...args) => safenot(safeor(...args));
    safeFormat = { format: format$1, safe: safe$1, safeand, safenot, safenotor };
    stringLength = (string) => /[\uD800-\uDFFF]/.test(string) ? [...string].length : string.length;
    isMultipleOf = (value, divisor, factor, factorMultiple) => {
      if (value % divisor === 0)
        return true;
      let multiple = value * factor;
      if (multiple === Infinity || multiple === -Infinity)
        multiple = value;
      if (multiple % factorMultiple === 0)
        return true;
      const normal = Math.floor(multiple + 0.5);
      return normal / factor === value && normal % factorMultiple === 0;
    };
    deepEqual = (obj, obj2) => {
      if (obj === obj2)
        return true;
      if (!obj || !obj2 || typeof obj !== typeof obj2)
        return false;
      if (obj !== obj2 && typeof obj !== "object")
        return false;
      const proto = Object.getPrototypeOf(obj);
      if (proto !== Object.getPrototypeOf(obj2))
        return false;
      if (proto === Array.prototype) {
        if (!Array.isArray(obj) || !Array.isArray(obj2))
          return false;
        if (obj.length !== obj2.length)
          return false;
        return obj.every((x2, i2) => deepEqual(x2, obj2[i2]));
      } else if (proto === Object.prototype) {
        const [keys, keys2] = [Object.keys(obj), Object.keys(obj2)];
        if (keys.length !== keys2.length)
          return false;
        const keyset2 = /* @__PURE__ */ new Set([...keys, ...keys2]);
        return keyset2.size === keys.length && keys.every((key2) => deepEqual(obj[key2], obj2[key2]));
      }
      return false;
    };
    unique = (array2) => {
      if (array2.length < 2)
        return true;
      if (array2.length === 2)
        return !deepEqual(array2[0], array2[1]);
      const objects = [];
      const primitives = array2.length > 20 ? /* @__PURE__ */ new Set() : null;
      let primitivesCount = 0;
      let pos = 0;
      for (const item of array2) {
        if (typeof item === "object") {
          objects.push(item);
        } else if (primitives) {
          primitives.add(item);
          if (primitives.size !== ++primitivesCount)
            return false;
        } else {
          if (array2.indexOf(item, pos + 1) !== -1)
            return false;
        }
        pos++;
      }
      for (let i2 = 1; i2 < objects.length; i2++)
        for (let j2 = 0; j2 < i2; j2++)
          if (deepEqual(objects[i2], objects[j2]))
            return false;
      return true;
    };
    deBase64 = (string) => {
      if (typeof Buffer !== "undefined")
        return Buffer.from(string, "base64").toString("utf-8");
      const b = atob(string);
      return new TextDecoder("utf-8").decode(new Uint8Array(b.length).map((_2, i2) => b.charCodeAt(i2)));
    };
    hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
    hasOwn[Symbol.for("toJayString")] = "Function.prototype.call.bind(Object.prototype.hasOwnProperty)";
    pointerPart = (s3) => /~\//.test(s3) ? `${s3}`.replace(/~/g, "~0").replace(/\//g, "~1") : s3;
    toPointer$1 = (path) => path.length === 0 ? "#" : `#/${path.map(pointerPart).join("/")}`;
    errorMerge = ({ keywordLocation, instanceLocation }, schemaBase, dataBase) => ({
      keywordLocation: `${schemaBase}${keywordLocation.slice(1)}`,
      instanceLocation: `${dataBase}${instanceLocation.slice(1)}`
    });
    propertyIn = (key2, [properties, patterns]) => properties.includes(true) || properties.some((prop) => prop === key2) || patterns.some((pattern2) => new RegExp(pattern2, "u").test(key2));
    dynamicResolve = (anchors, id) => (anchors.filter((x2) => x2[id])[0] || {})[id];
    extraUtils = { toPointer: toPointer$1, pointerPart, errorMerge, propertyIn, dynamicResolve };
    scopeFunctions = { stringLength, isMultipleOf, deepEqual, unique, deBase64, hasOwn, ...extraUtils };
    ({ format, safe } = safeFormat);
    new Map(
      Object.entries({
        null: (name2) => format("%s === null", name2),
        boolean: (name2) => format('typeof %s === "boolean"', name2),
        array: (name2) => format("Array.isArray(%s)", name2),
        object: (n2) => format('typeof %s === "object" && %s && !Array.isArray(%s)', n2, n2, n2),
        number: (name2) => format('typeof %s === "number"', name2),
        integer: (name2) => format("Number.isInteger(%s)", name2),
        string: (name2) => format('typeof %s === "string"', name2)
      })
    );
    new Set(
      [].concat(
        ...[Object, Array, String, Number, Boolean].map((c2) => Object.getOwnPropertyNames(c2.prototype))
      )
    );
    core = {
      // matches ajv + length checks + does not start with a dot
      // note that quoted emails are deliberately unsupported (as in ajv), who would want \x01 in email
      // first check is an additional fast path with lengths: 20+(1+21)*2 = 64, (1+61+1)+((1+60+1)+1)*3 = 252 < 253, that should cover most valid emails
      // max length is 64 (name) + 1 (@) + 253 (host), we want to ensure that prior to feeding to the fast regex
      // the second regex checks for quoted, starting-leading dot in name, and two dots anywhere
      email: (input) => {
        if (input.length > 318)
          return false;
        const fast = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i;
        if (fast.test(input))
          return true;
        if (!input.includes("@") || /(^\.|^"|\.@|\.\.)/.test(input))
          return false;
        const [name2, host, ...rest] = input.split("@");
        if (!name2 || !host || rest.length !== 0 || name2.length > 64 || host.length > 253)
          return false;
        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name2))
          return false;
        return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
      },
      // matches ajv + length checks
      hostname: (input) => {
        if (input.length > (input.endsWith(".") ? 254 : 253))
          return false;
        const hostname = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\.?$/i;
        return hostname.test(input);
      },
      // 'time' matches ajv + length checks, 'date' matches ajv full
      // date: https://tools.ietf.org/html/rfc3339#section-5.6
      // date-time: https://tools.ietf.org/html/rfc3339#section-5.6
      // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
      // 11: 1990-01-01, 1: T, 9: 00:00:00., 12: maxiumum fraction length (non-standard), 6: +00:00
      date: (input) => {
        if (input.length !== 10)
          return false;
        if (input[5] === "0" && input[6] === "2") {
          if (/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(input))
            return true;
          const matches2 = input.match(/^(\d\d\d\d)-02-29$/);
          if (!matches2)
            return false;
          const year = matches2[1] | 0;
          return year % 16 === 0 || year % 4 === 0 && year % 25 !== 0;
        }
        if (input.endsWith("31"))
          return /^\d\d\d\d-(?:0[13578]|1[02])-31$/.test(input);
        return /^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(input);
      },
      // leap second handling is special, we check it's 23:59:60.*
      time: (input) => {
        if (input.length > 9 + 12 + 6)
          return false;
        const time = /^(?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)?$/i;
        if (!time.test(input))
          return false;
        if (!/:60/.test(input))
          return true;
        const p2 = input.match(/([0-9.]+|[^0-9.])/g);
        let hm = Number(p2[0]) * 60 + Number(p2[2]);
        if (p2[5] === "+")
          hm += 24 * 60 - Number(p2[6] || 0) * 60 - Number(p2[8] || 0);
        else if (p2[5] === "-")
          hm += Number(p2[6] || 0) * 60 + Number(p2[8] || 0);
        return hm % (24 * 60) === 23 * 60 + 59;
      },
      // first two lines specific to date-time, then tests for unanchored (at end) date, code identical to 'date' above
      // input[17] === '6' is a check for :60
      "date-time": (input) => {
        if (input.length > 10 + 1 + 9 + 12 + 6)
          return false;
        const full = /^\d\d\d\d-(?:0[1-9]|1[0-2])-(?:[0-2]\d|3[01])[t\s](?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)$/i;
        const feb = input[5] === "0" && input[6] === "2";
        if (feb && input[8] === "3" || !full.test(input))
          return false;
        if (input[17] === "6") {
          const p2 = input.slice(11).match(/([0-9.]+|[^0-9.])/g);
          let hm = Number(p2[0]) * 60 + Number(p2[2]);
          if (p2[5] === "+")
            hm += 24 * 60 - Number(p2[6] || 0) * 60 - Number(p2[8] || 0);
          else if (p2[5] === "-")
            hm += Number(p2[6] || 0) * 60 + Number(p2[8] || 0);
          if (hm % (24 * 60) !== 23 * 60 + 59)
            return false;
        }
        if (feb) {
          if (/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(input))
            return true;
          const matches2 = input.match(/^(\d\d\d\d)-02-29/);
          if (!matches2)
            return false;
          const year = matches2[1] | 0;
          return year % 16 === 0 || year % 4 === 0 && year % 25 !== 0;
        }
        if (input[8] === "3" && input[9] === "1")
          return /^\d\d\d\d-(?:0[13578]|1[02])-31/.test(input);
        return /^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(input);
      },
      /* ipv4 and ipv6 are from ajv with length restriction */
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: (ip) => ip.length <= 15 && /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)$/.test(ip),
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      // max length: 1000:1000:1000:1000:1000:1000:255.255.255.255
      // we parse ip6 format with a simple scan, leaving embedded ipv4 validation to a regex
      // s0=count(:), s1=count(.), hex=count(a-zA-Z0-9), short=count(::)>0
      // 48-57: '0'-'9', 97-102, 65-70: 'a'-'f', 'A'-'F', 58: ':', 46: '.'
      /* eslint-disable one-var */
      // prettier-ignore
      ipv6: (input) => {
        if (input.length > 45 || input.length < 2)
          return false;
        let s0 = 0, s1 = 0, hex = 0, short = false, letters = false, last2 = 0, start = true;
        for (let i2 = 0; i2 < input.length; i2++) {
          const c2 = input.charCodeAt(i2);
          if (i2 === 1 && last2 === 58 && c2 !== 58)
            return false;
          if (c2 >= 48 && c2 <= 57) {
            if (++hex > 4)
              return false;
          } else if (c2 === 46) {
            if (s0 > 6 || s1 >= 3 || hex === 0 || letters)
              return false;
            s1++;
            hex = 0;
          } else if (c2 === 58) {
            if (s1 > 0 || s0 >= 7)
              return false;
            if (last2 === 58) {
              if (short)
                return false;
              short = true;
            } else if (i2 === 0)
              start = false;
            s0++;
            hex = 0;
            letters = false;
          } else if (c2 >= 97 && c2 <= 102 || c2 >= 65 && c2 <= 70) {
            if (s1 > 0)
              return false;
            if (++hex > 4)
              return false;
            letters = true;
          } else
            return false;
          last2 = c2;
        }
        if (s0 < 2 || s1 > 0 && (s1 !== 3 || hex === 0))
          return false;
        if (short && input.length === 2)
          return true;
        if (s1 > 0 && !/(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/.test(input))
          return false;
        const spaces = s1 > 0 ? 6 : 7;
        if (!short)
          return s0 === spaces && start && hex > 0;
        return (start || hex > 0) && s0 < spaces;
      },
      /* eslint-enable one-var */
      // matches ajv with optimization
      uri: /^[a-z][a-z0-9+\-.]*:(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // matches ajv with optimization
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // ajv has /^(([^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?([a-z0-9_]|%[0-9a-f]{2})+(:[1-9][0-9]{0,3}|\*)?(,([a-z0-9_]|%[0-9a-f]{2})+(:[1-9][0-9]{0,3}|\*)?)*\})*$/i
      // this is equivalent
      // uri-template: https://tools.ietf.org/html/rfc6570
      // eslint-disable-next-line no-control-regex
      "uri-template": /^(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2}|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // ajv has /^(\/([^~/]|~0|~1)*)*$/, this is equivalent
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      "json-pointer": /^(?:|\/(?:[^~]|~0|~1)*)$/,
      // ajv has /^(0|[1-9][0-9]*)(#|(\/([^~/]|~0|~1)*)*)$/, this is equivalent
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:|#|\/(?:[^~]|~0|~1)*)$/,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
      // length restriction is an arbitrary safeguard
      // first regex checks if this a week duration (can't be combined with others)
      // second regex verifies symbols, no more than one fraction, at least 1 block is present, and T is not last
      // third regex verifies structure
      duration: (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input))
      // TODO: iri, iri-reference, idn-email, idn-hostname
    };
    ({
      // basic
      alpha: /^[a-zA-Z]+$/,
      alphanumeric: /^[a-zA-Z0-9]+$/,
      // hex
      "hex-digits": /^[0-9a-f]+$/i,
      "hex-digits-prefixed": /^0x[0-9a-f]+$/i,
      "hex-bytes": /^([0-9a-f][0-9a-f])+$/i,
      "hex-bytes-prefixed": /^0x([0-9a-f][0-9a-f])+$/i,
      base64: (input) => input.length % 4 === 0 && /^[a-z0-9+/]*={0,3}$/i.test(input),
      // ajv has /^#(\/([a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, this is equivalent
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer-uri-fragment": /^#(|\/(\/|[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)$/i,
      // draft3 backwards compat
      "host-name": core.hostname,
      "ip-address": core.ipv4,
      // manually cleaned up from is-my-json-valid, CSS 2.1 colors only per draft03 spec
      color: /^(#[0-9A-Fa-f]{3,6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|rgb\(\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*\)|rgb\(\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*\))$/
      // style is deliberately unsupported, don't accept untrusted styles
    });
    ({ toPointer, ...functions } = scopeFunctions);
    schemaTypes = new Map(
      Object.entries({
        boolean: (arg) => typeof arg === "boolean",
        array: (arg) => Array.isArray(arg) && Object.getPrototypeOf(arg) === Array.prototype,
        object: (arg) => arg && Object.getPrototypeOf(arg) === Object.prototype,
        finite: (arg) => Number.isFinite(arg),
        natural: (arg) => Number.isInteger(arg) && arg >= 0,
        string: (arg) => typeof arg === "string",
        jsonval: (arg) => functions.deepEqual(arg, JSON.parse(JSON.stringify(arg)))
      })
    );
    schemaTypes.get("object");
  }
});

// .svelte-kit/output/server/chunks/superValidate.js
async function superValidate(data, adapter, options2) {
  if (data && "superFormValidationLibrary" in data) {
    options2 = adapter;
    adapter = data;
    data = void 0;
  }
  const validator2 = adapter;
  const defaults6 = options2?.defaults ?? validator2.defaults;
  const jsonSchema = validator2.jsonSchema;
  const parsed = await parseRequest(data, jsonSchema, options2);
  const addErrors = options2?.errors ?? (options2?.strict ? true : !!parsed.data);
  const parsedData = options2?.strict ? parsed.data ?? {} : mergeDefaults(parsed.data, defaults6);
  let status;
  if (!!parsed.data || addErrors) {
    status = await /* @__PURE__ */ validator2.validate(parsedData);
  } else {
    status = { success: false, issues: [] };
  }
  const valid = status.success;
  const errors = valid || !addErrors ? {} : mapErrors(status.issues, validator2.shape);
  const dataWithDefaults = valid ? status.data : replaceInvalidDefaults(options2?.strict ? mergeDefaults(parsedData, defaults6) : parsedData, defaults6, jsonSchema, status.issues, options2?.preprocessed);
  let outputData;
  if (jsonSchema.additionalProperties === false) {
    outputData = {};
    for (const key2 of Object.keys(jsonSchema.properties ?? {})) {
      if (key2 in dataWithDefaults)
        outputData[key2] = dataWithDefaults[key2];
    }
  } else {
    outputData = dataWithDefaults;
  }
  const output = {
    id: parsed.id ?? options2?.id ?? validator2.id,
    valid,
    posted: parsed.posted,
    errors,
    data: outputData
  };
  if (!parsed.posted) {
    output.constraints = validator2.constraints;
    if (Object.keys(validator2.shape).length) {
      output.shape = validator2.shape;
    }
  }
  return output;
}
function withFiles(obj) {
  if (typeof obj !== "object")
    return obj;
  for (const key2 in obj) {
    const value = obj[key2];
    if (value instanceof File)
      delete obj[key2];
    else if (value && typeof value === "object")
      withFiles(value);
  }
  return obj;
}
function fail2(status, data) {
  function checkForm(data2) {
    return !!data2 && typeof data2 === "object" && "valid" in data2 && "data" in data2 && "id" in data2;
  }
  function checkObj(data2) {
    if (data2 && typeof data2 === "object") {
      for (const key2 in data2) {
        const v2 = data2[key2];
        if (checkForm(v2)) {
          v2.valid = false;
          removeFiles(v2);
        } else if (v2 && typeof v2 === "object") {
          checkObj(v2);
        }
      }
    }
    return data2;
  }
  return fail(status, checkObj(data));
}
var removeFiles;
var init_superValidate = __esm({
  ".svelte-kit/output/server/chunks/superValidate.js"() {
    init_chunks();
    init_compile();
    removeFiles = withFiles;
  }
});

// .svelte-kit/output/server/entries/pages/app/_layout.server.ts.js
var layout_server_ts_exports2 = {};
__export(layout_server_ts_exports2, {
  load: () => load3
});
var load3;
var init_layout_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/app/_layout.server.ts.js"() {
    init_urls();
    init_pharmacist_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    load3 = async ({ locals, fetch: fetch2, parent: parent2, cookies }) => {
      const sessionKey = cookies.get(COOKIE_KEYS.SESSION_KEY);
      const deletePharmacistForm = await superValidate(zod(deletePharmacistSchema));
      if (locals.tholaApp === "thola-org") {
        const orgDetailsResponse = await get({
          url: "account/details",
          fetcher: fetch2,
          baseURL: locals.baseURL,
          options: {
            headers: {
              "Authorization": sessionKey || ""
            }
          }
        });
        if (!orgDetailsResponse.ok) {
          error(orgDetailsResponse.status, {
            message: orgDetailsResponse.message,
            status: orgDetailsResponse.status
          });
        }
        locals.orgInfo = orgDetailsResponse.organisation;
        return {
          orgInfo: orgDetailsResponse.organisation,
          userInfo: null,
          pharmacistInfo: null,
          deletePharmacistForm,
          pharmacyListStream: get({
            url: `pharmacy/all/${orgDetailsResponse.organisation.organisationId}`,
            baseURL: locals.baseURL,
            fetcher: fetch2,
            options: {
              headers: {
                "Authorization": sessionKey || ""
              }
            }
          }),
          organisationPharmacistListStream: get({
            url: `pharmacist/org/all/${orgDetailsResponse.organisation.organisationId}`,
            baseURL: locals.baseURL,
            fetcher: fetch2,
            options: {
              headers: {
                "Authorization": sessionKey || ""
              }
            }
          })
        };
      }
      return {
        ...await parent2(),
        orgInfo: null
      };
    };
  }
});

// node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r(e3) {
  var t2, f, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3)
    n2 += e3;
  else if ("object" == typeof e3)
    if (Array.isArray(e3)) {
      var o2 = e3.length;
      for (t2 = 0; t2 < o2; t2++)
        e3[t2] && (f = r(e3[t2])) && (n2 && (n2 += " "), n2 += f);
    } else
      for (f in e3)
        e3[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
function clsx() {
  for (var e3, t2, f = 0, n2 = "", o2 = arguments.length; f < o2; f++)
    (e3 = arguments[f]) && (t2 = r(e3)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var init_clsx = __esm({
  "node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs"() {
  }
});

// node_modules/.pnpm/tailwind-merge@2.3.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs
function createClassUtils(config) {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator: validator2
  }) => validator2(classRest))?.classGroupId;
}
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key2, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key2), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key2, value]) => [prefix + key2, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  function update(key2, value) {
    cache.set(key2, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get(key2) {
      let value = cache.get(key2);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key2)) !== void 0) {
        update(key2, value);
        return value;
      }
    },
    set(key2, value) {
      if (cache.has(key2)) {
        cache.set(key2, value);
      } else {
        update(key2, value);
      }
    }
  };
}
function createSplitModifiers(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index21 = 0; index21 < className.length; index21++) {
      let currentCharacter = className[index21];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index21, index21 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index21));
          modifierStart = index21 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index21;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
function mergeClassList(classList, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName) => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter((parsed) => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map((parsed) => parsed.originalClassName).join(" ");
}
function twJoin() {
  let index21 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index21 < arguments.length) {
    if (argument = arguments[index21++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key2) {
  const themeGetter = (theme) => theme[key2] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isNumber(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isInteger(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryImage(value) {
  return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function isAny() {
  return true;
}
function getIsArbitraryValue(value, label, testValue) {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
}
function isNever() {
  return false;
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
function getDefaultConfig() {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale2 = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumber = () => [isNumber, isArbitraryNumber];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale2]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale2]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale2]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function mergeConfigs(baseConfig, {
  cacheSize,
  prefix,
  separator,
  extend = {},
  override: override2 = {}
}) {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix);
  overrideProperty(baseConfig, "separator", separator);
  for (const configKey in override2) {
    overrideConfigProperties(baseConfig[configKey], override2[configKey]);
  }
  for (const key2 in extend) {
    mergeConfigProperties(baseConfig[key2], extend[key2]);
  }
  return baseConfig;
}
function overrideProperty(baseObject, overrideKey, overrideValue) {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
}
function overrideConfigProperties(baseObject, overrideObject) {
  if (overrideObject) {
    for (const key2 in overrideObject) {
      overrideProperty(baseObject, key2, overrideObject[key2]);
    }
  }
}
function mergeConfigProperties(baseObject, mergeObject) {
  if (mergeObject) {
    for (const key2 in mergeObject) {
      const mergeValue = mergeObject[key2];
      if (mergeValue !== void 0) {
        baseObject[key2] = (baseObject[key2] || []).concat(mergeValue);
      }
    }
  }
}
function extendTailwindMerge(configExtension, ...createConfig) {
  return typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
}
var CLASS_PART_SEPARATOR, arbitraryPropertyRegex, IMPORTANT_MODIFIER, SPLIT_CLASSES_REGEX, arbitraryValueRegex, fractionRegex, stringLengths, tshirtUnitRegex, lengthUnitRegex, colorFunctionRegex, shadowRegex, imageRegex, sizeLabels, imageLabels, twMerge;
var init_bundle_mjs = __esm({
  "node_modules/.pnpm/tailwind-merge@2.3.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs"() {
    CLASS_PART_SEPARATOR = "-";
    arbitraryPropertyRegex = /^\[(.+)\]$/;
    IMPORTANT_MODIFIER = "!";
    SPLIT_CLASSES_REGEX = /\s+/;
    arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    fractionRegex = /^\d+\/\d+$/;
    stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
    shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
    imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
    imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
    twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  }
});

// node_modules/.pnpm/tailwind-variants@0.2.1_tailwindcss@3.4.3/node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js
function i(e3, o2) {
  e3.forEach(function(r3) {
    Array.isArray(r3) ? i(r3, o2) : o2.push(r3);
  });
}
function y(e3) {
  let o2 = [];
  return i(e3, o2), o2;
}
var l, u, x, a, p, g;
var init_chunk_JXBJZR5A = __esm({
  "node_modules/.pnpm/tailwind-variants@0.2.1_tailwindcss@3.4.3/node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js"() {
    l = (e3) => typeof e3 == "boolean" ? `${e3}` : e3 === 0 ? "0" : e3;
    u = (e3) => !e3 || typeof e3 != "object" || Object.keys(e3).length === 0;
    x = (e3, o2) => JSON.stringify(e3) === JSON.stringify(o2);
    a = (...e3) => y(e3).filter(Boolean);
    p = (e3, o2) => {
      let r3 = {}, c2 = Object.keys(e3), f = Object.keys(o2);
      for (let t2 of c2)
        if (f.includes(t2)) {
          let s3 = e3[t2], n2 = o2[t2];
          typeof s3 == "object" && typeof n2 == "object" ? r3[t2] = p(s3, n2) : Array.isArray(s3) || Array.isArray(n2) ? r3[t2] = a(n2, s3) : r3[t2] = n2 + " " + s3;
        } else
          r3[t2] = e3[t2];
      for (let t2 of f)
        c2.includes(t2) || (r3[t2] = o2[t2]);
      return r3;
    };
    g = (e3) => !e3 || typeof e3 != "string" ? e3 : e3.replace(/\s+/g, " ").trim();
  }
});

// node_modules/.pnpm/tailwind-variants@0.2.1_tailwindcss@3.4.3/node_modules/tailwind-variants/dist/index.js
var ie, _, M, R, v, q, j, Z, ce;
var init_dist = __esm({
  "node_modules/.pnpm/tailwind-variants@0.2.1_tailwindcss@3.4.3/node_modules/tailwind-variants/dist/index.js"() {
    init_chunk_JXBJZR5A();
    init_bundle_mjs();
    ie = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
    _ = (s3) => s3 || void 0;
    M = (...s3) => _(y(s3).filter(Boolean).join(" "));
    R = null;
    v = {};
    q = false;
    j = (...s3) => (b$1) => b$1.twMerge ? ((!R || q) && (q = false, R = u(v) ? twMerge : extendTailwindMerge({ ...v, extend: { theme: v.theme, classGroups: v.classGroups, conflictingClassGroupModifiers: v.conflictingClassGroupModifiers, conflictingClassGroups: v.conflictingClassGroups, ...v.extend } })), _(R(M(s3)))) : M(s3);
    Z = (s3, b) => {
      for (let e3 in b)
        s3.hasOwnProperty(e3) ? s3[e3] = M(s3[e3], b[e3]) : s3[e3] = b[e3];
      return s3;
    };
    ce = (s3, b$1) => {
      let { extend: e3 = null, slots: N = {}, variants: F = {}, compoundVariants: U = [], compoundSlots: C = [], defaultVariants: W = {} } = s3, m = { ...ie, ...b$1 }, S = e3 != null && e3.base ? M(e3.base, s3 == null ? void 0 : s3.base) : s3 == null ? void 0 : s3.base, g$1 = e3 != null && e3.variants && !u(e3.variants) ? p(F, e3.variants) : F, A = e3 != null && e3.defaultVariants && !u(e3.defaultVariants) ? { ...e3.defaultVariants, ...W } : W;
      !u(m.twMergeConfig) && !x(m.twMergeConfig, v) && (q = true, v = m.twMergeConfig);
      let O = u(e3 == null ? void 0 : e3.slots), $ = u(N) ? {} : { base: M(s3 == null ? void 0 : s3.base, O && (e3 == null ? void 0 : e3.base)), ...N }, w = O ? $ : Z({ ...e3 == null ? void 0 : e3.slots }, u($) ? { base: s3 == null ? void 0 : s3.base } : $), h$1 = u(e3 == null ? void 0 : e3.compoundVariants) ? U : a(e3 == null ? void 0 : e3.compoundVariants, U), V = (f) => {
        if (u(g$1) && u(N) && O)
          return j(S, f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);
        if (h$1 && !Array.isArray(h$1))
          throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
        if (C && !Array.isArray(C))
          throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof C}`);
        let K = (t2, n2, a2 = [], i2) => {
          let r3 = a2;
          if (typeof n2 == "string")
            r3 = r3.concat(g(n2).split(" ").map((o2) => `${t2}:${o2}`));
          else if (Array.isArray(n2))
            r3 = r3.concat(n2.reduce((o2, c2) => o2.concat(`${t2}:${c2}`), []));
          else if (typeof n2 == "object" && typeof i2 == "string") {
            for (let o2 in n2)
              if (n2.hasOwnProperty(o2) && o2 === i2) {
                let c2 = n2[o2];
                if (c2 && typeof c2 == "string") {
                  let l2 = g(c2);
                  r3[i2] ? r3[i2] = r3[i2].concat(l2.split(" ").map((u2) => `${t2}:${u2}`)) : r3[i2] = l2.split(" ").map((u2) => `${t2}:${u2}`);
                } else
                  Array.isArray(c2) && c2.length > 0 && (r3[i2] = c2.reduce((l2, u2) => l2.concat(`${t2}:${u2}`), []));
              }
          }
          return r3;
        }, z2 = (t2, n2 = g$1, a$1 = null, i2 = null) => {
          var J;
          let r3 = n2[t2];
          if (!r3 || u(r3))
            return null;
          let o2 = (J = i2 == null ? void 0 : i2[t2]) != null ? J : f == null ? void 0 : f[t2];
          if (o2 === null)
            return null;
          let c2 = l(o2), l2 = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, u2 = A == null ? void 0 : A[t2], d = [];
          if (typeof c2 == "object" && l2)
            for (let [T, L] of Object.entries(c2)) {
              let ne = r3[L];
              if (T === "initial") {
                u2 = L;
                continue;
              }
              Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(T) || (d = K(T, ne, d, a$1));
            }
          let ae = c2 != null && typeof c2 != "object" ? c2 : l(u2), k = r3[ae || "false"];
          return typeof d == "object" && typeof a$1 == "string" && d[a$1] ? Z(d, k) : d.length > 0 ? (d.push(k), d) : k;
        }, P = () => g$1 ? Object.keys(g$1).map((t2) => z2(t2, g$1)) : null, p2 = (t2, n2) => {
          if (!g$1 || typeof g$1 != "object")
            return null;
          let a2 = new Array();
          for (let i2 in g$1) {
            let r3 = z2(i2, g$1, t2, n2), o2 = t2 === "base" && typeof r3 == "string" ? r3 : r3 && r3[t2];
            o2 && (a2[a2.length] = o2);
          }
          return a2;
        }, D = {};
        for (let t2 in f)
          f[t2] !== void 0 && (D[t2] = f[t2]);
        let H = (t2, n2) => {
          var i2;
          let a2 = typeof (f == null ? void 0 : f[t2]) == "object" ? { [t2]: (i2 = f[t2]) == null ? void 0 : i2.initial } : {};
          return { ...A, ...D, ...a2, ...n2 };
        }, I = (t2 = [], n2) => {
          let a2 = [];
          for (let { class: i2, className: r3, ...o2 } of t2) {
            let c2 = true;
            for (let [l2, u2] of Object.entries(o2)) {
              let d = H(l2, n2);
              if (Array.isArray(u2)) {
                if (!u2.includes(d[l2])) {
                  c2 = false;
                  break;
                }
              } else if (d[l2] !== u2) {
                c2 = false;
                break;
              }
            }
            c2 && (i2 && a2.push(i2), r3 && a2.push(r3));
          }
          return a2;
        }, ee = (t2) => {
          let n2 = I(h$1, t2);
          if (!Array.isArray(n2))
            return n2;
          let a2 = {};
          for (let i2 of n2)
            if (typeof i2 == "string" && (a2.base = j(a2.base, i2)(m)), typeof i2 == "object")
              for (let [r3, o2] of Object.entries(i2))
                a2[r3] = j(a2[r3], o2)(m);
          return a2;
        }, te = (t2) => {
          if (C.length < 1)
            return null;
          let n2 = {};
          for (let { slots: a2 = [], class: i2, className: r3, ...o2 } of C) {
            if (!u(o2)) {
              let c2 = true;
              for (let l2 of Object.keys(o2)) {
                let u2 = H(l2, t2)[l2];
                if (u2 === void 0 || (Array.isArray(o2[l2]) ? !o2[l2].includes(u2) : o2[l2] !== u2)) {
                  c2 = false;
                  break;
                }
              }
              if (!c2)
                continue;
            }
            for (let c2 of a2)
              n2[c2] = n2[c2] || [], n2[c2].push([i2, r3]);
          }
          return n2;
        };
        if (!u(N) || !O) {
          let t2 = {};
          if (typeof w == "object" && !u(w))
            for (let n2 of Object.keys(w))
              t2[n2] = (a2) => {
                var i2, r3;
                return j(w[n2], p2(n2, a2), ((i2 = ee(a2)) != null ? i2 : [])[n2], ((r3 = te(a2)) != null ? r3 : [])[n2], a2 == null ? void 0 : a2.class, a2 == null ? void 0 : a2.className)(m);
              };
          return t2;
        }
        return j(S, P(), I(h$1), f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);
      }, x2 = () => {
        if (!(!g$1 || typeof g$1 != "object"))
          return Object.keys(g$1);
      };
      return V.variantKeys = x2(), V.extend = e3, V.base = S, V.slots = w, V.variants = g$1, V.defaultVariants = A, V.compoundSlots = C, V.compoundVariants = h$1, V;
    };
  }
});

// .svelte-kit/output/server/chunks/index4.js
function find(iter, tar, key2) {
  for (key2 of iter.keys()) {
    if (dequal(key2, tar))
      return key2;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has2.call(foo, ctor) && ++len && !has2.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}
function styleToString(style) {
  return Object.keys(style).reduce((str, key2) => {
    if (style[key2] === void 0)
      return str;
    return str + `${key2}:${style[key2]};`;
  }, "");
}
function disabledAttr(disabled) {
  return disabled ? true : void 0;
}
function portalAttr(portal) {
  if (portal !== null) {
    return "";
  }
  return void 0;
}
function lightable(value) {
  function subscribe(run) {
    run(value);
    return () => {
    };
  }
  return { subscribe };
}
function getElementByMeltId(id) {
  if (!isBrowser2)
    return null;
  const el = document.querySelector(`[data-melt-id="${id}"]`);
  return isHTMLElement(el) ? el : null;
}
function makeElement(name2, args) {
  const { stores, action, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = (...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name2}`]: "",
              action: action ?? noop3
            });
          };
          fn.action = action ?? noop3;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name2}`]: "",
          action: action ?? noop3
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn?.();
      if (isFunctionWithParams(result)) {
        const resultFn = (...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name2}`]: "",
            action: action ?? noop3
          });
        };
        resultFn.action = action ?? noop3;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name2}`]: "",
        action: action ?? noop3
      }));
    }
  })();
  const actionFn = action ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
function createElHelpers(prefix) {
  const name2 = (part) => part ? `${prefix}-${part}` : prefix;
  const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ""}`;
  const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`;
  const getEl = (part) => document.querySelector(selector(part));
  return {
    name: name2,
    attribute,
    selector,
    getEl
  };
}
function isDocument(element2) {
  return element2 instanceof Document;
}
function isElement(element2) {
  return element2 instanceof Element;
}
function isHTMLElement(element2) {
  return element2 instanceof HTMLElement;
}
function isHTMLInputElement(element2) {
  return element2 instanceof HTMLInputElement;
}
function isHTMLLabelElement(element2) {
  return element2 instanceof HTMLLabelElement;
}
function isHTMLButtonElement(element2) {
  return element2 instanceof HTMLButtonElement;
}
function isElementDisabled(element2) {
  const ariaDisabled = element2.getAttribute("aria-disabled");
  const disabled = element2.getAttribute("disabled");
  const dataDisabled = element2.hasAttribute("data-disabled");
  if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
    return true;
  }
  return false;
}
function isTouch(event) {
  return event.pointerType === "touch";
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}
function isReadable(value) {
  return isObject2(value) && "subscribe" in value;
}
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function noop3() {
}
function addEventListener2(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options2));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options2));
  };
}
function addMeltEventListener(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options2));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options2));
    };
  }
  return () => noop3();
}
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
function withMelt(handler) {
  return (event) => {
    const customEvent = dispatchMeltEvent(event);
    if (customEvent?.defaultPrevented)
      return;
    return handler(event);
  };
}
function omit(obj, ...keys) {
  const result = {};
  for (const key2 of Object.keys(obj)) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
}
function stripValues(inputObject, toStrip, recursive) {
  return Object.fromEntries(Object.entries(inputObject).filter(([_2, value]) => !dequal(value, toStrip)));
}
function removeUndefined(obj) {
  const result = {};
  for (const key2 in obj) {
    const value = obj[key2];
    if (value !== void 0) {
      result[key2] = value;
    }
  }
  return result;
}
function withGet(store) {
  return {
    ...store,
    get: () => get_store_value(store)
  };
}
function effect2(stores, fn) {
  let cb = void 0;
  const destroy = derived(stores, (stores2) => {
    cb?.();
    cb = fn(stores2);
  }).subscribe(noop3);
  const unsub = () => {
    destroy();
    cb?.();
  };
  safeOnDestroy(unsub);
  return unsub;
}
function toReadableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key2) => {
    const propertyKey = key2;
    const value = properties[propertyKey];
    if (isReadable(value)) {
      result[propertyKey] = withGet(value);
    } else {
      result[propertyKey] = withGet(readable(value));
    }
  });
  return result;
}
function createHiddenInput(props) {
  const withDefaults = {
    ...defaults$1,
    ...removeUndefined(props)
  };
  const { name: elName } = createElHelpers(withDefaults.prefix);
  const { value, name: name2, disabled, required } = toReadableStores(omit(withDefaults, "prefix"));
  const nameStore = name2;
  const hiddenInput = makeElement(elName("hidden-input"), {
    stores: [value, nameStore, disabled, required],
    returned: ([$value, $name, $disabled, $required]) => {
      return {
        name: $name,
        value: $value?.toString(),
        "aria-hidden": "true",
        hidden: true,
        disabled: $disabled,
        required: $required,
        tabIndex: -1,
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    },
    action: (node) => {
      const unsub = value.subscribe((newValue) => {
        node.value = newValue;
        node.dispatchEvent(new Event("change", { bubbles: true }));
      });
      return {
        destroy: unsub
      };
    }
  });
  return hiddenInput;
}
function getAttrs(builders) {
  const attrs = {};
  builders.forEach((builder) => {
    Object.keys(builder).forEach((key2) => {
      if (key2 !== "action") {
        attrs[key2] = builder[key2];
      }
    });
  });
  return attrs;
}
function Button$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["href", "type", "builders", "el"]);
  push();
  let href = value_or_fallback($$props["href"], () => void 0);
  let type = value_or_fallback($$props["type"], () => void 0);
  let builders = value_or_fallback($$props["builders"], () => []);
  let el = value_or_fallback($$props["el"], () => void 0);
  const attrs = { "data-button-root": "" };
  $$payload.out += `<!--[-->`;
  if (builders && builders.length) {
    const $$tag = href ? "a" : "button";
    $$payload.out += `<!--[-->`;
    if ($$tag)
      element(
        $$payload,
        $$tag,
        () => {
          $$payload.out += `${spread_attributes({
            type: href ? void 0 : type,
            href,
            tabindex: "0",
            ...getAttrs(builders),
            ...$$restProps,
            ...attrs
          })}`;
        },
        () => {
          $$payload.out += `<!--[-->`;
          slot($$payload, default_slot($$props), {}, null);
          $$payload.out += `<!--]-->`;
        }
      );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    const $$tag_1 = href ? "a" : "button";
    $$payload.out += `<!--[-->`;
    if ($$tag_1)
      element(
        $$payload,
        $$tag_1,
        () => {
          $$payload.out += `${spread_attributes({
            type: href ? void 0 : type,
            href,
            tabindex: "0",
            ...$$restProps,
            ...attrs
          })}`;
        },
        () => {
          $$payload.out += `<!--[-->`;
          slot($$payload, default_slot($$props), {}, null);
          $$payload.out += `<!--]-->`;
        }
      );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]!-->";
  }
  bind_props($$props, { href, type, builders, el });
  pop();
}
function cubicOut(t2) {
  const f = t2 - 1;
  return f * f * f + 1;
}
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
function Button($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "variant", "size", "builders"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let variant = value_or_fallback($$props["variant"], () => "default");
  let size2 = value_or_fallback($$props["size"], () => "default");
  let builders = value_or_fallback($$props["builders"], () => []);
  $$payload.out += `<!--[-->`;
  Button$1($$payload, spread_props([
    {
      builders,
      class: cn(buttonVariants({ variant, size: size2, className })),
      type: "button"
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className, variant, size: size2, builders });
  pop();
}
var has2, hiddenAction, isFunctionWithParams, isBrowser2, isFunction, safeOnMount, safeOnDestroy, kbd, FIRST_KEYS, LAST_KEYS, FIRST_LAST_KEYS, SELECTION_KEYS, documentEscapeKeyStore, useEscapeKeydown, defaults$1, defaults, flyAndScale, buttonVariants;
var init_index4 = __esm({
  ".svelte-kit/output/server/chunks/index4.js"() {
    init_index3();
    init_misc();
    init_clsx();
    init_bundle_mjs();
    init_dist();
    init_index2();
    init_index_server();
    has2 = Object.prototype.hasOwnProperty;
    ({
      type: "hidden",
      "aria-hidden": true,
      hidden: true,
      tabIndex: -1,
      style: styleToString({
        position: "absolute",
        opacity: 0,
        "pointer-events": "none",
        margin: 0,
        transform: "translateX(-100%)"
      })
    });
    hiddenAction = (obj) => {
      return new Proxy(obj, {
        get(target, prop, receiver) {
          return Reflect.get(target, prop, receiver);
        },
        ownKeys(target) {
          return Reflect.ownKeys(target).filter((key2) => key2 !== "action");
        }
      });
    };
    isFunctionWithParams = (fn) => {
      return typeof fn === "function";
    };
    makeElement("empty");
    isBrowser2 = typeof document !== "undefined";
    isFunction = (v2) => typeof v2 === "function";
    safeOnMount = (fn) => {
      try {
        noop(fn);
      } catch {
        return fn;
      }
    };
    safeOnDestroy = (fn) => {
      try {
        onDestroy(fn);
      } catch {
        return fn;
      }
    };
    withGet.writable = function(initial2) {
      const internal2 = writable(initial2);
      let value = initial2;
      return {
        subscribe: internal2.subscribe,
        set(newValue) {
          internal2.set(newValue);
          value = newValue;
        },
        update(updater) {
          const newValue = updater(value);
          internal2.set(newValue);
          value = newValue;
        },
        get() {
          return value;
        }
      };
    };
    withGet.derived = function(stores, fn) {
      const subscribers = /* @__PURE__ */ new Map();
      const get5 = () => {
        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();
        return fn(values);
      };
      const subscribe = (subscriber) => {
        const unsubscribers = [];
        const storesArr = Array.isArray(stores) ? stores : [stores];
        storesArr.forEach((store) => {
          unsubscribers.push(store.subscribe(() => {
            subscriber(get5());
          }));
        });
        subscriber(get5());
        subscribers.set(subscriber, unsubscribers);
        return () => {
          const unsubscribers2 = subscribers.get(subscriber);
          if (unsubscribers2) {
            for (const unsubscribe of unsubscribers2) {
              unsubscribe();
            }
          }
          subscribers.delete(subscriber);
        };
      };
      return {
        get: get5,
        subscribe
      };
    };
    kbd = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*",
      A: "a",
      P: "p"
    };
    FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
    LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
    FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
    SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];
    readable(void 0, (set2) => {
      function clicked(event) {
        set2(event);
        set2(void 0);
      }
      const unsubscribe = addEventListener2(document, "pointerup", clicked, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    documentEscapeKeyStore = readable(void 0, (set2) => {
      function keydown(event) {
        if (event && event.key === kbd.ESCAPE) {
          set2(event);
        }
        set2(void 0);
      }
      const unsubscribe = addEventListener2(document, "keydown", keydown, {
        passive: false
      });
      return unsubscribe;
    });
    useEscapeKeydown = (node, config = {}) => {
      let unsub = noop3;
      function update(config2 = {}) {
        unsub();
        const options2 = { enabled: true, ...config2 };
        const enabled = isReadable(options2.enabled) ? options2.enabled : readable(options2.enabled);
        unsub = executeCallbacks(
          // Handle escape keydowns
          documentEscapeKeyStore.subscribe((e3) => {
            if (!e3 || !get_store_value(enabled))
              return;
            const target = e3.target;
            if (!isHTMLElement(target) || target.closest("[data-escapee]") !== node) {
              return;
            }
            e3.preventDefault();
            if (options2.ignore) {
              if (isFunction(options2.ignore)) {
                if (options2.ignore(e3))
                  return;
              } else if (Array.isArray(options2.ignore)) {
                if (options2.ignore.length > 0 && options2.ignore.some((ignoreEl) => {
                  return ignoreEl && target === ignoreEl;
                }))
                  return;
              }
            }
            options2.handler?.(e3);
          }),
          effect2(enabled, ($enabled) => {
            if ($enabled) {
              node.dataset.escapee = "";
            } else {
              delete node.dataset.escapee;
            }
          })
        );
      }
      update(config);
      return {
        update,
        destroy() {
          node.removeAttribute("data-escapee");
          unsub();
        }
      };
    };
    defaults$1 = {
      prefix: "",
      disabled: readable(false),
      required: readable(false),
      name: readable(void 0)
    };
    defaults = {
      isDateDisabled: void 0,
      isDateUnavailable: void 0,
      value: void 0,
      preventDeselect: false,
      numberOfMonths: 1,
      pagedNavigation: false,
      weekStartsOn: 0,
      fixedWeeks: false,
      calendarLabel: "Event Date",
      locale: "en",
      minValue: void 0,
      maxValue: void 0,
      disabled: false,
      readonly: false,
      weekdayFormat: "narrow"
    };
    ({
      isDateDisabled: void 0,
      isDateUnavailable: void 0,
      value: void 0,
      positioning: {
        placement: "bottom"
      },
      closeOnEscape: true,
      closeOnOutsideClick: true,
      onOutsideClick: void 0,
      preventScroll: false,
      forceVisible: false,
      locale: "en",
      granularity: void 0,
      disabled: false,
      readonly: false,
      minValue: void 0,
      maxValue: void 0,
      weekdayFormat: "narrow",
      ...omit(defaults, "isDateDisabled", "isDateUnavailable", "value", "locale", "disabled", "readonly", "minValue", "maxValue", "weekdayFormat")
    });
    flyAndScale = (node, params = { y: -8, x: 0, start: 0.95, duration: 150 }) => {
      const style = getComputedStyle(node);
      const transform = style.transform === "none" ? "" : style.transform;
      const scaleConversion = (valueA, scaleA, scaleB) => {
        const [minA, maxA] = scaleA;
        const [minB, maxB] = scaleB;
        const percentage = (valueA - minA) / (maxA - minA);
        const valueB = percentage * (maxB - minB) + minB;
        return valueB;
      };
      const styleToString2 = (style2) => {
        return Object.keys(style2).reduce((str, key2) => {
          if (style2[key2] === void 0)
            return str;
          return str + `${key2}:${style2[key2]};`;
        }, "");
      };
      return {
        duration: params.duration ?? 200,
        delay: 0,
        css: (t2) => {
          const y2 = scaleConversion(t2, [0, 1], [params.y ?? 5, 0]);
          const x2 = scaleConversion(t2, [0, 1], [params.x ?? 0, 0]);
          const scale2 = scaleConversion(t2, [0, 1], [params.start ?? 0.95, 1]);
          return styleToString2({
            transform: `${transform} translate3d(${x2}px, ${y2}px, 0) scale(${scale2})`,
            opacity: t2
          });
        },
        easing: cubicOut
      };
    };
    buttonVariants = ce({
      base: "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    });
  }
});

// .svelte-kit/output/server/chunks/input.js
function createBitAttrs(bit, parts) {
  const attrs = {};
  parts.forEach((part) => {
    attrs[part] = {
      [`data-${bit}-${part}`]: ""
    };
  });
  return (part) => attrs[part];
}
function disabledAttrs(disabled) {
  return disabled ? { "aria-disabled": "true", "data-disabled": "" } : { "aria-disabled": void 0, "data-disabled": void 0 };
}
function Input($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "value", "readonly"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let value = value_or_fallback($$props["value"], () => void 0);
  let readonly2 = value_or_fallback($$props["readonly"], () => void 0);
  $$payload.out += `<input${spread_attributes({
    class: cn("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", className),
    value,
    readonly: readonly2,
    ...$$restProps
  })}>`;
  bind_props($$props, { class: className, value, readonly: readonly2 });
  pop();
}
var urlAlphabet, nanoid;
var init_input = __esm({
  ".svelte-kit/output/server/chunks/input.js"() {
    init_index3();
    init_index4();
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    nanoid = (size2 = 21) => {
      let id = "";
      let i2 = size2;
      while (i2--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
  }
});

// .svelte-kit/output/server/chunks/helpers.js
function back(array2, index21, increment, loop = true) {
  const previousIndex = index21 - increment;
  if (previousIndex <= 0) {
    return loop ? array2[array2.length - 1] : array2[0];
  }
  return array2[previousIndex];
}
function forward(array2, index21, increment, loop = true) {
  const nextIndex = index21 + increment;
  if (nextIndex > array2.length - 1) {
    return loop ? array2[0] : array2[array2.length - 1];
  }
  return array2[nextIndex];
}
function next(array2, index21, loop = true) {
  if (index21 === array2.length - 1) {
    return loop ? array2[0] : array2[index21];
  }
  return array2[index21 + 1];
}
function prev(array2, currentIndex, loop = true) {
  if (currentIndex <= 0) {
    return loop ? array2[array2.length - 1] : array2[0];
  }
  return array2[currentIndex - 1];
}
function last(array2) {
  return array2[array2.length - 1];
}
function wrapArray(array2, startIndex) {
  return array2.map((_2, index21) => array2[(startIndex + index21) % array2.length]);
}
function toggle(item, array2, compare2 = dequal) {
  const itemIdx = array2.findIndex((innerItem) => compare2(innerItem, item));
  if (itemIdx !== -1) {
    array2.splice(itemIdx, 1);
  } else {
    array2.push(item);
  }
  return array2;
}
function addHighlight(element2) {
  element2.setAttribute("data-highlighted", "");
}
function removeHighlight(element2) {
  element2.removeAttribute("data-highlighted");
}
function sleep2(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
function generateId() {
  return nanoid(10);
}
function generateIds(args) {
  return args.reduce((acc, curr) => {
    acc[curr] = generateId();
    return acc;
  }, {});
}
function debounce(fn, wait = 500) {
  let timeout = null;
  return function(...args) {
    const later = () => {
      timeout = null;
      fn(...args);
    };
    timeout && clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body: body2 } = doc;
  const locked = body2.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop3;
  body2.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body2)[paddingProperty];
  const setStyle = () => assignStyle(body2, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = assignStyle(body2, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo(scrollX, scrollY);
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body2.removeAttribute(LOCK_CLASSNAME);
  };
}
function derivedVisible(obj) {
  const { open, forceVisible, activeTrigger } = obj;
  return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
}
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key2) => {
    const propertyKey = key2;
    const value = properties[propertyKey];
    result[propertyKey] = withGet(writable(value));
  });
  return result;
}
function handleRovingFocus(nextElement) {
  if (!isBrowser2)
    return;
  sleep2(1).then(() => {
    const currentFocusedElement = document.activeElement;
    if (!isHTMLElement(currentFocusedElement) || currentFocusedElement === nextElement)
      return;
    currentFocusedElement.tabIndex = -1;
    if (nextElement) {
      nextElement.tabIndex = 0;
      nextElement.focus();
    }
  });
}
function getFocusableElements() {
  return Array.from(document.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), textarea:not([disabled]):not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])'));
}
function getNextFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const nextIndex = currentIndex + 1;
  const nextElement = focusableElements[nextIndex];
  if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {
    return nextElement;
  }
  return null;
}
function getPreviousFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const previousIndex = currentIndex - 1;
  const prevElement = focusableElements[previousIndex];
  if (previousIndex >= 0 && isHTMLElement(prevElement)) {
    return prevElement;
  }
  return null;
}
function createTypeaheadSearch(args = {}) {
  const withDefaults = { ...defaults2, ...args };
  const typed = withGet(writable([]));
  const resetTyped = debounce(() => {
    typed.update(() => []);
  });
  const handleTypeaheadSearch = (key2, items) => {
    if (ignoredKeys.has(key2))
      return;
    const currentItem = withDefaults.getCurrentItem();
    const $typed = get_store_value(typed);
    if (!Array.isArray($typed)) {
      return;
    }
    $typed.push(key2.toLowerCase());
    typed.set($typed);
    const candidateItems = items.filter((item) => {
      if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
        return false;
      }
      return true;
    });
    const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
    const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
    const currentItemIndex = isHTMLElement(currentItem) ? candidateItems.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizeSearch.length === 1;
    if (excludeCurrentItem) {
      wrappedItems = wrappedItems.filter((v2) => v2 !== currentItem);
    }
    const nextItem = wrappedItems.find((item) => item?.innerText && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
    if (isHTMLElement(nextItem) && nextItem !== currentItem) {
      withDefaults.onMatch(nextItem);
    }
    resetTyped();
  };
  return {
    typed,
    resetTyped,
    handleTypeaheadSearch
  };
}
function getPortalParent(node) {
  let parent2 = node.parentElement;
  while (isHTMLElement(parent2) && !parent2.hasAttribute("data-portal")) {
    parent2 = parent2.parentElement;
  }
  return parent2 || "body";
}
function getPortalDestination(node, portalProp) {
  if (portalProp !== void 0)
    return portalProp;
  const portalParent = getPortalParent(node);
  if (portalParent === "body")
    return document.body;
  return null;
}
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement2(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement2(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isContainingBlock(element2) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element2);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement2(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.pageXOffset,
    scrollTop: element2.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element2) {
  const css = getComputedStyle$1(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement2(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function isTopLayer(element2) {
  return topLayerSelectors.some((selector) => {
    try {
      return element2.matches(selector);
    } catch (e3) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body2 = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body2.scrollWidth, body2.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body2.scrollHeight, body2.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body2).direction === "rtl") {
    x2 += max(html.clientWidth, body2.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale2 = isHTMLElement2(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale2.x;
  const height = element2.clientHeight * scale2.y;
  const x2 = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache) {
  const cachedResult = cache.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element2, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element2, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  const {
    width,
    height
  } = getCssDimensions(element2);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element2) {
  return getComputedStyle$1(element2).position === "static";
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement2(element2) || getComputedStyle$1(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  return element2.offsetParent;
}
function getOffsetParent(element2, polyfill) {
  const win = getWindow(element2);
  if (isTopLayer(element2)) {
    return win;
  }
  if (!isHTMLElement2(element2)) {
    let svgOffsetParent = getParentNode(element2);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element2) || win;
}
function isRTL(element2) {
  return getComputedStyle$1(element2).direction === "rtl";
}
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element2);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element2.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
function useFloating(reference, floating, opts = {}) {
  if (!floating || !reference || opts === null)
    return {
      destroy: noop3
    };
  const options2 = { ...defaultConfig$1, ...opts };
  const arrowEl = floating.querySelector("[data-arrow=true]");
  const middleware = [];
  if (options2.flip) {
    middleware.push(flip({
      boundary: options2.boundary,
      padding: options2.overflowPadding
    }));
  }
  const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
  if (options2.gutter || options2.offset) {
    const data = options2.gutter ? { mainAxis: options2.gutter } : options2.offset;
    if (data?.mainAxis != null) {
      data.mainAxis += arrowOffset;
    }
    middleware.push(offset(data));
  }
  middleware.push(shift({
    boundary: options2.boundary,
    crossAxis: options2.overlap,
    padding: options2.overflowPadding
  }));
  if (arrowEl) {
    middleware.push(arrow({ element: arrowEl, padding: 8 }));
  }
  middleware.push(size({
    padding: options2.overflowPadding,
    apply({ rects, availableHeight, availableWidth }) {
      if (options2.sameWidth) {
        Object.assign(floating.style, {
          width: `${Math.round(rects.reference.width)}px`,
          minWidth: "unset"
        });
      }
      if (options2.fitViewport) {
        Object.assign(floating.style, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        });
      }
    }
  }));
  function compute() {
    if (!reference || !floating)
      return;
    if (isHTMLElement(reference) && !reference.ownerDocument.documentElement.contains(reference))
      return;
    const { placement, strategy } = options2;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy
    }).then((data) => {
      const x2 = Math.round(data.x);
      const y2 = Math.round(data.y);
      const [side, align] = getSideAndAlignFromPlacement(data.placement);
      floating.setAttribute("data-side", side);
      floating.setAttribute("data-align", align);
      Object.assign(floating.style, {
        position: options2.strategy,
        top: `${y2}px`,
        left: `${x2}px`
      });
      if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {
        const { x: x22, y: y22 } = data.middlewareData.arrow;
        const dir = data.placement.split("-")[0];
        arrowEl.setAttribute("data-side", dir);
        Object.assign(arrowEl.style, {
          position: "absolute",
          left: x22 != null ? `${x22}px` : "",
          top: y22 != null ? `${y22}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
      }
      return data;
    });
  }
  Object.assign(floating.style, {
    position: options2.strategy
  });
  return {
    destroy: autoUpdate(reference, floating, compute)
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function ownKeys(e3, r3) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r3 && (o2 = o2.filter(function(r23) {
      return Object.getOwnPropertyDescriptor(e3, r23).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e3) {
  for (var r3 = 1; r3 < arguments.length; r3++) {
    var t2 = null != arguments[r3] ? arguments[r3] : {};
    r3 % 2 ? ownKeys(Object(t2), true).forEach(function(r23) {
      _defineProperty(e3, r23, t2[r23]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r23) {
      Object.defineProperty(e3, r23, Object.getOwnPropertyDescriptor(t2, r23));
    });
  }
  return e3;
}
function _defineProperty(obj, key2, value) {
  key2 = _toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return typeof key2 === "symbol" ? key2 : String(key2);
}
function createFocusTrap2(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = (opts) => trap?.activate(opts);
  const deactivate = (opts) => {
    trap?.deactivate(opts);
  };
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  };
  const useFocusTrap = (node) => {
    trap = createFocusTrap$1(node, {
      ...focusTrapOptions,
      onActivate() {
        hasFocus.set(true);
        config.onActivate?.();
      },
      onDeactivate() {
        hasFocus.set(false);
        config.onDeactivate?.();
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  };
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}
function isValidEvent(e3, node) {
  if ("button" in e3 && e3.button > 0)
    return false;
  const target = e3.target;
  if (!isElement(target))
    return false;
  const ownerDocument = target.ownerDocument;
  if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {
    return false;
  }
  return node && !isOrContainsTarget(node, target);
}
function isOrContainsTarget(node, target) {
  return node === target || node.contains(target);
}
function getOwnerDocument(el) {
  return el?.ownerDocument ?? document;
}
function removeUndefined2(obj) {
  const result = {};
  for (const key2 in obj) {
    const value = obj[key2];
    if (value !== void 0) {
      result[key2] = value;
    }
  }
  return result;
}
function getOptionUpdater(options2) {
  return function(key2, value) {
    if (value === void 0)
      return;
    const store = options2[key2];
    if (store) {
      store.set(value);
    }
  };
}
function getPositioningUpdater(store) {
  return (props = {}) => {
    return updatePositioning(store, props);
  };
}
function updatePositioning(store, props) {
  const defaultPositioningProps = {
    side: "bottom",
    align: "center",
    sideOffset: 0,
    alignOffset: 0,
    sameWidth: false,
    avoidCollisions: true,
    collisionPadding: 8,
    fitViewport: false,
    strategy: "absolute",
    overlap: false
  };
  const withDefaults = { ...defaultPositioningProps, ...props };
  store.update((prev2) => {
    return {
      ...prev2,
      placement: joinPlacement(withDefaults.side, withDefaults.align),
      offset: {
        ...prev2.offset,
        mainAxis: withDefaults.sideOffset,
        crossAxis: withDefaults.alignOffset
      },
      gutter: 0,
      sameWidth: withDefaults.sameWidth,
      flip: withDefaults.avoidCollisions,
      overflowPadding: withDefaults.collisionPadding,
      boundary: withDefaults.collisionBoundary,
      fitViewport: withDefaults.fitViewport,
      strategy: withDefaults.strategy,
      overlap: withDefaults.overlap
    };
  });
}
function joinPlacement(side, align) {
  if (align === "center")
    return side;
  return `${side}-${align}`;
}
var overridable, isDom, pt, isTouchDevice, isMac, isApple, isIos, LOCK_CLASSNAME, ignoredKeys, defaults2, min, max, round, floor, createCoords, oppositeSideMap, oppositeAlignmentMap, computePosition$1, arrow$1, flip$1, offset$1, shift$1, size$1, noOffsets, topLayerSelectors, getElementRects, platform, offset, shift, flip, size, arrow, computePosition, defaultConfig$1, ARROW_TRANSFORM, candidateSelectors, candidateSelector, NoElement, matches, getRootNode, isInert, isContentEditable, getCandidates, getCandidatesIteratively, hasTabIndex, getTabIndex, getSortOrderTabIndex, sortOrderedTabbables, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isNodeAttached, isZeroArea, isHidden, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isValidShadowRootTabbable, sortByOrder, tabbable, focusable, isTabbable, focusableCandidateSelector, isFocusable, activeFocusTraps, isSelectableInput, isEscapeEvent, isTabEvent, isKeyForward, isKeyBackward, delay, findIndex, valueOrHandler, getActualTarget, internalTrapStack, createFocusTrap$1, visibleModals, useModal, defaultConfig, usePopper, usePortal, useInteractOutside;
var init_helpers = __esm({
  ".svelte-kit/output/server/chunks/helpers.js"() {
    init_index4();
    init_input();
    init_index2();
    init_index_server();
    overridable = (_store, onChange) => {
      const store = withGet(_store);
      const update = (updater, sideEffect) => {
        store.update((curr) => {
          const next2 = updater(curr);
          let res = next2;
          if (onChange) {
            res = onChange({ curr, next: next2 });
          }
          sideEffect?.(res);
          return res;
        });
      };
      const set2 = (curr) => {
        update(() => curr);
      };
      return {
        ...store,
        update,
        set: set2
      };
    };
    isDom = () => typeof window !== "undefined";
    pt = (v2) => isDom() && v2.test(getPlatform().toLowerCase());
    isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
    isMac = () => pt(/^mac/) && !isTouchDevice();
    isApple = () => pt(/mac|iphone|ipad|ipod/i);
    isIos = () => isApple() && !isMac();
    LOCK_CLASSNAME = "data-melt-scroll-lock";
    ignoredKeys = /* @__PURE__ */ new Set(["Shift", "Control", "Alt", "Meta", "CapsLock", "NumLock"]);
    defaults2 = {
      onMatch: handleRovingFocus,
      getCurrentItem: () => document.activeElement
    };
    min = Math.min;
    max = Math.max;
    round = Math.round;
    floor = Math.floor;
    createCoords = (v2) => ({
      x: v2,
      y: v2
    });
    oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    computePosition$1 = async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x2,
        y: y2
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i2 = 0; i2 < validMiddleware.length; i2++) {
        const {
          name: name2,
          fn
        } = validMiddleware[i2];
        const {
          x: nextX,
          y: nextY,
          data,
          reset: reset2
        } = await fn({
          x: x2,
          y: y2,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x2 = nextX != null ? nextX : x2;
        y2 = nextY != null ? nextY : y2;
        middlewareData = {
          ...middlewareData,
          [name2]: {
            ...middlewareData[name2],
            ...data
          }
        };
        if (reset2 && resetCount <= 50) {
          resetCount++;
          if (typeof reset2 === "object") {
            if (reset2.placement) {
              statefulPlacement = reset2.placement;
            }
            if (reset2.rects) {
              rects = reset2.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset2.rects;
            }
            ({
              x: x2,
              y: y2
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i2 = -1;
        }
      }
      return {
        x: x2,
        y: y2,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    arrow$1 = (options2) => ({
      name: "arrow",
      options: options2,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element: element2,
          padding = 0
        } = evaluate(options2, state) || {};
        if (element2 == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x2,
          y: y2
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element2);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
        const min$1 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp(min$1, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    flip$1 = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "flip",
        options: options2,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options2, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides[0]], overflow[sides[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    offset$1 = function(options2) {
      if (options2 === void 0) {
        options2 = 0;
      }
      return {
        name: "offset",
        options: options2,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x2,
            y: y2,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options2);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x2 + diffCoords.x,
            y: y2 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    shift$1 = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "shift",
        options: options2,
        async fn(state) {
          const {
            x: x2,
            y: y2,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x22,
                  y: y22
                } = _ref;
                return {
                  x: x22,
                  y: y22
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const coords = {
            x: x2,
            y: y2
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x2,
              y: limitedCoords.y - y2
            }
          };
        }
      };
    };
    size$1 = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "size",
        options: options2,
        async fn(state) {
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply = () => {
            },
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const maximumClippingHeight = height - overflow.top - overflow.bottom;
          const maximumClippingWidth = width - overflow.left - overflow.right;
          const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
          const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis) {
            availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          await apply({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
    noOffsets = /* @__PURE__ */ createCoords(0);
    topLayerSelectors = [":popover-open", ":modal"];
    getElementRects = async function(data) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      const floatingDimensions = await getDimensionsFn(data.floating);
      return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
          x: 0,
          y: 0,
          width: floatingDimensions.width,
          height: floatingDimensions.height
        }
      };
    };
    platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement: isElement2,
      isRTL
    };
    offset = offset$1;
    shift = shift$1;
    flip = flip$1;
    size = size$1;
    arrow = arrow$1;
    computePosition = (reference, floating, options2) => {
      const cache = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options2
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
      };
      return computePosition$1(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
    defaultConfig$1 = {
      strategy: "absolute",
      placement: "top",
      gutter: 5,
      flip: true,
      sameWidth: false,
      overflowPadding: 8
    };
    ARROW_TRANSFORM = {
      bottom: "rotate(45deg)",
      left: "rotate(135deg)",
      top: "rotate(225deg)",
      right: "rotate(315deg)"
    };
    candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element2) {
      var _element$getRootNode;
      return element2 === null || element2 === void 0 ? void 0 : (_element$getRootNode = element2.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element2);
    } : function(element2) {
      return element2 === null || element2 === void 0 ? void 0 : element2.ownerDocument;
    };
    isInert = function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    };
    isContentEditable = function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    getCandidates = function getCandidates2(el, includeContainer, filter) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter);
      return candidates;
    };
    getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options2) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element2 = elementsToCheck.shift();
        if (isInert(element2, false)) {
          continue;
        }
        if (element2.tagName === "SLOT") {
          var assigned = element2.assignedElements();
          var content = assigned.length ? assigned : element2.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options2);
          if (options2.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element2,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches.call(element2, candidateSelector);
          if (validCandidate && options2.filter(element2) && (includeContainer || !elements.includes(element2))) {
            candidates.push(element2);
          }
          var shadowRoot = element2.shadowRoot || // check for an undisclosed shadow
          typeof options2.getShadowRoot === "function" && options2.getShadowRoot(element2);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options2.shadowRootFilter || options2.shadowRootFilter(element2));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element2.children : shadowRoot.children, true, options2);
            if (options2.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element2,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element2.children);
          }
        }
      }
      return candidates;
    };
    hasTabIndex = function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    getTabIndex = function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
      return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
    };
    isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r3 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r3;
    };
    getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i2 = 0; i2 < nodes.length; i2++) {
        if (nodes[i2].checked && nodes[i2].form === form) {
          return nodes[i2];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name2) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    isNodeAttached = function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i2 = 0; i2 < parentNode.children.length; i2++) {
              var child = parentNode.children.item(i2);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options2, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options2) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options2, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options2, node)) {
        return false;
      }
      return true;
    };
    isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i2) {
        var isScope = !!item.scopeParent;
        var element2 = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element2, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element2;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element2);
        } else {
          orderedTabbables.push({
            documentOrder: i2,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    tabbable = function tabbable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options2),
          flatten: false,
          getShadowRoot: options2.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options2));
      }
      return sortByOrder(candidates);
    };
    focusable = function focusable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options2),
          flatten: true,
          getShadowRoot: options2.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options2));
      }
      return candidates;
    };
    isTabbable = function isTabbable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options2, node);
    };
    focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    isFocusable = function isFocusable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options2, node);
    };
    activeFocusTraps = {
      activateTrap: function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
          trapStack.push(trap);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
          trapStack[trapStack.length - 1].unpause();
        }
      }
    };
    isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    isEscapeEvent = function isEscapeEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Escape" || (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Esc" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 27;
    };
    isTabEvent = function isTabEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Tab" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 9;
    };
    isKeyForward = function isKeyForward2(e3) {
      return isTabEvent(e3) && !e3.shiftKey;
    };
    isKeyBackward = function isKeyBackward2(e3) {
      return isTabEvent(e3) && e3.shiftKey;
    };
    delay = function delay2(fn) {
      return setTimeout(fn, 0);
    };
    findIndex = function findIndex2(arr, fn) {
      var idx = -1;
      arr.every(function(value, i2) {
        if (fn(value)) {
          idx = i2;
          return false;
        }
        return true;
      });
      return idx;
    };
    valueOrHandler = function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    };
    getActualTarget = function getActualTarget2(event) {
      return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
    };
    internalTrapStack = [];
    createFocusTrap$1 = function createFocusTrap(elements, userOptions) {
      var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
      };
      var findContainerIndex = function findContainerIndex2(element2, event) {
        var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element2) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element2;
          });
        });
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
          if (findContainerIndex(doc.activeElement) >= 0) {
            node = doc.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config.tabbableOptions);
          var focusableNodes = focusable(container, config.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: function nextTabbableNode(node) {
              var forward2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward2) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward2 ? 1 : -1)];
            }
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
          return group.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g2) {
          return g2.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      };
      var getActiveElement = function getActiveElement2(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
          return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
          return getActiveElement2(activeElement.shadowRoot);
        }
        return activeElement;
      };
      var tryFocus = function tryFocus2(node) {
        if (node === false) {
          return;
        }
        if (node === getActiveElement(document)) {
          return;
        }
        if (!node || !node.focus) {
          tryFocus2(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      };
      var findNextNavNode = function findNextNavNode2(_ref2) {
        var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target = target || getActualTarget(event);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target, event);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var firstTabbableNode = _ref3.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target, false);
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
              var lastTabbableNode = _ref4.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      };
      var checkPointerDown = function checkPointerDown2(e3) {
        var target = getActualTarget(e3);
        if (findContainerIndex(target, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          trap.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(event) {
        var target = getActualTarget(event);
        var targetContained = findContainerIndex(target, event) >= 0;
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          event.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g2) {
                return g2.tabbableNodes.some(function(n2) {
                  return getTabIndex(n2) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            tryFocus(nextNode);
          } else {
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      };
      var checkKeyNav = function checkKeyNav2(event) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event;
        var destinationNode = findNextNavNode({
          event,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event)) {
            event.preventDefault();
          }
          tryFocus(destinationNode);
        }
      };
      var checkKey = function checkKey2(event) {
        if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
          event.preventDefault();
          trap.deactivate();
          return;
        }
        if (config.isKeyForward(event) || config.isKeyBackward(event)) {
          checkKeyNav(event, config.isKeyBackward(event));
        }
      };
      var checkClick = function checkClick2(e3) {
        var target = getActualTarget(e3);
        if (findContainerIndex(target, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
        e3.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap);
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
          tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc.addEventListener("focusin", checkFocusIn, true);
        doc.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc.addEventListener("keydown", checkKey, {
          capture: true,
          passive: false
        });
        return trap;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc.removeEventListener("focusin", checkFocusIn, true);
        doc.removeEventListener("mousedown", checkPointerDown, true);
        doc.removeEventListener("touchstart", checkPointerDown, true);
        doc.removeEventListener("click", checkClick, true);
        doc.removeEventListener("keydown", checkKey, true);
        return trap;
      };
      var checkDomRemoval = function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          tryFocus(getInitialFocusNode());
        }
      };
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      };
      trap = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc.activeElement;
          onActivate === null || onActivate === void 0 || onActivate();
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 || onPostActivate();
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options2 = _objectSpread2({
            onDeactivate: config.onDeactivate,
            onPostDeactivate: config.onPostDeactivate,
            checkCanReturnFocus: config.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap);
          var onDeactivate = getOption(options2, "onDeactivate");
          var onPostDeactivate = getOption(options2, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options2, "checkCanReturnFocus");
          var returnFocus = getOption(options2, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 || onDeactivate();
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause(pauseOptions) {
          if (state.paused || !state.active) {
            return this;
          }
          var onPause = getOption(pauseOptions, "onPause");
          var onPostPause = getOption(pauseOptions, "onPostPause");
          state.paused = true;
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
          return this;
        },
        unpause: function unpause(unpauseOptions) {
          if (!state.paused || !state.active) {
            return this;
          }
          var onUnpause = getOption(unpauseOptions, "onUnpause");
          var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
          state.paused = false;
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element2) {
            return typeof element2 === "string" ? doc.querySelector(element2) : element2;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }
      };
      trap.updateContainerElements(elements);
      return trap;
    };
    visibleModals = [];
    useModal = (node, config) => {
      let unsubInteractOutside = noop3;
      function removeNodeFromVisibleModals() {
        const index21 = visibleModals.indexOf(node);
        if (index21 >= 0) {
          visibleModals.splice(index21, 1);
        }
      }
      function update(config2) {
        unsubInteractOutside();
        const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config2;
        sleep2(100).then(() => {
          if (open) {
            visibleModals.push(node);
          } else {
            removeNodeFromVisibleModals();
          }
        });
        function isLastModal() {
          return last(visibleModals) === node;
        }
        function closeModal() {
          if (isLastModal() && onClose) {
            onClose();
            removeNodeFromVisibleModals();
          }
        }
        function onInteractOutsideStart(e3) {
          const target = e3.target;
          if (!isElement(target))
            return;
          if (target && isLastModal()) {
            e3.preventDefault();
            e3.stopPropagation();
            e3.stopImmediatePropagation();
          }
        }
        function onInteractOutside(e3) {
          if (shouldCloseOnInteractOutside?.(e3) && isLastModal()) {
            e3.preventDefault();
            e3.stopPropagation();
            e3.stopImmediatePropagation();
            closeModal();
          }
        }
        unsubInteractOutside = useInteractOutside(node, {
          onInteractOutsideStart,
          onInteractOutside: closeOnInteractOutside ? onInteractOutside : void 0,
          enabled: open
        }).destroy;
      }
      update(config);
      return {
        update,
        destroy() {
          removeNodeFromVisibleModals();
          unsubInteractOutside();
        }
      };
    };
    defaultConfig = {
      floating: {},
      focusTrap: {},
      modal: {},
      escapeKeydown: {},
      portal: "body"
    };
    usePopper = (popperElement, args) => {
      popperElement.dataset.escapee = "";
      const { anchorElement, open, options: options2 } = args;
      if (!anchorElement || !open || !options2) {
        return { destroy: noop3 };
      }
      const opts = { ...defaultConfig, ...options2 };
      const callbacks = [];
      if (opts.portal !== null) {
        callbacks.push(usePortal(popperElement, opts.portal).destroy);
      }
      callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
      if (opts.focusTrap !== null) {
        const { useFocusTrap } = createFocusTrap2({
          immediate: true,
          escapeDeactivates: false,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: popperElement,
          ...opts.focusTrap
        });
        callbacks.push(useFocusTrap(popperElement).destroy);
      }
      if (opts.modal !== null) {
        callbacks.push(useModal(popperElement, {
          onClose: () => {
            if (isHTMLElement(anchorElement)) {
              open.set(false);
              anchorElement.focus();
            }
          },
          shouldCloseOnInteractOutside: (e3) => {
            if (e3.defaultPrevented)
              return false;
            if (isHTMLElement(anchorElement) && anchorElement.contains(e3.target)) {
              return false;
            }
            return true;
          },
          ...opts.modal
        }).destroy);
      }
      if (opts.escapeKeydown !== null) {
        callbacks.push(useEscapeKeydown(popperElement, {
          enabled: open,
          handler: () => {
            open.set(false);
          },
          ...opts.escapeKeydown
        }).destroy);
      }
      const unsubscribe = executeCallbacks(...callbacks);
      return {
        destroy() {
          unsubscribe();
        }
      };
    };
    usePortal = (el, target = "body") => {
      let targetEl;
      if (!isHTMLElement(target) && typeof target !== "string") {
        return {
          destroy: noop3
        };
      }
      async function update(newTarget) {
        target = newTarget;
        if (typeof target === "string") {
          targetEl = document.querySelector(target);
          if (targetEl === null) {
            await tick();
            targetEl = document.querySelector(target);
          }
          if (targetEl === null) {
            throw new Error(`No element found matching css selector: "${target}"`);
          }
        } else if (target instanceof HTMLElement) {
          targetEl = target;
        } else {
          throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
        }
        el.dataset.portal = "";
        targetEl.appendChild(el);
        el.hidden = false;
      }
      function destroy() {
        el.remove();
      }
      update(target);
      return {
        update,
        destroy
      };
    };
    useInteractOutside = (node, config) => {
      let unsub = noop3;
      let unsubClick = noop3;
      let isPointerDown = false;
      let isPointerDownInside = false;
      let ignoreEmulatedMouseEvents = false;
      function update(config2) {
        unsub();
        unsubClick();
        const { onInteractOutside, onInteractOutsideStart, enabled } = config2;
        if (!enabled)
          return;
        function onPointerDown(e3) {
          if (onInteractOutside && isValidEvent(e3, node)) {
            onInteractOutsideStart?.(e3);
          }
          const target = e3.target;
          if (isElement(target) && isOrContainsTarget(node, target)) {
            isPointerDownInside = true;
          }
          isPointerDown = true;
        }
        function triggerInteractOutside(e3) {
          onInteractOutside?.(e3);
        }
        const documentObj = getOwnerDocument(node);
        if (typeof PointerEvent !== "undefined") {
          const onPointerUp = (e3) => {
            unsubClick();
            const handler = (e22) => {
              if (shouldTriggerInteractOutside(e22)) {
                triggerInteractOutside(e22);
              }
              resetPointerState();
            };
            if (e3.pointerType === "touch") {
              unsubClick = addEventListener2(documentObj, "click", handler, {
                capture: true,
                once: true
              });
              return;
            }
            handler(e3);
          };
          unsub = executeCallbacks(addEventListener2(documentObj, "pointerdown", onPointerDown, true), addEventListener2(documentObj, "pointerup", onPointerUp, true));
        } else {
          const onMouseUp = (e3) => {
            if (ignoreEmulatedMouseEvents) {
              ignoreEmulatedMouseEvents = false;
            } else if (shouldTriggerInteractOutside(e3)) {
              triggerInteractOutside(e3);
            }
            resetPointerState();
          };
          const onTouchEnd = (e3) => {
            ignoreEmulatedMouseEvents = true;
            if (shouldTriggerInteractOutside(e3)) {
              triggerInteractOutside(e3);
            }
            resetPointerState();
          };
          unsub = executeCallbacks(addEventListener2(documentObj, "mousedown", onPointerDown, true), addEventListener2(documentObj, "mouseup", onMouseUp, true), addEventListener2(documentObj, "touchstart", onPointerDown, true), addEventListener2(documentObj, "touchend", onTouchEnd, true));
        }
      }
      function shouldTriggerInteractOutside(e3) {
        if (isPointerDown && !isPointerDownInside && isValidEvent(e3, node)) {
          return true;
        }
        return false;
      }
      function resetPointerState() {
        isPointerDown = false;
        isPointerDownInside = false;
      }
      update(config);
      return {
        update,
        destroy() {
          unsub();
          unsubClick();
        }
      };
    };
  }
});

// .svelte-kit/output/server/chunks/index5.js
function Chevron_right($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "chevron-right" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
async function handleFocus(args) {
  const { prop, defaultEl } = args;
  await Promise.all([sleep2(1), tick]);
  if (prop === void 0) {
    defaultEl?.focus();
    return;
  }
  const returned = isFunction(prop) ? prop(defaultEl) : prop;
  if (typeof returned === "string") {
    const el = document.querySelector(returned);
    if (!isHTMLElement(el))
      return;
    el.focus();
  } else if (isHTMLElement(returned)) {
    returned.focus();
  }
}
function createMenuBuilder(opts) {
  const { name: name2, selector } = createElHelpers(opts.selector);
  const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, loop, closeFocus, disableFocusFirstItem, closeOnItemClick, onOutsideClick } = opts.rootOptions;
  const rootOpen = opts.rootOpen;
  const rootActiveTrigger = opts.rootActiveTrigger;
  const nextFocusable = opts.nextFocusable;
  const prevFocusable = opts.prevFocusable;
  const isUsingKeyboard = withGet.writable(false);
  const lastPointerX = withGet(writable(0));
  const pointerGraceIntent = withGet(writable(null));
  const pointerDir = withGet(writable("right"));
  const currentFocusedItem = withGet(writable(null));
  const pointerMovingToSubmenu = withGet(derived([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {
    return (e3) => {
      const isMovingTowards = $pointerDir === $pointerGraceIntent?.side;
      return isMovingTowards && isPointerInGraceArea(e3, $pointerGraceIntent?.area);
    };
  }));
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const rootIds = toWritableStores({ ...generateIds(menuIdParts), ...opts.ids });
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const rootMenu = makeElement(name2(), {
    stores: [isVisible, portal, rootIds.menu, rootIds.trigger],
    returned: ([$isVisible, $portal, $rootMenuId, $rootTriggerId]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: $rootMenuId,
        "aria-labelledby": $rootTriggerId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal),
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop3;
      const unsubDerived = effect2([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          unsubPopper();
          setMeltMenuAttribute(node, selector);
          unsubPopper = usePopper(node, {
            anchorElement: $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              modal: {
                closeOnInteractOutside: $closeOnOutsideClick,
                shouldCloseOnInteractOutside: (e3) => {
                  onOutsideClick.get()?.(e3);
                  if (e3.defaultPrevented)
                    return false;
                  if (isHTMLElement($rootActiveTrigger) && $rootActiveTrigger.contains(e3.target)) {
                    return false;
                  }
                  return true;
                },
                onClose: () => {
                  rootOpen.set(false);
                  $rootActiveTrigger.focus();
                },
                open: $isVisible
              },
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          }).destroy;
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e3) => {
        const target = e3.target;
        const menuEl = e3.currentTarget;
        if (!isHTMLElement(target) || !isHTMLElement(menuEl))
          return;
        const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e3.key)) {
          handleMenuNavigation(e3, loop.get() ?? false);
        }
        if (e3.key === kbd.TAB) {
          e3.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e3, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e3.key.length === 1;
        const isModifierKey = e3.ctrlKey || e3.altKey || e3.metaKey;
        if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
          handleTypeaheadSearch(e3.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const rootTrigger = makeElement(name2("trigger"), {
    stores: [rootOpen, rootIds.menu, rootIds.trigger],
    returned: ([$rootOpen, $rootMenuId, $rootTriggerId]) => {
      return {
        "aria-controls": $rootMenuId,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: $rootTriggerId,
        tabindex: 0
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      rootActiveTrigger.update((p2) => {
        if (p2)
          return p2;
        return node;
      });
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        const $rootOpen = rootOpen.get();
        const triggerEl = e3.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        handleOpen(triggerEl);
        if (!$rootOpen)
          e3.preventDefault();
      }), addMeltEventListener(node, "keydown", (e3) => {
        const triggerEl = e3.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        if (!(SELECTION_KEYS.includes(e3.key) || e3.key === kbd.ARROW_DOWN))
          return;
        e3.preventDefault();
        handleOpen(triggerEl);
        const menuId = triggerEl.getAttribute("aria-controls");
        if (!menuId)
          return;
        const menu = document.getElementById(menuId);
        if (!menu)
          return;
        const menuItems = getMenuItems(menu);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const rootArrow = makeElement(name2("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const overlay = makeElement(name2("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": "true",
        "data-state": stateAttr($isVisible)
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop3;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            rootOpen.set(false);
            const $rootActiveTrigger = rootActiveTrigger.get();
            if ($rootActiveTrigger)
              $rootActiveTrigger.focus();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      const unsubPortal = effect2([portal], ([$portal]) => {
        if ($portal === null)
          return noop3;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop3;
        return usePortal(node, portalDestination).destroy;
      });
      return {
        destroy() {
          unsubEscapeKeydown();
          unsubPortal();
        }
      };
    }
  });
  const item = makeElement(name2("item"), {
    returned: () => {
      return {
        role: "menuitem",
        tabindex: -1,
        "data-orientation": "vertical"
      };
    },
    action: (node) => {
      setMeltMenuAttribute(node, selector);
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
        const itemEl = e3.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e3.preventDefault();
          return;
        }
      }), addMeltEventListener(node, "click", (e3) => {
        const itemEl = e3.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e3.preventDefault();
          return;
        }
        if (e3.defaultPrevented) {
          handleRovingFocus(itemEl);
          return;
        }
        if (closeOnItemClick.get()) {
          sleep2(1).then(() => {
            rootOpen.set(false);
          });
        }
      }), addMeltEventListener(node, "keydown", (e3) => {
        onItemKeyDown(e3);
      }), addMeltEventListener(node, "pointermove", (e3) => {
        onMenuItemPointerMove(e3);
      }), addMeltEventListener(node, "pointerleave", (e3) => {
        onMenuItemPointerLeave(e3);
      }), addMeltEventListener(node, "focusin", (e3) => {
        onItemFocusIn(e3);
      }), addMeltEventListener(node, "focusout", (e3) => {
        onItemFocusOut(e3);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const group = makeElement(name2("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = makeElement(name2("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const checkboxItemDefaults = {
    defaultChecked: false,
    disabled: false
  };
  const createCheckboxItem = (props) => {
    const withDefaults = { ...checkboxItemDefaults, ...props };
    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);
    const checked = overridable(checkedWritable, withDefaults.onCheckedChange);
    const disabled = writable(withDefaults.disabled);
    const checkboxItem = makeElement(name2("checkbox-item"), {
      stores: [checked, disabled],
      returned: ([$checked, $disabled]) => {
        return {
          role: "menuitemcheckbox",
          tabindex: -1,
          "data-orientation": "vertical",
          "aria-checked": isIndeterminate($checked) ? "mixed" : $checked ? "true" : "false",
          "data-disabled": disabledAttr($disabled),
          "data-state": getCheckedState($checked)
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector);
        applyAttrsIfDisabled(node);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e3.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e3.preventDefault();
            return;
          }
          if (e3.defaultPrevented) {
            handleRovingFocus(itemEl);
            return;
          }
          checked.update((prev2) => {
            if (isIndeterminate(prev2))
              return true;
            return !prev2;
          });
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          onItemKeyDown(e3);
        }), addMeltEventListener(node, "pointermove", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            onItemLeave(e3);
            return;
          }
          onMenuItemPointerMove(e3, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          onMenuItemPointerLeave(e3);
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          onItemFocusOut(e3);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(checked, ($checked) => $checked === true);
    const _isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
    return {
      elements: {
        checkboxItem
      },
      states: {
        checked
      },
      helpers: {
        isChecked,
        isIndeterminate: _isIndeterminate
      },
      options: {
        disabled
      }
    };
  };
  const createMenuRadioGroup = (args = {}) => {
    const valueWritable = args.value ?? writable(args.defaultValue ?? null);
    const value = overridable(valueWritable, args.onValueChange);
    const radioGroup = makeElement(name2("radio-group"), {
      returned: () => ({
        role: "group"
      })
    });
    const radioItemDefaults = {
      disabled: false
    };
    const radioItem = makeElement(name2("radio-item"), {
      stores: [value],
      returned: ([$value]) => {
        return (itemProps) => {
          const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };
          const checked = $value === itemValue;
          return {
            disabled,
            role: "menuitemradio",
            "data-state": checked ? "checked" : "unchecked",
            "aria-checked": checked,
            "data-disabled": disabledAttr(disabled),
            "data-value": itemValue,
            "data-orientation": "vertical",
            tabindex: -1
          };
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e3.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e3.preventDefault();
            return;
          }
          if (e3.defaultPrevented) {
            if (!isHTMLElement(itemEl))
              return;
            handleRovingFocus(itemEl);
            return;
          }
          value.set(itemValue);
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          onItemKeyDown(e3);
        }), addMeltEventListener(node, "pointermove", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            onItemLeave(e3);
            return;
          }
          onMenuItemPointerMove(e3, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          onMenuItemPointerLeave(e3);
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          onItemFocusOut(e3);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(value, ($value) => {
      return (itemValue) => {
        return $value === itemValue;
      };
    });
    return {
      elements: {
        radioGroup,
        radioItem
      },
      states: {
        value
      },
      helpers: {
        isChecked
      }
    };
  };
  const { elements: { root: separator } } = createSeparator({
    orientation: "horizontal"
  });
  const subMenuDefaults = {
    ...defaults$2,
    disabled: false,
    positioning: {
      placement: "right-start",
      gutter: 8
    }
  };
  const createSubmenu = (args) => {
    const withDefaults = { ...subMenuDefaults, ...args };
    const subOpenWritable = withDefaults.open ?? writable(false);
    const subOpen = overridable(subOpenWritable, withDefaults?.onOpenChange);
    const options2 = toWritableStores(omit(withDefaults, "ids"));
    const { positioning: positioning2, arrowSize: arrowSize2, disabled } = options2;
    const subActiveTrigger = withGet(writable(null));
    const subOpenTimer = withGet(writable(null));
    const pointerGraceTimer = withGet(writable(0));
    const subIds = toWritableStores({ ...generateIds(menuIdParts), ...withDefaults.ids });
    safeOnMount(() => {
      const subTrigger2 = document.getElementById(subIds.trigger.get());
      if (subTrigger2) {
        subActiveTrigger.set(subTrigger2);
      }
    });
    const subIsVisible = derivedVisible({
      open: subOpen,
      forceVisible,
      activeTrigger: subActiveTrigger
    });
    const subMenu = makeElement(name2("submenu"), {
      stores: [subIsVisible, subIds.menu, subIds.trigger],
      returned: ([$subIsVisible, $subMenuId, $subTriggerId]) => {
        return {
          role: "menu",
          hidden: $subIsVisible ? void 0 : true,
          style: styleToString({
            display: $subIsVisible ? void 0 : "none"
          }),
          id: $subMenuId,
          "aria-labelledby": $subTriggerId,
          "data-state": $subIsVisible ? "open" : "closed",
          // unit tests fail on `.closest` if the id starts with a number
          // so using a data attribute
          "data-id": $subMenuId,
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop3;
        const unsubDerived = effect2([subIsVisible, positioning2], ([$subIsVisible, $positioning]) => {
          unsubPopper();
          if (!$subIsVisible)
            return;
          const activeTrigger = subActiveTrigger.get();
          if (!activeTrigger)
            return;
          tick().then(() => {
            unsubPopper();
            const parentMenuEl = getParentMenu(activeTrigger);
            unsubPopper = usePopper(node, {
              anchorElement: activeTrigger,
              open: subOpen,
              options: {
                floating: $positioning,
                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : void 0,
                modal: null,
                focusTrap: null,
                escapeKeydown: null
              }
            }).destroy;
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e3) => {
          if (e3.key === kbd.ESCAPE) {
            return;
          }
          const target = e3.target;
          const menuEl = e3.currentTarget;
          if (!isHTMLElement(target) || !isHTMLElement(menuEl))
            return;
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e3.key)) {
            e3.stopImmediatePropagation();
            handleMenuNavigation(e3, loop.get() ?? false);
            return;
          }
          const isCloseKey = SUB_CLOSE_KEYS["ltr"].includes(e3.key);
          const isModifierKey = e3.ctrlKey || e3.altKey || e3.metaKey;
          const isCharacterKey = e3.key.length === 1;
          if (isCloseKey) {
            const $subActiveTrigger = subActiveTrigger.get();
            e3.preventDefault();
            subOpen.update(() => {
              if ($subActiveTrigger) {
                handleRovingFocus($subActiveTrigger);
              }
              return false;
            });
            return;
          }
          if (e3.key === kbd.TAB) {
            e3.preventDefault();
            rootOpen.set(false);
            handleTabNavigation(e3, nextFocusable, prevFocusable);
            return;
          }
          if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
            handleTypeaheadSearch(e3.key, getMenuItems(menuEl));
          }
        }), addMeltEventListener(node, "pointermove", (e3) => {
          onMenuPointerMove(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          const $subActiveTrigger = subActiveTrigger.get();
          if (isUsingKeyboard.get()) {
            const target = e3.target;
            const submenuEl = document.getElementById(subIds.menu.get());
            if (!isHTMLElement(submenuEl) || !isHTMLElement(target))
              return;
            if (!submenuEl.contains(target) && target !== $subActiveTrigger) {
              subOpen.set(false);
            }
          } else {
            const menuEl = e3.currentTarget;
            const relatedTarget = e3.relatedTarget;
            if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))
              return;
            if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {
              subOpen.set(false);
            }
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubPopper();
            unsubEvents();
          }
        };
      }
    });
    const subTrigger = makeElement(name2("subtrigger"), {
      stores: [subOpen, disabled, subIds.menu, subIds.trigger],
      returned: ([$subOpen, $disabled, $subMenuId, $subTriggerId]) => {
        return {
          role: "menuitem",
          id: $subTriggerId,
          tabindex: -1,
          "aria-controls": $subMenuId,
          "aria-expanded": $subOpen,
          "data-state": $subOpen ? "open" : "closed",
          "data-disabled": disabledAttr($disabled),
          "aria-haspopop": "menu"
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector);
        applyAttrsIfDisabled(node);
        subActiveTrigger.update((p2) => {
          if (p2)
            return p2;
          return node;
        });
        const unsubTimer = () => {
          clearTimerStore(subOpenTimer);
          window.clearTimeout(pointerGraceTimer.get());
          pointerGraceIntent.set(null);
        };
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
          if (e3.defaultPrevented)
            return;
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          if (!subOpen.get()) {
            subOpen.update((prev2) => {
              const isAlreadyOpen = prev2;
              if (!isAlreadyOpen) {
                subActiveTrigger.set(triggerEl);
                return !prev2;
              }
              return prev2;
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          const $typed = typed.get();
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          const isTypingAhead = $typed.length > 0;
          if (isTypingAhead && e3.key === kbd.SPACE)
            return;
          if (SUB_OPEN_KEYS["ltr"].includes(e3.key)) {
            if (!subOpen.get()) {
              triggerEl.click();
              e3.preventDefault();
              return;
            }
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menuEl = document.getElementById(menuId);
            if (!isHTMLElement(menuEl))
              return;
            const firstItem = getMenuItems(menuEl)[0];
            handleRovingFocus(firstItem);
          }
        }), addMeltEventListener(node, "pointermove", (e3) => {
          if (!isMouse(e3))
            return;
          onItemEnter(e3);
          if (e3.defaultPrevented)
            return;
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          if (!isFocusWithinSubmenu(subIds.menu.get())) {
            handleRovingFocus(triggerEl);
          }
          const openTimer = subOpenTimer.get();
          if (!subOpen.get() && !openTimer && !isElementDisabled(triggerEl)) {
            subOpenTimer.set(window.setTimeout(() => {
              subOpen.update(() => {
                subActiveTrigger.set(triggerEl);
                return true;
              });
              clearTimerStore(subOpenTimer);
            }, 100));
          }
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          if (!isMouse(e3))
            return;
          clearTimerStore(subOpenTimer);
          const submenuEl = document.getElementById(subIds.menu.get());
          const contentRect = submenuEl?.getBoundingClientRect();
          if (contentRect) {
            const side = submenuEl?.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            pointerGraceIntent.set({
              area: [
                // Apply a bleed on clientX to ensure that our exit point is
                // consistently within polygon bounds
                { x: e3.clientX + bleed, y: e3.clientY },
                { x: contentNearEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.bottom },
                { x: contentNearEdge, y: contentRect.bottom }
              ],
              side
            });
            window.clearTimeout(pointerGraceTimer.get());
            pointerGraceTimer.set(window.setTimeout(() => {
              pointerGraceIntent.set(null);
            }, 300));
          } else {
            onTriggerLeave(e3);
            if (e3.defaultPrevented)
              return;
            pointerGraceIntent.set(null);
          }
        }), addMeltEventListener(node, "focusout", (e3) => {
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          removeHighlight(triggerEl);
          const relatedTarget = e3.relatedTarget;
          if (!isHTMLElement(relatedTarget))
            return;
          const menuId = triggerEl.getAttribute("aria-controls");
          if (!menuId)
            return;
          const menu = document.getElementById(menuId);
          if (menu && !menu.contains(relatedTarget)) {
            subOpen.set(false);
          }
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }));
        return {
          destroy() {
            unsubTimer();
            unsubEvents();
          }
        };
      }
    });
    const subArrow = makeElement(name2("subarrow"), {
      stores: arrowSize2,
      returned: ($arrowSize) => ({
        "data-arrow": true,
        style: styleToString({
          position: "absolute",
          width: `var(--arrow-size, ${$arrowSize}px)`,
          height: `var(--arrow-size, ${$arrowSize}px)`
        })
      })
    });
    effect2([rootOpen], ([$rootOpen]) => {
      if (!$rootOpen) {
        subActiveTrigger.set(null);
        subOpen.set(false);
      }
    });
    effect2([pointerGraceIntent], ([$pointerGraceIntent]) => {
      if (!isBrowser2 || $pointerGraceIntent)
        return;
      window.clearTimeout(pointerGraceTimer.get());
    });
    effect2([subOpen], ([$subOpen]) => {
      if (!isBrowser2)
        return;
      if ($subOpen && isUsingKeyboard.get()) {
        sleep2(1).then(() => {
          const menuEl = document.getElementById(subIds.menu.get());
          if (!menuEl)
            return;
          const menuItems = getMenuItems(menuEl);
          if (!menuItems.length)
            return;
          handleRovingFocus(menuItems[0]);
        });
      }
      if (!$subOpen) {
        const focusedItem = currentFocusedItem.get();
        const subTriggerEl = document.getElementById(subIds.trigger.get());
        if (focusedItem) {
          sleep2(1).then(() => {
            const menuEl = document.getElementById(subIds.menu.get());
            if (!menuEl)
              return;
            if (menuEl.contains(focusedItem)) {
              removeHighlight(focusedItem);
            }
          });
        }
        if (!subTriggerEl || document.activeElement === subTriggerEl)
          return;
        removeHighlight(subTriggerEl);
      }
    });
    return {
      ids: subIds,
      elements: {
        subTrigger,
        subMenu,
        subArrow
      },
      states: {
        subOpen
      },
      options: options2
    };
  };
  safeOnMount(() => {
    const triggerEl = document.getElementById(rootIds.trigger.get());
    if (isHTMLElement(triggerEl) && rootOpen.get()) {
      rootActiveTrigger.set(triggerEl);
    }
    const unsubs = [];
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = () => {
      isUsingKeyboard.set(true);
      unsubs.push(executeCallbacks(addEventListener2(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener2(document, "pointermove", handlePointer, { capture: true, once: true })));
    };
    const keydownListener = (e3) => {
      if (e3.key === kbd.ESCAPE && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    };
    unsubs.push(addEventListener2(document, "keydown", handleKeyDown, { capture: true }));
    unsubs.push(addEventListener2(document, "keydown", keydownListener));
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect2([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {
    if (!$rootOpen && $currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
  });
  effect2([rootOpen], ([$rootOpen]) => {
    if (!isBrowser2)
      return;
    if (!$rootOpen) {
      const $rootActiveTrigger = rootActiveTrigger.get();
      if (!$rootActiveTrigger)
        return;
      const $closeFocus = closeFocus.get();
      if (!$rootOpen && $rootActiveTrigger) {
        handleFocus({ prop: $closeFocus, defaultEl: $rootActiveTrigger });
      }
    }
  });
  effect2([rootOpen, preventScroll], ([$rootOpen, $preventScroll]) => {
    if (!isBrowser2)
      return;
    const unsubs = [];
    if (opts.removeScroll && $rootOpen && $preventScroll) {
      unsubs.push(removeScroll());
    }
    sleep2(1).then(() => {
      const menuEl = document.getElementById(rootIds.menu.get());
      if (menuEl && $rootOpen && isUsingKeyboard.get()) {
        if (disableFocusFirstItem.get()) {
          handleRovingFocus(menuEl);
          return;
        }
        const menuItems = getMenuItems(menuEl);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect2(rootOpen, ($rootOpen) => {
    if (!isBrowser2)
      return;
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = (e3) => {
      isUsingKeyboard.set(true);
      if (e3.key === kbd.ESCAPE && $rootOpen && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    };
    return executeCallbacks(addEventListener2(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener2(document, "pointermove", handlePointer, { capture: true, once: true }), addEventListener2(document, "keydown", handleKeyDown, { capture: true }));
  });
  function handleOpen(triggerEl) {
    rootOpen.update((prev2) => {
      const isOpen = !prev2;
      if (isOpen) {
        nextFocusable.set(getNextFocusable(triggerEl));
        prevFocusable.set(getPreviousFocusable(triggerEl));
        rootActiveTrigger.set(triggerEl);
      }
      return isOpen;
    });
  }
  function onItemFocusIn(e3) {
    const itemEl = e3.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    const $currentFocusedItem = currentFocusedItem.get();
    if ($currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
    addHighlight(itemEl);
    currentFocusedItem.set(itemEl);
  }
  function onItemFocusOut(e3) {
    const itemEl = e3.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    removeHighlight(itemEl);
  }
  function onItemEnter(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      e3.preventDefault();
    }
  }
  function onItemLeave(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      return;
    }
    const target = e3.target;
    if (!isHTMLElement(target))
      return;
    const parentMenuEl = getParentMenu(target);
    if (!parentMenuEl)
      return;
    handleRovingFocus(parentMenuEl);
  }
  function onTriggerLeave(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      e3.preventDefault();
    }
  }
  function onMenuPointerMove(e3) {
    if (!isMouse(e3))
      return;
    const target = e3.target;
    const currentTarget = e3.currentTarget;
    if (!isHTMLElement(currentTarget) || !isHTMLElement(target))
      return;
    const $lastPointerX = lastPointerX.get();
    const pointerXHasChanged = $lastPointerX !== e3.clientX;
    if (currentTarget.contains(target) && pointerXHasChanged) {
      const newDir = e3.clientX > $lastPointerX ? "right" : "left";
      pointerDir.set(newDir);
      lastPointerX.set(e3.clientX);
    }
  }
  function onMenuItemPointerMove(e3, currTarget = null) {
    if (!isMouse(e3))
      return;
    onItemEnter(e3);
    if (e3.defaultPrevented)
      return;
    if (currTarget) {
      handleRovingFocus(currTarget);
      return;
    }
    const currentTarget = e3.currentTarget;
    if (!isHTMLElement(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  function onMenuItemPointerLeave(e3) {
    if (!isMouse(e3))
      return;
    onItemLeave(e3);
  }
  function onItemKeyDown(e3) {
    const $typed = typed.get();
    const isTypingAhead = $typed.length > 0;
    if (isTypingAhead && e3.key === kbd.SPACE) {
      e3.preventDefault();
      return;
    }
    if (SELECTION_KEYS.includes(e3.key)) {
      e3.preventDefault();
      const itemEl = e3.currentTarget;
      if (!isHTMLElement(itemEl))
        return;
      itemEl.click();
    }
  }
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function getCheckedState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function isPointerMovingToSubmenu(e3) {
    return pointerMovingToSubmenu.get()(e3);
  }
  function getParentMenu(element2) {
    const parentMenuEl = element2.closest('[role="menu"]');
    if (!isHTMLElement(parentMenuEl))
      return null;
    return parentMenuEl;
  }
  return {
    elements: {
      trigger: rootTrigger,
      menu: rootMenu,
      overlay,
      item,
      group,
      groupLabel,
      arrow: rootArrow,
      separator
    },
    builders: {
      createCheckboxItem,
      createSubmenu,
      createMenuRadioGroup
    },
    states: {
      open: rootOpen
    },
    helpers: {
      handleTypeaheadSearch
    },
    ids: rootIds,
    options: opts.rootOptions
  };
}
function handleTabNavigation(e3, nextFocusable, prevFocusable) {
  if (e3.shiftKey) {
    const $prevFocusable = prevFocusable.get();
    if ($prevFocusable) {
      e3.preventDefault();
      sleep2(1).then(() => $prevFocusable.focus());
      prevFocusable.set(null);
    }
  } else {
    const $nextFocusable = nextFocusable.get();
    if ($nextFocusable) {
      e3.preventDefault();
      sleep2(1).then(() => $nextFocusable.focus());
      nextFocusable.set(null);
    }
  }
}
function getMenuItems(menuElement) {
  return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id="${menuElement.id}"]`)).filter((item) => isHTMLElement(item));
}
function applyAttrsIfDisabled(element2) {
  if (!element2 || !isElementDisabled(element2))
    return;
  element2.setAttribute("data-disabled", "");
  element2.setAttribute("aria-disabled", "true");
}
function clearTimerStore(timerStore) {
  if (!isBrowser2)
    return;
  const timer = timerStore.get();
  if (timer) {
    window.clearTimeout(timer);
    timerStore.set(null);
  }
}
function isMouse(e3) {
  return e3.pointerType === "mouse";
}
function setMeltMenuAttribute(element2, selector) {
  if (!element2)
    return;
  const menuEl = element2.closest(`${selector()}, ${selector("submenu")}`);
  if (!isHTMLElement(menuEl))
    return;
  element2.setAttribute("data-melt-menu-id", menuEl.id);
}
function handleMenuNavigation(e3, loop) {
  e3.preventDefault();
  const currentFocusedItem = document.activeElement;
  const currentTarget = e3.currentTarget;
  if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))
    return;
  const menuItems = getMenuItems(currentTarget);
  if (!menuItems.length)
    return;
  const candidateNodes = menuItems.filter((item) => {
    if (item.hasAttribute("data-disabled") || item.getAttribute("disabled") === "true") {
      return false;
    }
    return true;
  });
  const currentIndex = candidateNodes.indexOf(currentFocusedItem);
  let nextIndex;
  switch (e3.key) {
    case kbd.ARROW_DOWN:
      if (loop) {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : 0;
      } else {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;
      }
      break;
    case kbd.ARROW_UP:
      if (loop) {
        nextIndex = currentIndex > 0 ? currentIndex - 1 : candidateNodes.length - 1;
      } else {
        nextIndex = currentIndex < 0 ? candidateNodes.length - 1 : currentIndex > 0 ? currentIndex - 1 : 0;
      }
      break;
    case kbd.HOME:
      nextIndex = 0;
      break;
    case kbd.END:
      nextIndex = candidateNodes.length - 1;
      break;
    default:
      return;
  }
  handleRovingFocus(candidateNodes[nextIndex]);
}
function isPointerInGraceArea(e3, area) {
  if (!area)
    return false;
  const cursorPos = { x: e3.clientX, y: e3.clientY };
  return isPointInPolygon(cursorPos, area);
}
function isPointInPolygon(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isFocusWithinSubmenu(submenuId) {
  const activeEl = document.activeElement;
  if (!isHTMLElement(activeEl))
    return false;
  const submenuEl = activeEl.closest(`[data-id="${submenuId}"]`);
  return isHTMLElement(submenuEl);
}
function stateAttr(open) {
  return open ? "open" : "closed";
}
function createDropdownMenu(props) {
  const withDefaults = { ...defaults$12, ...props };
  const rootOptions = toWritableStores(omit(withDefaults, "ids"));
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);
  const rootActiveTrigger = withGet(writable(null));
  const nextFocusable = withGet(writable(null));
  const prevFocusable = withGet(writable(null));
  const { elements, builders, ids, states, options: options2 } = createMenuBuilder({
    rootOptions,
    rootOpen,
    rootActiveTrigger: withGet(rootActiveTrigger),
    nextFocusable: withGet(nextFocusable),
    prevFocusable: withGet(prevFocusable),
    selector: "dropdown-menu",
    removeScroll: true,
    ids: withDefaults.ids
  });
  return {
    ids,
    elements,
    states,
    builders,
    options: options2
  };
}
function generateId2() {
  return nanoid(10);
}
function getMenuData() {
  const NAME = "menu";
  const SUB_NAME = "menu-submenu";
  const RADIO_GROUP_NAME = "menu-radiogroup";
  const CHECKBOX_ITEM_NAME = "menu-checkboxitem";
  const RADIO_ITEM_NAME = "menu-radioitem";
  const GROUP_NAME = "menu-group";
  const PARTS = [
    "arrow",
    "checkbox-indicator",
    "checkbox-item",
    "content",
    "group",
    "item",
    "label",
    "radio-group",
    "radio-item",
    "radio-indicator",
    "separator",
    "sub-content",
    "sub-trigger",
    "trigger"
  ];
  return {
    NAME,
    SUB_NAME,
    RADIO_GROUP_NAME,
    CHECKBOX_ITEM_NAME,
    RADIO_ITEM_NAME,
    GROUP_NAME,
    PARTS
  };
}
function getCtx() {
  const { NAME } = getMenuData();
  return getContext(NAME);
}
function setCtx(props) {
  const { NAME, PARTS } = getMenuData();
  const getAttrs2 = createBitAttrs("menu", PARTS);
  const dropdownMenu = {
    ...createDropdownMenu({ ...removeUndefined2(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, dropdownMenu);
  return {
    ...dropdownMenu,
    updateOption: getOptionUpdater(dropdownMenu.options)
  };
}
function setGroupCtx() {
  const { GROUP_NAME } = getMenuData();
  const { elements: { group }, getAttrs: getAttrs2 } = getCtx();
  const id = generateId2();
  setContext(GROUP_NAME, id);
  return { group, id, getAttrs: getAttrs2 };
}
function getGroupLabel() {
  const { GROUP_NAME } = getMenuData();
  const id = getContext(GROUP_NAME) ?? generateId2();
  const { elements: { groupLabel }, getAttrs: getAttrs2 } = getCtx();
  return { groupLabel, id, getAttrs: getAttrs2 };
}
function updatePositioning2(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}
function Menu_item($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["href", "asChild", "disabled", "el"]);
  push();
  var $$store_subs;
  let builder, attrs;
  let href = value_or_fallback($$props["href"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let disabled = value_or_fallback($$props["disabled"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { item }, getAttrs: getAttrs2 } = getCtx();
  builder = store_get($$store_subs ??= {}, "$item", item);
  attrs = {
    ...getAttrs2("item"),
    ...disabledAttrs(disabled)
  };
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    const $$tag = href ? "a" : "div";
    $$payload.out += `<!--[-->`;
    if ($$tag)
      element(
        $$payload,
        $$tag,
        () => {
          $$payload.out += `${spread_attributes({ href, ...builder, ...$$restProps })}`;
        },
        () => {
          $$payload.out += `<!--[-->`;
          slot(
            $$payload,
            default_slot($$props),
            {
              get builder() {
                return builder;
              }
            },
            null
          );
          $$payload.out += `<!--]-->`;
        }
      );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { href, asChild, disabled, el });
  pop();
}
function Menu_group($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { group, id, getAttrs: getAttrs2 } = setGroupCtx();
  const attrs = getAttrs2("group");
  builder = store_get($$store_subs ??= {}, "$group", group)(id);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Menu_label($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { groupLabel, id, getAttrs: getAttrs2 } = getGroupLabel();
  const attrs = getAttrs2("label");
  builder = store_get($$store_subs ??= {}, "$groupLabel", groupLabel)(id);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Menu_separator($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { separator }, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("separator");
  builder = store_get($$store_subs ??= {}, "$separator", separator);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({
      ...store_get($$store_subs ??= {}, "$separator", separator),
      ...$$restProps
    })}></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Menu($$payload, $$props) {
  push();
  var $$store_subs;
  let closeOnOutsideClick = value_or_fallback($$props["closeOnOutsideClick"], () => void 0);
  let closeOnEscape = value_or_fallback($$props["closeOnEscape"], () => void 0);
  let portal = value_or_fallback($$props["portal"], () => void 0);
  let open = value_or_fallback($$props["open"], () => void 0);
  let onOpenChange = value_or_fallback($$props["onOpenChange"], () => void 0);
  let preventScroll = value_or_fallback($$props["preventScroll"], () => void 0);
  let loop = value_or_fallback($$props["loop"], () => void 0);
  let dir = value_or_fallback($$props["dir"], () => void 0);
  let typeahead = value_or_fallback($$props["typeahead"], () => void 0);
  let closeFocus = value_or_fallback($$props["closeFocus"], () => void 0);
  let disableFocusFirstItem = value_or_fallback($$props["disableFocusFirstItem"], () => void 0);
  let closeOnItemClick = value_or_fallback($$props["closeOnItemClick"], () => void 0);
  let onOutsideClick = value_or_fallback($$props["onOutsideClick"], () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx({
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible: true,
    defaultOpen: open,
    preventScroll,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    closeOnItemClick,
    onOutsideClick,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  open !== void 0 && localOpen.set(open);
  updateOption("closeOnOutsideClick", closeOnOutsideClick);
  updateOption("closeOnEscape", closeOnEscape);
  updateOption("portal", portal);
  updateOption("preventScroll", preventScroll);
  updateOption("loop", loop);
  updateOption("dir", dir);
  updateOption("closeFocus", closeFocus);
  updateOption("disableFocusFirstItem", disableFocusFirstItem);
  updateOption("typeahead", typeahead);
  updateOption("closeOnItemClick", closeOnItemClick);
  updateOption("onOutsideClick", onOutsideClick);
  $$payload.out += `<!--[-->`;
  slot(
    $$payload,
    default_slot($$props),
    {
      get ids() {
        return store_get($$store_subs ??= {}, "$idValues", idValues);
      }
    },
    null
  );
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    open,
    onOpenChange,
    preventScroll,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    closeOnItemClick,
    onOutsideClick
  });
  pop();
}
function Menu_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = value_or_fallback($$props["transition"], () => void 0);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => void 0);
  let inTransition = value_or_fallback($$props["inTransition"], () => void 0);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], () => void 0);
  let outTransition = value_or_fallback($$props["outTransition"], () => void 0);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let id = value_or_fallback($$props["id"], () => void 0);
  let side = value_or_fallback($$props["side"], () => "bottom");
  let align = value_or_fallback($$props["align"], () => "center");
  let sideOffset = value_or_fallback($$props["sideOffset"], () => 0);
  let alignOffset = value_or_fallback($$props["alignOffset"], () => 0);
  let collisionPadding = value_or_fallback($$props["collisionPadding"], () => 8);
  let avoidCollisions = value_or_fallback($$props["avoidCollisions"], () => true);
  let collisionBoundary = value_or_fallback($$props["collisionBoundary"], () => void 0);
  let sameWidth = value_or_fallback($$props["sameWidth"], () => false);
  let fitViewport = value_or_fallback($$props["fitViewport"], () => false);
  let strategy = value_or_fallback($$props["strategy"], () => "absolute");
  let overlap = value_or_fallback($$props["overlap"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const {
    elements: { menu },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx();
  const attrs = getAttrs2("content");
  if (id) {
    ids.menu.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$menu", menu);
  Object.assign(builder, attrs);
  if (store_get($$store_subs ??= {}, "$open", open)) {
    updatePositioning2({
      side,
      align,
      sideOffset,
      alignOffset,
      collisionPadding,
      avoidCollisions,
      collisionBoundary,
      sameWidth,
      fitViewport,
      strategy,
      overlap
    });
  }
  $$payload.out += `<!--[-->`;
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
      slot(
        $$payload,
        default_slot($$props),
        {
          get builder() {
            return builder;
          }
        },
        null
      );
      $$payload.out += `<!--]--></div>`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
        slot(
          $$payload,
          default_slot($$props),
          {
            get builder() {
              return builder;
            }
          },
          null
        );
        $$payload.out += `<!--]--></div>`;
        $$payload.out += "<!--]-->";
      } else {
        $$payload.out += `<!--[-->`;
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
          slot(
            $$payload,
            default_slot($$props),
            {
              get builder() {
                return builder;
              }
            },
            null
          );
          $$payload.out += `<!--]--></div>`;
          $$payload.out += "<!--]-->";
        } else {
          $$payload.out += `<!--[-->`;
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
            slot(
              $$payload,
              default_slot($$props),
              {
                get builder() {
                  return builder;
                }
              },
              null
            );
            $$payload.out += `<!--]--></div>`;
            $$payload.out += "<!--]-->";
          } else {
            $$payload.out += `<!--[-->`;
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
              slot(
                $$payload,
                default_slot($$props),
                {
                  get builder() {
                    return builder;
                  }
                },
                null
              );
              $$payload.out += `<!--]--></div>`;
              $$payload.out += "<!--]-->";
            } else {
              $$payload.out += "<!--]!-->";
            }
            $$payload.out += "<!--]!-->";
          }
          $$payload.out += "<!--]!-->";
        }
        $$payload.out += "<!--]!-->";
      }
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    side,
    align,
    sideOffset,
    alignOffset,
    collisionPadding,
    avoidCollisions,
    collisionBoundary,
    sameWidth,
    fitViewport,
    strategy,
    overlap,
    el
  });
  pop();
}
function Menu_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let id = value_or_fallback($$props["id"], () => void 0);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("trigger");
  if (id) {
    ids.trigger.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$trigger", trigger);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></button>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, id, el });
  pop();
}
function Dropdown_menu_item($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "inset"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let inset = value_or_fallback($$props["inset"], () => void 0);
  $$payload.out += `<!--[-->`;
  Menu_item($$payload, spread_props([
    {
      class: cn("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground data-[disabled]:opacity-50", inset && "pl-8", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className, inset });
  pop();
}
function Dropdown_menu_label($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "inset"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let inset = value_or_fallback($$props["inset"], () => void 0);
  $$payload.out += `<!--[-->`;
  Menu_label($$payload, spread_props([
    {
      class: cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className, inset });
  pop();
}
function Dropdown_menu_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "class",
    "sideOffset",
    "transition",
    "transitionConfig"
  ]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let sideOffset = value_or_fallback($$props["sideOffset"], () => 4);
  let transition = value_or_fallback($$props["transition"], () => flyAndScale);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => void 0);
  $$payload.out += `<!--[-->`;
  Menu_content($$payload, spread_props([
    {
      transition,
      transitionConfig,
      sideOffset,
      class: cn("z-50 min-w-[8rem] rounded-md border bg-popover p-1 text-popover-foreground shadow-md focus:outline-none", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, {
    class: className,
    sideOffset,
    transition,
    transitionConfig
  });
  pop();
}
function Dropdown_menu_separator($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<!--[-->`;
  Menu_separator($$payload, spread_props([
    {
      class: cn("-mx-1 my-1 h-px bg-muted", className)
    },
    $$restProps
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className });
  pop();
}
var SUB_OPEN_KEYS, SUB_CLOSE_KEYS, menuIdParts, defaults$2, defaults$12, defaults3, createSeparator, Root2, Trigger, Group;
var init_index5 = __esm({
  ".svelte-kit/output/server/chunks/index5.js"() {
    init_index3();
    init_Icon();
    init_misc();
    init_index4();
    init_input();
    init_helpers();
    init_index2();
    init_index_server();
    init_clsx();
    SUB_OPEN_KEYS = {
      ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],
      rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT]
    };
    SUB_CLOSE_KEYS = {
      ltr: [kbd.ARROW_LEFT],
      rtl: [kbd.ARROW_RIGHT]
    };
    menuIdParts = ["menu", "trigger"];
    defaults$2 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      typeahead: true,
      closeOnItemClick: true,
      onOutsideClick: void 0
    };
    defaults$12 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      forceVisible: false,
      typeahead: true,
      closeFocus: void 0,
      disableFocusFirstItem: false,
      closeOnItemClick: true,
      onOutsideClick: void 0
    };
    defaults3 = {
      orientation: "horizontal",
      decorative: false
    };
    createSeparator = (props) => {
      const withDefaults = { ...defaults3, ...props };
      const options2 = toWritableStores(withDefaults);
      const { orientation, decorative } = options2;
      const root2 = makeElement("separator", {
        stores: [orientation, decorative],
        returned: ([$orientation, $decorative]) => {
          const ariaOrientation = $orientation === "vertical" ? $orientation : void 0;
          return {
            role: $decorative ? "none" : "separator",
            "aria-orientation": ariaOrientation,
            "aria-hidden": $decorative,
            "data-orientation": $orientation
          };
        }
      });
      return {
        elements: {
          root: root2
        },
        options: options2
      };
    };
    Root2 = Menu;
    Trigger = Menu_trigger;
    Group = Menu_group;
  }
});

// .svelte-kit/output/server/chunks/Logo.js
function Moon($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "path",
      { "d": "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "moon" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Sun($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "4" }
    ],
    ["path", { "d": "M12 2v2" }],
    ["path", { "d": "M12 20v2" }],
    ["path", { "d": "m4.93 4.93 1.41 1.41" }],
    ["path", { "d": "m17.66 17.66 1.41 1.41" }],
    ["path", { "d": "M2 12h2" }],
    ["path", { "d": "M20 12h2" }],
    ["path", { "d": "m6.34 17.66-1.41 1.41" }],
    ["path", { "d": "m19.07 4.93-1.41 1.41" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "sun" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function ThemeToggler($$payload, $$props) {
  push();
  $$payload.out += `<!--[-->`;
  Button($$payload, {
    variant: "outline",
    size: "icon",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Sun($$payload2, {
        class: "h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"
      });
      $$payload2.out += `<!--]--> <!--[-->`;
      Moon($$payload2, {
        class: "absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"
      });
      $$payload2.out += `<!--]--> <span class="sr-only">Toggle theme</span>`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]-->`;
  pop();
}
function Logo($$payload, $$props) {
  push();
  var $$store_subs;
  $$payload.out += `<!--[-->`;
  if (store_get($$store_subs ??= {}, "$mode", derivedMode) === "dark") {
    $$payload.out += `<h1>Dark Logo</h1>`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<h1>Light Logo</h1>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_Logo = __esm({
  ".svelte-kit/output/server/chunks/Logo.js"() {
    init_index3();
    init_stores();
    init_index4();
    init_Icon();
    init_misc();
  }
});

// .svelte-kit/output/server/chunks/index6.js
function cubic_out(t2) {
  const f = t2 - 1;
  return f * f * f + 1;
}
function split_css_unit(value) {
  const split = typeof value === "string" && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return split ? [parseFloat(split[1]), split[2] || "px"] : [
    /** @type {number} */
    value,
    "px"
  ];
}
function fade(node, { delay: delay3 = 0, duration = 400, easing = linear } = {}) {
  const o2 = +getComputedStyle(node).opacity;
  return {
    delay: delay3,
    duration,
    easing,
    css: (t2) => `opacity: ${t2 * o2}`
  };
}
function fly(node, { delay: delay3 = 0, duration = 400, easing = cubic_out, x: x2 = 0, y: y2 = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  const [x_value, x_unit] = split_css_unit(x2);
  const [y_value, y_unit] = split_css_unit(y2);
  return {
    delay: delay3,
    duration,
    easing,
    css: (t2, u2) => `
			transform: ${transform} translate(${(1 - t2) * x_value}${x_unit}, ${(1 - t2) * y_value}${y_unit});
			opacity: ${target_opacity - od * u2}`
  };
}
function scale(node, { delay: delay3 = 0, duration = 400, easing = cubic_out, start = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const sd = 1 - start;
  const od = target_opacity * (1 - opacity);
  return {
    delay: delay3,
    duration,
    easing,
    css: (_t, u2) => `
			transform: ${transform} scale(${1 - sd * u2});
			opacity: ${target_opacity - od * u2}
		`
  };
}
var linear;
var init_index6 = __esm({
  ".svelte-kit/output/server/chunks/index6.js"() {
    linear = (x2) => x2;
  }
});

// .svelte-kit/output/server/entries/pages/app/_layout.svelte.js
var layout_svelte_exports2 = {};
__export(layout_svelte_exports2, {
  default: () => _layout2
});
function Arrow_right_left($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    ["path", { "d": "m16 3 4 4-4 4" }],
    ["path", { "d": "M20 7H4" }],
    ["path", { "d": "m8 21-4-4 4-4" }],
    ["path", { "d": "M4 17h16" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "arrow-right-left" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Briefcase_medical($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    ["path", { "d": "M12 11v4" }],
    ["path", { "d": "M14 13h-4" }],
    [
      "path",
      {
        "d": "M16 6V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2"
      }
    ],
    ["path", { "d": "M18 6v14" }],
    ["path", { "d": "M6 6v14" }],
    [
      "rect",
      {
        "width": "20",
        "height": "14",
        "x": "2",
        "y": "6",
        "rx": "2"
      }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "briefcase-medical" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Credit_card($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "rect",
      {
        "width": "20",
        "height": "14",
        "x": "2",
        "y": "5",
        "rx": "2"
      }
    ],
    [
      "line",
      {
        "x1": "2",
        "x2": "22",
        "y1": "10",
        "y2": "10"
      }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "credit-card" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Home($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "path",
      {
        "d": "m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"
      }
    ],
    [
      "polyline",
      { "points": "9 22 9 12 15 12 15 22" }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "home" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Hospital($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    ["path", { "d": "M12 6v4" }],
    ["path", { "d": "M14 14h-4" }],
    ["path", { "d": "M14 18h-4" }],
    ["path", { "d": "M14 8h-4" }],
    [
      "path",
      {
        "d": "M18 12h2a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-9a2 2 0 0 1 2-2h2"
      }
    ],
    [
      "path",
      {
        "d": "M18 22V4a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v18"
      }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "hospital" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Line_chart($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    ["path", { "d": "M3 3v18h18" }],
    ["path", { "d": "m19 9-5 5-4-4-3 3" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "line-chart" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function List_ordered($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "line",
      {
        "x1": "10",
        "x2": "21",
        "y1": "6",
        "y2": "6"
      }
    ],
    [
      "line",
      {
        "x1": "10",
        "x2": "21",
        "y1": "12",
        "y2": "12"
      }
    ],
    [
      "line",
      {
        "x1": "10",
        "x2": "21",
        "y1": "18",
        "y2": "18"
      }
    ],
    ["path", { "d": "M4 6h1v4" }],
    ["path", { "d": "M4 10h2" }],
    [
      "path",
      { "d": "M6 18H4c0-1 2-2 2-3s-1-1.5-2-1" }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "list-ordered" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Package_2($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "path",
      {
        "d": "M3 9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9Z"
      }
    ],
    [
      "path",
      {
        "d": "m3 9 2.45-4.9A2 2 0 0 1 7.24 3h9.52a2 2 0 0 1 1.8 1.1L21 9"
      }
    ],
    ["path", { "d": "M12 3v6" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "package-2" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Panel_left($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "rect",
      {
        "width": "18",
        "height": "18",
        "x": "3",
        "y": "3",
        "rx": "2"
      }
    ],
    ["path", { "d": "M9 3v18" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "panel-left" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Search($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "circle",
      { "cx": "11", "cy": "11", "r": "8" }
    ],
    ["path", { "d": "m21 21-4.3-4.3" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "search" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Settings($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "path",
      {
        "d": "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "3" }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "settings" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Shield_plus($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "path",
      {
        "d": "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { "d": "M9 12h6" }],
    ["path", { "d": "M12 9v6" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "shield-plus" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Users_round($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    ["path", { "d": "M18 21a8 8 0 0 0-16 0" }],
    [
      "circle",
      { "cx": "10", "cy": "8", "r": "5" }
    ],
    [
      "path",
      {
        "d": "M22 20c0-3.37-2-6.5-4-8a5 5 0 0 0-.45-8.3"
      }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "users-round" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function X($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    ["path", { "d": "M18 6 6 18" }],
    ["path", { "d": "m6 6 12 12" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "x" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function makeHull(points) {
  const newPoints = points.slice();
  newPoints.sort(POINT_COMPARATOR);
  return makeHullPresorted(newPoints);
}
function makeHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r3 = upperHull[upperHull.length - 2];
      if ((q2.x - r3.x) * (p2.y - r3.y) >= (q2.y - r3.y) * (p2.x - r3.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i2 = points.length - 1; i2 >= 0; i2--) {
    const p2 = points[i2];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r3 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r3.x) * (p2.y - r3.y) >= (q2.y - r3.y) * (p2.x - r3.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
function POINT_COMPARATOR(a2, b) {
  if (a2.x < b.x)
    return -1;
  else if (a2.x > b.x)
    return 1;
  else if (a2.y < b.y)
    return -1;
  else if (a2.y > b.y)
    return 1;
  else
    return 0;
}
function getPointsFromEl(el) {
  const rect = el.getBoundingClientRect();
  return [
    { x: rect.left, y: rect.top },
    { x: rect.right, y: rect.top },
    { x: rect.right, y: rect.bottom },
    { x: rect.left, y: rect.bottom }
  ];
}
function makeHullFromElements(els) {
  const points = els.flatMap((el) => getPointsFromEl(el));
  return makeHull(points);
}
function pointInPolygon(point, polygon) {
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function createDialog(props) {
  const withDefaults = { ...defaults$13, ...props };
  const options2 = toWritableStores(omit(withDefaults, "ids"));
  const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible, openFocus, closeFocus, onOutsideClick } = options2;
  const activeTrigger = withGet.writable(null);
  const ids = toWritableStores({
    ...generateIds(dialogIdParts),
    ...withDefaults.ids
  });
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  let unsubScroll = noop3;
  function handleOpen(e3) {
    const el = e3.currentTarget;
    const triggerEl = e3.currentTarget;
    if (!isHTMLElement(el) || !isHTMLElement(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  function handleClose() {
    open.set(false);
    handleFocus({
      prop: closeFocus.get(),
      defaultEl: activeTrigger.get()
    });
  }
  const trigger = makeElement(name$1("trigger"), {
    stores: [open],
    returned: ([$open]) => {
      return {
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        handleOpen(e3);
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.key !== kbd.ENTER && e3.key !== kbd.SPACE)
          return;
        e3.preventDefault();
        handleOpen(e3);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = makeElement(name$1("overlay"), {
    stores: [isVisible, open],
    returned: ([$isVisible, $open]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $open ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop3;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = makeElement(name$1("content"), {
    stores: [isVisible, ids.content, ids.description, ids.title, open],
    returned: ([$isVisible, $contentId, $descriptionId, $titleId, $open]) => {
      return {
        id: $contentId,
        role: role.get(),
        "aria-describedby": $descriptionId,
        "aria-labelledby": $titleId,
        "aria-modal": $isVisible ? "true" : void 0,
        "data-state": $open ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop3;
      let deactivate = noop3;
      const destroy = executeCallbacks(effect2([open, closeOnOutsideClick, closeOnEscape], ([$open, $closeOnOutsideClick, $closeOnEscape]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap2({
          immediate: false,
          escapeDeactivates: $closeOnEscape,
          clickOutsideDeactivates: $closeOnOutsideClick,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac = focusTrap.useFocusTrap(node);
        if (ac && ac.destroy) {
          return ac.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect2([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useModal(node, {
          open: $open,
          closeOnInteractOutside: $closeOnOutsideClick,
          onClose() {
            handleClose();
          },
          shouldCloseOnInteractOutside(e3) {
            onOutsideClick.get()?.(e3);
            if (e3.defaultPrevented)
              return false;
            return true;
          }
        }).destroy;
      }), effect2([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop3;
        return useEscapeKeydown(node, { handler: handleClose }).destroy;
      }), effect2([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy: () => {
          unsubScroll();
          destroy();
        }
      };
    }
  });
  const portalled = makeElement(name$1("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": portalAttr($portal)
    }),
    action: (node) => {
      const unsubPortal = effect2([portal], ([$portal]) => {
        if ($portal === null)
          return noop3;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop3;
        return usePortal(node, portalDestination).destroy;
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = makeElement(name$1("title"), {
    stores: [ids.title],
    returned: ([$titleId]) => ({
      id: $titleId
    })
  });
  const description = makeElement(name$1("description"), {
    stores: [ids.description],
    returned: ([$descriptionId]) => ({
      id: $descriptionId
    })
  });
  const close = makeElement(name$1("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.key !== kbd.SPACE && e3.key !== kbd.ENTER)
          return;
        e3.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect2([open, preventScroll], ([$open, $preventScroll]) => {
    if (!isBrowser2)
      return;
    if ($preventScroll && $open)
      unsubScroll = removeScroll();
    if ($open) {
      const contentEl = document.getElementById(ids.content.get());
      handleFocus({ prop: openFocus.get(), defaultEl: contentEl });
    }
    return () => {
      if (!forceVisible.get()) {
        unsubScroll();
      }
    };
  });
  return {
    ids,
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close,
      portalled
    },
    states: {
      open
    },
    options: options2
  };
}
function createTooltip(props) {
  const withDefaults = { ...defaults4, ...props };
  const options2 = toWritableStores(omit(withDefaults, "open", "ids"));
  const { positioning, arrowSize, closeOnPointerDown, openDelay, closeDelay, forceVisible, portal, closeOnEscape, disableHoverableContent, group } = options2;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const openReason = writable(null);
  const ids = toWritableStores({ ...generateIds(tooltipIdParts), ...withDefaults.ids });
  let clickedTrigger = false;
  const getEl = (part) => {
    if (!isBrowser2)
      return null;
    return document.getElementById(ids[part].get());
  };
  let openTimeout = null;
  let closeTimeout = null;
  function openTooltip(reason) {
    if (closeTimeout) {
      window.clearTimeout(closeTimeout);
      closeTimeout = null;
    }
    if (!openTimeout) {
      openTimeout = window.setTimeout(() => {
        open.set(true);
        openReason.update((prev2) => prev2 ?? reason);
        openTimeout = null;
      }, openDelay.get());
    }
  }
  function closeTooltip(isBlur) {
    if (openTimeout) {
      window.clearTimeout(openTimeout);
      openTimeout = null;
    }
    if (isBlur && isMouseInTooltipArea) {
      openReason.set("pointer");
      return;
    }
    if (!closeTimeout) {
      closeTimeout = window.setTimeout(() => {
        open.set(false);
        openReason.set(null);
        if (isBlur)
          clickedTrigger = false;
        closeTimeout = null;
      }, closeDelay.get());
    }
  }
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  const trigger = makeElement(name("trigger"), {
    stores: [ids.content, ids.trigger, open],
    returned: ([$contentId, $triggerId, $open]) => {
      return {
        "aria-describedby": $contentId,
        id: $triggerId,
        "data-state": $open ? "open" : "closed"
      };
    },
    action: (node) => {
      const keydownHandler = (e3) => {
        if (closeOnEscape.get() && e3.key === kbd.ESCAPE) {
          if (openTimeout) {
            window.clearTimeout(openTimeout);
            openTimeout = null;
          }
          open.set(false);
        }
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", () => {
        const $closeOnPointerDown = closeOnPointerDown.get();
        if (!$closeOnPointerDown)
          return;
        open.set(false);
        clickedTrigger = true;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "pointerenter", (e3) => {
        if (isTouch(e3))
          return;
        openTooltip("pointer");
      }), addMeltEventListener(node, "pointerleave", (e3) => {
        if (isTouch(e3))
          return;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "focus", () => {
        if (clickedTrigger)
          return;
        openTooltip("focus");
      }), addMeltEventListener(node, "blur", () => closeTooltip(true)), addMeltEventListener(node, "keydown", keydownHandler), addEventListener2(document, "keydown", keydownHandler));
      return {
        destroy: unsub
      };
    }
  });
  const content = makeElement(name("content"), {
    stores: [isVisible, open, portal, ids.content],
    returned: ([$isVisible, $open, $portal, $contentId]) => {
      return removeUndefined({
        role: "tooltip",
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: $isVisible ? void 0 : styleToString({ display: "none" }),
        id: $contentId,
        "data-portal": portalAttr($portal),
        "data-state": $open ? "open" : "closed"
      });
    },
    action: (node) => {
      let unsubFloating = noop3;
      let unsubPortal = noop3;
      const unsubDerived = effect2([isVisible, positioning, portal], ([$isVisible, $positioning, $portal]) => {
        unsubPortal();
        unsubFloating();
        const triggerEl = getEl("trigger");
        if (!$isVisible || !triggerEl)
          return;
        tick().then(() => {
          unsubPortal();
          unsubFloating();
          const portalDest = getPortalDestination(node, $portal);
          if (portalDest)
            unsubPortal = usePortal(node, portalDest).destroy;
          unsubFloating = useFloating(triggerEl, node, $positioning).destroy;
        });
      });
      function handleScroll(e3) {
        if (!open.get())
          return;
        const target = e3.target;
        if (!isElement(target) && !isDocument(target))
          return;
        const triggerEl = getEl("trigger");
        if (triggerEl && target.contains(triggerEl)) {
          closeTooltip();
        }
      }
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "pointerenter", () => openTooltip("pointer")), addMeltEventListener(node, "pointerdown", () => openTooltip("pointer")), addEventListener2(window, "scroll", handleScroll, { capture: true }));
      return {
        destroy() {
          unsubEvents();
          unsubPortal();
          unsubFloating();
          unsubDerived();
        }
      };
    }
  });
  const arrow2 = makeElement(name("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  let isMouseInTooltipArea = false;
  effect2(open, ($open) => {
    const currentGroup = group.get();
    if (currentGroup === void 0 || currentGroup === false) {
      return;
    }
    if (!$open) {
      if (groupMap.get(currentGroup) === open) {
        groupMap.delete(currentGroup);
      }
      return;
    }
    const currentOpen = groupMap.get(currentGroup);
    currentOpen?.set(false);
    groupMap.set(currentGroup, open);
  });
  effect2([open, openReason], ([$open, $openReason]) => {
    if (!$open || !isBrowser2)
      return;
    return executeCallbacks(addEventListener2(document, "mousemove", (e3) => {
      const contentEl = getEl("content");
      const triggerEl = getEl("trigger");
      if (!contentEl || !triggerEl)
        return;
      const polygonElements = disableHoverableContent.get() ? [triggerEl] : [triggerEl, contentEl];
      const polygon = makeHullFromElements(polygonElements);
      isMouseInTooltipArea = pointInPolygon({
        x: e3.clientX,
        y: e3.clientY
      }, polygon);
      if ($openReason !== "pointer")
        return;
      if (!isMouseInTooltipArea) {
        closeTooltip();
      }
    }));
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow2
    },
    states: { open },
    options: options2
  };
}
function getDialogData() {
  const NAME = "dialog";
  const PARTS = [
    "close",
    "content",
    "description",
    "overlay",
    "portal",
    "title",
    "trigger"
  ];
  return {
    NAME,
    PARTS
  };
}
function setCtx$1(props) {
  const { NAME, PARTS } = getDialogData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const dialog = {
    ...createDialog({ ...removeUndefined2(props), role: "dialog", forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, dialog);
  return {
    ...dialog,
    updateOption: getOptionUpdater(dialog.options)
  };
}
function getCtx$1() {
  const { NAME } = getDialogData();
  return getContext(NAME);
}
function Dialog($$payload, $$props) {
  push();
  var $$store_subs;
  let preventScroll = value_or_fallback($$props["preventScroll"], () => void 0);
  let closeOnEscape = value_or_fallback($$props["closeOnEscape"], () => void 0);
  let closeOnOutsideClick = value_or_fallback($$props["closeOnOutsideClick"], () => void 0);
  let portal = value_or_fallback($$props["portal"], () => void 0);
  let open = value_or_fallback($$props["open"], () => void 0);
  let onOpenChange = value_or_fallback($$props["onOpenChange"], () => void 0);
  let openFocus = value_or_fallback($$props["openFocus"], () => void 0);
  let closeFocus = value_or_fallback($$props["closeFocus"], () => void 0);
  let onOutsideClick = value_or_fallback($$props["onOutsideClick"], () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx$1({
    closeOnEscape,
    preventScroll,
    closeOnOutsideClick,
    portal,
    forceVisible: true,
    defaultOpen: open,
    openFocus,
    closeFocus,
    onOutsideClick,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
    content: $contentId,
    description: $descriptionId,
    title: $titleId
  }));
  open !== void 0 && localOpen.set(open);
  updateOption("preventScroll", preventScroll);
  updateOption("closeOnEscape", closeOnEscape);
  updateOption("closeOnOutsideClick", closeOnOutsideClick);
  updateOption("portal", portal);
  updateOption("openFocus", openFocus);
  updateOption("closeFocus", closeFocus);
  updateOption("onOutsideClick", onOutsideClick);
  $$payload.out += `<!--[-->`;
  slot(
    $$payload,
    default_slot($$props),
    {
      get ids() {
        return store_get($$store_subs ??= {}, "$idValues", idValues);
      }
    },
    null
  );
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    preventScroll,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    open,
    onOpenChange,
    openFocus,
    closeFocus,
    onOutsideClick
  });
  pop();
}
function Dialog_close($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { close }, getAttrs: getAttrs2 } = getCtx$1();
  const attrs = getAttrs2("close");
  builder = store_get($$store_subs ??= {}, "$close", close);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></button>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Dialog_portal($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { portalled }, getAttrs: getAttrs2 } = getCtx$1();
  const attrs = getAttrs2("portal");
  builder = store_get($$store_subs ??= {}, "$portalled", portalled);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Dialog_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = value_or_fallback($$props["transition"], () => void 0);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => void 0);
  let inTransition = value_or_fallback($$props["inTransition"], () => void 0);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], () => void 0);
  let outTransition = value_or_fallback($$props["outTransition"], () => void 0);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let id = value_or_fallback($$props["id"], () => void 0);
  let el = value_or_fallback($$props["el"], () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx$1();
  const attrs = getAttrs2("content");
  if (id) {
    ids.content.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$content", content);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
      slot(
        $$payload,
        default_slot($$props),
        {
          get builder() {
            return builder;
          }
        },
        null
      );
      $$payload.out += `<!--]--></div>`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
        slot(
          $$payload,
          default_slot($$props),
          {
            get builder() {
              return builder;
            }
          },
          null
        );
        $$payload.out += `<!--]--></div>`;
        $$payload.out += "<!--]-->";
      } else {
        $$payload.out += `<!--[-->`;
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
          slot(
            $$payload,
            default_slot($$props),
            {
              get builder() {
                return builder;
              }
            },
            null
          );
          $$payload.out += `<!--]--></div>`;
          $$payload.out += "<!--]-->";
        } else {
          $$payload.out += `<!--[-->`;
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
            slot(
              $$payload,
              default_slot($$props),
              {
                get builder() {
                  return builder;
                }
              },
              null
            );
            $$payload.out += `<!--]--></div>`;
            $$payload.out += "<!--]-->";
          } else {
            $$payload.out += `<!--[-->`;
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
              slot(
                $$payload,
                default_slot($$props),
                {
                  get builder() {
                    return builder;
                  }
                },
                null
              );
              $$payload.out += `<!--]--></div>`;
              $$payload.out += "<!--]-->";
            } else {
              $$payload.out += "<!--]!-->";
            }
            $$payload.out += "<!--]!-->";
          }
          $$payload.out += "<!--]!-->";
        }
        $$payload.out += "<!--]!-->";
      }
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    el
  });
  pop();
}
function Dialog_overlay($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = value_or_fallback($$props["transition"], () => void 0);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => void 0);
  let inTransition = value_or_fallback($$props["inTransition"], () => void 0);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], () => void 0);
  let outTransition = value_or_fallback($$props["outTransition"], () => void 0);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const {
    elements: { overlay },
    states: { open },
    getAttrs: getAttrs2
  } = getCtx$1();
  const attrs = getAttrs2("overlay");
  builder = store_get($$store_subs ??= {}, "$overlay", overlay);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
        $$payload.out += "<!--]-->";
      } else {
        $$payload.out += `<!--[-->`;
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
          $$payload.out += "<!--]-->";
        } else {
          $$payload.out += `<!--[-->`;
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
            $$payload.out += "<!--]-->";
          } else {
            $$payload.out += `<!--[-->`;
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
              $$payload.out += "<!--]-->";
            } else {
              $$payload.out += "<!--]!-->";
            }
            $$payload.out += "<!--]!-->";
          }
          $$payload.out += "<!--]!-->";
        }
        $$payload.out += "<!--]!-->";
      }
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    el
  });
  pop();
}
function Dialog_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx$1();
  const attrs = getAttrs2("trigger");
  builder = store_get($$store_subs ??= {}, "$trigger", trigger);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></button>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function getTooltipData() {
  const NAME = "tooltip";
  const PARTS = ["arrow", "content", "trigger"];
  return {
    NAME,
    PARTS
  };
}
function setCtx2(props) {
  const { NAME, PARTS } = getTooltipData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const tooltip = {
    ...createTooltip({
      positioning: {
        placement: "top",
        gutter: 0
      },
      openDelay: 700,
      ...removeUndefined2(props),
      forceVisible: true
    }),
    getAttrs: getAttrs2
  };
  setContext(NAME, tooltip);
  return {
    ...tooltip,
    updateOption: getOptionUpdater(tooltip.options)
  };
}
function getCtx2() {
  const { NAME } = getTooltipData();
  return getContext(NAME);
}
function updatePositioning3(props) {
  const defaultPlacement = {
    side: "top",
    align: "center",
    sideOffset: 1
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx2();
  const updater = getPositioningUpdater(positioning);
  updater({ ...withDefaults });
}
function Tooltip($$payload, $$props) {
  push();
  var $$store_subs;
  let closeOnEscape = value_or_fallback($$props["closeOnEscape"], () => void 0);
  let portal = value_or_fallback($$props["portal"], () => void 0);
  let closeOnPointerDown = value_or_fallback($$props["closeOnPointerDown"], () => void 0);
  let openDelay = value_or_fallback($$props["openDelay"], () => void 0);
  let closeDelay = value_or_fallback($$props["closeDelay"], () => void 0);
  let open = value_or_fallback($$props["open"], () => void 0);
  let onOpenChange = value_or_fallback($$props["onOpenChange"], () => void 0);
  let disableHoverableContent = value_or_fallback($$props["disableHoverableContent"], () => void 0);
  let group = value_or_fallback($$props["group"], () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx2({
    closeOnEscape,
    portal,
    closeOnPointerDown,
    openDelay,
    closeDelay,
    forceVisible: true,
    defaultOpen: open,
    disableHoverableContent,
    group,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    },
    positioning: { gutter: 0, offset: { mainAxis: 1 } }
  });
  const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
  open !== void 0 && localOpen.set(open);
  updateOption("closeOnEscape", closeOnEscape);
  updateOption("portal", portal);
  updateOption("closeOnPointerDown", closeOnPointerDown);
  updateOption("openDelay", openDelay);
  updateOption("closeDelay", closeDelay);
  updateOption("group", group);
  updateOption("disableHoverableContent", disableHoverableContent);
  $$payload.out += `<!--[-->`;
  slot(
    $$payload,
    default_slot($$props),
    {
      get ids() {
        return store_get($$store_subs ??= {}, "$idValues", idValues);
      }
    },
    null
  );
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    closeOnEscape,
    portal,
    closeOnPointerDown,
    openDelay,
    closeDelay,
    open,
    onOpenChange,
    disableHoverableContent,
    group
  });
  pop();
}
function Tooltip_content$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = value_or_fallback($$props["transition"], () => void 0);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => void 0);
  let inTransition = value_or_fallback($$props["inTransition"], () => void 0);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], () => void 0);
  let outTransition = value_or_fallback($$props["outTransition"], () => void 0);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let id = value_or_fallback($$props["id"], () => void 0);
  let side = value_or_fallback($$props["side"], () => "top");
  let align = value_or_fallback($$props["align"], () => "center");
  let sideOffset = value_or_fallback($$props["sideOffset"], () => 0);
  let alignOffset = value_or_fallback($$props["alignOffset"], () => 0);
  let collisionPadding = value_or_fallback($$props["collisionPadding"], () => 8);
  let avoidCollisions = value_or_fallback($$props["avoidCollisions"], () => true);
  let collisionBoundary = value_or_fallback($$props["collisionBoundary"], () => void 0);
  let sameWidth = value_or_fallback($$props["sameWidth"], () => false);
  let fitViewport = value_or_fallback($$props["fitViewport"], () => false);
  let strategy = value_or_fallback($$props["strategy"], () => "absolute");
  let overlap = value_or_fallback($$props["overlap"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx2();
  const attrs = getAttrs2("content");
  if (id) {
    ids.content.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$content", content);
  Object.assign(builder, attrs);
  if (store_get($$store_subs ??= {}, "$open", open)) {
    updatePositioning3({
      side,
      align,
      sideOffset,
      alignOffset,
      collisionPadding,
      avoidCollisions,
      collisionBoundary,
      sameWidth,
      fitViewport,
      strategy,
      overlap
    });
  }
  $$payload.out += `<!--[-->`;
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
      slot(
        $$payload,
        default_slot($$props),
        {
          get builder() {
            return builder;
          }
        },
        null
      );
      $$payload.out += `<!--]--></div>`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
        slot(
          $$payload,
          default_slot($$props),
          {
            get builder() {
              return builder;
            }
          },
          null
        );
        $$payload.out += `<!--]--></div>`;
        $$payload.out += "<!--]-->";
      } else {
        $$payload.out += `<!--[-->`;
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
          slot(
            $$payload,
            default_slot($$props),
            {
              get builder() {
                return builder;
              }
            },
            null
          );
          $$payload.out += `<!--]--></div>`;
          $$payload.out += "<!--]-->";
        } else {
          $$payload.out += `<!--[-->`;
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
            slot(
              $$payload,
              default_slot($$props),
              {
                get builder() {
                  return builder;
                }
              },
              null
            );
            $$payload.out += `<!--]--></div>`;
            $$payload.out += "<!--]-->";
          } else {
            $$payload.out += `<!--[-->`;
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
              slot(
                $$payload,
                default_slot($$props),
                {
                  get builder() {
                    return builder;
                  }
                },
                null
              );
              $$payload.out += `<!--]--></div>`;
              $$payload.out += "<!--]-->";
            } else {
              $$payload.out += "<!--]!-->";
            }
            $$payload.out += "<!--]!-->";
          }
          $$payload.out += "<!--]!-->";
        }
        $$payload.out += "<!--]!-->";
      }
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    side,
    align,
    sideOffset,
    alignOffset,
    collisionPadding,
    avoidCollisions,
    collisionBoundary,
    sameWidth,
    fitViewport,
    strategy,
    overlap,
    el
  });
  pop();
}
function Tooltip_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let id = value_or_fallback($$props["id"], () => void 0);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx2();
  const attrs = getAttrs2("trigger");
  if (id) {
    ids.trigger.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$trigger", trigger);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></button>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, id, el });
  pop();
}
function Sheet_portal($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<!--[-->`;
  Dialog_portal($$payload, spread_props([
    { class: cn(className) },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className });
  pop();
}
function Sheet_overlay($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "transition", "transitionConfig"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let transition = value_or_fallback($$props["transition"], () => fade);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => ({ duration: 150 }));
  $$payload.out += `<!--[-->`;
  Dialog_overlay($$payload, spread_props([
    {
      transition,
      transitionConfig,
      class: cn("fixed inset-0 z-50 bg-background/80 backdrop-blur-sm ", className)
    },
    $$restProps
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, {
    class: className,
    transition,
    transitionConfig
  });
  pop();
}
function Sheet_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "class",
    "side",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig"
  ]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let side = value_or_fallback($$props["side"], () => "right");
  let inTransition = value_or_fallback($$props["inTransition"], () => fly);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], () => sheetTransitions[side ?? "right"].in);
  let outTransition = value_or_fallback($$props["outTransition"], () => fly);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], () => sheetTransitions[side ?? "right"].out);
  $$payload.out += `<!--[-->`;
  Sheet_portal($$payload, {
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Sheet_overlay($$payload2, {});
      $$payload2.out += `<!--]--> <!--[-->`;
      Dialog_content($$payload2, spread_props([
        {
          inTransition,
          inTransitionConfig,
          outTransition,
          outTransitionConfig,
          class: cn(sheetVariants({ side }), className)
        },
        $$restProps,
        {
          children: ($$payload3, $$slotProps2) => {
            $$payload3.out += `<!--[-->`;
            slot($$payload3, default_slot($$props), {}, null);
            $$payload3.out += `<!--]--> <!--[-->`;
            Dialog_close($$payload3, {
              class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary",
              children: ($$payload4, $$slotProps3) => {
                $$payload4.out += `<!--[-->`;
                X($$payload4, { class: "h-4 w-4" });
                $$payload4.out += `<!--]--> <span class="sr-only">Close</span>`;
              },
              $$slots: { default: true }
            });
            $$payload3.out += `<!--]-->`;
          },
          $$slots: { default: true }
        }
      ]));
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]-->`;
  bind_props($$props, {
    class: className,
    side,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig
  });
  pop();
}
function Breadcrumb($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["el", "class"]);
  push();
  let el = value_or_fallback($$props["el"], () => void 0);
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<nav${spread_attributes({
    class: className,
    "aria-label": "breadcrumb",
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></nav>`;
  bind_props($$props, { el, class: className });
  pop();
}
function Breadcrumb_item($$payload, $$props) {
  push();
  let el = value_or_fallback($$props["el"], () => void 0);
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<li${attr("class", cn("inline-flex items-center gap-1.5", className), false)}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></li>`;
  bind_props($$props, { el, class: className });
  pop();
}
function Breadcrumb_separator($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["el", "class"]);
  push();
  let el = value_or_fallback($$props["el"], () => void 0);
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<li${spread_attributes({
    role: "presentation",
    "aria-hidden": "true",
    class: cn("[&>svg]:size-3.5", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, () => {
    $$payload.out += `<!--[-->`;
    Chevron_right($$payload, {});
    $$payload.out += `<!--]-->`;
  });
  $$payload.out += `<!--]--></li>`;
  bind_props($$props, { el, class: className });
  pop();
}
function Breadcrumb_link($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["href", "el", "asChild", "class"]);
  push();
  let href = value_or_fallback($$props["href"], () => void 0);
  let el = value_or_fallback($$props["el"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let className = value_or_fallback($$props["class"], () => void 0);
  let attrs;
  attrs = {
    class: cn("transition-colors hover:text-foreground", className),
    href,
    ...$$restProps
  };
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get attrs() {
          return attrs;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<a${spread_attributes({ ...attrs, href })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get attrs() {
          return attrs;
        }
      },
      null
    );
    $$payload.out += `<!--]--></a>`;
    $$payload.out += "<!--]!-->";
  }
  bind_props($$props, { href, el, asChild, class: className });
  pop();
}
function Breadcrumb_list($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["el", "class"]);
  push();
  let el = value_or_fallback($$props["el"], () => void 0);
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<ol${spread_attributes({
    class: cn("flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></ol>`;
  bind_props($$props, { el, class: className });
  pop();
}
function DashboardHeader($$payload, $$props) {
  push();
  var $$store_subs;
  let pathSegments = store_get($$store_subs ??= {}, "$page", page).url.pathname.split("/").slice(1);
  $$payload.out += `<header class="bg-background sticky top-0 z-30 flex h-14 items-center gap-4 border-b px-4 sm:static sm:h-auto sm:border-0 sm:bg-transparent sm:px-6"><!--[-->`;
  Root$1($$payload, {
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Trigger$1($$payload2, {
        asChild: true,
        children: ($$payload3, $$slotProps2) => {
          const builder = $$slotProps2.builder;
          $$payload3.out += `<!--[-->`;
          Button($$payload3, {
            builders: [builder],
            size: "icon",
            variant: "outline",
            class: "sm:hidden",
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `<!--[-->`;
              Panel_left($$payload4, { class: "h-5 w-5" });
              $$payload4.out += `<!--]--> <span class="sr-only">Toggle Menu</span>`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]--> <!--[-->`;
      Sheet_content($$payload2, {
        side: "left",
        class: "sm:max-w-xs",
        children: ($$payload3, $$slotProps2) => {
          $$payload3.out += `<nav class="grid gap-6 text-lg font-medium"><a href="/app" class="bg-primary text-primary-foreground group flex h-10 w-10 shrink-0 items-center justify-center gap-2 rounded-full text-lg font-semibold md:text-base"><!--[-->`;
          Package_2($$payload3, {
            class: "h-5 w-5 transition-all group-hover:scale-110"
          });
          $$payload3.out += `<!--]--> <span class="sr-only">Acme Inc</span></a> <a href="/app" class="text-muted-foreground hover:text-foreground flex items-center gap-4 px-2.5"><!--[-->`;
          Home($$payload3, { class: "h-5 w-5" });
          $$payload3.out += `<!--]--> Home</a> <a href="/app/pharmacies" class="text-foreground flex items-center gap-4 px-2.5"><!--[-->`;
          Hospital($$payload3, { class: "h-5 w-5" });
          $$payload3.out += `<!--]--> Pharmacies</a> <a href="/app/pharmacists" class="text-muted-foreground hover:text-foreground flex items-center gap-4 px-2.5"><!--[-->`;
          Shield_plus($$payload3, { class: "h-5 w-5" });
          $$payload3.out += `<!--]--> Pharmacists</a> <a href="/app/customers" class="text-muted-foreground hover:text-foreground flex items-center gap-4 px-2.5"><!--[-->`;
          Users_round($$payload3, { class: "h-5 w-5" });
          $$payload3.out += `<!--]--> Customers</a> <a href="/app/analytics" class="text-muted-foreground hover:text-foreground flex items-center gap-4 px-2.5"><!--[-->`;
          Line_chart($$payload3, { class: "h-5 w-5" });
          $$payload3.out += `<!--]--> Analytics</a> <a href="/app/settings" class="text-muted-foreground hover:text-foreground flex items-center gap-4 px-2.5"><!--[-->`;
          Settings($$payload3, { class: "h-5 w-5" });
          $$payload3.out += `<!--]--> Settings</a></nav>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--> <!--[-->`;
  Breadcrumb($$payload, {
    class: "hidden md:flex",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Breadcrumb_list($$payload2, {
        children: ($$payload3, $$slotProps2) => {
          const each_array = ensure_array_like(pathSegments);
          $$payload3.out += `<!--[-->`;
          for (let idx = 0; idx < each_array.length; idx++) {
            const segment = each_array[idx];
            $$payload3.out += "<!--[-->";
            $$payload3.out += `<!--[-->`;
            Breadcrumb_item($$payload3, {
              children: ($$payload4, $$slotProps3) => {
                $$payload4.out += `<!--[-->`;
                Breadcrumb_link($$payload4, {
                  href: segment === "app" ? "/app" : `${pathSegments.slice(0, idx + 1).join("/")}`,
                  class: "capitalize",
                  children: ($$payload5, $$slotProps4) => {
                    $$payload5.out += `${escape_html(segment === "app" ? "Home" : segment)}`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload3.out += `<!--]--> <!--[-->`;
            if (pathSegments.length > 1 && idx !== pathSegments.length - 1) {
              $$payload3.out += `<!--[-->`;
              Breadcrumb_separator($$payload3, {
                class: "mx-2",
                children: ($$payload4, $$slotProps3) => {
                  $$payload4.out += `/`;
                },
                $$slots: { default: true }
              });
              $$payload3.out += `<!--]-->`;
              $$payload3.out += "<!--]-->";
            } else {
              $$payload3.out += "<!--]!-->";
            }
            $$payload3.out += "<!--]-->";
          }
          $$payload3.out += "<!--]-->";
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--> <div class="relative ml-auto flex-1 md:grow-0"><!--[-->`;
  Search($$payload, {
    class: "text-muted-foreground absolute left-2.5 top-2.5 h-4 w-4"
  });
  $$payload.out += `<!--]--> <!--[-->`;
  Input($$payload, {
    type: "search",
    placeholder: "Search...",
    class: "bg-background w-full rounded-lg pl-8 md:w-[200px] lg:w-[336px]"
  });
  $$payload.out += `<!--]--></div> <!--[-->`;
  Root2($$payload, {
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Trigger($$payload2, {
        asChild: true,
        children: ($$payload3, $$slotProps2) => {
          const builder = $$slotProps2.builder;
          $$payload3.out += `<!--[-->`;
          Button($$payload3, {
            variant: "outline",
            size: "icon",
            class: "overflow-hidden rounded-full",
            builders: [builder],
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `<img src="/images/placeholder-user.webp"${attr("width", 36, false)}${attr("height", 36, false)} alt="Avatar" class="overflow-hidden rounded-full">`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]--> <!--[-->`;
      Dropdown_menu_content($$payload2, {
        align: "end",
        children: ($$payload3, $$slotProps2) => {
          $$payload3.out += `<!--[-->`;
          if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org" && store_get($$store_subs ??= {}, "$page", page).data.orgInfo) {
            $$payload3.out += `<!--[-->`;
            Dropdown_menu_label($$payload3, {
              class: "capitalize",
              children: ($$payload4, $$slotProps3) => {
                $$payload4.out += `${escape_html(store_get($$store_subs ??= {}, "$page", page).data.orgInfo.username)}'s Account`;
              },
              $$slots: { default: true }
            });
            $$payload3.out += `<!--]-->`;
            $$payload3.out += "<!--]-->";
          } else {
            $$payload3.out += `<!--[-->`;
            if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-pharmacy" && store_get($$store_subs ??= {}, "$page", page).data.pharmacistInfo && typeof store_get($$store_subs ??= {}, "$page", page).data.pharmacistInfo === "object" && "username" in store_get($$store_subs ??= {}, "$page", page).data.pharmacistInfo) {
              $$payload3.out += `<!--[-->`;
              Dropdown_menu_label($$payload3, {
                class: "capitalize",
                children: ($$payload4, $$slotProps3) => {
                  $$payload4.out += `${escape_html(store_get($$store_subs ??= {}, "$page", page).data.pharmacistInfo.username)}'s Account`;
                },
                $$slots: { default: true }
              });
              $$payload3.out += `<!--]-->`;
              $$payload3.out += "<!--]-->";
            } else {
              $$payload3.out += `<!--[-->`;
              if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client" && store_get($$store_subs ??= {}, "$page", page).data.userInfo && typeof store_get($$store_subs ??= {}, "$page", page).data.userInfo === "object" && "firstName" in store_get($$store_subs ??= {}, "$page", page).data.userInfo) {
                $$payload3.out += `<!--[-->`;
                Dropdown_menu_label($$payload3, {
                  class: "capitalize",
                  children: ($$payload4, $$slotProps3) => {
                    $$payload4.out += `${escape_html(store_get($$store_subs ??= {}, "$page", page).data.userInfo.firstName)}'s Account`;
                  },
                  $$slots: { default: true }
                });
                $$payload3.out += `<!--]-->`;
                $$payload3.out += "<!--]-->";
              } else {
                $$payload3.out += `<!--[-->`;
                Dropdown_menu_label($$payload3, {
                  class: "capitalize",
                  children: ($$payload4, $$slotProps3) => {
                    $$payload4.out += `My Account`;
                  },
                  $$slots: { default: true }
                });
                $$payload3.out += `<!--]-->`;
                $$payload3.out += "<!--]!-->";
              }
              $$payload3.out += "<!--]!-->";
            }
            $$payload3.out += "<!--]!-->";
          }
          $$payload3.out += ` <a href="/app/settings" class="block rounded-md border border-solid px-3 py-1 text-sm"><!--[-->`;
          Dropdown_menu_label($$payload3, {
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `Settings`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]--></a> <!--[-->`;
          Dropdown_menu_separator($$payload3, {});
          $$payload3.out += `<!--]--> <form method="POST" action="/auth/login?/logout"><!--[-->`;
          Button($$payload3, {
            type: "submit",
            variant: "outline",
            class: "w-full justify-start bg-transparent",
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `<!--[-->`;
              Dropdown_menu_item($$payload4, {
                children: ($$payload5, $$slotProps4) => {
                  $$payload5.out += `Logout`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!--]-->`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]--></form>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--> <!--[-->`;
  ThemeToggler($$payload);
  $$payload.out += `<!--]--></header>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function Tooltip_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "class",
    "sideOffset",
    "transition",
    "transitionConfig"
  ]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let sideOffset = value_or_fallback($$props["sideOffset"], () => 4);
  let transition = value_or_fallback($$props["transition"], () => flyAndScale);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => ({ y: 8, duration: 150 }));
  $$payload.out += `<!--[-->`;
  Tooltip_content$1($$payload, spread_props([
    {
      transition,
      transitionConfig,
      sideOffset,
      class: cn("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, {
    class: className,
    sideOffset,
    transition,
    transitionConfig
  });
  pop();
}
function NavLink($$payload, $$props) {
  push();
  var $$store_subs;
  let { href, label, children: icon } = $$props;
  let activeClass = store_get($$store_subs ??= {}, "$page", page).url.pathname === href ? "bg-accent" : "";
  let classList = (() => {
    const defaultClasses = "text-muted-foreground hover:text-foreground hover:bg-accent flex h-9 w-9 items-center justify-center rounded-lg transition-colors md:h-8 md:w-8";
    return cn(defaultClasses, activeClass);
  })();
  $$payload.out += `<!--[-->`;
  Root3($$payload, {
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Trigger2($$payload2, {
        asChild: true,
        children: ($$payload3, $$slotProps2) => {
          const builder = $$slotProps2.builder;
          $$payload3.out += `<a${spread_attributes({ href, class: classList, ...builder })}><!--[-->`;
          icon($$payload3);
          $$payload3.out += `<!--]--> <span class="sr-only">${escape_html(label)}</span></a>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]--> <!--[-->`;
      Tooltip_content($$payload2, {
        side: "right",
        children: ($$payload3, $$slotProps2) => {
          $$payload3.out += `${escape_html(label)}`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function DashboardAside($$payload, $$props) {
  push();
  var $$store_subs;
  $$payload.out += `<aside class="bg-background fixed inset-y-0 left-0 z-10 hidden w-14 flex-col border-r sm:flex"><nav class="flex flex-col items-center gap-4 px-2 sm:py-5"><a href="/" class="bg-primary text-primary-foreground group flex h-9 w-9 shrink-0 items-center justify-center gap-2 rounded-full text-lg font-semibold md:h-8 md:w-8 md:text-base"><!--[-->`;
  Logo($$payload);
  $$payload.out += `<!--]--> <span class="sr-only">Thola Kimonganga</span></a> <!--[-->`;
  NavLink($$payload, {
    href: "/app",
    label: "Home",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Home($$payload2, {});
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--> <!--[-->`;
  if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org") {
    $$payload.out += `<!--[-->`;
    NavLink($$payload, {
      href: "/app/pharmacies",
      label: "Pharmacies",
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        Hospital($$payload2, {});
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]--> <!--[-->`;
    NavLink($$payload, {
      href: "/app/pharmacists",
      label: "Pharmacists",
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        Shield_plus($$payload2, {});
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]--> <!--[-->`;
    NavLink($$payload, {
      href: "/app/subscriptions",
      label: "Manage Subscription",
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        Credit_card($$payload2, {});
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += "<!--]!-->";
  }
  $$payload.out += ` <!--[-->`;
  if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org" || store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-pharmacy") {
    $$payload.out += `<!--[-->`;
    NavLink($$payload, {
      href: "/app/transactions",
      label: "Transactions",
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        Arrow_right_left($$payload2, {});
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]--> <!--[-->`;
    NavLink($$payload, {
      href: "/app/medication",
      label: "Medication",
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        Briefcase_medical($$payload2, {});
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += "<!--]!-->";
  }
  $$payload.out += ` <!--[-->`;
  if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-pharmacy") {
    $$payload.out += `<!--[-->`;
    NavLink($$payload, {
      href: "/app/orders",
      label: "Orders",
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        List_ordered($$payload2, {});
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += "<!--]!-->";
  }
  $$payload.out += ` <!--[-->`;
  NavLink($$payload, {
    href: "/app/customers",
    label: "Customers",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Users_round($$payload2, {});
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--> <!--[-->`;
  NavLink($$payload, {
    href: "/app/analytics",
    label: "Analytics",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Line_chart($$payload2, {});
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--></nav> <nav class="mt-auto flex flex-col items-center gap-4 px-2 sm:py-5"><!--[-->`;
  NavLink($$payload, {
    href: "/app/settings",
    label: "Settings",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Settings($$payload2, {});
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--></nav></aside>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function OrganisationLayout($$payload, $$props) {
  push();
  let { children } = $$props;
  $$payload.out += `<div class="flex min-h-screen w-full flex-col bg-muted/40"><!--[-->`;
  DashboardAside($$payload);
  $$payload.out += `<!--]--> <!--[-->`;
  children($$payload);
  $$payload.out += `<!--]--></div>`;
  pop();
}
function _layout2($$payload, $$props) {
  push();
  var $$store_subs;
  let { children, data } = $$props;
  setContext(CONTEXT_KEYS.PHARMACY_LIST_STREAM, data.pharmacyListStream);
  setContext(CONTEXT_KEYS.ORGANISATION_PHARMACIST_LIST_STREAM, data.organisationPharmacistListStream);
  setContext(CONTEXT_KEYS.DELETE_PHARMACIST_FORM, data.deletePharmacistForm);
  $$payload.out += `<!--[-->`;
  if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org") {
    $$payload.out += `<!--[-->`;
    OrganisationLayout($$payload, {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<div class="flex flex-col sm:gap-4 sm:py-4 sm:pl-14"><!--[-->`;
        DashboardHeader($$payload2);
        $$payload2.out += `<!--]--> <!--[-->`;
        children($$payload2);
        $$payload2.out += `<!--]--></div>`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    children($$payload);
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var name$1, defaults$13, dialogIdParts, defaults4, name, groupMap, tooltipIdParts, Root$1, Trigger$1, sheetVariants, sheetTransitions, Root3, Trigger2;
var init_layout_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/app/_layout.svelte.js"() {
    init_index3();
    init_stores2();
    init_index4();
    init_index2();
    init_index_server();
    init_helpers();
    init_index5();
    init_input();
    init_misc();
    init_dist();
    init_clsx();
    init_client();
    init_Logo();
    init_Icon();
    init_index6();
    init_context_keys();
    ({ name: name$1 } = createElHelpers("dialog"));
    defaults$13 = {
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      role: "dialog",
      defaultOpen: false,
      portal: void 0,
      forceVisible: false,
      openFocus: void 0,
      closeFocus: void 0,
      onOutsideClick: void 0
    };
    dialogIdParts = ["content", "title", "description"];
    defaults4 = {
      positioning: {
        placement: "bottom"
      },
      arrowSize: 8,
      defaultOpen: false,
      closeOnPointerDown: true,
      openDelay: 1e3,
      closeDelay: 0,
      forceVisible: false,
      portal: void 0,
      closeOnEscape: true,
      disableHoverableContent: false,
      group: void 0
    };
    ({ name } = createElHelpers("tooltip"));
    groupMap = /* @__PURE__ */ new Map();
    tooltipIdParts = ["trigger", "content"];
    Root$1 = Dialog;
    Trigger$1 = Dialog_trigger;
    sheetVariants = ce({
      base: "fixed z-50 gap-4 bg-background p-6 shadow-lg",
      variants: {
        side: {
          top: "inset-x-0 top-0 border-b",
          bottom: "inset-x-0 bottom-0 border-t",
          left: "inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          right: "inset-y-0 right-0 h-full w-3/4  border-l sm:max-w-sm"
        }
      },
      defaultVariants: {
        side: "right"
      }
    });
    sheetTransitions = {
      top: {
        in: {
          y: "-100%",
          duration: 500,
          opacity: 1
        },
        out: {
          y: "-100%",
          duration: 300,
          opacity: 1
        }
      },
      bottom: {
        in: {
          y: "100%",
          duration: 500,
          opacity: 1
        },
        out: {
          y: "100%",
          duration: 300,
          opacity: 1
        }
      },
      left: {
        in: {
          x: "-100%",
          duration: 500,
          opacity: 1
        },
        out: {
          x: "-100%",
          duration: 300,
          opacity: 1
        }
      },
      right: {
        in: {
          x: "100%",
          duration: 500,
          opacity: 1
        },
        out: {
          x: "100%",
          duration: 300,
          opacity: 1
        }
      }
    };
    Root3 = Tooltip;
    Trigger2 = Tooltip_trigger;
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  server: () => layout_server_ts_exports2,
  server_id: () => server_id2,
  stylesheets: () => stylesheets3
});
var index3, component_cache3, component3, server_id2, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_layout_server_ts2();
    index3 = 2;
    component3 = async () => component_cache3 ??= (await Promise.resolve().then(() => (init_layout_svelte2(), layout_svelte_exports2))).default;
    server_id2 = "src/routes/app/+layout.server.ts";
    imports3 = ["_app/immutable/nodes/2.CWhyuR6T.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/snippet.CBj7fh4M.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/helpers.DNOQU4WG.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/index.Cn0Hvpco.js", "_app/immutable/chunks/Icon.JZj92Q4v.js", "_app/immutable/chunks/transitions.Bmz1fhPf.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/Logo.Dm3XqtGW.js", "_app/immutable/chunks/mode.Cq9Pf7ez.js", "_app/immutable/chunks/index.DkWdW2MU.js"];
    stylesheets3 = [];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/_layout.server.ts.js
var layout_server_ts_exports3 = {};
__export(layout_server_ts_exports3, {
  load: () => load4
});
var load4;
var init_layout_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/_layout.server.ts.js"() {
    init_chunks();
    load4 = async ({ locals }) => {
      if (locals.tholaApp !== "thola-org") {
        throw redirect(302, "/app");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/_layout.svelte.js
var layout_svelte_exports3 = {};
__export(layout_svelte_exports3, {
  default: () => _layout3
});
function _layout3($$payload, $$props) {
  push();
  let { children } = $$props;
  $$payload.out += `<div class="container"><!--[-->`;
  children($$payload);
  $$payload.out += `<!--]--></div>`;
  pop();
}
var init_layout_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/_layout.svelte.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  server: () => layout_server_ts_exports3,
  server_id: () => server_id3,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, server_id3, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_layout_server_ts3();
    index4 = 3;
    component4 = async () => component_cache4 ??= (await Promise.resolve().then(() => (init_layout_svelte3(), layout_svelte_exports3))).default;
    server_id3 = "src/routes/app/pharmacies/+layout.server.ts";
    imports4 = ["_app/immutable/nodes/3.Bo4n0uCW.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/snippet.CBj7fh4M.js"];
    stylesheets4 = [];
    fonts4 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacists/_layout.svelte.js
var layout_svelte_exports4 = {};
__export(layout_svelte_exports4, {
  default: () => _layout4
});
function _layout4($$payload, $$props) {
  push();
  let { children } = $$props;
  $$payload.out += `<div class="container"><!--[-->`;
  children($$payload);
  $$payload.out += `<!--]--></div>`;
  pop();
}
var init_layout_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacists/_layout.svelte.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  stylesheets: () => stylesheets5
});
var index5, component_cache5, component5, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    index5 = 4;
    component5 = async () => component_cache5 ??= (await Promise.resolve().then(() => (init_layout_svelte4(), layout_svelte_exports4))).default;
    imports5 = ["_app/immutable/nodes/4.Bo4n0uCW.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/snippet.CBj7fh4M.js"];
    stylesheets5 = [];
    fonts5 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/_layout.svelte.js
var layout_svelte_exports5 = {};
__export(layout_svelte_exports5, {
  default: () => _layout5
});
function _layout5($$payload, $$props) {
  push();
  var $$store_subs;
  let { children } = $$props;
  $$payload.out += `<div class="absolute top-0 flex w-full items-center justify-between p-3 max-md:bg-secondary max-md:shadow-xl container"><!--[-->`;
  Logo($$payload);
  $$payload.out += `<!--]--> <!--[-->`;
  ThemeToggler($$payload);
  $$payload.out += `<!--]--></div> <div class="flex flex-col min-h-screen w-full items-center justify-center dark:bg-inherit mt-12"><!--[-->`;
  children($$payload);
  $$payload.out += `<!--]--> <div class="flex items-center justify-center p-5"><h1 class="text-center text-xl">Welcome to Thola Kimonganga. ${escape_html(store_get($$store_subs ??= {}, "$page", page).url.pathname.includes("login") ? "Log into your account to continue" : store_get($$store_subs ??= {}, "$page", page).url.pathname.includes("signup") ? "Create an account to continue" : store_get($$store_subs ??= {}, "$page", page).url.pathname.includes("forgot-password") ? "Enter your email to recover your password" : store_get($$store_subs ??= {}, "$page", page).url.pathname.includes("reset-password") ? "Reset your password" : "")}</h1></div></div>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_layout_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/_layout.svelte.js"() {
    init_index3();
    init_Logo();
    init_stores2();
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  stylesheets: () => stylesheets6
});
var index6, component_cache6, component6, imports6, stylesheets6, fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    index6 = 5;
    component6 = async () => component_cache6 ??= (await Promise.resolve().then(() => (init_layout_svelte5(), layout_svelte_exports5))).default;
    imports6 = ["_app/immutable/nodes/5.Cd1IHbVB.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/snippet.CBj7fh4M.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/Logo.Dm3XqtGW.js", "_app/immutable/chunks/mode.Cq9Pf7ez.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/Icon.JZj92Q4v.js"];
    stylesheets6 = [];
    fonts6 = [];
  }
});

// .svelte-kit/output/server/entries/pages/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => _page
});
function _page($$payload, $$props) {
  push();
  var $$store_subs;
  $$payload.out += `<p>tholaKimonganga: ${escape_html(store_get($$store_subs ??= {}, "$page", page).data.tholaApp)}</p>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_index3();
    init_stores2();
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  stylesheets: () => stylesheets7
});
var index7, component_cache7, component7, imports7, stylesheets7, fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    index7 = 6;
    component7 = async () => component_cache7 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default;
    imports7 = ["_app/immutable/nodes/6.Dq6rjw10.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js"];
    stylesheets7 = [];
    fonts7 = [];
  }
});

// .svelte-kit/output/server/chunks/table-row.js
function Arrow_up_down($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    ["path", { "d": "m21 16-4 4-4-4" }],
    ["path", { "d": "M17 20V4" }],
    ["path", { "d": "m3 8 4-4 4 4" }],
    ["path", { "d": "M7 4v16" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "arrow-up-down" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Circle_plus($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "10" }
    ],
    ["path", { "d": "M8 12h8" }],
    ["path", { "d": "M12 8v8" }]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "circle-plus" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Ellipsis($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "1" }
    ],
    [
      "circle",
      { "cx": "19", "cy": "12", "r": "1" }
    ],
    [
      "circle",
      { "cx": "5", "cy": "12", "r": "1" }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "ellipsis" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Squirrel($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "path",
      { "d": "M15.236 22a3 3 0 0 0-2.2-5" }
    ],
    [
      "path",
      {
        "d": "M16 20a3 3 0 0 1 3-3h1a2 2 0 0 0 2-2v-2a4 4 0 0 0-4-4V4"
      }
    ],
    ["path", { "d": "M18 13h.01" }],
    [
      "path",
      {
        "d": "M18 6a4 4 0 0 0-4 4 7 7 0 0 0-7 7c0-5 4-5 4-10.5a4.5 4.5 0 1 0-9 0 2.5 2.5 0 0 0 5 0C7 10 3 11 3 17c0 2.8 2.2 5 5 5h10"
      }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "squirrel" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function LoadingSpinner($$payload, $$props) {
  push();
  let { size: size2 = "md" } = $$props;
  let dimension = (() => {
    if (size2 === "md")
      return "w-16 h-16";
    if (size2 === "lg")
      return "w-24 h-24";
    return "w-10 h-10";
  })();
  $$payload.out += `<div class="flex w-full items-center justify-center rounded-md border-2 px-2 py-5 blur-sm"><div role="status"><svg aria-hidden="true"${attr("class", cn("fill-primary dark:fill-secondary animate-spin text-gray-200 dark:text-gray-600", dimension), false)} viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"></path><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"></path></svg> <span class="sr-only">Loading...</span></div></div>`;
  pop();
}
function QueryErrorPlaceHolder($$payload, $$props) {
  push();
  var $$store_subs;
  let { query } = $$props;
  $$payload.out += `<!--[-->`;
  if (store_get($$store_subs ??= {}, "$query", query).isError) {
    $$payload.out += `<div class="flex w-full flex-col items-center justify-center gap-3 rounded-md border-2 px-2 py-5"><h1>Oops, something went wrong</h1> <!--[-->`;
    Squirrel($$payload, { size: 48 });
    $$payload.out += `<!--]--> <!--[-->`;
    if (store_get($$store_subs ??= {}, "$query", query).failureCount > 3) {
      $$payload.out += `<!--[-->`;
      Button($$payload, {
        onclick: () => store_get($$store_subs ??= {}, "$query", query).refetch(),
        children: ($$payload2, $$slotProps) => {
          $$payload2.out += `Try Again`;
        },
        $$slots: { default: true }
      });
      $$payload.out += `<!--]-->`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += `</div>`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function Subscribe($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, []);
  push();
  var $$store_subs;
  const values = derivedKeys($$restProps);
  $$payload.out += `<!--[-->`;
  slot(
    $$payload,
    default_slot($$props),
    spread_props([
      {},
      store_get($$store_subs ??= {}, "$values", values)
    ]),
    null
  );
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function PropsRenderer($$payload, $$props) {
  push();
  let instance = value_or_fallback($$props["instance"], () => void 0);
  let config = $$props["config"];
  let props = value_or_fallback($$props["props"], () => void 0);
  $$payload.out += `<!--[-->`;
  if (config.children.length === 0) {
    $$payload.out += `<!--[-->`;
    config.component?.($$payload, spread_props([props ?? {}]));
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    config.component?.($$payload, spread_props([
      props ?? {},
      {
        children: ($$payload2, $$slotProps) => {
          const each_array = ensure_array_like(config.children);
          $$payload2.out += `<!--[-->`;
          for (let $$index = 0; $$index < each_array.length; $$index++) {
            const child = each_array[$$index];
            $$payload2.out += "<!--[-->";
            $$payload2.out += `<!--[-->`;
            Render($$payload2, { of: child });
            $$payload2.out += `<!--]-->`;
            $$payload2.out += "<!--]-->";
          }
          $$payload2.out += "<!--]-->";
        },
        $$slots: { default: true }
      }
    ]));
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]!-->";
  }
  bind_props($$props, { instance, config, props });
  pop();
}
function ComponentRenderer($$payload, $$props) {
  push();
  let config = $$props["config"];
  let instance;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    if (isReadable2(config.props)) {
      $$payload2.out += `<!--[-->`;
      Subscribe($$payload2, {
        props: config.props,
        children: ($$payload3, $$slotProps) => {
          const props = $$slotProps.props;
          $$payload3.out += `<!--[-->`;
          PropsRenderer($$payload3, {
            get instance() {
              return instance;
            },
            set instance($$value) {
              instance = $$value;
              $$settled = false;
            },
            config,
            props
          });
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
      $$payload2.out += "<!--]-->";
    } else {
      $$payload2.out += `<!--[-->`;
      PropsRenderer($$payload2, {
        get instance() {
          return instance;
        },
        set instance($$value) {
          instance = $$value;
          $$settled = false;
        },
        config,
        props: config.props
      });
      $$payload2.out += `<!--]-->`;
      $$payload2.out += "<!--]!-->";
    }
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  bind_props($$props, { config });
  pop();
}
function Render($$payload, $$props) {
  push();
  var $$store_subs;
  let config = $$props["of"];
  const readableConfig = isReadable2(config) ? config : Undefined;
  $$payload.out += `<!--[-->`;
  if (isReadable2(config)) {
    $$payload.out += `${escape_html(store_get($$store_subs ??= {}, "$readableConfig", readableConfig))}`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (typeof config !== "object") {
      $$payload.out += `${escape_html(config)}`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      ComponentRenderer($$payload, { config });
      $$payload.out += `<!--]-->`;
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { of: config });
  pop();
}
function createRender(component21, props) {
  return new ComponentRenderConfig(component21, props);
}
function Table2($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<div class="relative w-full overflow-auto"><table${spread_attributes({
    class: cn("w-full caption-bottom text-sm", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></table></div>`;
  bind_props($$props, { class: className });
  pop();
}
function Table_body($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<tbody${spread_attributes({
    class: cn("[&_tr:last-child]:border-0", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></tbody>`;
  bind_props($$props, { class: className });
  pop();
}
function Table_cell($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<td${spread_attributes({
    class: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></td>`;
  bind_props($$props, { class: className });
  pop();
}
function Table_head($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<th${spread_attributes({
    class: cn("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></th>`;
  bind_props($$props, { class: className });
  pop();
}
function Table_header($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<thead${spread_attributes({
    class: cn("[&_tr]:border-b", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></thead>`;
  bind_props($$props, { class: className });
  pop();
}
function Table_row($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<tr${spread_attributes({
    class: cn("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></tr>`;
  bind_props($$props, { class: className });
  pop();
}
var derivedKeys, isReadable2, Undefined, ComponentRenderConfig, Column, FlatColumn, DataColumn, DisplayColumn, GroupColumn, getFlatColumnIds, getFlatColumns, getCounter, getDuplicates, stringifyCss, mergeAttributes, finalizeAttributes, TableComponent, BodyCell, DataBodyCell, DisplayBodyCell, nonUndefined, BodyRow, DataBodyRow, getBodyRows, getColumnedBodyRows, NBSP, HeaderCell, FlatHeaderCell, DataHeaderCell, FlatDisplayHeaderCell, GroupHeaderCell, GroupDisplayHeaderCell, sum, getNullMatrix, getTransposed, HeaderRow, getHeaderRows, getHeaderRowMatrix, loadHeaderRowMatrix, getOrderedColumnMatrix, populateGroupHeaderCellIds, headerRowsForRowMatrix, getMergedRow, createViewModel, Table$1, createTable, textPrefixFilter, recordSetStore, isShiftClick, MIN_PAGE_SIZE, createPageStore, addPagination, compare, compareArray, DEFAULT_TOGGLE_ORDER, createSortKeysStore, getSortedRows, addSortBy, getFilteredRows, addTableFilter;
var init_table_row = __esm({
  ".svelte-kit/output/server/chunks/table-row.js"() {
    init_index3();
    init_Icon();
    init_misc();
    init_index4();
    init_index2();
    derivedKeys = (storeMap) => {
      const entries = Object.entries(storeMap);
      const keys = entries.map(([key2]) => key2);
      return derived(entries.map(([, store]) => store), ($stores) => {
        return Object.fromEntries($stores.map((store, idx) => [keys[idx], store]));
      });
    };
    isReadable2 = (value) => {
      return value?.subscribe instanceof Function;
    };
    Undefined = readable(void 0);
    ComponentRenderConfig = class {
      component;
      props;
      constructor(component21, props) {
        this.component = component21;
        this.props = props;
      }
      eventHandlers = [];
      on(type, handler) {
        this.eventHandlers.push([type, handler]);
        return this;
      }
      children = [];
      slot(...children) {
        this.children = children;
        return this;
      }
    };
    Column = class {
      header;
      footer;
      height;
      plugins;
      constructor({ header, footer, height, plugins }) {
        this.header = header;
        this.footer = footer;
        this.height = height;
        this.plugins = plugins;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isFlat() {
        return "__flat" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isDisplay() {
        return "__display" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isGroup() {
        return "__group" in this;
      }
    };
    FlatColumn = class extends Column {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __flat = true;
      id;
      constructor({ header, footer, plugins, id }) {
        super({ header, footer, plugins, height: 1 });
        this.id = id ?? String(header);
      }
    };
    DataColumn = class extends FlatColumn {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      cell;
      accessorKey;
      accessorFn;
      constructor({ header, footer, plugins, cell, accessor, id }) {
        super({ header, footer, plugins, id: "Initialization not complete" });
        this.cell = cell;
        if (accessor instanceof Function) {
          this.accessorFn = accessor;
        } else {
          this.accessorKey = accessor;
        }
        if (id === void 0 && this.accessorKey === void 0 && header === void 0) {
          throw new Error("A column id, string accessor, or header is required");
        }
        const accessorKeyId = typeof this.accessorKey === "string" ? this.accessorKey : null;
        this.id = id ?? accessorKeyId ?? String(header);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      getValue(item) {
        if (this.accessorFn !== void 0) {
          return this.accessorFn(item);
        }
        if (this.accessorKey !== void 0) {
          return item[this.accessorKey];
        }
        return void 0;
      }
    };
    DisplayColumn = class extends FlatColumn {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      cell;
      data;
      constructor({ header, footer, plugins, id, cell, data }) {
        super({ header, footer, plugins, id });
        this.cell = cell;
        this.data = data;
      }
    };
    GroupColumn = class extends Column {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __group = true;
      columns;
      ids;
      constructor({ header, footer, columns, plugins }) {
        const height = Math.max(...columns.map((c2) => c2.height)) + 1;
        super({ header, footer, height, plugins });
        this.columns = columns;
        this.ids = getFlatColumnIds(columns);
      }
    };
    getFlatColumnIds = (columns) => columns.flatMap((c2) => c2.isFlat() ? [c2.id] : c2.isGroup() ? c2.ids : []);
    getFlatColumns = (columns) => {
      return columns.flatMap((c2) => c2.isFlat() ? [c2] : c2.isGroup() ? getFlatColumns(c2.columns) : []);
    };
    getCounter = (items) => {
      const result = /* @__PURE__ */ new Map();
      items.forEach((item) => {
        result.set(item, (result.get(item) ?? 0) + 1);
      });
      return result;
    };
    getDuplicates = (items) => {
      return Array.from(getCounter(items).entries()).filter(([, count]) => count !== 1).map(([key2]) => key2);
    };
    stringifyCss = (style) => {
      return Object.entries(style).map(([name2, value]) => `${name2}:${value}`).join(";");
    };
    mergeAttributes = (a2, b) => {
      if (a2.style === void 0 && b.style === void 0) {
        return { ...a2, ...b };
      }
      return {
        ...a2,
        ...b,
        style: {
          ...typeof a2.style === "object" ? a2.style : {},
          ...typeof b.style === "object" ? b.style : {}
        }
      };
    };
    finalizeAttributes = (attrs) => {
      if (attrs.style === void 0 || typeof attrs.style !== "object") {
        return attrs;
      }
      return {
        ...attrs,
        style: stringifyCss(attrs.style)
      };
    };
    TableComponent = class {
      id;
      constructor({ id }) {
        this.id = id;
      }
      attrsForName = {};
      attrs() {
        return derived(Object.values(this.attrsForName), ($attrsArray) => {
          let $mergedAttrs = {};
          $attrsArray.forEach(($attrs) => {
            $mergedAttrs = mergeAttributes($mergedAttrs, $attrs);
          });
          return finalizeAttributes($mergedAttrs);
        });
      }
      propsForName = {};
      props() {
        return derivedKeys(this.propsForName);
      }
      state;
      injectState(state) {
        this.state = state;
      }
      applyHook(pluginName, hook) {
        if (hook.props !== void 0) {
          this.propsForName[pluginName] = hook.props;
        }
        if (hook.attrs !== void 0) {
          this.attrsForName[pluginName] = hook.attrs;
        }
      }
    };
    BodyCell = class extends TableComponent {
      row;
      constructor({ id, row }) {
        super({ id });
        this.row = row;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "cell"
          };
        });
      }
      rowColId() {
        return `${this.row.id}:${this.column.id}`;
      }
      dataRowColId() {
        if (!this.row.isData()) {
          return void 0;
        }
        return `${this.row.dataId}:${this.column.id}`;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isDisplay() {
        return "__display" in this;
      }
    };
    DataBodyCell = class _DataBodyCell extends BodyCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      column;
      label;
      value;
      constructor({ row, column, label, value }) {
        super({ id: column.id, row });
        this.column = column;
        this.label = label;
        this.value = value;
      }
      render() {
        if (this.label === void 0) {
          return `${this.value}`;
        }
        if (this.state === void 0) {
          throw new Error("Missing `state` reference");
        }
        return this.label(this, this.state);
      }
      clone() {
        const clonedCell = new _DataBodyCell({
          row: this.row,
          column: this.column,
          label: this.label,
          value: this.value
        });
        return clonedCell;
      }
    };
    DisplayBodyCell = class _DisplayBodyCell extends BodyCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      column;
      label;
      constructor({ row, column, label }) {
        super({ id: column.id, row });
        this.column = column;
        this.label = label;
      }
      render() {
        if (this.state === void 0) {
          throw new Error("Missing `state` reference");
        }
        return this.label(this, this.state);
      }
      clone() {
        const clonedCell = new _DisplayBodyCell({
          row: this.row,
          column: this.column,
          label: this.label
        });
        return clonedCell;
      }
    };
    nonUndefined = (value) => value !== void 0;
    BodyRow = class extends TableComponent {
      cells;
      /**
       * Get the cell with a given column id.
       *
       * **This includes hidden cells.**
       */
      cellForId;
      depth;
      parentRow;
      subRows;
      constructor({ id, cells, cellForId, depth = 0, parentRow }) {
        super({ id });
        this.cells = cells;
        this.cellForId = cellForId;
        this.depth = depth;
        this.parentRow = parentRow;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "row"
          };
        });
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isDisplay() {
        return "__display" in this;
      }
    };
    DataBodyRow = class _DataBodyRow extends BodyRow {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      dataId;
      original;
      constructor({ id, dataId, original, cells, cellForId, depth = 0, parentRow }) {
        super({ id, cells, cellForId, depth, parentRow });
        this.dataId = dataId;
        this.original = original;
      }
      clone({ includeCells = false, includeSubRows = false } = {}) {
        const clonedRow = new _DataBodyRow({
          id: this.id,
          dataId: this.dataId,
          cellForId: this.cellForId,
          cells: this.cells,
          original: this.original,
          depth: this.depth
        });
        if (includeCells) {
          const clonedCellsForId = Object.fromEntries(Object.entries(clonedRow.cellForId).map(([id, cell]) => {
            const clonedCell = cell.clone();
            clonedCell.row = clonedRow;
            return [id, clonedCell];
          }));
          const clonedCells = clonedRow.cells.map(({ id }) => clonedCellsForId[id]);
          clonedRow.cellForId = clonedCellsForId;
          clonedRow.cells = clonedCells;
        }
        if (includeSubRows) {
          const clonedSubRows = this.subRows?.map((row) => row.clone({ includeCells, includeSubRows }));
          clonedRow.subRows = clonedSubRows;
        } else {
          clonedRow.subRows = this.subRows;
        }
        return clonedRow;
      }
    };
    getBodyRows = (data, flatColumns, { rowDataId } = {}) => {
      const rows = data.map((item, idx) => {
        const id = idx.toString();
        return new DataBodyRow({
          id,
          dataId: rowDataId !== void 0 ? rowDataId(item, idx) : id,
          original: item,
          cells: [],
          cellForId: {}
        });
      });
      data.forEach((item, rowIdx) => {
        const cells = flatColumns.map((col) => {
          if (col.isData()) {
            const dataCol = col;
            const value = dataCol.getValue(item);
            return new DataBodyCell({
              row: rows[rowIdx],
              column: dataCol,
              label: col.cell,
              value
            });
          }
          if (col.isDisplay()) {
            const displayCol = col;
            return new DisplayBodyCell({
              row: rows[rowIdx],
              column: displayCol,
              label: col.cell
            });
          }
          throw new Error("Unrecognized `FlatColumn` implementation");
        });
        rows[rowIdx].cells = cells;
        flatColumns.forEach((c2, colIdx) => {
          rows[rowIdx].cellForId[c2.id] = cells[colIdx];
        });
      });
      return rows;
    };
    getColumnedBodyRows = (rows, columnIdOrder) => {
      const columnedRows = rows.map((row) => {
        const clonedRow = row.clone();
        clonedRow.cells = [];
        clonedRow.cellForId = {};
        return clonedRow;
      });
      if (rows.length === 0 || columnIdOrder.length === 0)
        return rows;
      rows.forEach((row, rowIdx) => {
        const cells = row.cells.map((cell) => {
          const clonedCell = cell.clone();
          clonedCell.row = columnedRows[rowIdx];
          return clonedCell;
        });
        const visibleCells = columnIdOrder.map((cid) => {
          return cells.find((c2) => c2.id === cid);
        }).filter(nonUndefined);
        columnedRows[rowIdx].cells = visibleCells;
        cells.forEach((cell) => {
          columnedRows[rowIdx].cellForId[cell.id] = cell;
        });
      });
      return columnedRows;
    };
    NBSP = " ";
    HeaderCell = class extends TableComponent {
      label;
      colspan;
      colstart;
      constructor({ id, label, colspan, colstart }) {
        super({ id });
        this.label = label;
        this.colspan = colspan;
        this.colstart = colstart;
      }
      render() {
        if (this.label instanceof Function) {
          if (this.state === void 0) {
            throw new Error("Missing `state` reference");
          }
          return this.label(this, this.state);
        }
        return this.label;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "columnheader",
            colspan: this.colspan
          };
        });
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isFlat() {
        return "__flat" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isFlatDisplay() {
        return "__flat" in this && "__display" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isGroup() {
        return "__group" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isGroupDisplay() {
        return "__group" in this && "__display" in this;
      }
    };
    FlatHeaderCell = class _FlatHeaderCell extends HeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __flat = true;
      constructor({ id, label, colstart }) {
        super({ id, label, colspan: 1, colstart });
      }
      clone() {
        return new _FlatHeaderCell({
          id: this.id,
          label: this.label,
          colstart: this.colstart
        });
      }
    };
    DataHeaderCell = class _DataHeaderCell extends FlatHeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      accessorKey;
      accessorFn;
      constructor({ id, label, accessorKey, accessorFn, colstart }) {
        super({ id, label, colstart });
        this.accessorKey = accessorKey;
        this.accessorFn = accessorFn;
      }
      clone() {
        return new _DataHeaderCell({
          id: this.id,
          label: this.label,
          accessorFn: this.accessorFn,
          accessorKey: this.accessorKey,
          colstart: this.colstart
        });
      }
    };
    FlatDisplayHeaderCell = class _FlatDisplayHeaderCell extends FlatHeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      constructor({ id, label = NBSP, colstart }) {
        super({ id, label, colstart });
      }
      clone() {
        return new _FlatDisplayHeaderCell({
          id: this.id,
          label: this.label,
          colstart: this.colstart
        });
      }
    };
    GroupHeaderCell = class _GroupHeaderCell extends HeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __group = true;
      ids;
      allId;
      allIds;
      constructor({ label, ids, allIds, colspan, colstart }) {
        super({ id: `[${ids.join(",")}]`, label, colspan, colstart });
        this.ids = ids;
        this.allId = `[${allIds.join(",")}]`;
        this.allIds = allIds;
      }
      setIds(ids) {
        this.ids = ids;
        this.id = `[${this.ids.join(",")}]`;
      }
      pushId(id) {
        this.ids = [...this.ids, id];
        this.id = `[${this.ids.join(",")}]`;
      }
      clone() {
        return new _GroupHeaderCell({
          label: this.label,
          ids: this.ids,
          allIds: this.allIds,
          colspan: this.colspan,
          colstart: this.colstart
        });
      }
    };
    GroupDisplayHeaderCell = class _GroupDisplayHeaderCell extends GroupHeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      constructor({ label = NBSP, ids, allIds, colspan = 1, colstart }) {
        super({ label, ids, allIds, colspan, colstart });
      }
      clone() {
        return new _GroupDisplayHeaderCell({
          label: this.label,
          ids: this.ids,
          allIds: this.allIds,
          colspan: this.colspan,
          colstart: this.colstart
        });
      }
    };
    sum = (nums) => nums.reduce((a2, b) => a2 + b, 0);
    getNullMatrix = (width, height) => {
      const result = [];
      for (let i2 = 0; i2 < height; i2++) {
        result.push(Array(width).fill(null));
      }
      return result;
    };
    getTransposed = (matrix) => {
      const height = matrix.length;
      if (height === 0) {
        return matrix;
      }
      const width = matrix[0].length;
      const result = getNullMatrix(height, width);
      for (let i2 = 0; i2 < width; i2++) {
        for (let j2 = 0; j2 < height; j2++) {
          result[i2][j2] = matrix[j2][i2];
        }
      }
      return result;
    };
    HeaderRow = class _HeaderRow extends TableComponent {
      cells;
      constructor({ id, cells }) {
        super({ id });
        this.cells = cells;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "row"
          };
        });
      }
      clone() {
        return new _HeaderRow({
          id: this.id,
          cells: this.cells
        });
      }
    };
    getHeaderRows = (columns, flatColumnIds = []) => {
      const rowMatrix = getHeaderRowMatrix(columns);
      let columnMatrix = getTransposed(rowMatrix);
      columnMatrix = getOrderedColumnMatrix(columnMatrix, flatColumnIds);
      populateGroupHeaderCellIds(columnMatrix);
      return headerRowsForRowMatrix(getTransposed(columnMatrix));
    };
    getHeaderRowMatrix = (columns) => {
      const maxColspan = sum(columns.map((c2) => c2.isGroup() ? c2.ids.length : 1));
      const maxHeight = Math.max(...columns.map((c2) => c2.height));
      const rowMatrix = getNullMatrix(maxColspan, maxHeight);
      let cellOffset = 0;
      columns.forEach((c2) => {
        const heightOffset = maxHeight - c2.height;
        loadHeaderRowMatrix(rowMatrix, c2, heightOffset, cellOffset);
        cellOffset += c2.isGroup() ? c2.ids.length : 1;
      });
      return rowMatrix.map((cells, rowIdx) => cells.map((cell, columnIdx) => {
        if (cell !== null)
          return cell;
        if (rowIdx === maxHeight - 1)
          return new FlatDisplayHeaderCell({ id: columnIdx.toString(), colstart: columnIdx });
        const flatId = rowMatrix[maxHeight - 1][columnIdx]?.id ?? columnIdx.toString();
        return new GroupDisplayHeaderCell({ ids: [], allIds: [flatId], colstart: columnIdx });
      }));
    };
    loadHeaderRowMatrix = (rowMatrix, column, rowOffset, cellOffset) => {
      if (column.isData()) {
        rowMatrix[rowMatrix.length - 1][cellOffset] = new DataHeaderCell({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          label: column.header,
          accessorFn: column.accessorFn,
          accessorKey: column.accessorKey,
          id: column.id,
          colstart: cellOffset
        });
        return;
      }
      if (column.isDisplay()) {
        rowMatrix[rowMatrix.length - 1][cellOffset] = new FlatDisplayHeaderCell({
          id: column.id,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          label: column.header,
          colstart: cellOffset
        });
        return;
      }
      if (column.isGroup()) {
        for (let i2 = 0; i2 < column.ids.length; i2++) {
          rowMatrix[rowOffset][cellOffset + i2] = new GroupHeaderCell({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            label: column.header,
            colspan: 1,
            allIds: column.ids,
            ids: [],
            colstart: cellOffset
          });
        }
        let childCellOffset = 0;
        column.columns.forEach((c2) => {
          loadHeaderRowMatrix(rowMatrix, c2, rowOffset + 1, cellOffset + childCellOffset);
          childCellOffset += c2.isGroup() ? c2.ids.length : 1;
        });
        return;
      }
    };
    getOrderedColumnMatrix = (columnMatrix, flatColumnIds) => {
      if (flatColumnIds.length === 0) {
        return columnMatrix;
      }
      const orderedColumnMatrix = [];
      flatColumnIds.forEach((key2, columnIdx) => {
        const nextColumn = columnMatrix.find((columnCells) => {
          const flatCell = columnCells[columnCells.length - 1];
          if (!flatCell.isFlat()) {
            throw new Error("The last element of each column must be a `FlatHeaderCell`");
          }
          return flatCell.id === key2;
        });
        if (nextColumn !== void 0) {
          orderedColumnMatrix.push(nextColumn.map((column) => {
            const clonedColumn = column.clone();
            clonedColumn.colstart = columnIdx;
            return clonedColumn;
          }));
        }
      });
      return orderedColumnMatrix;
    };
    populateGroupHeaderCellIds = (columnMatrix) => {
      columnMatrix.forEach((columnCells) => {
        const lastCell = columnCells[columnCells.length - 1];
        if (!lastCell.isFlat()) {
          throw new Error("The last element of each column must be a `FlatHeaderCell`");
        }
        columnCells.forEach((c2) => {
          if (c2.isGroup()) {
            c2.pushId(lastCell.id);
          }
        });
      });
    };
    headerRowsForRowMatrix = (rowMatrix) => {
      return rowMatrix.map((rowCells, rowIdx) => {
        return new HeaderRow({ id: rowIdx.toString(), cells: getMergedRow(rowCells) });
      });
    };
    getMergedRow = (cells) => {
      if (cells.length === 0) {
        return cells;
      }
      const mergedCells = [];
      let startIdx = 0;
      let endIdx = 1;
      while (startIdx < cells.length) {
        const cell = cells[startIdx].clone();
        if (!cell.isGroup()) {
          mergedCells.push(cell);
          startIdx++;
          continue;
        }
        endIdx = startIdx + 1;
        const ids = [...cell.ids];
        while (endIdx < cells.length) {
          const nextCell = cells[endIdx];
          if (!nextCell.isGroup()) {
            break;
          }
          if (cell.allId !== nextCell.allId) {
            break;
          }
          ids.push(...nextCell.ids);
          endIdx++;
        }
        cell.setIds(ids);
        cell.colspan = endIdx - startIdx;
        mergedCells.push(cell);
        startIdx = endIdx;
      }
      return mergedCells;
    };
    createViewModel = (table, columns, { rowDataId } = {}) => {
      const { data, plugins } = table;
      const $flatColumns = getFlatColumns(columns);
      const flatColumns = readable($flatColumns);
      const originalRows = derived([data, flatColumns], ([$data, $flatColumns2]) => {
        return getBodyRows($data, $flatColumns2, { rowDataId });
      });
      const _visibleColumns = writable([]);
      const _headerRows = writable();
      const _rows = writable([]);
      const _pageRows = writable([]);
      const _tableAttrs = writable({
        role: "table"
      });
      const _tableHeadAttrs = writable({});
      const _tableBodyAttrs = writable({
        role: "rowgroup"
      });
      const pluginInitTableState = {
        data,
        columns,
        flatColumns: $flatColumns,
        tableAttrs: _tableAttrs,
        tableHeadAttrs: _tableHeadAttrs,
        tableBodyAttrs: _tableBodyAttrs,
        visibleColumns: _visibleColumns,
        headerRows: _headerRows,
        originalRows,
        rows: _rows,
        pageRows: _pageRows
      };
      const pluginInstances = Object.fromEntries(Object.entries(plugins).map(([pluginName, plugin]) => {
        const columnOptions = Object.fromEntries($flatColumns.map((c2) => {
          const option = c2.plugins?.[pluginName];
          if (option === void 0)
            return void 0;
          return [c2.id, option];
        }).filter(nonUndefined));
        return [
          pluginName,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          plugin({ pluginName, tableState: pluginInitTableState, columnOptions })
        ];
      }));
      const pluginStates = Object.fromEntries(Object.entries(pluginInstances).map(([key2, pluginInstance]) => [
        key2,
        pluginInstance.pluginState
      ]));
      const tableState = {
        data,
        columns,
        flatColumns: $flatColumns,
        tableAttrs: _tableAttrs,
        tableHeadAttrs: _tableHeadAttrs,
        tableBodyAttrs: _tableBodyAttrs,
        visibleColumns: _visibleColumns,
        headerRows: _headerRows,
        originalRows,
        rows: _rows,
        pageRows: _pageRows,
        pluginStates
      };
      const deriveTableAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableAttrs).filter(nonUndefined);
      let tableAttrs = readable({
        role: "table"
      });
      deriveTableAttrsFns.forEach((fn) => {
        tableAttrs = fn(tableAttrs);
      });
      const finalizedTableAttrs = derived(tableAttrs, ($tableAttrs) => {
        const $finalizedAttrs = finalizeAttributes($tableAttrs);
        _tableAttrs.set($finalizedAttrs);
        return $finalizedAttrs;
      });
      const deriveTableHeadAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
      let tableHeadAttrs = readable({});
      deriveTableHeadAttrsFns.forEach((fn) => {
        tableHeadAttrs = fn(tableHeadAttrs);
      });
      const finalizedTableHeadAttrs = derived(tableHeadAttrs, ($tableHeadAttrs) => {
        const $finalizedAttrs = finalizeAttributes($tableHeadAttrs);
        _tableHeadAttrs.set($finalizedAttrs);
        return $finalizedAttrs;
      });
      const deriveTableBodyAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
      let tableBodyAttrs = readable({
        role: "rowgroup"
      });
      deriveTableBodyAttrsFns.forEach((fn) => {
        tableBodyAttrs = fn(tableBodyAttrs);
      });
      const finalizedTableBodyAttrs = derived(tableBodyAttrs, ($tableBodyAttrs) => {
        const $finalizedAttrs = finalizeAttributes($tableBodyAttrs);
        _tableBodyAttrs.set($finalizedAttrs);
        return $finalizedAttrs;
      });
      const deriveFlatColumnsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveFlatColumns).filter(nonUndefined);
      let visibleColumns = flatColumns;
      deriveFlatColumnsFns.forEach((fn) => {
        visibleColumns = fn(visibleColumns);
      });
      const injectedColumns = derived(visibleColumns, ($visibleColumns) => {
        _visibleColumns.set($visibleColumns);
        return $visibleColumns;
      });
      const columnedRows = derived([originalRows, injectedColumns], ([$originalRows, $injectedColumns]) => {
        return getColumnedBodyRows($originalRows, $injectedColumns.map((c2) => c2.id));
      });
      const deriveRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveRows).filter(nonUndefined);
      let rows = columnedRows;
      deriveRowsFns.forEach((fn) => {
        rows = fn(rows);
      });
      const injectedRows = derived(rows, ($rows) => {
        $rows.forEach((row) => {
          row.injectState(tableState);
          row.cells.forEach((cell) => {
            cell.injectState(tableState);
          });
        });
        Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
          $rows.forEach((row) => {
            if (pluginInstance.hooks?.["tbody.tr"] !== void 0) {
              row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
            }
            row.cells.forEach((cell) => {
              if (pluginInstance.hooks?.["tbody.tr.td"] !== void 0) {
                cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
              }
            });
          });
        });
        _rows.set($rows);
        return $rows;
      });
      const derivePageRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.derivePageRows).filter(nonUndefined);
      let pageRows = injectedRows;
      derivePageRowsFns.forEach((fn) => {
        pageRows = fn(pageRows);
      });
      const injectedPageRows = derived(pageRows, ($pageRows) => {
        $pageRows.forEach((row) => {
          row.injectState(tableState);
          row.cells.forEach((cell) => {
            cell.injectState(tableState);
          });
        });
        Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
          $pageRows.forEach((row) => {
            if (pluginInstance.hooks?.["tbody.tr"] !== void 0) {
              row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
            }
            row.cells.forEach((cell) => {
              if (pluginInstance.hooks?.["tbody.tr.td"] !== void 0) {
                cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
              }
            });
          });
        });
        _pageRows.set($pageRows);
        return $pageRows;
      });
      const headerRows = derived(injectedColumns, ($injectedColumns) => {
        const $headerRows = getHeaderRows(columns, $injectedColumns.map((c2) => c2.id));
        $headerRows.forEach((row) => {
          row.injectState(tableState);
          row.cells.forEach((cell) => {
            cell.injectState(tableState);
          });
        });
        Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
          $headerRows.forEach((row) => {
            if (pluginInstance.hooks?.["thead.tr"] !== void 0) {
              row.applyHook(pluginName, pluginInstance.hooks["thead.tr"](row));
            }
            row.cells.forEach((cell) => {
              if (pluginInstance.hooks?.["thead.tr.th"] !== void 0) {
                cell.applyHook(pluginName, pluginInstance.hooks["thead.tr.th"](cell));
              }
            });
          });
        });
        _headerRows.set($headerRows);
        return $headerRows;
      });
      return {
        tableAttrs: finalizedTableAttrs,
        tableHeadAttrs: finalizedTableHeadAttrs,
        tableBodyAttrs: finalizedTableBodyAttrs,
        visibleColumns: injectedColumns,
        flatColumns: $flatColumns,
        headerRows,
        originalRows,
        rows: injectedRows,
        pageRows: injectedPageRows,
        pluginStates
      };
    };
    Table$1 = class Table {
      data;
      plugins;
      constructor(data, plugins) {
        this.data = data;
        this.plugins = plugins;
      }
      createColumns(columns) {
        const ids = getFlatColumnIds(columns);
        const duplicateIds = getDuplicates(ids);
        if (duplicateIds.length !== 0) {
          throw new Error(`Duplicate column ids not allowed: "${duplicateIds.join('", "')}"`);
        }
        return columns;
      }
      column(def) {
        return new DataColumn(def);
      }
      group(def) {
        return new GroupColumn(def);
      }
      display(def) {
        return new DisplayColumn(def);
      }
      createViewModel(columns, options2) {
        return createViewModel(this, columns, options2);
      }
    };
    createTable = (data, plugins = {}) => {
      return new Table$1(data, plugins);
    };
    textPrefixFilter = ({ filterValue, value }) => {
      if (filterValue === "") {
        return true;
      }
      return String(value).toLowerCase().startsWith(String(filterValue).toLowerCase());
    };
    readable(void 0);
    recordSetStore = (initial2 = {}) => {
      const withFalseRemoved = (record) => {
        return Object.fromEntries(Object.entries(record).filter(([, v2]) => v2));
      };
      const { subscribe, update, set: set2 } = writable(withFalseRemoved(initial2));
      const updateAndRemoveFalse = (fn) => {
        update(($recordSet) => {
          const newRecordSet = fn($recordSet);
          return withFalseRemoved(newRecordSet);
        });
      };
      const toggle2 = (item) => {
        update(($recordSet) => {
          if ($recordSet[item] === true) {
            delete $recordSet[item];
            return $recordSet;
          }
          return {
            ...$recordSet,
            [item]: true
          };
        });
      };
      const add = (item) => {
        update(($recordSet) => ({
          ...$recordSet,
          [item]: true
        }));
      };
      const addAll = (items) => {
        update(($recordSet) => ({
          ...$recordSet,
          ...Object.fromEntries(items.map((item) => [item, true]))
        }));
      };
      const remove2 = (item) => {
        update(($recordSet) => {
          delete $recordSet[item];
          return $recordSet;
        });
      };
      const removeAll = (items) => {
        update(($recordSet) => {
          for (const item of items) {
            delete $recordSet[item];
          }
          return $recordSet;
        });
      };
      const clear2 = () => {
        set2({});
      };
      return {
        subscribe,
        update: updateAndRemoveFalse,
        set: (newValue) => updateAndRemoveFalse(() => newValue),
        toggle: toggle2,
        add,
        addAll,
        remove: remove2,
        removeAll,
        clear: clear2
      };
    };
    isShiftClick = (event) => {
      if (!(event instanceof MouseEvent))
        return false;
      return event.shiftKey;
    };
    MIN_PAGE_SIZE = 1;
    createPageStore = ({ items, initialPageSize, initialPageIndex, serverSide, serverItemCount }) => {
      const pageSize = writable(initialPageSize);
      const updatePageSize = (fn) => {
        pageSize.update(($pageSize) => {
          const newPageSize = fn($pageSize);
          return Math.max(newPageSize, MIN_PAGE_SIZE);
        });
      };
      const setPageSize = (newPageSize) => updatePageSize(() => newPageSize);
      const pageIndex = writable(initialPageIndex);
      function calcPageCountAndLimitIndex([$pageSize, $itemCount]) {
        const $pageCount = Math.ceil($itemCount / $pageSize);
        pageIndex.update(($pageIndex) => {
          if ($pageCount > 0 && $pageIndex >= $pageCount) {
            return $pageCount - 1;
          }
          return $pageIndex;
        });
        return $pageCount;
      }
      let pageCount;
      if (serverSide && serverItemCount != null) {
        pageCount = derived([pageSize, serverItemCount], calcPageCountAndLimitIndex);
      } else {
        const itemCount = derived(items, ($items) => $items.length);
        pageCount = derived([pageSize, itemCount], calcPageCountAndLimitIndex);
      }
      const hasPreviousPage = derived(pageIndex, ($pageIndex) => {
        return $pageIndex > 0;
      });
      const hasNextPage = derived([pageIndex, pageCount], ([$pageIndex, $pageCount]) => {
        return $pageIndex < $pageCount - 1;
      });
      return {
        pageSize: {
          subscribe: pageSize.subscribe,
          update: updatePageSize,
          set: setPageSize
        },
        pageIndex,
        pageCount,
        serverItemCount,
        hasPreviousPage,
        hasNextPage
      };
    };
    addPagination = ({ initialPageIndex = 0, initialPageSize = 10, serverSide = false, serverItemCount } = {}) => () => {
      const prePaginatedRows = writable([]);
      const paginatedRows = writable([]);
      const { pageSize, pageIndex, pageCount, hasPreviousPage, hasNextPage } = createPageStore({
        items: prePaginatedRows,
        initialPageIndex,
        initialPageSize,
        serverSide,
        serverItemCount
      });
      const pluginState = {
        pageSize,
        pageIndex,
        pageCount,
        hasPreviousPage,
        hasNextPage
      };
      const derivePageRows = (rows) => {
        return derived([rows, pageSize, pageIndex], ([$rows, $pageSize, $pageIndex]) => {
          prePaginatedRows.set($rows);
          if (serverSide) {
            paginatedRows.set($rows);
            return $rows;
          }
          const startIdx = $pageIndex * $pageSize;
          const _paginatedRows = $rows.slice(startIdx, startIdx + $pageSize);
          paginatedRows.set(_paginatedRows);
          return _paginatedRows;
        });
      };
      return {
        pluginState,
        derivePageRows
      };
    };
    compare = (a2, b) => {
      if (Array.isArray(a2) && Array.isArray(b)) {
        return compareArray(a2, b);
      }
      if (typeof a2 === "number" && typeof b === "number")
        return a2 - b;
      return a2 < b ? -1 : a2 > b ? 1 : 0;
    };
    compareArray = (a2, b) => {
      const minLength = Math.min(a2.length, b.length);
      for (let i2 = 0; i2 < minLength; i2++) {
        const order = compare(a2[i2], b[i2]);
        if (order !== 0)
          return order;
      }
      return 0;
    };
    DEFAULT_TOGGLE_ORDER = ["asc", "desc", void 0];
    createSortKeysStore = (initKeys) => {
      const { subscribe, update, set: set2 } = writable(initKeys);
      const toggleId = (id, { multiSort = true, toggleOrder = DEFAULT_TOGGLE_ORDER } = {}) => {
        update(($sortKeys) => {
          const keyIdx = $sortKeys.findIndex((key22) => key22.id === id);
          const key2 = $sortKeys[keyIdx];
          const order = key2?.order;
          const orderIdx = toggleOrder.findIndex((o2) => o2 === order);
          const nextOrderIdx = (orderIdx + 1) % toggleOrder.length;
          const nextOrder = toggleOrder[nextOrderIdx];
          if (!multiSort) {
            if (nextOrder === void 0) {
              return [];
            }
            return [{ id, order: nextOrder }];
          }
          if (keyIdx === -1 && nextOrder !== void 0) {
            return [...$sortKeys, { id, order: nextOrder }];
          }
          if (nextOrder === void 0) {
            return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
          }
          return [
            ...$sortKeys.slice(0, keyIdx),
            { id, order: nextOrder },
            ...$sortKeys.slice(keyIdx + 1)
          ];
        });
      };
      const clearId = (id) => {
        update(($sortKeys) => {
          const keyIdx = $sortKeys.findIndex((key2) => key2.id === id);
          if (keyIdx === -1) {
            return $sortKeys;
          }
          return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
        });
      };
      return {
        subscribe,
        update,
        set: set2,
        toggleId,
        clearId
      };
    };
    getSortedRows = (rows, sortKeys, columnOptions) => {
      const $sortedRows = [...rows];
      $sortedRows.sort((a2, b) => {
        for (const key2 of sortKeys) {
          const invert = columnOptions[key2.id]?.invert ?? false;
          const cellA = a2.cellForId[key2.id];
          const cellB = b.cellForId[key2.id];
          let order = 0;
          const compareFn = columnOptions[key2.id]?.compareFn;
          const getSortValue = columnOptions[key2.id]?.getSortValue;
          if (!cellA.isData()) {
            return 0;
          }
          const valueA = cellA.value;
          const valueB = cellB.value;
          if (compareFn !== void 0) {
            order = compareFn(valueA, valueB);
          } else if (getSortValue !== void 0) {
            const sortValueA = getSortValue(valueA);
            const sortValueB = getSortValue(valueB);
            order = compare(sortValueA, sortValueB);
          } else if (typeof valueA === "string" || typeof valueA === "number") {
            order = compare(valueA, valueB);
          } else if (valueA instanceof Date || valueB instanceof Date) {
            const sortValueA = valueA instanceof Date ? valueA.getTime() : 0;
            const sortValueB = valueB instanceof Date ? valueB.getTime() : 0;
            order = compare(sortValueA, sortValueB);
          }
          if (order !== 0) {
            let orderFactor = 1;
            if (key2.order === "desc") {
              orderFactor *= -1;
            }
            if (invert) {
              orderFactor *= -1;
            }
            return order * orderFactor;
          }
        }
        return 0;
      });
      for (let i2 = 0; i2 < $sortedRows.length; i2++) {
        const { subRows } = $sortedRows[i2];
        if (subRows === void 0) {
          continue;
        }
        const sortedSubRows = getSortedRows(subRows, sortKeys, columnOptions);
        const clonedRow = $sortedRows[i2].clone();
        clonedRow.subRows = sortedSubRows;
        $sortedRows[i2] = clonedRow;
      }
      return $sortedRows;
    };
    addSortBy = ({ initialSortKeys = [], disableMultiSort = false, isMultiSortEvent = isShiftClick, toggleOrder, serverSide = false } = {}) => ({ columnOptions }) => {
      const disabledSortIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
      const sortKeys = createSortKeysStore(initialSortKeys);
      const preSortedRows = writable([]);
      const deriveRows = (rows) => {
        return derived([rows, sortKeys], ([$rows, $sortKeys]) => {
          preSortedRows.set($rows);
          if (serverSide) {
            return $rows;
          }
          return getSortedRows($rows, $sortKeys, columnOptions);
        });
      };
      const pluginState = { sortKeys, preSortedRows };
      return {
        pluginState,
        deriveRows,
        hooks: {
          "thead.tr.th": (cell) => {
            const disabled = disabledSortIds.includes(cell.id);
            const props = derived(sortKeys, ($sortKeys) => {
              const key2 = $sortKeys.find((k) => k.id === cell.id);
              const toggle2 = (event) => {
                if (!cell.isData())
                  return;
                if (disabled)
                  return;
                sortKeys.toggleId(cell.id, {
                  multiSort: disableMultiSort ? false : isMultiSortEvent(event),
                  toggleOrder
                });
              };
              const clear2 = () => {
                if (!cell.isData())
                  return;
                if (disabledSortIds.includes(cell.id))
                  return;
                sortKeys.clearId(cell.id);
              };
              return {
                order: key2?.order,
                toggle: toggle2,
                clear: clear2,
                disabled
              };
            });
            return { props };
          },
          "tbody.tr.td": (cell) => {
            const props = derived(sortKeys, ($sortKeys) => {
              const key2 = $sortKeys.find((k) => k.id === cell.id);
              return {
                order: key2?.order
              };
            });
            return { props };
          }
        }
      };
    };
    getFilteredRows = (rows, filterValue, columnOptions, { tableCellMatches, fn, includeHiddenColumns }) => {
      const $filteredRows = rows.map((row) => {
        const { subRows } = row;
        if (subRows === void 0) {
          return row;
        }
        const filteredSubRows = getFilteredRows(subRows, filterValue, columnOptions, {
          tableCellMatches,
          fn,
          includeHiddenColumns
        });
        const clonedRow = row.clone();
        clonedRow.subRows = filteredSubRows;
        return clonedRow;
      }).filter((row) => {
        if ((row.subRows?.length ?? 0) !== 0) {
          return true;
        }
        const rowCellMatches = Object.values(row.cellForId).map((cell) => {
          const options2 = columnOptions[cell.id];
          if (options2?.exclude === true) {
            return false;
          }
          const isHidden3 = row.cells.find((c2) => c2.id === cell.id) === void 0;
          if (isHidden3 && !includeHiddenColumns) {
            return false;
          }
          if (!cell.isData()) {
            return false;
          }
          let value = cell.value;
          if (options2?.getFilterValue !== void 0) {
            value = options2?.getFilterValue(value);
          }
          const matches2 = fn({ value: String(value), filterValue });
          if (matches2) {
            const dataRowColId = cell.dataRowColId();
            if (dataRowColId !== void 0) {
              tableCellMatches[dataRowColId] = matches2;
            }
          }
          return matches2;
        });
        return rowCellMatches.includes(true);
      });
      return $filteredRows;
    };
    addTableFilter = ({ fn = textPrefixFilter, initialFilterValue = "", includeHiddenColumns = false, serverSide = false } = {}) => ({ columnOptions }) => {
      const filterValue = writable(initialFilterValue);
      const preFilteredRows = writable([]);
      const tableCellMatches = recordSetStore();
      const pluginState = { filterValue, preFilteredRows };
      const deriveRows = (rows) => {
        return derived([rows, filterValue], ([$rows, $filterValue]) => {
          preFilteredRows.set($rows);
          tableCellMatches.clear();
          const $tableCellMatches = {};
          const $filteredRows = getFilteredRows($rows, $filterValue, columnOptions, {
            tableCellMatches: $tableCellMatches,
            fn,
            includeHiddenColumns
          });
          tableCellMatches.set($tableCellMatches);
          if (serverSide) {
            return $rows;
          }
          return $filteredRows;
        });
      };
      return {
        pluginState,
        deriveRows,
        hooks: {
          "tbody.tr.td": (cell) => {
            const props = derived([filterValue, tableCellMatches], ([$filterValue, $tableCellMatches]) => {
              const dataRowColId = cell.dataRowColId();
              return {
                matches: $filterValue !== "" && dataRowColId !== void 0 && ($tableCellMatches[dataRowColId] ?? false)
              };
            });
            return { props };
          }
        }
      };
    };
  }
});

// .svelte-kit/output/server/chunks/queryOptions.js
function shouldLoadOnMount(query, options2) {
  return options2.enabled !== false && query.state.data === void 0 && !(query.state.status === "error" && options2.retryOnMount === false);
}
function shouldFetchOnMount(query, options2) {
  return shouldLoadOnMount(query, options2) || query.state.data !== void 0 && shouldFetchOn(query, options2, options2.refetchOnMount);
}
function shouldFetchOn(query, options2, field) {
  if (options2.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options2);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options2, prevOptions) {
  return (query !== prevQuery || prevOptions.enabled === false) && (!options2.suspense || query.state.status !== "error") && isStale(query, options2);
}
function isStale(query, options2) {
  return options2.enabled !== false && query.isStaleByTime(options2.staleTime);
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
function useIsRestoring() {
  return getIsRestoringContext();
}
function useQueryClient(queryClient) {
  if (queryClient)
    return queryClient;
  return getQueryClientContext();
}
function isSvelteStore(obj) {
  return "subscribe" in obj && typeof obj.subscribe === "function";
}
function createBaseQuery(options2, Observer, queryClient) {
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const optionsStore = isSvelteStore(options2) ? options2 : readable(options2);
  const defaultedOptionsStore = derived([optionsStore, isRestoring], ([$optionsStore, $isRestoring]) => {
    const defaultedOptions = client.defaultQueryOptions($optionsStore);
    defaultedOptions._optimisticResults = $isRestoring ? "isRestoring" : "optimistic";
    return defaultedOptions;
  });
  const observer = new Observer(client, get_store_value(defaultedOptionsStore));
  defaultedOptionsStore.subscribe(($defaultedOptions) => {
    observer.setOptions($defaultedOptions, { listeners: false });
  });
  const result = derived(isRestoring, ($isRestoring, set2) => {
    const unsubscribe = $isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(set2));
    observer.updateResult();
    return unsubscribe;
  });
  const { subscribe } = derived([result, defaultedOptionsStore], ([$result, $defaultedOptionsStore]) => {
    $result = observer.getOptimisticResult($defaultedOptionsStore);
    return !$defaultedOptionsStore.notifyOnChangeProps ? observer.trackResult($result) : $result;
  });
  return { subscribe };
}
function createQuery(options2, queryClient) {
  return createBaseQuery(options2, QueryObserver, queryClient);
}
function queryOptions(options2) {
  return options2;
}
var QueryObserver;
var init_queryOptions = __esm({
  ".svelte-kit/output/server/chunks/queryOptions.js"() {
    init_query();
    init_index2();
    init_context();
    QueryObserver = class extends Subscribable {
      constructor(client, options2) {
        super();
        this.options = options2;
        this.#client = client;
        this.#selectError = null;
        this.bindMethods();
        this.setOptions(options2);
      }
      #client;
      #currentQuery = void 0;
      #currentQueryInitialState = void 0;
      #currentResult = void 0;
      #currentResultState;
      #currentResultOptions;
      #selectError;
      #selectFn;
      #selectResult;
      // This property keeps track of the last query with defined data.
      // It will be used to pass the previous data and query to the placeholder function between renders.
      #lastQueryWithDefinedData;
      #staleTimeoutId;
      #refetchIntervalId;
      #currentRefetchInterval;
      #trackedProps = /* @__PURE__ */ new Set();
      bindMethods() {
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.#currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.#currentQuery, this.options)) {
            this.#executeFetch();
          } else {
            this.updateResult();
          }
          this.#updateTimers();
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.destroy();
        }
      }
      shouldFetchOnReconnect() {
        return shouldFetchOn(
          this.#currentQuery,
          this.options,
          this.options.refetchOnReconnect
        );
      }
      shouldFetchOnWindowFocus() {
        return shouldFetchOn(
          this.#currentQuery,
          this.options,
          this.options.refetchOnWindowFocus
        );
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.#clearStaleTimeout();
        this.#clearRefetchInterval();
        this.#currentQuery.removeObserver(this);
      }
      setOptions(options2, notifyOptions) {
        const prevOptions = this.options;
        const prevQuery = this.#currentQuery;
        this.options = this.#client.defaultQueryOptions(options2);
        if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean") {
          throw new Error("Expected enabled to be a boolean");
        }
        this.#updateQuery();
        this.#currentQuery.setOptions(this.options);
        if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
          this.#client.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.#currentQuery,
            observer: this
          });
        }
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(
          this.#currentQuery,
          prevQuery,
          this.options,
          prevOptions
        )) {
          this.#executeFetch();
        }
        this.updateResult(notifyOptions);
        if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
          this.#updateStaleTimeout();
        }
        const nextRefetchInterval = this.#computeRefetchInterval();
        if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.#currentRefetchInterval)) {
          this.#updateRefetchInterval(nextRefetchInterval);
        }
      }
      getOptimisticResult(options2) {
        const query = this.#client.getQueryCache().build(this.#client, options2);
        const result = this.createResult(query, options2);
        if (shouldAssignObserverCurrentProperties(this, result)) {
          this.#currentResult = result;
          this.#currentResultOptions = this.options;
          this.#currentResultState = this.#currentQuery.state;
        }
        return result;
      }
      getCurrentResult() {
        return this.#currentResult;
      }
      trackResult(result, onPropTracked) {
        const trackedResult = {};
        Object.keys(result).forEach((key2) => {
          Object.defineProperty(trackedResult, key2, {
            configurable: false,
            enumerable: true,
            get: () => {
              this.trackProp(key2);
              onPropTracked?.(key2);
              return result[key2];
            }
          });
        });
        return trackedResult;
      }
      trackProp(key2) {
        this.#trackedProps.add(key2);
      }
      getCurrentQuery() {
        return this.#currentQuery;
      }
      refetch({ ...options2 } = {}) {
        return this.fetch({
          ...options2
        });
      }
      fetchOptimistic(options2) {
        const defaultedOptions = this.#client.defaultQueryOptions(options2);
        const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
        query.isFetchingOptimistic = true;
        return query.fetch().then(() => this.createResult(query, defaultedOptions));
      }
      fetch(fetchOptions) {
        return this.#executeFetch({
          ...fetchOptions,
          cancelRefetch: fetchOptions.cancelRefetch ?? true
        }).then(() => {
          this.updateResult();
          return this.#currentResult;
        });
      }
      #executeFetch(fetchOptions) {
        this.#updateQuery();
        let promise = this.#currentQuery.fetch(
          this.options,
          fetchOptions
        );
        if (!fetchOptions?.throwOnError) {
          promise = promise.catch(noop2);
        }
        return promise;
      }
      #updateStaleTimeout() {
        this.#clearStaleTimeout();
        if (isServer || this.#currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
          return;
        }
        const time = timeUntilStale(
          this.#currentResult.dataUpdatedAt,
          this.options.staleTime
        );
        const timeout = time + 1;
        this.#staleTimeoutId = setTimeout(() => {
          if (!this.#currentResult.isStale) {
            this.updateResult();
          }
        }, timeout);
      }
      #computeRefetchInterval() {
        return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
      }
      #updateRefetchInterval(nextInterval) {
        this.#clearRefetchInterval();
        this.#currentRefetchInterval = nextInterval;
        if (isServer || this.options.enabled === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
          return;
        }
        this.#refetchIntervalId = setInterval(() => {
          if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
            this.#executeFetch();
          }
        }, this.#currentRefetchInterval);
      }
      #updateTimers() {
        this.#updateStaleTimeout();
        this.#updateRefetchInterval(this.#computeRefetchInterval());
      }
      #clearStaleTimeout() {
        if (this.#staleTimeoutId) {
          clearTimeout(this.#staleTimeoutId);
          this.#staleTimeoutId = void 0;
        }
      }
      #clearRefetchInterval() {
        if (this.#refetchIntervalId) {
          clearInterval(this.#refetchIntervalId);
          this.#refetchIntervalId = void 0;
        }
      }
      createResult(query, options2) {
        const prevQuery = this.#currentQuery;
        const prevOptions = this.options;
        const prevResult = this.#currentResult;
        const prevResultState = this.#currentResultState;
        const prevResultOptions = this.#currentResultOptions;
        const queryChange = query !== prevQuery;
        const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
        const { state } = query;
        let newState = { ...state };
        let isPlaceholderData = false;
        let data;
        if (options2._optimisticResults) {
          const mounted = this.hasListeners();
          const fetchOnMount = !mounted && shouldFetchOnMount(query, options2);
          const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options2, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            newState = {
              ...newState,
              ...fetchState(state.data, query.options)
            };
          }
          if (options2._optimisticResults === "isRestoring") {
            newState.fetchStatus = "idle";
          }
        }
        let { error: error2, errorUpdatedAt, status } = newState;
        if (options2.select && newState.data !== void 0) {
          if (prevResult && newState.data === prevResultState?.data && options2.select === this.#selectFn) {
            data = this.#selectResult;
          } else {
            try {
              this.#selectFn = options2.select;
              data = options2.select(newState.data);
              data = replaceData(prevResult?.data, data, options2);
              this.#selectResult = data;
              this.#selectError = null;
            } catch (selectError) {
              this.#selectError = selectError;
            }
          }
        } else {
          data = newState.data;
        }
        if (options2.placeholderData !== void 0 && data === void 0 && status === "pending") {
          let placeholderData;
          if (prevResult?.isPlaceholderData && options2.placeholderData === prevResultOptions?.placeholderData) {
            placeholderData = prevResult.data;
          } else {
            placeholderData = typeof options2.placeholderData === "function" ? options2.placeholderData(
              this.#lastQueryWithDefinedData?.state.data,
              this.#lastQueryWithDefinedData
            ) : options2.placeholderData;
            if (options2.select && placeholderData !== void 0) {
              try {
                placeholderData = options2.select(placeholderData);
                this.#selectError = null;
              } catch (selectError) {
                this.#selectError = selectError;
              }
            }
          }
          if (placeholderData !== void 0) {
            status = "success";
            data = replaceData(
              prevResult?.data,
              placeholderData,
              options2
            );
            isPlaceholderData = true;
          }
        }
        if (this.#selectError) {
          error2 = this.#selectError;
          data = this.#selectResult;
          errorUpdatedAt = Date.now();
          status = "error";
        }
        const isFetching = newState.fetchStatus === "fetching";
        const isPending = status === "pending";
        const isError = status === "error";
        const isLoading = isPending && isFetching;
        const hasData = data !== void 0;
        const result = {
          status,
          fetchStatus: newState.fetchStatus,
          isPending,
          isSuccess: status === "success",
          isError,
          isInitialLoading: isLoading,
          isLoading,
          data,
          dataUpdatedAt: newState.dataUpdatedAt,
          error: error2,
          errorUpdatedAt,
          failureCount: newState.fetchFailureCount,
          failureReason: newState.fetchFailureReason,
          errorUpdateCount: newState.errorUpdateCount,
          isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
          isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && !isPending,
          isLoadingError: isError && !hasData,
          isPaused: newState.fetchStatus === "paused",
          isPlaceholderData,
          isRefetchError: isError && hasData,
          isStale: isStale(query, options2),
          refetch: this.refetch
        };
        return result;
      }
      updateResult(notifyOptions) {
        const prevResult = this.#currentResult;
        const nextResult = this.createResult(this.#currentQuery, this.options);
        this.#currentResultState = this.#currentQuery.state;
        this.#currentResultOptions = this.options;
        if (this.#currentResultState.data !== void 0) {
          this.#lastQueryWithDefinedData = this.#currentQuery;
        }
        if (shallowEqualObjects(nextResult, prevResult)) {
          return;
        }
        this.#currentResult = nextResult;
        const defaultNotifyOptions = {};
        const shouldNotifyListeners = () => {
          if (!prevResult) {
            return true;
          }
          const { notifyOnChangeProps } = this.options;
          const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
          if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
            return true;
          }
          const includedProps = new Set(
            notifyOnChangePropsValue ?? this.#trackedProps
          );
          if (this.options.throwOnError) {
            includedProps.add("error");
          }
          return Object.keys(this.#currentResult).some((key2) => {
            const typedKey = key2;
            const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
            return changed && includedProps.has(typedKey);
          });
        };
        if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {
          defaultNotifyOptions.listeners = true;
        }
        this.#notify({ ...defaultNotifyOptions, ...notifyOptions });
      }
      #updateQuery() {
        const query = this.#client.getQueryCache().build(this.#client, this.options);
        if (query === this.#currentQuery) {
          return;
        }
        const prevQuery = this.#currentQuery;
        this.#currentQuery = query;
        this.#currentQueryInitialState = query.state;
        if (this.hasListeners()) {
          prevQuery?.removeObserver(this);
          query.addObserver(this);
        }
      }
      onQueryUpdate() {
        this.updateResult();
        if (this.hasListeners()) {
          this.#updateTimers();
        }
      }
      #notify(notifyOptions) {
        notifyManager.batch(() => {
          if (notifyOptions.listeners) {
            this.listeners.forEach((listener) => {
              listener(this.#currentResult);
            });
          }
          this.#client.getQueryCache().notify({
            query: this.#currentQuery,
            type: "observerResultsUpdated"
          });
        });
      }
    };
  }
});

// .svelte-kit/output/server/chunks/pharmacy.query.js
function pharmacyListOptions(stream) {
  return queryOptions({
    queryKey: ["pharmacy-list"],
    queryFn: async () => await stream,
    refetchOnMount: true
  });
}
var init_pharmacy_query = __esm({
  ".svelte-kit/output/server/chunks/pharmacy.query.js"() {
    init_queryOptions();
  }
});

// .svelte-kit/output/server/chunks/pharmacies-table-wrapper.js
function Pharmacies_table_action($$payload, $$props) {
  push();
  $$payload.out += `<!--[-->`;
  Root2($$payload, {
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `<!--[-->`;
      Trigger($$payload2, {
        asChild: true,
        children: ($$payload3, $$slotProps2) => {
          const builder = $$slotProps2.builder;
          $$payload3.out += `<!--[-->`;
          Button($$payload3, {
            variant: "ghost",
            builders: [builder],
            size: "icon",
            class: "relative h-8 w-8 p-0",
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `<span class="sr-only">Open menu</span> <!--[-->`;
              Ellipsis($$payload4, { class: "h-4 w-4" });
              $$payload4.out += `<!--]-->`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]--> <!--[-->`;
      Dropdown_menu_content($$payload2, {
        children: ($$payload3, $$slotProps2) => {
          $$payload3.out += `<!--[-->`;
          Group($$payload3, {
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `<!--[-->`;
              Dropdown_menu_label($$payload4, {
                children: ($$payload5, $$slotProps4) => {
                  $$payload5.out += `More actions`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!--]-->`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]--> <!--[-->`;
          Dropdown_menu_separator($$payload3, {});
          $$payload3.out += `<!--]--> <!--[-->`;
          Dropdown_menu_item($$payload3, {
            class: "cursor-pointer",
            onclick: () => {
              goto();
            },
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `View pharmacists`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]--> <!--[-->`;
          Dropdown_menu_item($$payload3, {
            class: "cursor-pointer",
            onclick: () => {
              goto();
            },
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `Edit Pharmacy Details`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]--> <!--[-->`;
          Dropdown_menu_item($$payload3, {
            class: "cursor-pointer",
            onclick: () => {
              goto();
            },
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `View pharmacy details`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]-->`;
  pop();
}
function Pharmacies_table($$payload, $$props) {
  push();
  var $$store_subs;
  let { pharmacies } = $$props;
  const table = createTable(readable(pharmacies), {
    page: addPagination({ initialPageSize: 10 }),
    sort: addSortBy(),
    filter: addTableFilter({
      fn: ({ filterValue: filterValue2, value }) => value.toLowerCase().includes(filterValue2.toLowerCase())
    })
  });
  const columns = table.createColumns([
    table.column({
      accessor: ({ pharmacyId }) => pharmacies.indexOf(pharmacies.find((p2) => p2.pharmacyId === pharmacyId)) + 1,
      header: ""
    }),
    table.column({ accessor: "name", header: "Name" }),
    table.column({ accessor: "country", header: "Country" }),
    table.column({ accessor: "region", header: "State" }),
    table.column({ accessor: "city", header: "City" }),
    table.column({ accessor: "address", header: "Address" }),
    table.column({
      accessor: ({ pharmacyId }) => pharmacyId,
      header: "Actions",
      cell: ({ value }) => {
        return createRender(Pharmacies_table_action, { pharmacyId: value });
      }
    })
  ]);
  const {
    headerRows,
    pageRows,
    tableAttrs,
    tableBodyAttrs,
    pluginStates
  } = table.createViewModel(columns);
  let tmp = pluginStates.page, pageIndex = tmp.pageIndex, hasNextPage = tmp.hasNextPage, hasPreviousPage = tmp.hasPreviousPage;
  const tmp_1 = pluginStates.filter, filterValue = tmp_1.filterValue;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    if (store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app/pharmacies") {
      $$payload2.out += `<div class="flex items-center"><!--[-->`;
      Input($$payload2, {
        class: "max-w-sm",
        placeholder: "Filter pharmacies...",
        type: "text",
        get value() {
          return store_get($$store_subs ??= {}, "$filterValue", filterValue);
        },
        set value($$value) {
          store_set(filterValue, $$value);
          $$settled = false;
        }
      });
      $$payload2.out += `<!--]--></div>`;
      $$payload2.out += "<!--]-->";
    } else {
      $$payload2.out += "<!--]!-->";
    }
    $$payload2.out += ` <div class="rounded-md border"><!--[-->`;
    Table2($$payload2, spread_props([
      store_get($$store_subs ??= {}, "$tableAttrs", tableAttrs),
      {
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `<!--[-->`;
          Table_header($$payload3, {
            children: ($$payload4, $$slotProps2) => {
              const each_array = ensure_array_like(store_get($$store_subs ??= {}, "$headerRows", headerRows));
              $$payload4.out += `<!--[-->`;
              for (let $$index_1 = 0; $$index_1 < each_array.length; $$index_1++) {
                const headerRow = each_array[$$index_1];
                $$payload4.out += "<!--[-->";
                $$payload4.out += `<!--[-->`;
                Subscribe($$payload4, {
                  rowAttrs: headerRow.attrs(),
                  children: ($$payload5, $$slotProps3) => {
                    $$payload5.out += `<!--[-->`;
                    Table_row($$payload5, {
                      children: ($$payload6, $$slotProps4) => {
                        const each_array_1 = ensure_array_like(headerRow.cells);
                        $$payload6.out += `<!--[-->`;
                        for (let $$index = 0; $$index < each_array_1.length; $$index++) {
                          const cell = each_array_1[$$index];
                          $$payload6.out += "<!--[-->";
                          $$payload6.out += `<!--[-->`;
                          Subscribe($$payload6, {
                            attrs: cell.attrs(),
                            props: cell.props(),
                            children: ($$payload7, $$slotProps5) => {
                              const attrs = $$slotProps5.attrs;
                              const props = $$slotProps5.props;
                              $$payload7.out += `<!--[-->`;
                              Table_head($$payload7, spread_props([
                                attrs,
                                {
                                  children: ($$payload8, $$slotProps6) => {
                                    $$payload8.out += `<!--[-->`;
                                    if (cell.id === "name") {
                                      $$payload8.out += `<!--[-->`;
                                      Button($$payload8, {
                                        variant: "ghost",
                                        onclick: props.sort.toggle,
                                        children: ($$payload9, $$slotProps7) => {
                                          $$payload9.out += `<!--[-->`;
                                          Render($$payload9, { of: cell.render() });
                                          $$payload9.out += `<!--]--> <!--[-->`;
                                          Arrow_up_down($$payload9, { class: "ml-2 h-4 w-4" });
                                          $$payload9.out += `<!--]-->`;
                                        },
                                        $$slots: { default: true }
                                      });
                                      $$payload8.out += `<!--]-->`;
                                      $$payload8.out += "<!--]-->";
                                    } else {
                                      $$payload8.out += `<!--[-->`;
                                      Render($$payload8, { of: cell.render() });
                                      $$payload8.out += `<!--]-->`;
                                      $$payload8.out += "<!--]!-->";
                                    }
                                  },
                                  $$slots: { default: true }
                                }
                              ]));
                              $$payload7.out += `<!--]-->`;
                            },
                            $$slots: { default: true }
                          });
                          $$payload6.out += `<!--]-->`;
                          $$payload6.out += "<!--]-->";
                        }
                        $$payload6.out += "<!--]-->";
                      },
                      $$slots: { default: true }
                    });
                    $$payload5.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!--]-->`;
                $$payload4.out += "<!--]-->";
              }
              $$payload4.out += "<!--]-->";
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]--> <!--[-->`;
          Table_body($$payload3, spread_props([
            store_get($$store_subs ??= {}, "$tableBodyAttrs", tableBodyAttrs),
            {
              children: ($$payload4, $$slotProps2) => {
                const each_array_2 = ensure_array_like(store_get($$store_subs ??= {}, "$pageRows", pageRows));
                $$payload4.out += `<!--[-->`;
                for (let $$index_3 = 0; $$index_3 < each_array_2.length; $$index_3++) {
                  const row = each_array_2[$$index_3];
                  $$payload4.out += "<!--[-->";
                  $$payload4.out += `<!--[-->`;
                  Subscribe($$payload4, {
                    rowAttrs: row.attrs(),
                    children: ($$payload5, $$slotProps3) => {
                      const rowAttrs = $$slotProps3.rowAttrs;
                      $$payload5.out += `<!--[-->`;
                      Table_row($$payload5, spread_props([
                        rowAttrs,
                        {
                          children: ($$payload6, $$slotProps4) => {
                            const each_array_3 = ensure_array_like(row.cells);
                            $$payload6.out += `<!--[-->`;
                            for (let $$index_2 = 0; $$index_2 < each_array_3.length; $$index_2++) {
                              const cell = each_array_3[$$index_2];
                              $$payload6.out += "<!--[-->";
                              $$payload6.out += `<!--[-->`;
                              Subscribe($$payload6, {
                                attrs: cell.attrs(),
                                children: ($$payload7, $$slotProps5) => {
                                  const attrs = $$slotProps5.attrs;
                                  $$payload7.out += `<!--[-->`;
                                  Table_cell($$payload7, spread_props([
                                    attrs,
                                    {
                                      children: ($$payload8, $$slotProps6) => {
                                        $$payload8.out += `<!--[-->`;
                                        Render($$payload8, { of: cell.render() });
                                        $$payload8.out += `<!--]-->`;
                                      },
                                      $$slots: { default: true }
                                    }
                                  ]));
                                  $$payload7.out += `<!--]-->`;
                                },
                                $$slots: { default: true }
                              });
                              $$payload6.out += `<!--]-->`;
                              $$payload6.out += "<!--]-->";
                            }
                            $$payload6.out += "<!--]-->";
                          },
                          $$slots: { default: true }
                        }
                      ]));
                      $$payload5.out += `<!--]-->`;
                    },
                    $$slots: { default: true }
                  });
                  $$payload4.out += `<!--]-->`;
                  $$payload4.out += "<!--]-->";
                }
                $$payload4.out += "<!--]-->";
              },
              $$slots: { default: true }
            }
          ]));
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      }
    ]));
    $$payload2.out += `<!--]--> <div class="flex items-center justify-center space-x-4 py-2"><!--[-->`;
    if (store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app/pharmacies") {
      $$payload2.out += `<!--[-->`;
      Button($$payload2, {
        variant: "outline",
        size: "sm",
        onclick: () => store_set(pageIndex, store_get($$store_subs ??= {}, "$pageIndex", pageIndex) - 1),
        disabled: !store_get($$store_subs ??= {}, "$hasPreviousPage", hasPreviousPage),
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `Previous`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]--> <!--[-->`;
      Button($$payload2, {
        variant: "outline",
        size: "sm",
        disabled: !store_get($$store_subs ??= {}, "$hasNextPage", hasNextPage),
        onclick: () => store_set(pageIndex, store_get($$store_subs ??= {}, "$pageIndex", pageIndex) + 1),
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `Next`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
      $$payload2.out += "<!--]-->";
    } else {
      $$payload2.out += `<!--[-->`;
      Button($$payload2, {
        variant: "outline",
        size: "sm",
        href: "/app/pharmacies",
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `View More <!--[-->`;
          Chevron_right($$payload3, { class: "ml-2 h-4 w-4" });
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
      $$payload2.out += "<!--]!-->";
    }
    $$payload2.out += `</div></div>`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function Pharmacies_table_wrapper($$payload, $$props) {
  push();
  var $$store_subs;
  let pharmacyListStream = getContext(CONTEXT_KEYS.PHARMACY_LIST_STREAM);
  let pharmaciesQuery = createQuery(pharmacyListOptions(pharmacyListStream));
  $$payload.out += `<!--[-->`;
  if (store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).isFetching) {
    $$payload.out += `<!--[-->`;
    LoadingSpinner($$payload, { size: "lg" });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).isError) {
      $$payload.out += `<!--[-->`;
      QueryErrorPlaceHolder($$payload, { query: pharmaciesQuery });
      $$payload.out += `<!--]-->`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      if (store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).data && store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).data.ok) {
        const pharmacies = store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).data.pharmacies;
        $$payload.out += `<div class="flex items-center justify-between"><h1 class="text-xl font-bold">Pharmacy Listing</h1> <!--[-->`;
        if (store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app") {
          $$payload.out += `<div class="flex items-center justify-center gap-2"><!--[-->`;
          Button($$payload, {
            variant: "outline",
            href: "/app/pharmacies/new",
            children: ($$payload2, $$slotProps) => {
              $$payload2.out += `Create New Pharmacy <!--[-->`;
              Circle_plus($$payload2, { class: "ml-2 h-4 w-4" });
              $$payload2.out += `<!--]-->`;
            },
            $$slots: { default: true }
          });
          $$payload.out += `<!--]--> <!--[-->`;
          Button($$payload, {
            variant: "outline",
            size: "sm",
            href: "/app/pharmacies",
            children: ($$payload2, $$slotProps) => {
              $$payload2.out += `View More <!--[-->`;
              Chevron_right($$payload2, { class: "ml-2 h-4 w-4" });
              $$payload2.out += `<!--]-->`;
            },
            $$slots: { default: true }
          });
          $$payload.out += `<!--]--></div>`;
          $$payload.out += "<!--]-->";
        } else {
          $$payload.out += "<!--]!-->";
        }
        $$payload.out += `</div> <!--[-->`;
        Pharmacies_table($$payload, {
          pharmacies: store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app/pharmacies" ? pharmacies : pharmacies.slice(0, 5)
        });
        $$payload.out += `<!--]-->`;
        $$payload.out += "<!--]-->";
      } else {
        $$payload.out += "<!--]!-->";
      }
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_pharmacies_table_wrapper = __esm({
  ".svelte-kit/output/server/chunks/pharmacies-table-wrapper.js"() {
    init_index3();
    init_table_row();
    init_pharmacy_query();
    init_queryOptions();
    init_index2();
    init_index4();
    init_clsx();
    init_index5();
    init_client();
    init_input();
    init_stores2();
    init_context_keys();
  }
});

// .svelte-kit/output/server/chunks/Spinner.js
function setFormField(props) {
  setContext(FORM_FIELD, props);
  return props;
}
function getFormField() {
  if (!hasContext(FORM_FIELD)) {
    ctxError("Form.Field");
  }
  return getContext(FORM_FIELD);
}
function setFormControl(props) {
  setContext(FORM_CONTROL, props);
  return props;
}
function getFormControl() {
  if (!hasContext(FORM_CONTROL)) {
    ctxError("<Control />");
  }
  return getContext(FORM_CONTROL);
}
function ctxError(ctx) {
  throw new Error(`Unable to find \`${ctx}\` context. Did you forget to wrap the component in a \`${ctx}\`?`);
}
function getAriaDescribedBy({ fieldErrorsId = void 0, descriptionId = void 0, errors }) {
  let describedBy = "";
  if (descriptionId) {
    describedBy += descriptionId + " ";
  }
  if (errors.length && fieldErrorsId) {
    describedBy += fieldErrorsId;
  }
  return describedBy ? describedBy.trim() : void 0;
}
function getAriaRequired(constraints2) {
  if (!("required" in constraints2))
    return void 0;
  return constraints2.required ? "true" : void 0;
}
function getAriaInvalid(errors) {
  return errors && errors.length ? "true" : void 0;
}
function getDataFsError(errors) {
  return errors && errors.length ? "" : void 0;
}
function generateId3() {
  return nanoid(5);
}
function extractErrorArray(errors) {
  if (Array.isArray(errors))
    return errors;
  if (typeof errors === "object" && "_errors" in errors) {
    if (errors._errors !== void 0)
      return errors._errors;
  }
  return [];
}
function getValueAtPath(path, obj) {
  const keys = path.split(/[[\].]/).filter(Boolean);
  let value = obj;
  for (const key2 of keys) {
    if (typeof value !== "object" || value === null) {
      return void 0;
    }
    value = value[key2];
  }
  return value;
}
function Field($$payload, $$props) {
  push();
  var $$store_subs;
  let formErrors, formConstraints, formTainted, formData;
  let form = $$props["form"];
  let name2 = $$props["name"];
  const field = {
    name: writable(name2),
    errors: writable([]),
    constraints: writable({}),
    tainted: writable(false),
    fieldErrorsId: writable(),
    descriptionId: writable(),
    form
  };
  const { tainted, errors } = field;
  setFormField(field);
  ({
    errors: formErrors,
    constraints: formConstraints,
    tainted: formTainted,
    form: formData
  } = form);
  field.name.set(name2);
  field.errors.set(extractErrorArray(getValueAtPath(name2, store_get($$store_subs ??= {}, "$formErrors", formErrors))));
  field.constraints.set(getValueAtPath(name2, store_get($$store_subs ??= {}, "$formConstraints", formConstraints)) ?? {});
  field.tainted.set(store_get($$store_subs ??= {}, "$formTainted", formTainted) ? getValueAtPath(name2, store_get($$store_subs ??= {}, "$formTainted", formTainted)) === true : false);
  $$payload.out += `<!--[-->`;
  slot(
    $$payload,
    default_slot($$props),
    {
      get value() {
        return store_get($$store_subs ??= {}, "$formData", formData)[name2];
      },
      get errors() {
        return store_get($$store_subs ??= {}, "$errors", errors);
      },
      get tainted() {
        return store_get($$store_subs ??= {}, "$tainted", tainted);
      },
      get constraints() {
        return store_get($$store_subs ??= {}, "$formConstraints", formConstraints)[name2];
      }
    },
    null
  );
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { form, name: name2 });
  pop();
}
function Control$1($$payload, $$props) {
  push();
  var $$store_subs;
  let errorAttr, attrs, labelAttrs;
  let id = value_or_fallback($$props["id"], generateId3);
  const {
    name: name2,
    fieldErrorsId,
    descriptionId,
    errors,
    constraints: constraints2
  } = getFormField();
  const controlContext = {
    id: writable(id),
    attrs: writable(),
    labelAttrs: writable()
  };
  const { id: idStore } = controlContext;
  setFormControl(controlContext);
  controlContext.id.set(id);
  errorAttr = getDataFsError(store_get($$store_subs ??= {}, "$errors", errors));
  attrs = {
    name: store_get($$store_subs ??= {}, "$name", name2),
    id: store_get($$store_subs ??= {}, "$idStore", idStore),
    "data-fs-error": errorAttr,
    "aria-describedby": getAriaDescribedBy({
      fieldErrorsId: store_get($$store_subs ??= {}, "$fieldErrorsId", fieldErrorsId),
      descriptionId: store_get($$store_subs ??= {}, "$descriptionId", descriptionId),
      errors: store_get($$store_subs ??= {}, "$errors", errors)
    }),
    "aria-invalid": getAriaInvalid(store_get($$store_subs ??= {}, "$errors", errors)),
    "aria-required": getAriaRequired(store_get($$store_subs ??= {}, "$constraints", constraints2)),
    "data-fs-control": ""
  };
  labelAttrs = {
    for: store_get($$store_subs ??= {}, "$idStore", idStore),
    "data-fs-label": "",
    "data-fs-error": errorAttr
  };
  controlContext.attrs.set(attrs);
  controlContext.labelAttrs.set(labelAttrs);
  $$payload.out += `<!--[-->`;
  slot(
    $$payload,
    default_slot($$props),
    {
      get attrs() {
        return attrs;
      }
    },
    null
  );
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { id });
  pop();
}
function Form_field($$payload, $$props) {
  push();
  let form = $$props["form"];
  let name2 = $$props["name"];
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<!--[-->`;
  Field($$payload, {
    form,
    name: name2,
    children: ($$payload2, $$slotProps) => {
      const constraints2 = $$slotProps.constraints;
      const errors = $$slotProps.errors;
      const tainted = $$slotProps.tainted;
      const value = $$slotProps.value;
      $$payload2.out += `<div${attr("class", cn("space-y-2", className), false)}><!--[-->`;
      slot(
        $$payload2,
        default_slot($$props),
        {
          get constraints() {
            return constraints2;
          },
          get errors() {
            return errors;
          },
          get tainted() {
            return tainted;
          },
          get value() {
            return value;
          }
        },
        null
      );
      $$payload2.out += `<!--]--></div>`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]-->`;
  bind_props($$props, { form, name: name2, class: className });
  pop();
}
function Spinner($$payload, $$props) {
  push();
  $$payload.out += `<svg aria-hidden="true" role="status" class="mr-3 inline h-4 w-4 animate-spin text-white" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="#E5E7EB"></path><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentColor"></path></svg>`;
  pop();
}
var FORM_FIELD, FORM_CONTROL, Control;
var init_Spinner = __esm({
  ".svelte-kit/output/server/chunks/Spinner.js"() {
    init_index3();
    init_index2();
    init_misc();
    init_index4();
    init_input();
    init_clsx();
    FORM_FIELD = Symbol("FORM_FIELD_CTX");
    FORM_CONTROL = Symbol("FORM_CONTROL_CTX");
    Control = Control$1;
  }
});

// .svelte-kit/output/server/chunks/pharmacist-table-wrapper.js
function organisationPharmacistListOptions(stream) {
  return queryOptions({
    queryKey: ["pharmacist-list"],
    queryFn: async () => await stream,
    refetchOnMount: true
  });
}
function Pharmacists_table_action($$payload, $$props) {
  push();
  var $$store_subs;
  let { pharmacistId, pharmacyId, firstName } = $$props;
  let deletingPharmacist = false;
  let toastState = getContext(CONTEXT_KEYS.TOAST);
  let organisationPharmacistListResponse = getContext(CONTEXT_KEYS.ORGANISATION_PHARMACIST_LIST_STREAM);
  let organisationPharmacistListData = store_get($$store_subs ??= {}, "$page", page).data.queryClient.getQueryData(organisationPharmacistListOptions(organisationPharmacistListResponse).queryKey);
  const deletePharmacistForm = getContext(CONTEXT_KEYS.DELETE_PHARMACIST_FORM);
  let form = superForm(deletePharmacistForm, {
    validators: zodClient(deletePharmacistSchema),
    onSubmit: () => {
      deletingPharmacist = true;
    },
    onError: ({ result }) => {
      deletingPharmacist = false;
      if (result.type === "error") {
        toastState.addToast({
          title: "Operation Failed",
          message: result.error.message,
          type: "error"
        });
        return;
      }
    },
    onResult: ({ result }) => {
      deletingPharmacist = false;
      if (result.type === "success") {
        toastState.addToast({
          title: "Success",
          message: result.data?.message,
          type: "success"
        });
        if (organisationPharmacistListData && organisationPharmacistListData.ok) {
          store_get($$store_subs ??= {}, "$page", page).data.queryClient.setQueryData(organisationPharmacistListOptions(organisationPharmacistListResponse).queryKey, {
            ...organisationPharmacistListData,
            pharmacists: organisationPharmacistListData.pharmacists.filter((pharmacist) => pharmacist.pharmacistId !== pharmacistId)
          });
        }
        return;
      }
      if (result.type === "failure") {
        const errors = result.data?.form.errors;
        for (const key2 in errors) {
          toastState.addToast({ type: "error", message: errors[key2][0] });
        }
      }
      return;
    }
  });
  let { form: formData, enhance: enhance2 } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    Root2($$payload2, {
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Trigger($$payload3, {
          asChild: true,
          children: ($$payload4, $$slotProps2) => {
            const builder = $$slotProps2.builder;
            $$payload4.out += `<!--[-->`;
            Button($$payload4, {
              variant: "ghost",
              builders: [builder],
              size: "icon",
              class: "relative h-8 w-8 p-0",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<span class="sr-only">Open menu</span> <!--[-->`;
                Ellipsis($$payload5, { class: "h-4 w-4" });
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Dropdown_menu_content($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<!--[-->`;
            Group($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Dropdown_menu_label($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `More actions`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Dropdown_menu_separator($$payload4, {});
            $$payload4.out += `<!--]--> <!--[-->`;
            Dropdown_menu_item($$payload4, {
              class: "cursor-pointer",
              onclick: () => {
                goto();
              },
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `View Pharmacy Details`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Dropdown_menu_item($$payload4, {
              class: "cursor-pointer",
              onclick: () => {
              },
              // goto(`/app/pharmacies/${pharmacyId}/edit`);
              // delete pharmacist logic
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<form method="POST" action="?/deletePharmacist"><!--[-->`;
                Form_field($$payload5, {
                  form,
                  name: "pharmacistId",
                  class: "grid gap-2",
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `<!--[-->`;
                    Control($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        const attrs = $$slotProps5.attrs;
                        $$payload7.out += `<!--[-->`;
                        Input($$payload7, {
                          hidden: true,
                          name: attrs.name,
                          class: "hidden",
                          get value() {
                            return store_get($$store_subs ??= {}, "$formData", formData).pharmacistId;
                          },
                          set value($$value) {
                            mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).pharmacistId = $$value);
                            $$settled = false;
                          }
                        });
                        $$payload7.out += `<!--]-->`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Button($$payload5, {
                  type: "submit",
                  class: "h-full w-full",
                  variant: "outline",
                  disabled: deletingPharmacist,
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `<!--[-->`;
                    if (deletingPharmacist) {
                      $$payload6.out += `<!--[-->`;
                      Spinner($$payload6);
                      $$payload6.out += `<!--]--> Deleting...`;
                      $$payload6.out += "<!--]-->";
                    } else {
                      $$payload6.out += `Delete ${escape_html(firstName)}`;
                      $$payload6.out += "<!--]!-->";
                    }
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--></form>`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]-->`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function Pharmacists_table($$payload, $$props) {
  push();
  var $$store_subs;
  let { pharmacists } = $$props;
  const table = createTable(readable(pharmacists), {
    page: addPagination({ initialPageSize: 10 }),
    sort: addSortBy(),
    filter: addTableFilter({
      fn: ({ filterValue: filterValue2, value }) => value.toLowerCase().includes(filterValue2.toLowerCase())
    })
  });
  const columns = table.createColumns([
    table.column({
      accessor: ({ pharmacistId }) => pharmacists.indexOf(pharmacists.find((p2) => p2.pharmacistId === pharmacistId)) + 1,
      header: ""
    }),
    table.column({ accessor: "firstName", header: "First Name" }),
    table.column({ accessor: "lastName", header: "Last Name" }),
    table.column({ accessor: "username", header: "Username" }),
    table.column({
      accessor: "phoneNumber",
      header: "Phone Number"
    }),
    table.column({ accessor: "pharmacyName", header: "Pharmacy" }),
    table.column({
      accessor: ({ pharmacistId, pharmacyId, firstName }) => {
        return { pharmacyId, pharmacistId, firstName };
      },
      header: "Actions",
      cell: ({ value }) => {
        return createRender(Pharmacists_table_action, {
          pharmacistId: value.pharmacistId,
          pharmacyId: value.pharmacyId,
          firstName: value.firstName
        });
      }
    })
  ]);
  const {
    headerRows,
    pageRows,
    tableAttrs,
    tableBodyAttrs,
    pluginStates
  } = table.createViewModel(columns);
  let tmp = pluginStates.page, pageIndex = tmp.pageIndex, hasNextPage = tmp.hasNextPage, hasPreviousPage = tmp.hasPreviousPage;
  const tmp_1 = pluginStates.filter, filterValue = tmp_1.filterValue;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    if (store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app/pharmacists") {
      $$payload2.out += `<div class="flex items-center"><!--[-->`;
      Input($$payload2, {
        class: "max-w-sm",
        placeholder: "Filter pharmacists...",
        type: "text",
        get value() {
          return store_get($$store_subs ??= {}, "$filterValue", filterValue);
        },
        set value($$value) {
          store_set(filterValue, $$value);
          $$settled = false;
        }
      });
      $$payload2.out += `<!--]--></div>`;
      $$payload2.out += "<!--]-->";
    } else {
      $$payload2.out += "<!--]!-->";
    }
    $$payload2.out += ` <div class="rounded-md border"><!--[-->`;
    Table2($$payload2, spread_props([
      store_get($$store_subs ??= {}, "$tableAttrs", tableAttrs),
      {
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `<!--[-->`;
          Table_header($$payload3, {
            children: ($$payload4, $$slotProps2) => {
              const each_array = ensure_array_like(store_get($$store_subs ??= {}, "$headerRows", headerRows));
              $$payload4.out += `<!--[-->`;
              for (let $$index_1 = 0; $$index_1 < each_array.length; $$index_1++) {
                const headerRow = each_array[$$index_1];
                $$payload4.out += "<!--[-->";
                $$payload4.out += `<!--[-->`;
                Subscribe($$payload4, {
                  rowAttrs: headerRow.attrs(),
                  children: ($$payload5, $$slotProps3) => {
                    $$payload5.out += `<!--[-->`;
                    Table_row($$payload5, {
                      children: ($$payload6, $$slotProps4) => {
                        const each_array_1 = ensure_array_like(headerRow.cells);
                        $$payload6.out += `<!--[-->`;
                        for (let $$index = 0; $$index < each_array_1.length; $$index++) {
                          const cell = each_array_1[$$index];
                          $$payload6.out += "<!--[-->";
                          $$payload6.out += `<!--[-->`;
                          Subscribe($$payload6, {
                            attrs: cell.attrs(),
                            props: cell.props(),
                            children: ($$payload7, $$slotProps5) => {
                              const attrs = $$slotProps5.attrs;
                              const props = $$slotProps5.props;
                              $$payload7.out += `<!--[-->`;
                              Table_head($$payload7, spread_props([
                                attrs,
                                {
                                  children: ($$payload8, $$slotProps6) => {
                                    $$payload8.out += `<!--[-->`;
                                    if (cell.id === "firstName") {
                                      $$payload8.out += `<!--[-->`;
                                      Button($$payload8, {
                                        variant: "ghost",
                                        onclick: props.sort.toggle,
                                        children: ($$payload9, $$slotProps7) => {
                                          $$payload9.out += `<!--[-->`;
                                          Render($$payload9, { of: cell.render() });
                                          $$payload9.out += `<!--]--> <!--[-->`;
                                          Arrow_up_down($$payload9, { class: "ml-2 h-4 w-4" });
                                          $$payload9.out += `<!--]-->`;
                                        },
                                        $$slots: { default: true }
                                      });
                                      $$payload8.out += `<!--]-->`;
                                      $$payload8.out += "<!--]-->";
                                    } else {
                                      $$payload8.out += `<!--[-->`;
                                      Render($$payload8, { of: cell.render() });
                                      $$payload8.out += `<!--]-->`;
                                      $$payload8.out += "<!--]!-->";
                                    }
                                  },
                                  $$slots: { default: true }
                                }
                              ]));
                              $$payload7.out += `<!--]-->`;
                            },
                            $$slots: { default: true }
                          });
                          $$payload6.out += `<!--]-->`;
                          $$payload6.out += "<!--]-->";
                        }
                        $$payload6.out += "<!--]-->";
                      },
                      $$slots: { default: true }
                    });
                    $$payload5.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!--]-->`;
                $$payload4.out += "<!--]-->";
              }
              $$payload4.out += "<!--]-->";
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!--]--> <!--[-->`;
          Table_body($$payload3, spread_props([
            store_get($$store_subs ??= {}, "$tableBodyAttrs", tableBodyAttrs),
            {
              children: ($$payload4, $$slotProps2) => {
                const each_array_2 = ensure_array_like(store_get($$store_subs ??= {}, "$pageRows", pageRows));
                $$payload4.out += `<!--[-->`;
                for (let $$index_3 = 0; $$index_3 < each_array_2.length; $$index_3++) {
                  const row = each_array_2[$$index_3];
                  $$payload4.out += "<!--[-->";
                  $$payload4.out += `<!--[-->`;
                  Subscribe($$payload4, {
                    rowAttrs: row.attrs(),
                    children: ($$payload5, $$slotProps3) => {
                      const rowAttrs = $$slotProps3.rowAttrs;
                      $$payload5.out += `<!--[-->`;
                      Table_row($$payload5, spread_props([
                        rowAttrs,
                        {
                          children: ($$payload6, $$slotProps4) => {
                            const each_array_3 = ensure_array_like(row.cells);
                            $$payload6.out += `<!--[-->`;
                            for (let $$index_2 = 0; $$index_2 < each_array_3.length; $$index_2++) {
                              const cell = each_array_3[$$index_2];
                              $$payload6.out += "<!--[-->";
                              $$payload6.out += `<!--[-->`;
                              Subscribe($$payload6, {
                                attrs: cell.attrs(),
                                children: ($$payload7, $$slotProps5) => {
                                  const attrs = $$slotProps5.attrs;
                                  $$payload7.out += `<!--[-->`;
                                  Table_cell($$payload7, spread_props([
                                    attrs,
                                    {
                                      children: ($$payload8, $$slotProps6) => {
                                        $$payload8.out += `<!--[-->`;
                                        Render($$payload8, { of: cell.render() });
                                        $$payload8.out += `<!--]-->`;
                                      },
                                      $$slots: { default: true }
                                    }
                                  ]));
                                  $$payload7.out += `<!--]-->`;
                                },
                                $$slots: { default: true }
                              });
                              $$payload6.out += `<!--]-->`;
                              $$payload6.out += "<!--]-->";
                            }
                            $$payload6.out += "<!--]-->";
                          },
                          $$slots: { default: true }
                        }
                      ]));
                      $$payload5.out += `<!--]-->`;
                    },
                    $$slots: { default: true }
                  });
                  $$payload4.out += `<!--]-->`;
                  $$payload4.out += "<!--]-->";
                }
                $$payload4.out += "<!--]-->";
              },
              $$slots: { default: true }
            }
          ]));
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      }
    ]));
    $$payload2.out += `<!--]--> <div class="flex items-center justify-center space-x-4 py-2"><!--[-->`;
    if (store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app/pharmacists") {
      $$payload2.out += `<!--[-->`;
      Button($$payload2, {
        variant: "outline",
        size: "sm",
        onclick: () => store_set(pageIndex, store_get($$store_subs ??= {}, "$pageIndex", pageIndex) - 1),
        disabled: !store_get($$store_subs ??= {}, "$hasPreviousPage", hasPreviousPage),
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `Previous`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]--> <!--[-->`;
      Button($$payload2, {
        variant: "outline",
        size: "sm",
        disabled: !store_get($$store_subs ??= {}, "$hasNextPage", hasNextPage),
        onclick: () => store_set(pageIndex, store_get($$store_subs ??= {}, "$pageIndex", pageIndex) + 1),
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `Next`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
      $$payload2.out += "<!--]-->";
    } else {
      $$payload2.out += `<!--[-->`;
      Button($$payload2, {
        variant: "outline",
        size: "sm",
        href: "/app/pharmacists",
        children: ($$payload3, $$slotProps) => {
          $$payload3.out += `View More <!--[-->`;
          Chevron_right($$payload3, { class: "ml-2 h-4 w-4" });
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!--]-->`;
      $$payload2.out += "<!--]!-->";
    }
    $$payload2.out += `</div></div>`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function Pharmacist_table_wrapper($$payload, $$props) {
  push();
  var $$store_subs;
  let organisationPharmacistListStream = getContext(CONTEXT_KEYS.ORGANISATION_PHARMACIST_LIST_STREAM);
  let pharmaciesQuery = createQuery(organisationPharmacistListOptions(organisationPharmacistListStream));
  $$payload.out += `<!--[-->`;
  if (store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).isFetching) {
    $$payload.out += `<!--[-->`;
    LoadingSpinner($$payload, { size: "lg" });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).isError) {
      $$payload.out += `<!--[-->`;
      QueryErrorPlaceHolder($$payload, { query: pharmaciesQuery });
      $$payload.out += `<!--]-->`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      if (store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).data && store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).data.ok) {
        const pharmacists = store_get($$store_subs ??= {}, "$pharmaciesQuery", pharmaciesQuery).data.pharmacists;
        $$payload.out += `<div class="flex items-center justify-between"><h1 class="text-xl font-bold">Pharmacists Listing</h1> <!--[-->`;
        if (store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app") {
          $$payload.out += `<div class="flex items-center justify-center gap-2"><!--[-->`;
          Button($$payload, {
            variant: "outline",
            href: "/app/pharmacists/new",
            children: ($$payload2, $$slotProps) => {
              $$payload2.out += `Create New Pharmacist <!--[-->`;
              Circle_plus($$payload2, { class: "ml-2 h-4 w-4" });
              $$payload2.out += `<!--]-->`;
            },
            $$slots: { default: true }
          });
          $$payload.out += `<!--]--> <!--[-->`;
          Button($$payload, {
            variant: "outline",
            size: "sm",
            href: "/app/pharmacists",
            children: ($$payload2, $$slotProps) => {
              $$payload2.out += `View More <!--[-->`;
              Chevron_right($$payload2, { class: "ml-2 h-4 w-4" });
              $$payload2.out += `<!--]-->`;
            },
            $$slots: { default: true }
          });
          $$payload.out += `<!--]--></div>`;
          $$payload.out += "<!--]-->";
        } else {
          $$payload.out += "<!--]!-->";
        }
        $$payload.out += `</div> <!--[-->`;
        Pharmacists_table($$payload, {
          pharmacists: store_get($$store_subs ??= {}, "$page", page).url.pathname === "/app/pharmacists" ? pharmacists : pharmacists.slice(0, 5)
        });
        $$payload.out += `<!--]-->`;
        $$payload.out += "<!--]-->";
      } else {
        $$payload.out += "<!--]!-->";
      }
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_pharmacist_table_wrapper = __esm({
  ".svelte-kit/output/server/chunks/pharmacist-table-wrapper.js"() {
    init_index3();
    init_table_row();
    init_queryOptions();
    init_index2();
    init_index4();
    init_clsx();
    init_index5();
    init_client();
    init_context_keys();
    init_stores2();
    init_compile();
    init_chunks();
    init_pharmacist_form();
    init_Spinner();
    init_input();
  }
});

// .svelte-kit/output/server/entries/pages/app/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => _page2
});
function getSeparatorData() {
  const NAME = "separator";
  const PARTS = ["root"];
  return {
    NAME,
    PARTS
  };
}
function setCtx3(props) {
  const { NAME, PARTS } = getSeparatorData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const separator = { ...createSeparator(removeUndefined2(props)), getAttrs: getAttrs2 };
  return {
    ...separator,
    updateOption: getOptionUpdater(separator.options)
  };
}
function Separator$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "orientation",
    "decorative",
    "asChild",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let orientation = value_or_fallback($$props["orientation"], () => "horizontal");
  let decorative = value_or_fallback($$props["decorative"], () => true);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { root: root2 }, updateOption, getAttrs: getAttrs2 } = setCtx3({ orientation, decorative });
  const attrs = getAttrs2("root");
  updateOption("orientation", orientation);
  updateOption("decorative", decorative);
  builder = store_get($$store_subs ??= {}, "$root", root2);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { orientation, decorative, asChild, el });
  pop();
}
function Separator($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "orientation", "decorative"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let orientation = value_or_fallback($$props["orientation"], () => "horizontal");
  let decorative = value_or_fallback($$props["decorative"], () => void 0);
  $$payload.out += `<!--[-->`;
  Separator$1($$payload, spread_props([
    {
      class: cn("shrink-0 bg-border", orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", className),
      orientation,
      decorative
    },
    $$restProps
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className, orientation, decorative });
  pop();
}
function Organisation_home($$payload, $$props) {
  push();
  $$payload.out += `<div class="flex flex-col gap-5 px-5"><!--[-->`;
  Pharmacies_table_wrapper($$payload);
  $$payload.out += `<!--]--> <!--[-->`;
  Separator($$payload, {});
  $$payload.out += `<!--]--> <!--[-->`;
  Pharmacist_table_wrapper($$payload);
  $$payload.out += `<!--]--></div>`;
  pop();
}
function _page2($$payload, $$props) {
  push();
  var $$store_subs;
  $$payload.out += `<div class="container mx-auto flex flex-col items-center justify-center space-y-3 py-4"><h1 class="text-xl font-bold capitalize sm:text-2xl md:text-3xl lg:text-5xl">Hello, ${escape_html(store_get($$store_subs ??= {}, "$page", page).data.orgInfo ? store_get($$store_subs ??= {}, "$page", page).data.orgInfo.username : store_get($$store_subs ??= {}, "$page", page).data.pharmacistInfo ? store_get($$store_subs ??= {}, "$page", page).data.pharmacistInfo : store_get($$store_subs ??= {}, "$page", page).data.userInfo)}</h1> <p>Welcome back to Thola Kimonganga</p></div> <!--[-->`;
  Separator($$payload, {});
  $$payload.out += `<!--]--> <!--[-->`;
  if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org") {
    $$payload.out += `<!--[-->`;
    Organisation_home($$payload);
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/app/_page.svelte.js"() {
    init_index3();
    init_stores2();
    init_index4();
    init_index5();
    init_input();
    init_helpers();
    init_misc();
    init_pharmacies_table_wrapper();
    init_pharmacist_table_wrapper();
  }
});

// .svelte-kit/output/server/nodes/7.js
var __exports8 = {};
__export(__exports8, {
  component: () => component8,
  fonts: () => fonts8,
  imports: () => imports8,
  index: () => index8,
  stylesheets: () => stylesheets8
});
var index8, component_cache8, component8, imports8, stylesheets8, fonts8;
var init__8 = __esm({
  ".svelte-kit/output/server/nodes/7.js"() {
    index8 = 7;
    component8 = async () => component_cache8 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default;
    imports8 = ["_app/immutable/nodes/7.kyyuh8qQ.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/index.Cn0Hvpco.js", "_app/immutable/chunks/Icon.JZj92Q4v.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/transitions.Bmz1fhPf.js", "_app/immutable/chunks/helpers.DNOQU4WG.js", "_app/immutable/chunks/pharmacies-table-wrapper.Bm-KSPOf.js", "_app/immutable/chunks/table-row.B1j5B89g.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/svelte-component.DG8WHjyG.js", "_app/immutable/chunks/pharmacy.query.BZHZ1xYY.js", "_app/immutable/chunks/queryOptions.mHeyUsN7.js", "_app/immutable/chunks/context.C9dpIilQ.js", "_app/immutable/chunks/pharmacist-table-wrapper.D9myEyLS.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/pharmacist.form.f4vWm665.js"];
    stylesheets8 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts8 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => _page3
});
function CreatePharmacyTrigger($$payload, $$props) {
  push();
  $$payload.out += `<div class="container mx-auto flex items-center justify-center rounded-md border-2 border-dashed py-6 mt-5"><!--[-->`;
  Button($$payload, {
    variant: "outline",
    href: "/app/pharmacies/new",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `Create A New Pharmacy <!--[-->`;
      Circle_plus($$payload2, { class: "ml-2 h-4 w-4" });
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--></div>`;
  pop();
}
function _page3($$payload, $$props) {
  push();
  $$payload.out += `<div class="flex flex-col gap-5"><!--[-->`;
  CreatePharmacyTrigger($$payload);
  $$payload.out += `<!--]--> <!--[-->`;
  Pharmacies_table_wrapper($$payload);
  $$payload.out += `<!--]--></div>`;
  pop();
}
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/_page.svelte.js"() {
    init_index3();
    init_index4();
    init_table_row();
    init_pharmacies_table_wrapper();
  }
});

// .svelte-kit/output/server/nodes/8.js
var __exports9 = {};
__export(__exports9, {
  component: () => component9,
  fonts: () => fonts9,
  imports: () => imports9,
  index: () => index9,
  stylesheets: () => stylesheets9
});
var index9, component_cache9, component9, imports9, stylesheets9, fonts9;
var init__9 = __esm({
  ".svelte-kit/output/server/nodes/8.js"() {
    index9 = 8;
    component9 = async () => component_cache9 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default;
    imports9 = ["_app/immutable/nodes/8.BipzJ94h.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/table-row.B1j5B89g.js", "_app/immutable/chunks/Icon.JZj92Q4v.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/svelte-component.DG8WHjyG.js", "_app/immutable/chunks/pharmacies-table-wrapper.Bm-KSPOf.js", "_app/immutable/chunks/pharmacy.query.BZHZ1xYY.js", "_app/immutable/chunks/queryOptions.mHeyUsN7.js", "_app/immutable/chunks/context.C9dpIilQ.js", "_app/immutable/chunks/index.Cn0Hvpco.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/transitions.Bmz1fhPf.js", "_app/immutable/chunks/helpers.DNOQU4WG.js"];
    stylesheets9 = [];
    fonts9 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/_pharmacyId_/_page.svelte.js
var page_svelte_exports4 = {};
__export(page_svelte_exports4, {
  default: () => _page4
});
function _page4($$payload, $$props) {
  push();
  $$payload.out += `<h1>View and update pharmacy details here</h1>`;
  pop();
}
var init_page_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/_pharmacyId_/_page.svelte.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/nodes/9.js
var __exports10 = {};
__export(__exports10, {
  component: () => component10,
  fonts: () => fonts10,
  imports: () => imports10,
  index: () => index10,
  stylesheets: () => stylesheets10
});
var index10, component_cache10, component10, imports10, stylesheets10, fonts10;
var init__10 = __esm({
  ".svelte-kit/output/server/nodes/9.js"() {
    index10 = 9;
    component10 = async () => component_cache10 ??= (await Promise.resolve().then(() => (init_page_svelte4(), page_svelte_exports4))).default;
    imports10 = ["_app/immutable/nodes/9.DmdQI8PY.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js"];
    stylesheets10 = [];
    fonts10 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/_pharmacyId_/edit/_page.svelte.js
var page_svelte_exports5 = {};
__export(page_svelte_exports5, {
  default: () => _page5
});
function _page5($$payload, $$props) {
  push();
  $$payload.out += `<h1>Edit pharmacy details</h1>`;
  pop();
}
var init_page_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/_pharmacyId_/edit/_page.svelte.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/nodes/10.js
var __exports11 = {};
__export(__exports11, {
  component: () => component11,
  fonts: () => fonts11,
  imports: () => imports11,
  index: () => index11,
  stylesheets: () => stylesheets11
});
var index11, component_cache11, component11, imports11, stylesheets11, fonts11;
var init__11 = __esm({
  ".svelte-kit/output/server/nodes/10.js"() {
    index11 = 10;
    component11 = async () => component_cache11 ??= (await Promise.resolve().then(() => (init_page_svelte5(), page_svelte_exports5))).default;
    imports11 = ["_app/immutable/nodes/10.UfbszAtU.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js"];
    stylesheets11 = [];
    fonts11 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/_pharmacyId_/pharmacists/_page.svelte.js
var page_svelte_exports6 = {};
__export(page_svelte_exports6, {
  default: () => _page6
});
function _page6($$payload, $$props) {
  push();
  $$payload.out += `<h1>view the pharmacists belongging to specified pharmacy</h1>`;
  pop();
}
var init_page_svelte6 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/_pharmacyId_/pharmacists/_page.svelte.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/nodes/11.js
var __exports12 = {};
__export(__exports12, {
  component: () => component12,
  fonts: () => fonts12,
  imports: () => imports12,
  index: () => index12,
  stylesheets: () => stylesheets12
});
var index12, component_cache12, component12, imports12, stylesheets12, fonts12;
var init__12 = __esm({
  ".svelte-kit/output/server/nodes/11.js"() {
    index12 = 11;
    component12 = async () => component_cache12 ??= (await Promise.resolve().then(() => (init_page_svelte6(), page_svelte_exports6))).default;
    imports12 = ["_app/immutable/nodes/11.BaBmhItA.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js"];
    stylesheets12 = [];
    fonts12 = [];
  }
});

// .svelte-kit/output/server/chunks/pharmacy.form.js
var createPharmacySchema;
var init_pharmacy_form = __esm({
  ".svelte-kit/output/server/chunks/pharmacy.form.js"() {
    init_lib();
    createPharmacySchema = z.object({
      name: z.string().min(3, "Name is required"),
      address: z.string().min(3, "Address is required"),
      country: z.string().min(3, "Country is required"),
      region: z.string().min(3, "State is required"),
      city: z.string().min(3, "City is required"),
      latitude: z.coerce.number(),
      longitude: z.coerce.number(),
      organisationId: z.string().uuid("Invalid organisation id")
    });
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/new/_page.server.ts.js
var page_server_ts_exports = {};
__export(page_server_ts_exports, {
  actions: () => actions,
  load: () => load5
});
var load5, actions;
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/new/_page.server.ts.js"() {
    init_pharmacy_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    init_urls();
    load5 = async () => {
      const createPharmacyForm = await superValidate(zod(createPharmacySchema));
      return { createPharmacyForm };
    };
    actions = {
      default: async ({ request, locals, fetch: fetch2, cookies }) => {
        const sessionKey = cookies.get(COOKIE_KEYS.SESSION_KEY);
        const form = await superValidate(request, zod(createPharmacySchema));
        if (!form.valid)
          ;
        const createPharmacyResponse = await post({
          url: `pharmacy/create/${form.data.organisationId}`,
          input: {
            name: form.data.name,
            country: form.data.country,
            address: form.data.address,
            city: form.data.city,
            longitude: form.data.longitude,
            latitude: form.data.latitude,
            region: form.data.region
          },
          fetcher: fetch2,
          baseURL: locals.baseURL,
          options: {
            headers: {
              "Authorization": sessionKey || ""
            }
          }
        });
        if (!createPharmacyResponse.ok) {
          error(createPharmacyResponse.status, {
            message: createPharmacyResponse.message,
            status: createPharmacyResponse.status
          });
        }
        return {
          message: createPharmacyResponse.message,
          status: 200
        };
      }
    };
  }
});

// .svelte-kit/output/server/chunks/form-field-errors.js
function createLabel() {
  const root2 = makeElement("label", {
    action: (node) => {
      const mouseDown = addMeltEventListener(node, "mousedown", (e3) => {
        if (!e3.defaultPrevented && e3.detail > 1) {
          e3.preventDefault();
        }
      });
      return {
        destroy: mouseDown
      };
    }
  });
  return {
    elements: {
      root: root2
    }
  };
}
function getLabelData() {
  const NAME = "label";
  const PARTS = ["root"];
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  return {
    NAME,
    getAttrs: getAttrs2
  };
}
function Label$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { root: root2 } } = createLabel();
  const { getAttrs: getAttrs2 } = getLabelData();
  const attrs = getAttrs2("root");
  builder = store_get($$store_subs ??= {}, "$root", root2);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<label${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></label>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Field_errors($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["id", "asChild", "el"]);
  push();
  var $$store_subs;
  let errorAttr, fieldErrorsAttrs, errorAttrs;
  const tmp = getFormField(), fieldErrorsId = tmp.fieldErrorsId, errors = tmp.errors;
  let id = value_or_fallback($$props["id"], generateId3);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  errorAttr = getDataFsError(store_get($$store_subs ??= {}, "$errors", errors));
  fieldErrorsId.set(id);
  fieldErrorsAttrs = {
    id: store_get($$store_subs ??= {}, "$fieldErrorsId", fieldErrorsId),
    "data-fs-error": errorAttr,
    "data-fs-field-errors": "",
    "aria-live": "assertive",
    ...$$restProps
  };
  errorAttrs = {
    "data-fs-field-error": "",
    "data-fs-error": errorAttr
  };
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get errors() {
          return store_get($$store_subs ??= {}, "$errors", errors);
        },
        get fieldErrorsAttrs() {
          return fieldErrorsAttrs;
        },
        get errorAttrs() {
          return errorAttrs;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...fieldErrorsAttrs })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get errors() {
          return store_get($$store_subs ??= {}, "$errors", errors);
        },
        get fieldErrorsAttrs() {
          return fieldErrorsAttrs;
        },
        get errorAttrs() {
          return errorAttrs;
        }
      },
      () => {
        const each_array = ensure_array_like(store_get($$store_subs ??= {}, "$errors", errors));
        $$payload.out += `<!--[-->`;
        for (let $$index = 0; $$index < each_array.length; $$index++) {
          const error2 = each_array[$$index];
          $$payload.out += "<!--[-->";
          $$payload.out += `<div${spread_attributes({ ...errorAttrs })}>${escape_html(error2)}</div>`;
          $$payload.out += "<!--]-->";
        }
        $$payload.out += "<!--]-->";
      }
    );
    $$payload.out += `<!--]--></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { id, asChild, el });
  pop();
}
function Label($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<!--[-->`;
  Label$1($$payload, spread_props([
    {
      class: cn("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className });
  pop();
}
function Form_label($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  var $$store_subs;
  let className = value_or_fallback($$props["class"], () => void 0);
  const { labelAttrs } = getFormControl();
  $$payload.out += `<!--[-->`;
  Label($$payload, spread_props([
    store_get($$store_subs ??= {}, "$labelAttrs", labelAttrs),
    {
      class: cn("data-[fs-error]:text-destructive", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), { labelAttrs }, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { class: className });
  pop();
}
function Form_field_errors($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "errorClasses"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let errorClasses = value_or_fallback($$props["errorClasses"], () => void 0);
  $$payload.out += `<!--[-->`;
  Field_errors($$payload, spread_props([
    {
      class: cn("text-sm font-medium text-destructive", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        const errors = $$slotProps.errors;
        const fieldErrorsAttrs = $$slotProps.fieldErrorsAttrs;
        const errorAttrs = $$slotProps.errorAttrs;
        $$payload2.out += `<!--[-->`;
        slot(
          $$payload2,
          default_slot($$props),
          {
            get errors() {
              return errors;
            },
            get fieldErrorsAttrs() {
              return fieldErrorsAttrs;
            },
            get errorAttrs() {
              return errorAttrs;
            }
          },
          () => {
            const each_array = ensure_array_like(errors);
            $$payload2.out += `<!--[-->`;
            for (let $$index = 0; $$index < each_array.length; $$index++) {
              const error2 = each_array[$$index];
              $$payload2.out += "<!--[-->";
              $$payload2.out += `<div${spread_attributes({ ...errorAttrs, class: cn(errorClasses) })}>${escape_html(error2)}</div>`;
              $$payload2.out += "<!--]-->";
            }
            $$payload2.out += "<!--]-->";
          }
        );
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className, errorClasses });
  pop();
}
var init_form_field_errors = __esm({
  ".svelte-kit/output/server/chunks/form-field-errors.js"() {
    init_index3();
    init_Spinner();
    init_index4();
    init_input();
    init_misc();
  }
});

// .svelte-kit/output/server/chunks/index7.js
function Check($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [["path", { "d": "M20 6 9 17l-5-5" }]];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "check" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Chevron_down($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [["path", { "d": "m6 9 6 6 6-6" }]];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "chevron-down" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function getOptions(el) {
  return Array.from(el.querySelectorAll('[role="option"]:not([data-disabled])')).filter((el2) => isHTMLElement(el2));
}
function createClickOutsideIgnore(meltId) {
  return (e3) => {
    const target = e3.target;
    const triggerEl = getElementByMeltId(meltId);
    if (!triggerEl || !isElement(target))
      return false;
    const id = triggerEl.id;
    if (isHTMLLabelElement(target) && id === target.htmlFor) {
      return true;
    }
    if (target.closest(`label[for="${id}"]`)) {
      return true;
    }
    return false;
  };
}
function createListbox(props) {
  const withDefaults = { ...defaults5, ...props };
  const activeTrigger = withGet(writable(null));
  const highlightedItem = withGet(writable(null));
  const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);
  const selected = overridable(selectedWritable, withDefaults?.onSelectedChange);
  const highlighted = derived(highlightedItem, ($highlightedItem) => $highlightedItem ? getOptionProps($highlightedItem) : void 0);
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const options2 = toWritableStores({
    ...omit(withDefaults, "open", "defaultOpen", "builder", "ids"),
    multiple: withDefaults.multiple ?? false
  });
  const { scrollAlignment, loop, closeOnOutsideClick, closeOnEscape, preventScroll, portal, forceVisible, positioning, multiple, arrowSize, disabled, required, typeahead, name: nameProp, highlightOnHover, onOutsideClick } = options2;
  const { name: name2, selector } = createElHelpers(withDefaults.builder);
  const ids = toWritableStores({ ...generateIds(listboxIdParts), ...withDefaults.ids });
  const { handleTypeaheadSearch } = createTypeaheadSearch({
    onMatch: (element2) => {
      highlightedItem.set(element2);
      element2.scrollIntoView({ block: scrollAlignment.get() });
    },
    getCurrentItem() {
      return highlightedItem.get();
    }
  });
  function getOptionProps(el) {
    const value = el.getAttribute("data-value");
    const label2 = el.getAttribute("data-label");
    const disabled2 = el.hasAttribute("data-disabled");
    return {
      value: value ? JSON.parse(value) : value,
      label: label2 ?? el.textContent ?? void 0,
      disabled: disabled2 ? true : false
    };
  }
  const setOption = (newOption) => {
    selected.update(($option) => {
      const $multiple = multiple.get();
      if ($multiple) {
        const optionArr = Array.isArray($option) ? [...$option] : [];
        return toggle(newOption, optionArr, (itemA, itemB) => dequal(itemA.value, itemB.value));
      }
      return newOption;
    });
  };
  function selectItem(item) {
    const props2 = getOptionProps(item);
    setOption(props2);
  }
  async function openMenu() {
    open.set(true);
    const triggerEl = document.getElementById(ids.trigger.get());
    if (!triggerEl)
      return;
    if (triggerEl !== activeTrigger.get())
      activeTrigger.set(triggerEl);
    await tick();
    const menuElement = document.getElementById(ids.menu.get());
    if (!isHTMLElement(menuElement))
      return;
    const selectedItem = menuElement.querySelector("[aria-selected=true]");
    if (!isHTMLElement(selectedItem))
      return;
    highlightedItem.set(selectedItem);
  }
  function closeMenu() {
    open.set(false);
    highlightedItem.set(null);
  }
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const isSelected = derived([selected], ([$selected]) => {
    return (value) => {
      if (Array.isArray($selected)) {
        return $selected.some((o2) => dequal(o2.value, value));
      }
      if (isObject2(value)) {
        return dequal($selected?.value, stripValues(value, void 0));
      }
      return dequal($selected?.value, value);
    };
  });
  const isHighlighted = derived([highlighted], ([$value]) => {
    return (item) => {
      return dequal($value?.value, item);
    };
  });
  const trigger = makeElement(name2("trigger"), {
    stores: [open, highlightedItem, disabled, ids.menu, ids.trigger, ids.label],
    returned: ([$open, $highlightedItem, $disabled, $menuId, $triggerId, $labelId]) => {
      return {
        "aria-activedescendant": $highlightedItem?.id,
        "aria-autocomplete": "list",
        "aria-controls": $menuId,
        "aria-expanded": $open,
        "aria-labelledby": $labelId,
        // autocomplete: 'off',
        id: $triggerId,
        role: "combobox",
        disabled: disabledAttr($disabled),
        type: withDefaults.builder === "select" ? "button" : void 0
      };
    },
    action: (node) => {
      const isInput3 = isHTMLInputElement(node);
      const unsubscribe = executeCallbacks(
        addMeltEventListener(node, "click", () => {
          node.focus();
          const $open = open.get();
          if ($open) {
            closeMenu();
          } else {
            openMenu();
          }
        }),
        // Handle all input key events including typing, meta, and navigation.
        addMeltEventListener(node, "keydown", (e3) => {
          const $open = open.get();
          if (!$open) {
            if (INTERACTION_KEYS.includes(e3.key)) {
              return;
            }
            if (e3.key === kbd.TAB) {
              return;
            }
            if (e3.key === kbd.BACKSPACE && isInput3 && node.value === "") {
              return;
            }
            if (e3.key === kbd.SPACE && isHTMLButtonElement(node)) {
              return;
            }
            openMenu();
            tick().then(() => {
              const $selectedItem = selected.get();
              if ($selectedItem)
                return;
              const menuEl = document.getElementById(ids.menu.get());
              if (!isHTMLElement(menuEl))
                return;
              const enabledItems = Array.from(menuEl.querySelectorAll(`${selector("item")}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement(item));
              if (!enabledItems.length)
                return;
              if (e3.key === kbd.ARROW_DOWN) {
                highlightedItem.set(enabledItems[0]);
                enabledItems[0].scrollIntoView({ block: scrollAlignment.get() });
              } else if (e3.key === kbd.ARROW_UP) {
                highlightedItem.set(last(enabledItems));
                last(enabledItems).scrollIntoView({ block: scrollAlignment.get() });
              }
            });
          }
          if (e3.key === kbd.TAB) {
            closeMenu();
            return;
          }
          if (e3.key === kbd.ENTER && !e3.isComposing || e3.key === kbd.SPACE && isHTMLButtonElement(node)) {
            e3.preventDefault();
            const $highlightedItem = highlightedItem.get();
            if ($highlightedItem) {
              selectItem($highlightedItem);
            }
            if (!multiple.get()) {
              closeMenu();
            }
          }
          if (e3.key === kbd.ARROW_UP && e3.altKey) {
            closeMenu();
          }
          if (FIRST_LAST_KEYS.includes(e3.key)) {
            e3.preventDefault();
            const menuElement = document.getElementById(ids.menu.get());
            if (!isHTMLElement(menuElement))
              return;
            const itemElements = getOptions(menuElement);
            if (!itemElements.length)
              return;
            const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === void 0);
            const $currentItem = highlightedItem.get();
            const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;
            const $loop = loop.get();
            const $scrollAlignment = scrollAlignment.get();
            let nextItem;
            switch (e3.key) {
              case kbd.ARROW_DOWN:
                nextItem = next(candidateNodes, currentIndex, $loop);
                break;
              case kbd.ARROW_UP:
                nextItem = prev(candidateNodes, currentIndex, $loop);
                break;
              case kbd.PAGE_DOWN:
                nextItem = forward(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.PAGE_UP:
                nextItem = back(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.HOME:
                nextItem = candidateNodes[0];
                break;
              case kbd.END:
                nextItem = last(candidateNodes);
                break;
              default:
                return;
            }
            highlightedItem.set(nextItem);
            nextItem?.scrollIntoView({ block: $scrollAlignment });
          } else if (typeahead.get()) {
            const menuEl = document.getElementById(ids.menu.get());
            if (!isHTMLElement(menuEl))
              return;
            handleTypeaheadSearch(e3.key, getOptions(menuEl));
          }
        })
      );
      let unsubEscapeKeydown = noop3;
      const escape = useEscapeKeydown(node, {
        handler: closeMenu,
        enabled: derived([open, closeOnEscape], ([$open, $closeOnEscape]) => {
          return $open && $closeOnEscape;
        })
      });
      if (escape && escape.destroy) {
        unsubEscapeKeydown = escape.destroy;
      }
      return {
        destroy() {
          unsubscribe();
          unsubEscapeKeydown();
        }
      };
    }
  });
  const menu = makeElement(name2("menu"), {
    stores: [isVisible, ids.menu],
    returned: ([$isVisible, $menuId]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        id: $menuId,
        role: "listbox",
        style: styleToString({ display: $isVisible ? void 0 : "none" })
      };
    },
    action: (node) => {
      let unsubPopper = noop3;
      const unsubscribe = executeCallbacks(
        // Bind the popper portal to the input element.
        effect2([isVisible, portal, closeOnOutsideClick, positioning, activeTrigger], ([$isVisible, $portal, $closeOnOutsideClick, $positioning, $activeTrigger]) => {
          unsubPopper();
          if (!$isVisible || !$activeTrigger)
            return;
          tick().then(() => {
            unsubPopper();
            const ignoreHandler = createClickOutsideIgnore(ids.trigger.get());
            unsubPopper = usePopper(node, {
              anchorElement: $activeTrigger,
              open,
              options: {
                floating: $positioning,
                focusTrap: null,
                modal: {
                  closeOnInteractOutside: $closeOnOutsideClick,
                  onClose: closeMenu,
                  open: $isVisible,
                  shouldCloseOnInteractOutside: (e3) => {
                    onOutsideClick.get()?.(e3);
                    if (e3.defaultPrevented)
                      return false;
                    const target = e3.target;
                    if (!isElement(target))
                      return false;
                    if (target === $activeTrigger || $activeTrigger.contains(target)) {
                      return false;
                    }
                    if (ignoreHandler(e3))
                      return false;
                    return true;
                  }
                },
                escapeKeydown: null,
                portal: getPortalDestination(node, $portal)
              }
            }).destroy;
          });
        })
      );
      return {
        destroy: () => {
          unsubscribe();
          unsubPopper();
        }
      };
    }
  });
  const { elements: { root: labelBuilder } } = createLabel();
  const { action: labelAction } = get_store_value(labelBuilder);
  const label = makeElement(name2("label"), {
    stores: [ids.label, ids.trigger],
    returned: ([$labelId, $triggerId]) => {
      return {
        id: $labelId,
        for: $triggerId
      };
    },
    action: labelAction
  });
  const option = makeElement(name2("option"), {
    stores: [isSelected],
    returned: ([$isSelected]) => (props2) => {
      const selected2 = $isSelected(props2.value);
      return {
        "data-value": JSON.stringify(props2.value),
        "data-label": props2.label,
        "data-disabled": disabledAttr(props2.disabled),
        "aria-disabled": props2.disabled ? true : void 0,
        "aria-selected": selected2,
        "data-selected": selected2 ? "" : void 0,
        id: generateId(),
        role: "option"
      };
    },
    action: (node) => {
      const unsubscribe = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        if (isElementDisabled(node)) {
          e3.preventDefault();
          return;
        }
        selectItem(node);
        if (!multiple.get()) {
          closeMenu();
        }
      }), effect2(highlightOnHover, ($highlightOnHover) => {
        if (!$highlightOnHover)
          return;
        const unsub = executeCallbacks(addMeltEventListener(node, "mouseover", () => {
          highlightedItem.set(node);
        }), addMeltEventListener(node, "mouseleave", () => {
          highlightedItem.set(null);
        }));
        return unsub;
      }));
      return { destroy: unsubscribe };
    }
  });
  const group = makeElement(name2("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = makeElement(name2("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const hiddenInput = createHiddenInput({
    value: derived([selected], ([$selected]) => {
      const value = Array.isArray($selected) ? $selected.map((o2) => o2.value) : $selected?.value;
      return typeof value === "string" ? value : JSON.stringify(value);
    }),
    name: readonly(nameProp),
    required,
    prefix: withDefaults.builder
  });
  const arrow2 = makeElement(name2("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  safeOnMount(() => {
    if (!isBrowser2)
      return;
    const menuEl = document.getElementById(ids.menu.get());
    const triggerEl = document.getElementById(ids.trigger.get());
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
    if (!menuEl)
      return;
    const selectedEl = menuEl.querySelector("[data-selected]");
    if (!isHTMLElement(selectedEl))
      return;
  });
  effect2([highlightedItem], ([$highlightedItem]) => {
    if (!isBrowser2)
      return;
    const menuElement = document.getElementById(ids.menu.get());
    if (!isHTMLElement(menuElement))
      return;
    getOptions(menuElement).forEach((node) => {
      if (node === $highlightedItem) {
        addHighlight(node);
      } else {
        removeHighlight(node);
      }
    });
  });
  effect2([open], ([$open]) => {
    if (!isBrowser2)
      return;
    let unsubScroll = noop3;
    if (preventScroll.get() && $open) {
      unsubScroll = removeScroll();
    }
    return () => {
      unsubScroll();
    };
  });
  return {
    ids,
    elements: {
      trigger,
      group,
      option,
      menu,
      groupLabel,
      label,
      hiddenInput,
      arrow: arrow2
    },
    states: {
      open,
      selected,
      highlighted,
      highlightedItem
    },
    helpers: {
      isSelected,
      isHighlighted,
      closeMenu
    },
    options: options2
  };
}
function createSelect(props) {
  const listbox = createListbox({ ...props, builder: "select" });
  const selectedLabel = derived(listbox.states.selected, ($selected) => {
    if (Array.isArray($selected)) {
      return $selected.map((o2) => o2.label).join(", ");
    }
    return $selected?.label ?? "";
  });
  return {
    ...listbox,
    elements: {
      ...listbox.elements
    },
    states: {
      ...listbox.states,
      selectedLabel
    }
  };
}
function arraysAreEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((value, index21) => value === arr2[index21]);
}
function getSelectData() {
  const NAME = "select";
  const GROUP_NAME = "select-group";
  const ITEM_NAME = "select-item";
  const PARTS = [
    "arrow",
    "content",
    "group",
    "item",
    "indicator",
    "input",
    "label",
    "trigger",
    "value"
  ];
  return {
    NAME,
    GROUP_NAME,
    ITEM_NAME,
    PARTS
  };
}
function getCtx3() {
  const { NAME } = getSelectData();
  return getContext(NAME);
}
function setCtx4(props) {
  const { NAME, PARTS } = getSelectData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const select = {
    ...createSelect({ ...removeUndefined2(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, select);
  return {
    ...select,
    updateOption: getOptionUpdater(select.options)
  };
}
function setItemCtx(value) {
  const { ITEM_NAME } = getSelectData();
  const select = getCtx3();
  setContext(ITEM_NAME, value);
  return select;
}
function getItemIndicator() {
  const { ITEM_NAME } = getSelectData();
  const { helpers: { isSelected }, getAttrs: getAttrs2 } = getCtx3();
  const value = getContext(ITEM_NAME);
  return {
    value,
    isSelected,
    getAttrs: getAttrs2
  };
}
function updatePositioning4(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center",
    sameWidth: true
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx3();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}
function Select($$payload, $$props) {
  push();
  var $$store_subs;
  let required = value_or_fallback($$props["required"], () => void 0);
  let disabled = value_or_fallback($$props["disabled"], () => void 0);
  let preventScroll = value_or_fallback($$props["preventScroll"], () => void 0);
  let loop = value_or_fallback($$props["loop"], () => void 0);
  let closeOnEscape = value_or_fallback($$props["closeOnEscape"], () => void 0);
  let closeOnOutsideClick = value_or_fallback($$props["closeOnOutsideClick"], () => void 0);
  let portal = value_or_fallback($$props["portal"], () => void 0);
  let name2 = value_or_fallback($$props["name"], () => void 0);
  let multiple = value_or_fallback($$props["multiple"], () => false);
  let selected = value_or_fallback($$props["selected"], () => void 0);
  let onSelectedChange = value_or_fallback($$props["onSelectedChange"], () => void 0);
  let open = value_or_fallback($$props["open"], () => void 0);
  let onOpenChange = value_or_fallback($$props["onOpenChange"], () => void 0);
  let items = value_or_fallback($$props["items"], () => []);
  let onOutsideClick = value_or_fallback($$props["onOutsideClick"], () => void 0);
  const {
    states: { open: localOpen, selected: localSelected },
    updateOption,
    ids
  } = setCtx4({
    required,
    disabled,
    preventScroll,
    loop,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    name: name2,
    onOutsideClick,
    multiple,
    forceVisible: true,
    defaultSelected: Array.isArray(selected) ? [...selected] : selected,
    defaultOpen: open,
    onSelectedChange: ({ next: next2 }) => {
      if (Array.isArray(next2)) {
        if (!Array.isArray(selected) || !arraysAreEqual(selected, next2)) {
          onSelectedChange?.(next2);
          selected = next2;
          return next2;
        }
        return next2;
      }
      if (selected !== next2) {
        onSelectedChange?.(next2);
        selected = next2;
      }
      return next2;
    },
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    },
    items
  });
  const idValues = derived([ids.menu, ids.trigger, ids.label], ([$menuId, $triggerId, $labelId]) => ({
    menu: $menuId,
    trigger: $triggerId,
    label: $labelId
  }));
  open !== void 0 && localOpen.set(open);
  selected !== void 0 && localSelected.set(Array.isArray(selected) ? [...selected] : selected);
  updateOption("required", required);
  updateOption("disabled", disabled);
  updateOption("preventScroll", preventScroll);
  updateOption("loop", loop);
  updateOption("closeOnEscape", closeOnEscape);
  updateOption("closeOnOutsideClick", closeOnOutsideClick);
  updateOption("portal", portal);
  updateOption("name", name2);
  updateOption("multiple", multiple);
  updateOption("onOutsideClick", onOutsideClick);
  $$payload.out += `<!--[-->`;
  slot(
    $$payload,
    default_slot($$props),
    {
      get ids() {
        return store_get($$store_subs ??= {}, "$idValues", idValues);
      }
    },
    null
  );
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    required,
    disabled,
    preventScroll,
    loop,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    name: name2,
    multiple,
    selected,
    onSelectedChange,
    open,
    onOpenChange,
    items,
    onOutsideClick
  });
  pop();
}
function Select_content$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = value_or_fallback($$props["transition"], () => void 0);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], () => void 0);
  let inTransition = value_or_fallback($$props["inTransition"], () => void 0);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], () => void 0);
  let outTransition = value_or_fallback($$props["outTransition"], () => void 0);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let id = value_or_fallback($$props["id"], () => void 0);
  let side = value_or_fallback($$props["side"], () => "bottom");
  let align = value_or_fallback($$props["align"], () => "center");
  let sideOffset = value_or_fallback($$props["sideOffset"], () => 0);
  let alignOffset = value_or_fallback($$props["alignOffset"], () => 0);
  let collisionPadding = value_or_fallback($$props["collisionPadding"], () => 8);
  let avoidCollisions = value_or_fallback($$props["avoidCollisions"], () => true);
  let collisionBoundary = value_or_fallback($$props["collisionBoundary"], () => void 0);
  let sameWidth = value_or_fallback($$props["sameWidth"], () => true);
  let fitViewport = value_or_fallback($$props["fitViewport"], () => false);
  let strategy = value_or_fallback($$props["strategy"], () => "absolute");
  let overlap = value_or_fallback($$props["overlap"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const {
    elements: { menu },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx3();
  const attrs = getAttrs2("content");
  if (id) {
    ids.menu.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$menu", menu);
  Object.assign(builder, attrs);
  if (store_get($$store_subs ??= {}, "$open", open)) {
    updatePositioning4({
      side,
      align,
      sideOffset,
      alignOffset,
      collisionPadding,
      avoidCollisions,
      collisionBoundary,
      sameWidth,
      fitViewport,
      strategy,
      overlap
    });
  }
  $$payload.out += `<!--[-->`;
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
      slot(
        $$payload,
        default_slot($$props),
        {
          get builder() {
            return builder;
          }
        },
        null
      );
      $$payload.out += `<!--]--></div>`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += `<!--[-->`;
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
        slot(
          $$payload,
          default_slot($$props),
          {
            get builder() {
              return builder;
            }
          },
          null
        );
        $$payload.out += `<!--]--></div>`;
        $$payload.out += "<!--]-->";
      } else {
        $$payload.out += `<!--[-->`;
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
          slot(
            $$payload,
            default_slot($$props),
            {
              get builder() {
                return builder;
              }
            },
            null
          );
          $$payload.out += `<!--]--></div>`;
          $$payload.out += "<!--]-->";
        } else {
          $$payload.out += `<!--[-->`;
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
            slot(
              $$payload,
              default_slot($$props),
              {
                get builder() {
                  return builder;
                }
              },
              null
            );
            $$payload.out += `<!--]--></div>`;
            $$payload.out += "<!--]-->";
          } else {
            $$payload.out += `<!--[-->`;
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
              slot(
                $$payload,
                default_slot($$props),
                {
                  get builder() {
                    return builder;
                  }
                },
                null
              );
              $$payload.out += `<!--]--></div>`;
              $$payload.out += "<!--]-->";
            } else {
              $$payload.out += "<!--]!-->";
            }
            $$payload.out += "<!--]!-->";
          }
          $$payload.out += "<!--]!-->";
        }
        $$payload.out += "<!--]!-->";
      }
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    side,
    align,
    sideOffset,
    alignOffset,
    collisionPadding,
    avoidCollisions,
    collisionBoundary,
    sameWidth,
    fitViewport,
    strategy,
    overlap,
    el
  });
  pop();
}
function Select_item$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "value",
    "disabled",
    "label",
    "asChild",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder, isSelected;
  let value = $$props["value"];
  let disabled = value_or_fallback($$props["disabled"], () => void 0);
  let label = value_or_fallback($$props["label"], () => void 0);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const {
    elements: { option: item },
    helpers: { isSelected: isSelectedStore },
    getAttrs: getAttrs2
  } = setItemCtx(value);
  const attrs = getAttrs2("item");
  builder = store_get($$store_subs ??= {}, "$item", item)({ value, disabled, label });
  Object.assign(builder, attrs);
  isSelected = store_get($$store_subs ??= {}, "$isSelectedStore", isSelectedStore)(value);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        },
        get isSelected() {
          return isSelected;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        },
        get isSelected() {
          return isSelected;
        }
      },
      () => {
        $$payload.out += `${escape_html(label || value)}`;
      }
    );
    $$payload.out += `<!--]--></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { value, disabled, label, asChild, el });
  pop();
}
function Select_item_indicator($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { isSelected, value, getAttrs: getAttrs2 } = getItemIndicator();
  const attrs = getAttrs2("indicator");
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        attrs,
        get isSelected() {
          return store_get($$store_subs ??= {}, "$isSelected", isSelected)(value);
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...$$restProps, ...attrs })}><!--[-->`;
    if (store_get($$store_subs ??= {}, "$isSelected", isSelected)(value)) {
      $$payload.out += `<!--[-->`;
      slot(
        $$payload,
        default_slot($$props),
        {
          attrs,
          get isSelected() {
            return store_get($$store_subs ??= {}, "$isSelected", isSelected)(value);
          }
        },
        null
      );
      $$payload.out += `<!--]-->`;
      $$payload.out += "<!--]-->";
    } else {
      $$payload.out += "<!--]!-->";
    }
    $$payload.out += `</div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Select_trigger$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let id = value_or_fallback($$props["id"], () => void 0);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx3();
  const attrs = getAttrs2("trigger");
  if (id) {
    ids.trigger.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$trigger", trigger);
  Object.assign(builder, attrs);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get builder() {
          return builder;
        }
      },
      null
    );
    $$payload.out += `<!--]--></button>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, id, el });
  pop();
}
function Select_value($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["placeholder", "asChild", "el"]);
  push();
  var $$store_subs;
  let label;
  let placeholder = value_or_fallback($$props["placeholder"], () => "");
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  const { states: { selectedLabel }, getAttrs: getAttrs2 } = getCtx3();
  const attrs = getAttrs2("value");
  label = store_get($$store_subs ??= {}, "$selectedLabel", selectedLabel);
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get label() {
          return label;
        },
        attrs
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<span${spread_attributes({
      ...$$restProps,
      ...attrs,
      "data-placeholder": !label ? "" : void 0
    })}>${escape_html(label || placeholder)}</span>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { placeholder, asChild, el });
  pop();
}
function Form_button($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, []);
  push();
  $$payload.out += `<!--[-->`;
  Button($$payload, spread_props([
    { type: "submit" },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Select_item($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "value", "label", "disabled"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let value = $$props["value"];
  let label = value_or_fallback($$props["label"], () => void 0);
  let disabled = value_or_fallback($$props["disabled"], () => void 0);
  $$payload.out += `<!--[-->`;
  Select_item$1($$payload, spread_props([
    {
      value,
      disabled,
      label,
      class: cn("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground data-[disabled]:opacity-50", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<span class="absolute left-2 flex h-3.5 w-3.5 items-center justify-center"><!--[-->`;
        Select_item_indicator($$payload2, {
          children: ($$payload3, $$slotProps2) => {
            $$payload3.out += `<!--[-->`;
            Check($$payload3, { class: "h-4 w-4" });
            $$payload3.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload2.out += `<!--]--></span> <!--[-->`;
        slot($$payload2, default_slot($$props), {}, () => {
          $$payload2.out += `${escape_html(label || value)}`;
        });
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className, value, label, disabled });
  pop();
}
function Select_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "sideOffset",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "class"
  ]);
  push();
  let sideOffset = value_or_fallback($$props["sideOffset"], () => 4);
  let inTransition = value_or_fallback($$props["inTransition"], () => flyAndScale);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], () => void 0);
  let outTransition = value_or_fallback($$props["outTransition"], () => scale);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], () => ({ start: 0.95, opacity: 0, duration: 50 }));
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<!--[-->`;
  Select_content$1($$payload, spread_props([
    {
      inTransition,
      inTransitionConfig,
      outTransition,
      outTransitionConfig,
      sideOffset,
      class: cn("relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md outline-none", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<div class="w-full p-1"><!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]--></div>`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, {
    sideOffset,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    class: className
  });
  pop();
}
function Select_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<!--[-->`;
  Select_trigger$1($$payload, spread_props([
    {
      class: cn("flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        const builder = $$slotProps.builder;
        $$payload2.out += `<!--[-->`;
        slot(
          $$payload2,
          default_slot($$props),
          {
            get builder() {
              return builder;
            }
          },
          null
        );
        $$payload2.out += `<!--]--> <div><!--[-->`;
        Chevron_down($$payload2, { class: "h-4 w-4 opacity-50" });
        $$payload2.out += `<!--]--></div>`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className });
  pop();
}
var INTERACTION_KEYS, defaults5, listboxIdParts, Root4, Value;
var init_index7 = __esm({
  ".svelte-kit/output/server/chunks/index7.js"() {
    init_index3();
    init_index4();
    init_misc();
    init_Icon();
    init_index6();
    init_index2();
    init_helpers();
    init_index_server();
    init_form_field_errors();
    init_input();
    init_clsx();
    INTERACTION_KEYS = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];
    defaults5 = {
      positioning: {
        placement: "bottom",
        sameWidth: true
      },
      scrollAlignment: "nearest",
      loop: true,
      defaultOpen: false,
      closeOnOutsideClick: true,
      preventScroll: true,
      closeOnEscape: true,
      forceVisible: false,
      portal: void 0,
      builder: "listbox",
      disabled: false,
      required: false,
      name: void 0,
      typeahead: true,
      highlightOnHover: true,
      onOutsideClick: void 0
    };
    listboxIdParts = ["trigger", "menu", "label"];
    Root4 = Select;
    Value = Select_value;
  }
});

// node_modules/.pnpm/mapbox-gl@3.4.0/node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/.pnpm/mapbox-gl@3.4.0/node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker2, mapboxgl;
      function define2(_2, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker2) {
          worker2 = chunk;
        } else {
          var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker2 + ")(sharedChunk); self.onerror = null;";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl = chunk(sharedChunk);
          if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
            mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t2) {
        "use strict";
        var e3 = "3.4.0";
        let r3;
        const n2 = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          if (null == r3) {
            const t3 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            try {
              r3 = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t3;
            } catch (e4) {
              r3 = t3;
            }
          }
          return r3;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!n2.API_URL)
            return null;
          try {
            const t3 = new URL(n2.API_URL);
            return "api.mapbox.cn" === t3.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t3.hostname ? "https://events.mapbox.com/events/v2" : null;
          } catch (t3) {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf" };
        function i2(t3) {
          return n2.API_URL_REGEX.test(t3);
        }
        function s3(t3) {
          return 0 === t3.indexOf("mapbox:");
        }
        function a2(t3) {
          return n2.API_CDN_URL_REGEX.test(t3);
        }
        function o2(t3) {
          return n2.API_SPRITE_REGEX.test(t3);
        }
        function l2(t3) {
          return n2.API_STYLE_REGEX.test(t3) && !o2(t3);
        }
        const u2 = { create: "create", load: "load", fullLoad: "fullLoad" };
        function c2(t3) {
          const e4 = t3.name.split("?")[0];
          return a2(e4) && e4.includes("mapbox-gl.js") ? "javascript" : a2(e4) && e4.includes("mapbox-gl.css") ? "css" : function(t4) {
            return n2.API_FONTS_REGEX.test(t4);
          }(e4) ? "fontRange" : o2(e4) ? "sprite" : l2(e4) ? "style" : function(t4) {
            return n2.API_TILEJSON_REGEX.test(t4);
          }(e4) ? "tilejson" : "other";
        }
        function h(t3) {
          return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
        }
        var p2 = {}, f = {};
        Object.defineProperty(f, "__esModule", { value: true }), f.setMatrixArrayType = function(t3) {
          f.ARRAY_TYPE = m = t3;
        }, f.toRadian = function(t3) {
          return t3 * g2;
        }, f.equals = function(t3, e4) {
          return Math.abs(t3 - e4) <= d * Math.max(1, Math.abs(t3), Math.abs(e4));
        }, f.RANDOM = f.ARRAY_TYPE = f.EPSILON = void 0;
        var d = 1e-6;
        f.EPSILON = d;
        var m = "undefined" != typeof Float32Array ? Float32Array : Array;
        f.ARRAY_TYPE = m;
        var y2 = Math.random;
        f.RANDOM = y2;
        var g2 = Math.PI / 180;
        Math.hypot || (Math.hypot = function() {
          for (var t3 = 0, e4 = arguments.length; e4--; )
            t3 += arguments[e4] * arguments[e4];
          return Math.sqrt(t3);
        });
        var x2 = {};
        function b(t3) {
          return b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, b(t3);
        }
        Object.defineProperty(x2, "__esModule", { value: true }), x2.create = function() {
          var t3 = new v2.ARRAY_TYPE(4);
          return v2.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0), t3[0] = 1, t3[3] = 1, t3;
        }, x2.clone = function(t3) {
          var e4 = new v2.ARRAY_TYPE(4);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4;
        }, x2.copy = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3;
        }, x2.identity = function(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
        }, x2.fromValues = function(t3, e4, r4, n3) {
          var i3 = new v2.ARRAY_TYPE(4);
          return i3[0] = t3, i3[1] = e4, i3[2] = r4, i3[3] = n3, i3;
        }, x2.set = function(t3, e4, r4, n3, i3) {
          return t3[0] = e4, t3[1] = r4, t3[2] = n3, t3[3] = i3, t3;
        }, x2.transpose = function(t3, e4) {
          if (t3 === e4) {
            var r4 = e4[1];
            t3[1] = e4[2], t3[2] = r4;
          } else
            t3[0] = e4[0], t3[1] = e4[2], t3[2] = e4[1], t3[3] = e4[3];
          return t3;
        }, x2.invert = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = r4 * s4 - i3 * n3;
          return a3 ? (t3[0] = s4 * (a3 = 1 / a3), t3[1] = -n3 * a3, t3[2] = -i3 * a3, t3[3] = r4 * a3, t3) : null;
        }, x2.adjoint = function(t3, e4) {
          var r4 = e4[0];
          return t3[0] = e4[3], t3[1] = -e4[1], t3[2] = -e4[2], t3[3] = r4, t3;
        }, x2.determinant = function(t3) {
          return t3[0] * t3[3] - t3[2] * t3[1];
        }, x2.multiply = w, x2.rotate = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = Math.sin(r4), l3 = Math.cos(r4);
          return t3[0] = n3 * l3 + s4 * o3, t3[1] = i3 * l3 + a3 * o3, t3[2] = n3 * -o3 + s4 * l3, t3[3] = i3 * -o3 + a3 * l3, t3;
        }, x2.scale = function(t3, e4, r4) {
          var n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = r4[0], o3 = r4[1];
          return t3[0] = e4[0] * a3, t3[1] = n3 * a3, t3[2] = i3 * o3, t3[3] = s4 * o3, t3;
        }, x2.fromRotation = function(t3, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t3[0] = n3, t3[1] = r4, t3[2] = -r4, t3[3] = n3, t3;
        }, x2.fromScaling = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = 0, t3[2] = 0, t3[3] = e4[1], t3;
        }, x2.str = function(t3) {
          return "mat2(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
        }, x2.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
        }, x2.LDU = function(t3, e4, r4, n3) {
          return t3[2] = n3[2] / n3[0], r4[0] = n3[0], r4[1] = n3[1], r4[3] = n3[3] - t3[2] * r4[1], [t3, e4, r4];
        }, x2.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3[2] = e4[2] + r4[2], t3[3] = e4[3] + r4[3], t3;
        }, x2.subtract = M2, x2.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1] && t3[2] === e4[2] && t3[3] === e4[3];
        }, x2.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = t3[3], a3 = e4[0], o3 = e4[1], l3 = e4[2], u3 = e4[3];
          return Math.abs(r4 - a3) <= v2.EPSILON * Math.max(1, Math.abs(r4), Math.abs(a3)) && Math.abs(n3 - o3) <= v2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i3 - l3) <= v2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(l3)) && Math.abs(s4 - u3) <= v2.EPSILON * Math.max(1, Math.abs(s4), Math.abs(u3));
        }, x2.multiplyScalar = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3[2] = e4[2] * r4, t3[3] = e4[3] * r4, t3;
        }, x2.multiplyScalarAndAdd = function(t3, e4, r4, n3) {
          return t3[0] = e4[0] + r4[0] * n3, t3[1] = e4[1] + r4[1] * n3, t3[2] = e4[2] + r4[2] * n3, t3[3] = e4[3] + r4[3] * n3, t3;
        }, x2.sub = x2.mul = void 0;
        var v2 = function(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== b(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = _2(void 0);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }(f);
        function _2(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (_2 = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function w(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = r4[0], l3 = r4[1], u3 = r4[2], c3 = r4[3];
          return t3[0] = n3 * o3 + s4 * l3, t3[1] = i3 * o3 + a3 * l3, t3[2] = n3 * u3 + s4 * c3, t3[3] = i3 * u3 + a3 * c3, t3;
        }
        function M2(t3, e4, r4) {
          return t3[0] = e4[0] - r4[0], t3[1] = e4[1] - r4[1], t3[2] = e4[2] - r4[2], t3[3] = e4[3] - r4[3], t3;
        }
        x2.mul = w, x2.sub = M2;
        var A = {};
        function S(t3) {
          return S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, S(t3);
        }
        Object.defineProperty(A, "__esModule", { value: true }), A.create = function() {
          var t3 = new I.ARRAY_TYPE(6);
          return I.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[4] = 0, t3[5] = 0), t3[0] = 1, t3[3] = 1, t3;
        }, A.clone = function(t3) {
          var e4 = new I.ARRAY_TYPE(6);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4;
        }, A.copy = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3;
        }, A.identity = function(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0, t3[5] = 0, t3;
        }, A.fromValues = function(t3, e4, r4, n3, i3, s4) {
          var a3 = new I.ARRAY_TYPE(6);
          return a3[0] = t3, a3[1] = e4, a3[2] = r4, a3[3] = n3, a3[4] = i3, a3[5] = s4, a3;
        }, A.set = function(t3, e4, r4, n3, i3, s4, a3) {
          return t3[0] = e4, t3[1] = r4, t3[2] = n3, t3[3] = i3, t3[4] = s4, t3[5] = a3, t3;
        }, A.invert = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l3 = r4 * s4 - n3 * i3;
          return l3 ? (t3[0] = s4 * (l3 = 1 / l3), t3[1] = -n3 * l3, t3[2] = -i3 * l3, t3[3] = r4 * l3, t3[4] = (i3 * o3 - s4 * a3) * l3, t3[5] = (n3 * a3 - r4 * o3) * l3, t3) : null;
        }, A.determinant = function(t3) {
          return t3[0] * t3[3] - t3[1] * t3[2];
        }, A.multiply = P, A.rotate = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = Math.sin(r4), c3 = Math.cos(r4);
          return t3[0] = n3 * c3 + s4 * u3, t3[1] = i3 * c3 + a3 * u3, t3[2] = n3 * -u3 + s4 * c3, t3[3] = i3 * -u3 + a3 * c3, t3[4] = o3, t3[5] = l3, t3;
        }, A.scale = function(t3, e4, r4) {
          var n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l3 = r4[0], u3 = r4[1];
          return t3[0] = e4[0] * l3, t3[1] = n3 * l3, t3[2] = i3 * u3, t3[3] = s4 * u3, t3[4] = a3, t3[5] = o3, t3;
        }, A.translate = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = r4[0], c3 = r4[1];
          return t3[0] = n3, t3[1] = i3, t3[2] = s4, t3[3] = a3, t3[4] = n3 * u3 + s4 * c3 + o3, t3[5] = i3 * u3 + a3 * c3 + l3, t3;
        }, A.fromRotation = function(t3, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t3[0] = n3, t3[1] = r4, t3[2] = -r4, t3[3] = n3, t3[4] = 0, t3[5] = 0, t3;
        }, A.fromScaling = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = 0, t3[2] = 0, t3[3] = e4[1], t3[4] = 0, t3[5] = 0, t3;
        }, A.fromTranslation = function(t3, e4) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = e4[0], t3[5] = e4[1], t3;
        }, A.str = function(t3) {
          return "mat2d(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ")";
        }, A.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], 1);
        }, A.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3[2] = e4[2] + r4[2], t3[3] = e4[3] + r4[3], t3[4] = e4[4] + r4[4], t3[5] = e4[5] + r4[5], t3;
        }, A.subtract = E, A.multiplyScalar = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3[2] = e4[2] * r4, t3[3] = e4[3] * r4, t3[4] = e4[4] * r4, t3[5] = e4[5] * r4, t3;
        }, A.multiplyScalarAndAdd = function(t3, e4, r4, n3) {
          return t3[0] = e4[0] + r4[0] * n3, t3[1] = e4[1] + r4[1] * n3, t3[2] = e4[2] + r4[2] * n3, t3[3] = e4[3] + r4[3] * n3, t3[4] = e4[4] + r4[4] * n3, t3[5] = e4[5] + r4[5] * n3, t3;
        }, A.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1] && t3[2] === e4[2] && t3[3] === e4[3] && t3[4] === e4[4] && t3[5] === e4[5];
        }, A.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = t3[3], a3 = t3[4], o3 = t3[5], l3 = e4[0], u3 = e4[1], c3 = e4[2], h2 = e4[3], p3 = e4[4], f2 = e4[5];
          return Math.abs(r4 - l3) <= I.EPSILON * Math.max(1, Math.abs(r4), Math.abs(l3)) && Math.abs(n3 - u3) <= I.EPSILON * Math.max(1, Math.abs(n3), Math.abs(u3)) && Math.abs(i3 - c3) <= I.EPSILON * Math.max(1, Math.abs(i3), Math.abs(c3)) && Math.abs(s4 - h2) <= I.EPSILON * Math.max(1, Math.abs(s4), Math.abs(h2)) && Math.abs(a3 - p3) <= I.EPSILON * Math.max(1, Math.abs(a3), Math.abs(p3)) && Math.abs(o3 - f2) <= I.EPSILON * Math.max(1, Math.abs(o3), Math.abs(f2));
        }, A.sub = A.mul = void 0;
        var I = function(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== S(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = k(void 0);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }(f);
        function k(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (k = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function P(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = r4[0], c3 = r4[1], h2 = r4[2], p3 = r4[3], f2 = r4[4], d2 = r4[5];
          return t3[0] = n3 * u3 + s4 * c3, t3[1] = i3 * u3 + a3 * c3, t3[2] = n3 * h2 + s4 * p3, t3[3] = i3 * h2 + a3 * p3, t3[4] = n3 * f2 + s4 * d2 + o3, t3[5] = i3 * f2 + a3 * d2 + l3, t3;
        }
        function E(t3, e4, r4) {
          return t3[0] = e4[0] - r4[0], t3[1] = e4[1] - r4[1], t3[2] = e4[2] - r4[2], t3[3] = e4[3] - r4[3], t3[4] = e4[4] - r4[4], t3[5] = e4[5] - r4[5], t3;
        }
        A.mul = P, A.sub = E;
        var z2 = {};
        function T(t3) {
          return T = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, T(t3);
        }
        Object.defineProperty(z2, "__esModule", { value: true }), z2.create = function() {
          var t3 = new B.ARRAY_TYPE(9);
          return B.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
        }, z2.fromMat4 = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[4], t3[4] = e4[5], t3[5] = e4[6], t3[6] = e4[8], t3[7] = e4[9], t3[8] = e4[10], t3;
        }, z2.clone = function(t3) {
          var e4 = new B.ARRAY_TYPE(9);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4[8] = t3[8], e4;
        }, z2.copy = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3[8] = e4[8], t3;
        }, z2.fromValues = function(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          var u3 = new B.ARRAY_TYPE(9);
          return u3[0] = t3, u3[1] = e4, u3[2] = r4, u3[3] = n3, u3[4] = i3, u3[5] = s4, u3[6] = a3, u3[7] = o3, u3[8] = l3, u3;
        }, z2.set = function(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3) {
          return t3[0] = e4, t3[1] = r4, t3[2] = n3, t3[3] = i3, t3[4] = s4, t3[5] = a3, t3[6] = o3, t3[7] = l3, t3[8] = u3, t3;
        }, z2.identity = function(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 1, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, z2.transpose = function(t3, e4) {
          if (t3 === e4) {
            var r4 = e4[1], n3 = e4[2], i3 = e4[5];
            t3[1] = e4[3], t3[2] = e4[6], t3[3] = r4, t3[5] = e4[7], t3[6] = n3, t3[7] = i3;
          } else
            t3[0] = e4[0], t3[1] = e4[3], t3[2] = e4[6], t3[3] = e4[1], t3[4] = e4[4], t3[5] = e4[7], t3[6] = e4[2], t3[7] = e4[5], t3[8] = e4[8];
          return t3;
        }, z2.invert = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l3 = e4[6], u3 = e4[7], c3 = e4[8], h2 = c3 * a3 - o3 * u3, p3 = -c3 * s4 + o3 * l3, f2 = u3 * s4 - a3 * l3, d2 = r4 * h2 + n3 * p3 + i3 * f2;
          return d2 ? (t3[0] = h2 * (d2 = 1 / d2), t3[1] = (-c3 * n3 + i3 * u3) * d2, t3[2] = (o3 * n3 - i3 * a3) * d2, t3[3] = p3 * d2, t3[4] = (c3 * r4 - i3 * l3) * d2, t3[5] = (-o3 * r4 + i3 * s4) * d2, t3[6] = f2 * d2, t3[7] = (-u3 * r4 + n3 * l3) * d2, t3[8] = (a3 * r4 - n3 * s4) * d2, t3) : null;
        }, z2.adjoint = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l3 = e4[6], u3 = e4[7], c3 = e4[8];
          return t3[0] = a3 * c3 - o3 * u3, t3[1] = i3 * u3 - n3 * c3, t3[2] = n3 * o3 - i3 * a3, t3[3] = o3 * l3 - s4 * c3, t3[4] = r4 * c3 - i3 * l3, t3[5] = i3 * s4 - r4 * o3, t3[6] = s4 * u3 - a3 * l3, t3[7] = n3 * l3 - r4 * u3, t3[8] = r4 * a3 - n3 * s4, t3;
        }, z2.determinant = function(t3) {
          var e4 = t3[3], r4 = t3[4], n3 = t3[5], i3 = t3[6], s4 = t3[7], a3 = t3[8];
          return t3[0] * (a3 * r4 - n3 * s4) + t3[1] * (-a3 * e4 + n3 * i3) + t3[2] * (s4 * e4 - r4 * i3);
        }, z2.multiply = R2, z2.translate = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = e4[8], p3 = r4[0], f2 = r4[1];
          return t3[0] = n3, t3[1] = i3, t3[2] = s4, t3[3] = a3, t3[4] = o3, t3[5] = l3, t3[6] = p3 * n3 + f2 * a3 + u3, t3[7] = p3 * i3 + f2 * o3 + c3, t3[8] = p3 * s4 + f2 * l3 + h2, t3;
        }, z2.rotate = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = e4[8], p3 = Math.sin(r4), f2 = Math.cos(r4);
          return t3[0] = f2 * n3 + p3 * a3, t3[1] = f2 * i3 + p3 * o3, t3[2] = f2 * s4 + p3 * l3, t3[3] = f2 * a3 - p3 * n3, t3[4] = f2 * o3 - p3 * i3, t3[5] = f2 * l3 - p3 * s4, t3[6] = u3, t3[7] = c3, t3[8] = h2, t3;
        }, z2.scale = function(t3, e4, r4) {
          var n3 = r4[0], i3 = r4[1];
          return t3[0] = n3 * e4[0], t3[1] = n3 * e4[1], t3[2] = n3 * e4[2], t3[3] = i3 * e4[3], t3[4] = i3 * e4[4], t3[5] = i3 * e4[5], t3[6] = e4[6], t3[7] = e4[7], t3[8] = e4[8], t3;
        }, z2.fromTranslation = function(t3, e4) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 1, t3[5] = 0, t3[6] = e4[0], t3[7] = e4[1], t3[8] = 1, t3;
        }, z2.fromRotation = function(t3, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t3[0] = n3, t3[1] = r4, t3[2] = 0, t3[3] = -r4, t3[4] = n3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, z2.fromScaling = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = e4[1], t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, z2.fromMat2d = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = 0, t3[3] = e4[2], t3[4] = e4[3], t3[5] = 0, t3[6] = e4[4], t3[7] = e4[5], t3[8] = 1, t3;
        }, z2.fromQuat = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = r4 + r4, o3 = n3 + n3, l3 = i3 + i3, u3 = r4 * a3, c3 = n3 * a3, h2 = n3 * o3, p3 = i3 * a3, f2 = i3 * o3, d2 = i3 * l3, m2 = s4 * a3, y3 = s4 * o3, g3 = s4 * l3;
          return t3[0] = 1 - h2 - d2, t3[3] = c3 - g3, t3[6] = p3 + y3, t3[1] = c3 + g3, t3[4] = 1 - u3 - d2, t3[7] = f2 - m2, t3[2] = p3 - y3, t3[5] = f2 + m2, t3[8] = 1 - u3 - h2, t3;
        }, z2.normalFromMat4 = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l3 = e4[6], u3 = e4[7], c3 = e4[8], h2 = e4[9], p3 = e4[10], f2 = e4[11], d2 = e4[12], m2 = e4[13], y3 = e4[14], g3 = e4[15], x3 = r4 * o3 - n3 * a3, b2 = r4 * l3 - i3 * a3, v3 = r4 * u3 - s4 * a3, _3 = n3 * l3 - i3 * o3, w2 = n3 * u3 - s4 * o3, M3 = i3 * u3 - s4 * l3, A2 = c3 * m2 - h2 * d2, S2 = c3 * y3 - p3 * d2, I2 = c3 * g3 - f2 * d2, k2 = h2 * y3 - p3 * m2, P2 = h2 * g3 - f2 * m2, E2 = p3 * g3 - f2 * y3, z3 = x3 * E2 - b2 * P2 + v3 * k2 + _3 * I2 - w2 * S2 + M3 * A2;
          return z3 ? (t3[0] = (o3 * E2 - l3 * P2 + u3 * k2) * (z3 = 1 / z3), t3[1] = (l3 * I2 - a3 * E2 - u3 * S2) * z3, t3[2] = (a3 * P2 - o3 * I2 + u3 * A2) * z3, t3[3] = (i3 * P2 - n3 * E2 - s4 * k2) * z3, t3[4] = (r4 * E2 - i3 * I2 + s4 * S2) * z3, t3[5] = (n3 * I2 - r4 * P2 - s4 * A2) * z3, t3[6] = (m2 * M3 - y3 * w2 + g3 * _3) * z3, t3[7] = (y3 * v3 - d2 * M3 - g3 * b2) * z3, t3[8] = (d2 * w2 - m2 * v3 + g3 * x3) * z3, t3) : null;
        }, z2.projection = function(t3, e4, r4) {
          return t3[0] = 2 / e4, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = -2 / r4, t3[5] = 0, t3[6] = -1, t3[7] = 1, t3[8] = 1, t3;
        }, z2.str = function(t3) {
          return "mat3(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ", " + t3[8] + ")";
        }, z2.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6], t3[7], t3[8]);
        }, z2.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3[2] = e4[2] + r4[2], t3[3] = e4[3] + r4[3], t3[4] = e4[4] + r4[4], t3[5] = e4[5] + r4[5], t3[6] = e4[6] + r4[6], t3[7] = e4[7] + r4[7], t3[8] = e4[8] + r4[8], t3;
        }, z2.subtract = V, z2.multiplyScalar = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3[2] = e4[2] * r4, t3[3] = e4[3] * r4, t3[4] = e4[4] * r4, t3[5] = e4[5] * r4, t3[6] = e4[6] * r4, t3[7] = e4[7] * r4, t3[8] = e4[8] * r4, t3;
        }, z2.multiplyScalarAndAdd = function(t3, e4, r4, n3) {
          return t3[0] = e4[0] + r4[0] * n3, t3[1] = e4[1] + r4[1] * n3, t3[2] = e4[2] + r4[2] * n3, t3[3] = e4[3] + r4[3] * n3, t3[4] = e4[4] + r4[4] * n3, t3[5] = e4[5] + r4[5] * n3, t3[6] = e4[6] + r4[6] * n3, t3[7] = e4[7] + r4[7] * n3, t3[8] = e4[8] + r4[8] * n3, t3;
        }, z2.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1] && t3[2] === e4[2] && t3[3] === e4[3] && t3[4] === e4[4] && t3[5] === e4[5] && t3[6] === e4[6] && t3[7] === e4[7] && t3[8] === e4[8];
        }, z2.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = t3[3], a3 = t3[4], o3 = t3[5], l3 = t3[6], u3 = t3[7], c3 = t3[8], h2 = e4[0], p3 = e4[1], f2 = e4[2], d2 = e4[3], m2 = e4[4], y3 = e4[5], g3 = e4[6], x3 = e4[7], b2 = e4[8];
          return Math.abs(r4 - h2) <= B.EPSILON * Math.max(1, Math.abs(r4), Math.abs(h2)) && Math.abs(n3 - p3) <= B.EPSILON * Math.max(1, Math.abs(n3), Math.abs(p3)) && Math.abs(i3 - f2) <= B.EPSILON * Math.max(1, Math.abs(i3), Math.abs(f2)) && Math.abs(s4 - d2) <= B.EPSILON * Math.max(1, Math.abs(s4), Math.abs(d2)) && Math.abs(a3 - m2) <= B.EPSILON * Math.max(1, Math.abs(a3), Math.abs(m2)) && Math.abs(o3 - y3) <= B.EPSILON * Math.max(1, Math.abs(o3), Math.abs(y3)) && Math.abs(l3 - g3) <= B.EPSILON * Math.max(1, Math.abs(l3), Math.abs(g3)) && Math.abs(u3 - x3) <= B.EPSILON * Math.max(1, Math.abs(u3), Math.abs(x3)) && Math.abs(c3 - b2) <= B.EPSILON * Math.max(1, Math.abs(c3), Math.abs(b2));
        }, z2.sub = z2.mul = void 0;
        var B = function(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== T(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = C(void 0);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }(f);
        function C(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (C = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function R2(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = e4[8], p3 = r4[0], f2 = r4[1], d2 = r4[2], m2 = r4[3], y3 = r4[4], g3 = r4[5], x3 = r4[6], b2 = r4[7], v3 = r4[8];
          return t3[0] = p3 * n3 + f2 * a3 + d2 * u3, t3[1] = p3 * i3 + f2 * o3 + d2 * c3, t3[2] = p3 * s4 + f2 * l3 + d2 * h2, t3[3] = m2 * n3 + y3 * a3 + g3 * u3, t3[4] = m2 * i3 + y3 * o3 + g3 * c3, t3[5] = m2 * s4 + y3 * l3 + g3 * h2, t3[6] = x3 * n3 + b2 * a3 + v3 * u3, t3[7] = x3 * i3 + b2 * o3 + v3 * c3, t3[8] = x3 * s4 + b2 * l3 + v3 * h2, t3;
        }
        function V(t3, e4, r4) {
          return t3[0] = e4[0] - r4[0], t3[1] = e4[1] - r4[1], t3[2] = e4[2] - r4[2], t3[3] = e4[3] - r4[3], t3[4] = e4[4] - r4[4], t3[5] = e4[5] - r4[5], t3[6] = e4[6] - r4[6], t3[7] = e4[7] - r4[7], t3[8] = e4[8] - r4[8], t3;
        }
        z2.mul = R2, z2.sub = V;
        var D = {};
        function L(t3) {
          return L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, L(t3);
        }
        Object.defineProperty(D, "__esModule", { value: true }), D.create = function() {
          var t3 = new F.ARRAY_TYPE(16);
          return F.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
        }, D.clone = function(t3) {
          var e4 = new F.ARRAY_TYPE(16);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4[8] = t3[8], e4[9] = t3[9], e4[10] = t3[10], e4[11] = t3[11], e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15], e4;
        }, D.copy = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3[8] = e4[8], t3[9] = e4[9], t3[10] = e4[10], t3[11] = e4[11], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15], t3;
        }, D.fromValues = function(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2) {
          var y3 = new F.ARRAY_TYPE(16);
          return y3[0] = t3, y3[1] = e4, y3[2] = r4, y3[3] = n3, y3[4] = i3, y3[5] = s4, y3[6] = a3, y3[7] = o3, y3[8] = l3, y3[9] = u3, y3[10] = c3, y3[11] = h2, y3[12] = p3, y3[13] = f2, y3[14] = d2, y3[15] = m2, y3;
        }, D.set = function(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3) {
          return t3[0] = e4, t3[1] = r4, t3[2] = n3, t3[3] = i3, t3[4] = s4, t3[5] = a3, t3[6] = o3, t3[7] = l3, t3[8] = u3, t3[9] = c3, t3[10] = h2, t3[11] = p3, t3[12] = f2, t3[13] = d2, t3[14] = m2, t3[15] = y3, t3;
        }, D.identity = U, D.transpose = function(t3, e4) {
          if (t3 === e4) {
            var r4 = e4[1], n3 = e4[2], i3 = e4[3], s4 = e4[6], a3 = e4[7], o3 = e4[11];
            t3[1] = e4[4], t3[2] = e4[8], t3[3] = e4[12], t3[4] = r4, t3[6] = e4[9], t3[7] = e4[13], t3[8] = n3, t3[9] = s4, t3[11] = e4[14], t3[12] = i3, t3[13] = a3, t3[14] = o3;
          } else
            t3[0] = e4[0], t3[1] = e4[4], t3[2] = e4[8], t3[3] = e4[12], t3[4] = e4[1], t3[5] = e4[5], t3[6] = e4[9], t3[7] = e4[13], t3[8] = e4[2], t3[9] = e4[6], t3[10] = e4[10], t3[11] = e4[14], t3[12] = e4[3], t3[13] = e4[7], t3[14] = e4[11], t3[15] = e4[15];
          return t3;
        }, D.invert = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l3 = e4[6], u3 = e4[7], c3 = e4[8], h2 = e4[9], p3 = e4[10], f2 = e4[11], d2 = e4[12], m2 = e4[13], y3 = e4[14], g3 = e4[15], x3 = r4 * o3 - n3 * a3, b2 = r4 * l3 - i3 * a3, v3 = r4 * u3 - s4 * a3, _3 = n3 * l3 - i3 * o3, w2 = n3 * u3 - s4 * o3, M3 = i3 * u3 - s4 * l3, A2 = c3 * m2 - h2 * d2, S2 = c3 * y3 - p3 * d2, I2 = c3 * g3 - f2 * d2, k2 = h2 * y3 - p3 * m2, P2 = h2 * g3 - f2 * m2, E2 = p3 * g3 - f2 * y3, z3 = x3 * E2 - b2 * P2 + v3 * k2 + _3 * I2 - w2 * S2 + M3 * A2;
          return z3 ? (t3[0] = (o3 * E2 - l3 * P2 + u3 * k2) * (z3 = 1 / z3), t3[1] = (i3 * P2 - n3 * E2 - s4 * k2) * z3, t3[2] = (m2 * M3 - y3 * w2 + g3 * _3) * z3, t3[3] = (p3 * w2 - h2 * M3 - f2 * _3) * z3, t3[4] = (l3 * I2 - a3 * E2 - u3 * S2) * z3, t3[5] = (r4 * E2 - i3 * I2 + s4 * S2) * z3, t3[6] = (y3 * v3 - d2 * M3 - g3 * b2) * z3, t3[7] = (c3 * M3 - p3 * v3 + f2 * b2) * z3, t3[8] = (a3 * P2 - o3 * I2 + u3 * A2) * z3, t3[9] = (n3 * I2 - r4 * P2 - s4 * A2) * z3, t3[10] = (d2 * w2 - m2 * v3 + g3 * x3) * z3, t3[11] = (h2 * v3 - c3 * w2 - f2 * x3) * z3, t3[12] = (o3 * S2 - a3 * k2 - l3 * A2) * z3, t3[13] = (r4 * k2 - n3 * S2 + i3 * A2) * z3, t3[14] = (m2 * b2 - d2 * _3 - y3 * x3) * z3, t3[15] = (c3 * _3 - h2 * b2 + p3 * x3) * z3, t3) : null;
        }, D.adjoint = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l3 = e4[6], u3 = e4[7], c3 = e4[8], h2 = e4[9], p3 = e4[10], f2 = e4[11], d2 = e4[12], m2 = e4[13], y3 = e4[14], g3 = e4[15];
          return t3[0] = o3 * (p3 * g3 - f2 * y3) - h2 * (l3 * g3 - u3 * y3) + m2 * (l3 * f2 - u3 * p3), t3[1] = -(n3 * (p3 * g3 - f2 * y3) - h2 * (i3 * g3 - s4 * y3) + m2 * (i3 * f2 - s4 * p3)), t3[2] = n3 * (l3 * g3 - u3 * y3) - o3 * (i3 * g3 - s4 * y3) + m2 * (i3 * u3 - s4 * l3), t3[3] = -(n3 * (l3 * f2 - u3 * p3) - o3 * (i3 * f2 - s4 * p3) + h2 * (i3 * u3 - s4 * l3)), t3[4] = -(a3 * (p3 * g3 - f2 * y3) - c3 * (l3 * g3 - u3 * y3) + d2 * (l3 * f2 - u3 * p3)), t3[5] = r4 * (p3 * g3 - f2 * y3) - c3 * (i3 * g3 - s4 * y3) + d2 * (i3 * f2 - s4 * p3), t3[6] = -(r4 * (l3 * g3 - u3 * y3) - a3 * (i3 * g3 - s4 * y3) + d2 * (i3 * u3 - s4 * l3)), t3[7] = r4 * (l3 * f2 - u3 * p3) - a3 * (i3 * f2 - s4 * p3) + c3 * (i3 * u3 - s4 * l3), t3[8] = a3 * (h2 * g3 - f2 * m2) - c3 * (o3 * g3 - u3 * m2) + d2 * (o3 * f2 - u3 * h2), t3[9] = -(r4 * (h2 * g3 - f2 * m2) - c3 * (n3 * g3 - s4 * m2) + d2 * (n3 * f2 - s4 * h2)), t3[10] = r4 * (o3 * g3 - u3 * m2) - a3 * (n3 * g3 - s4 * m2) + d2 * (n3 * u3 - s4 * o3), t3[11] = -(r4 * (o3 * f2 - u3 * h2) - a3 * (n3 * f2 - s4 * h2) + c3 * (n3 * u3 - s4 * o3)), t3[12] = -(a3 * (h2 * y3 - p3 * m2) - c3 * (o3 * y3 - l3 * m2) + d2 * (o3 * p3 - l3 * h2)), t3[13] = r4 * (h2 * y3 - p3 * m2) - c3 * (n3 * y3 - i3 * m2) + d2 * (n3 * p3 - i3 * h2), t3[14] = -(r4 * (o3 * y3 - l3 * m2) - a3 * (n3 * y3 - i3 * m2) + d2 * (n3 * l3 - i3 * o3)), t3[15] = r4 * (o3 * p3 - l3 * h2) - a3 * (n3 * p3 - i3 * h2) + c3 * (n3 * l3 - i3 * o3), t3;
        }, D.determinant = function(t3) {
          var e4 = t3[0], r4 = t3[1], n3 = t3[2], i3 = t3[3], s4 = t3[4], a3 = t3[5], o3 = t3[6], l3 = t3[7], u3 = t3[8], c3 = t3[9], h2 = t3[10], p3 = t3[11], f2 = t3[12], d2 = t3[13], m2 = t3[14], y3 = t3[15];
          return (e4 * a3 - r4 * s4) * (h2 * y3 - p3 * m2) - (e4 * o3 - n3 * s4) * (c3 * y3 - p3 * d2) + (e4 * l3 - i3 * s4) * (c3 * m2 - h2 * d2) + (r4 * o3 - n3 * a3) * (u3 * y3 - p3 * f2) - (r4 * l3 - i3 * a3) * (u3 * m2 - h2 * f2) + (n3 * l3 - i3 * o3) * (u3 * d2 - c3 * f2);
        }, D.multiply = N, D.translate = function(t3, e4, r4) {
          var n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2 = r4[0], y3 = r4[1], g3 = r4[2];
          return e4 === t3 ? (t3[12] = e4[0] * m2 + e4[4] * y3 + e4[8] * g3 + e4[12], t3[13] = e4[1] * m2 + e4[5] * y3 + e4[9] * g3 + e4[13], t3[14] = e4[2] * m2 + e4[6] * y3 + e4[10] * g3 + e4[14], t3[15] = e4[3] * m2 + e4[7] * y3 + e4[11] * g3 + e4[15]) : (i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = e4[8], p3 = e4[9], f2 = e4[10], d2 = e4[11], t3[0] = n3 = e4[0], t3[1] = i3, t3[2] = s4, t3[3] = a3, t3[4] = o3, t3[5] = l3, t3[6] = u3, t3[7] = c3, t3[8] = h2, t3[9] = p3, t3[10] = f2, t3[11] = d2, t3[12] = n3 * m2 + o3 * y3 + h2 * g3 + e4[12], t3[13] = i3 * m2 + l3 * y3 + p3 * g3 + e4[13], t3[14] = s4 * m2 + u3 * y3 + f2 * g3 + e4[14], t3[15] = a3 * m2 + c3 * y3 + d2 * g3 + e4[15]), t3;
        }, D.scale = function(t3, e4, r4) {
          var n3 = r4[0], i3 = r4[1], s4 = r4[2];
          return t3[0] = e4[0] * n3, t3[1] = e4[1] * n3, t3[2] = e4[2] * n3, t3[3] = e4[3] * n3, t3[4] = e4[4] * i3, t3[5] = e4[5] * i3, t3[6] = e4[6] * i3, t3[7] = e4[7] * i3, t3[8] = e4[8] * s4, t3[9] = e4[9] * s4, t3[10] = e4[10] * s4, t3[11] = e4[11] * s4, t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15], t3;
        }, D.rotate = function(t3, e4, r4, n3) {
          var i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3, x3, b2, v3, _3, w2, M3, A2, S2, I2, k2, P2 = n3[0], E2 = n3[1], z3 = n3[2], T2 = Math.hypot(P2, E2, z3);
          return T2 < F.EPSILON ? null : (P2 *= T2 = 1 / T2, E2 *= T2, z3 *= T2, i3 = Math.sin(r4), s4 = Math.cos(r4), l3 = e4[1], u3 = e4[2], c3 = e4[3], p3 = e4[5], f2 = e4[6], d2 = e4[7], y3 = e4[9], g3 = e4[10], x3 = e4[11], b2 = P2 * P2 * (a3 = 1 - s4) + s4, w2 = P2 * E2 * a3 - z3 * i3, M3 = E2 * E2 * a3 + s4, A2 = z3 * E2 * a3 + P2 * i3, S2 = P2 * z3 * a3 + E2 * i3, I2 = E2 * z3 * a3 - P2 * i3, k2 = z3 * z3 * a3 + s4, t3[0] = (o3 = e4[0]) * b2 + (h2 = e4[4]) * (v3 = E2 * P2 * a3 + z3 * i3) + (m2 = e4[8]) * (_3 = z3 * P2 * a3 - E2 * i3), t3[1] = l3 * b2 + p3 * v3 + y3 * _3, t3[2] = u3 * b2 + f2 * v3 + g3 * _3, t3[3] = c3 * b2 + d2 * v3 + x3 * _3, t3[4] = o3 * w2 + h2 * M3 + m2 * A2, t3[5] = l3 * w2 + p3 * M3 + y3 * A2, t3[6] = u3 * w2 + f2 * M3 + g3 * A2, t3[7] = c3 * w2 + d2 * M3 + x3 * A2, t3[8] = o3 * S2 + h2 * I2 + m2 * k2, t3[9] = l3 * S2 + p3 * I2 + y3 * k2, t3[10] = u3 * S2 + f2 * I2 + g3 * k2, t3[11] = c3 * S2 + d2 * I2 + x3 * k2, e4 !== t3 && (t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15]), t3);
        }, D.rotateX = function(t3, e4, r4) {
          var n3 = Math.sin(r4), i3 = Math.cos(r4), s4 = e4[4], a3 = e4[5], o3 = e4[6], l3 = e4[7], u3 = e4[8], c3 = e4[9], h2 = e4[10], p3 = e4[11];
          return e4 !== t3 && (t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15]), t3[4] = s4 * i3 + u3 * n3, t3[5] = a3 * i3 + c3 * n3, t3[6] = o3 * i3 + h2 * n3, t3[7] = l3 * i3 + p3 * n3, t3[8] = u3 * i3 - s4 * n3, t3[9] = c3 * i3 - a3 * n3, t3[10] = h2 * i3 - o3 * n3, t3[11] = p3 * i3 - l3 * n3, t3;
        }, D.rotateY = function(t3, e4, r4) {
          var n3 = Math.sin(r4), i3 = Math.cos(r4), s4 = e4[0], a3 = e4[1], o3 = e4[2], l3 = e4[3], u3 = e4[8], c3 = e4[9], h2 = e4[10], p3 = e4[11];
          return e4 !== t3 && (t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15]), t3[0] = s4 * i3 - u3 * n3, t3[1] = a3 * i3 - c3 * n3, t3[2] = o3 * i3 - h2 * n3, t3[3] = l3 * i3 - p3 * n3, t3[8] = s4 * n3 + u3 * i3, t3[9] = a3 * n3 + c3 * i3, t3[10] = o3 * n3 + h2 * i3, t3[11] = l3 * n3 + p3 * i3, t3;
        }, D.rotateZ = function(t3, e4, r4) {
          var n3 = Math.sin(r4), i3 = Math.cos(r4), s4 = e4[0], a3 = e4[1], o3 = e4[2], l3 = e4[3], u3 = e4[4], c3 = e4[5], h2 = e4[6], p3 = e4[7];
          return e4 !== t3 && (t3[8] = e4[8], t3[9] = e4[9], t3[10] = e4[10], t3[11] = e4[11], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15]), t3[0] = s4 * i3 + u3 * n3, t3[1] = a3 * i3 + c3 * n3, t3[2] = o3 * i3 + h2 * n3, t3[3] = l3 * i3 + p3 * n3, t3[4] = u3 * i3 - s4 * n3, t3[5] = c3 * i3 - a3 * n3, t3[6] = h2 * i3 - o3 * n3, t3[7] = p3 * i3 - l3 * n3, t3;
        }, D.fromTranslation = function(t3, e4) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = e4[0], t3[13] = e4[1], t3[14] = e4[2], t3[15] = 1, t3;
        }, D.fromScaling = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e4[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e4[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, D.fromRotation = function(t3, e4, r4) {
          var n3, i3, s4, a3 = r4[0], o3 = r4[1], l3 = r4[2], u3 = Math.hypot(a3, o3, l3);
          return u3 < F.EPSILON ? null : (a3 *= u3 = 1 / u3, o3 *= u3, l3 *= u3, n3 = Math.sin(e4), i3 = Math.cos(e4), t3[0] = a3 * a3 * (s4 = 1 - i3) + i3, t3[1] = o3 * a3 * s4 + l3 * n3, t3[2] = l3 * a3 * s4 - o3 * n3, t3[3] = 0, t3[4] = a3 * o3 * s4 - l3 * n3, t3[5] = o3 * o3 * s4 + i3, t3[6] = l3 * o3 * s4 + a3 * n3, t3[7] = 0, t3[8] = a3 * l3 * s4 + o3 * n3, t3[9] = o3 * l3 * s4 - a3 * n3, t3[10] = l3 * l3 * s4 + i3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3);
        }, D.fromXRotation = function(t3, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = n3, t3[6] = r4, t3[7] = 0, t3[8] = 0, t3[9] = -r4, t3[10] = n3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, D.fromYRotation = function(t3, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t3[0] = n3, t3[1] = 0, t3[2] = -r4, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = r4, t3[9] = 0, t3[10] = n3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, D.fromZRotation = function(t3, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t3[0] = n3, t3[1] = r4, t3[2] = 0, t3[3] = 0, t3[4] = -r4, t3[5] = n3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, D.fromRotationTranslation = j2, D.fromQuat2 = function(t3, e4) {
          var r4 = new F.ARRAY_TYPE(3), n3 = -e4[0], i3 = -e4[1], s4 = -e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = n3 * n3 + i3 * i3 + s4 * s4 + a3 * a3;
          return h2 > 0 ? (r4[0] = 2 * (o3 * a3 + c3 * n3 + l3 * s4 - u3 * i3) / h2, r4[1] = 2 * (l3 * a3 + c3 * i3 + u3 * n3 - o3 * s4) / h2, r4[2] = 2 * (u3 * a3 + c3 * s4 + o3 * i3 - l3 * n3) / h2) : (r4[0] = 2 * (o3 * a3 + c3 * n3 + l3 * s4 - u3 * i3), r4[1] = 2 * (l3 * a3 + c3 * i3 + u3 * n3 - o3 * s4), r4[2] = 2 * (u3 * a3 + c3 * s4 + o3 * i3 - l3 * n3)), j2(t3, e4, r4), t3;
        }, D.getTranslation = function(t3, e4) {
          return t3[0] = e4[12], t3[1] = e4[13], t3[2] = e4[14], t3;
        }, D.getScaling = q2, D.getRotation = function(t3, e4) {
          var r4 = new F.ARRAY_TYPE(3);
          q2(r4, e4);
          var n3 = 1 / r4[0], i3 = 1 / r4[1], s4 = 1 / r4[2], a3 = e4[0] * n3, o3 = e4[1] * i3, l3 = e4[2] * s4, u3 = e4[4] * n3, c3 = e4[5] * i3, h2 = e4[6] * s4, p3 = e4[8] * n3, f2 = e4[9] * i3, d2 = e4[10] * s4, m2 = a3 + c3 + d2, y3 = 0;
          return m2 > 0 ? (y3 = 2 * Math.sqrt(m2 + 1), t3[3] = 0.25 * y3, t3[0] = (h2 - f2) / y3, t3[1] = (p3 - l3) / y3, t3[2] = (o3 - u3) / y3) : a3 > c3 && a3 > d2 ? (y3 = 2 * Math.sqrt(1 + a3 - c3 - d2), t3[3] = (h2 - f2) / y3, t3[0] = 0.25 * y3, t3[1] = (o3 + u3) / y3, t3[2] = (p3 + l3) / y3) : c3 > d2 ? (y3 = 2 * Math.sqrt(1 + c3 - a3 - d2), t3[3] = (p3 - l3) / y3, t3[0] = (o3 + u3) / y3, t3[1] = 0.25 * y3, t3[2] = (h2 + f2) / y3) : (y3 = 2 * Math.sqrt(1 + d2 - a3 - c3), t3[3] = (o3 - u3) / y3, t3[0] = (p3 + l3) / y3, t3[1] = (h2 + f2) / y3, t3[2] = 0.25 * y3), t3;
        }, D.fromRotationTranslationScale = function(t3, e4, r4, n3) {
          var i3 = e4[0], s4 = e4[1], a3 = e4[2], o3 = e4[3], l3 = i3 + i3, u3 = s4 + s4, c3 = a3 + a3, h2 = i3 * l3, p3 = i3 * u3, f2 = i3 * c3, d2 = s4 * u3, m2 = s4 * c3, y3 = a3 * c3, g3 = o3 * l3, x3 = o3 * u3, b2 = o3 * c3, v3 = n3[0], _3 = n3[1], w2 = n3[2];
          return t3[0] = (1 - (d2 + y3)) * v3, t3[1] = (p3 + b2) * v3, t3[2] = (f2 - x3) * v3, t3[3] = 0, t3[4] = (p3 - b2) * _3, t3[5] = (1 - (h2 + y3)) * _3, t3[6] = (m2 + g3) * _3, t3[7] = 0, t3[8] = (f2 + x3) * w2, t3[9] = (m2 - g3) * w2, t3[10] = (1 - (h2 + d2)) * w2, t3[11] = 0, t3[12] = r4[0], t3[13] = r4[1], t3[14] = r4[2], t3[15] = 1, t3;
        }, D.fromRotationTranslationScaleOrigin = function(t3, e4, r4, n3, i3) {
          var s4 = e4[0], a3 = e4[1], o3 = e4[2], l3 = e4[3], u3 = s4 + s4, c3 = a3 + a3, h2 = o3 + o3, p3 = s4 * u3, f2 = s4 * c3, d2 = s4 * h2, m2 = a3 * c3, y3 = a3 * h2, g3 = o3 * h2, x3 = l3 * u3, b2 = l3 * c3, v3 = l3 * h2, _3 = n3[0], w2 = n3[1], M3 = n3[2], A2 = i3[0], S2 = i3[1], I2 = i3[2], k2 = (1 - (m2 + g3)) * _3, P2 = (f2 + v3) * _3, E2 = (d2 - b2) * _3, z3 = (f2 - v3) * w2, T2 = (1 - (p3 + g3)) * w2, B2 = (y3 + x3) * w2, C2 = (d2 + b2) * M3, R3 = (y3 - x3) * M3, V2 = (1 - (p3 + m2)) * M3;
          return t3[0] = k2, t3[1] = P2, t3[2] = E2, t3[3] = 0, t3[4] = z3, t3[5] = T2, t3[6] = B2, t3[7] = 0, t3[8] = C2, t3[9] = R3, t3[10] = V2, t3[11] = 0, t3[12] = r4[0] + A2 - (k2 * A2 + z3 * S2 + C2 * I2), t3[13] = r4[1] + S2 - (P2 * A2 + T2 * S2 + R3 * I2), t3[14] = r4[2] + I2 - (E2 * A2 + B2 * S2 + V2 * I2), t3[15] = 1, t3;
        }, D.fromQuat = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = r4 + r4, o3 = n3 + n3, l3 = i3 + i3, u3 = r4 * a3, c3 = n3 * a3, h2 = n3 * o3, p3 = i3 * a3, f2 = i3 * o3, d2 = i3 * l3, m2 = s4 * a3, y3 = s4 * o3, g3 = s4 * l3;
          return t3[0] = 1 - h2 - d2, t3[1] = c3 + g3, t3[2] = p3 - y3, t3[3] = 0, t3[4] = c3 - g3, t3[5] = 1 - u3 - d2, t3[6] = f2 + m2, t3[7] = 0, t3[8] = p3 + y3, t3[9] = f2 - m2, t3[10] = 1 - u3 - h2, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, D.frustum = function(t3, e4, r4, n3, i3, s4, a3) {
          var o3 = 1 / (r4 - e4), l3 = 1 / (i3 - n3), u3 = 1 / (s4 - a3);
          return t3[0] = 2 * s4 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 2 * s4 * l3, t3[6] = 0, t3[7] = 0, t3[8] = (r4 + e4) * o3, t3[9] = (i3 + n3) * l3, t3[10] = (a3 + s4) * u3, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[14] = a3 * s4 * 2 * u3, t3[15] = 0, t3;
        }, D.perspectiveNO = $, D.perspectiveZO = function(t3, e4, r4, n3, i3) {
          var s4, a3 = 1 / Math.tan(e4 / 2);
          return t3[0] = a3 / r4, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = i3 * (s4 = 1 / (n3 - i3)), t3[14] = i3 * n3 * s4) : (t3[10] = -1, t3[14] = -n3), t3;
        }, D.perspectiveFromFieldOfView = function(t3, e4, r4, n3) {
          var i3 = Math.tan(e4.upDegrees * Math.PI / 180), s4 = Math.tan(e4.downDegrees * Math.PI / 180), a3 = Math.tan(e4.leftDegrees * Math.PI / 180), o3 = Math.tan(e4.rightDegrees * Math.PI / 180), l3 = 2 / (a3 + o3), u3 = 2 / (i3 + s4);
          return t3[0] = l3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = u3, t3[6] = 0, t3[7] = 0, t3[8] = -(a3 - o3) * l3 * 0.5, t3[9] = (i3 - s4) * u3 * 0.5, t3[10] = n3 / (r4 - n3), t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[14] = n3 * r4 / (r4 - n3), t3[15] = 0, t3;
        }, D.orthoNO = G, D.orthoZO = function(t3, e4, r4, n3, i3, s4, a3) {
          var o3 = 1 / (e4 - r4), l3 = 1 / (n3 - i3), u3 = 1 / (s4 - a3);
          return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = u3, t3[11] = 0, t3[12] = (e4 + r4) * o3, t3[13] = (i3 + n3) * l3, t3[14] = s4 * u3, t3[15] = 1, t3;
        }, D.lookAt = function(t3, e4, r4, n3) {
          var i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2 = e4[0], m2 = e4[1], y3 = e4[2], g3 = n3[0], x3 = n3[1], b2 = n3[2], v3 = r4[0], _3 = r4[1], w2 = r4[2];
          return Math.abs(d2 - v3) < F.EPSILON && Math.abs(m2 - _3) < F.EPSILON && Math.abs(y3 - w2) < F.EPSILON ? U(t3) : (c3 = d2 - v3, h2 = m2 - _3, p3 = y3 - w2, i3 = x3 * (p3 *= f2 = 1 / Math.hypot(c3, h2, p3)) - b2 * (h2 *= f2), s4 = b2 * (c3 *= f2) - g3 * p3, a3 = g3 * h2 - x3 * c3, (f2 = Math.hypot(i3, s4, a3)) ? (i3 *= f2 = 1 / f2, s4 *= f2, a3 *= f2) : (i3 = 0, s4 = 0, a3 = 0), o3 = h2 * a3 - p3 * s4, l3 = p3 * i3 - c3 * a3, u3 = c3 * s4 - h2 * i3, (f2 = Math.hypot(o3, l3, u3)) ? (o3 *= f2 = 1 / f2, l3 *= f2, u3 *= f2) : (o3 = 0, l3 = 0, u3 = 0), t3[0] = i3, t3[1] = o3, t3[2] = c3, t3[3] = 0, t3[4] = s4, t3[5] = l3, t3[6] = h2, t3[7] = 0, t3[8] = a3, t3[9] = u3, t3[10] = p3, t3[11] = 0, t3[12] = -(i3 * d2 + s4 * m2 + a3 * y3), t3[13] = -(o3 * d2 + l3 * m2 + u3 * y3), t3[14] = -(c3 * d2 + h2 * m2 + p3 * y3), t3[15] = 1, t3);
        }, D.targetTo = function(t3, e4, r4, n3) {
          var i3 = e4[0], s4 = e4[1], a3 = e4[2], o3 = n3[0], l3 = n3[1], u3 = n3[2], c3 = i3 - r4[0], h2 = s4 - r4[1], p3 = a3 - r4[2], f2 = c3 * c3 + h2 * h2 + p3 * p3;
          f2 > 0 && (c3 *= f2 = 1 / Math.sqrt(f2), h2 *= f2, p3 *= f2);
          var d2 = l3 * p3 - u3 * h2, m2 = u3 * c3 - o3 * p3, y3 = o3 * h2 - l3 * c3;
          return (f2 = d2 * d2 + m2 * m2 + y3 * y3) > 0 && (d2 *= f2 = 1 / Math.sqrt(f2), m2 *= f2, y3 *= f2), t3[0] = d2, t3[1] = m2, t3[2] = y3, t3[3] = 0, t3[4] = h2 * y3 - p3 * m2, t3[5] = p3 * d2 - c3 * y3, t3[6] = c3 * m2 - h2 * d2, t3[7] = 0, t3[8] = c3, t3[9] = h2, t3[10] = p3, t3[11] = 0, t3[12] = i3, t3[13] = s4, t3[14] = a3, t3[15] = 1, t3;
        }, D.str = function(t3) {
          return "mat4(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ", " + t3[8] + ", " + t3[9] + ", " + t3[10] + ", " + t3[11] + ", " + t3[12] + ", " + t3[13] + ", " + t3[14] + ", " + t3[15] + ")";
        }, D.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6], t3[7], t3[8], t3[9], t3[10], t3[11], t3[12], t3[13], t3[14], t3[15]);
        }, D.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3[2] = e4[2] + r4[2], t3[3] = e4[3] + r4[3], t3[4] = e4[4] + r4[4], t3[5] = e4[5] + r4[5], t3[6] = e4[6] + r4[6], t3[7] = e4[7] + r4[7], t3[8] = e4[8] + r4[8], t3[9] = e4[9] + r4[9], t3[10] = e4[10] + r4[10], t3[11] = e4[11] + r4[11], t3[12] = e4[12] + r4[12], t3[13] = e4[13] + r4[13], t3[14] = e4[14] + r4[14], t3[15] = e4[15] + r4[15], t3;
        }, D.subtract = Q, D.multiplyScalar = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3[2] = e4[2] * r4, t3[3] = e4[3] * r4, t3[4] = e4[4] * r4, t3[5] = e4[5] * r4, t3[6] = e4[6] * r4, t3[7] = e4[7] * r4, t3[8] = e4[8] * r4, t3[9] = e4[9] * r4, t3[10] = e4[10] * r4, t3[11] = e4[11] * r4, t3[12] = e4[12] * r4, t3[13] = e4[13] * r4, t3[14] = e4[14] * r4, t3[15] = e4[15] * r4, t3;
        }, D.multiplyScalarAndAdd = function(t3, e4, r4, n3) {
          return t3[0] = e4[0] + r4[0] * n3, t3[1] = e4[1] + r4[1] * n3, t3[2] = e4[2] + r4[2] * n3, t3[3] = e4[3] + r4[3] * n3, t3[4] = e4[4] + r4[4] * n3, t3[5] = e4[5] + r4[5] * n3, t3[6] = e4[6] + r4[6] * n3, t3[7] = e4[7] + r4[7] * n3, t3[8] = e4[8] + r4[8] * n3, t3[9] = e4[9] + r4[9] * n3, t3[10] = e4[10] + r4[10] * n3, t3[11] = e4[11] + r4[11] * n3, t3[12] = e4[12] + r4[12] * n3, t3[13] = e4[13] + r4[13] * n3, t3[14] = e4[14] + r4[14] * n3, t3[15] = e4[15] + r4[15] * n3, t3;
        }, D.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1] && t3[2] === e4[2] && t3[3] === e4[3] && t3[4] === e4[4] && t3[5] === e4[5] && t3[6] === e4[6] && t3[7] === e4[7] && t3[8] === e4[8] && t3[9] === e4[9] && t3[10] === e4[10] && t3[11] === e4[11] && t3[12] === e4[12] && t3[13] === e4[13] && t3[14] === e4[14] && t3[15] === e4[15];
        }, D.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = t3[3], a3 = t3[4], o3 = t3[5], l3 = t3[6], u3 = t3[7], c3 = t3[8], h2 = t3[9], p3 = t3[10], f2 = t3[11], d2 = t3[12], m2 = t3[13], y3 = t3[14], g3 = t3[15], x3 = e4[0], b2 = e4[1], v3 = e4[2], _3 = e4[3], w2 = e4[4], M3 = e4[5], A2 = e4[6], S2 = e4[7], I2 = e4[8], k2 = e4[9], P2 = e4[10], E2 = e4[11], z3 = e4[12], T2 = e4[13], B2 = e4[14], C2 = e4[15];
          return Math.abs(r4 - x3) <= F.EPSILON * Math.max(1, Math.abs(r4), Math.abs(x3)) && Math.abs(n3 - b2) <= F.EPSILON * Math.max(1, Math.abs(n3), Math.abs(b2)) && Math.abs(i3 - v3) <= F.EPSILON * Math.max(1, Math.abs(i3), Math.abs(v3)) && Math.abs(s4 - _3) <= F.EPSILON * Math.max(1, Math.abs(s4), Math.abs(_3)) && Math.abs(a3 - w2) <= F.EPSILON * Math.max(1, Math.abs(a3), Math.abs(w2)) && Math.abs(o3 - M3) <= F.EPSILON * Math.max(1, Math.abs(o3), Math.abs(M3)) && Math.abs(l3 - A2) <= F.EPSILON * Math.max(1, Math.abs(l3), Math.abs(A2)) && Math.abs(u3 - S2) <= F.EPSILON * Math.max(1, Math.abs(u3), Math.abs(S2)) && Math.abs(c3 - I2) <= F.EPSILON * Math.max(1, Math.abs(c3), Math.abs(I2)) && Math.abs(h2 - k2) <= F.EPSILON * Math.max(1, Math.abs(h2), Math.abs(k2)) && Math.abs(p3 - P2) <= F.EPSILON * Math.max(1, Math.abs(p3), Math.abs(P2)) && Math.abs(f2 - E2) <= F.EPSILON * Math.max(1, Math.abs(f2), Math.abs(E2)) && Math.abs(d2 - z3) <= F.EPSILON * Math.max(1, Math.abs(d2), Math.abs(z3)) && Math.abs(m2 - T2) <= F.EPSILON * Math.max(1, Math.abs(m2), Math.abs(T2)) && Math.abs(y3 - B2) <= F.EPSILON * Math.max(1, Math.abs(y3), Math.abs(B2)) && Math.abs(g3 - C2) <= F.EPSILON * Math.max(1, Math.abs(g3), Math.abs(C2));
        }, D.sub = D.mul = D.ortho = D.perspective = void 0;
        var F = function(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== L(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = O(void 0);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }(f);
        function O(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (O = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function U(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }
        function N(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = e4[8], p3 = e4[9], f2 = e4[10], d2 = e4[11], m2 = e4[12], y3 = e4[13], g3 = e4[14], x3 = e4[15], b2 = r4[0], v3 = r4[1], _3 = r4[2], w2 = r4[3];
          return t3[0] = b2 * n3 + v3 * o3 + _3 * h2 + w2 * m2, t3[1] = b2 * i3 + v3 * l3 + _3 * p3 + w2 * y3, t3[2] = b2 * s4 + v3 * u3 + _3 * f2 + w2 * g3, t3[3] = b2 * a3 + v3 * c3 + _3 * d2 + w2 * x3, t3[4] = (b2 = r4[4]) * n3 + (v3 = r4[5]) * o3 + (_3 = r4[6]) * h2 + (w2 = r4[7]) * m2, t3[5] = b2 * i3 + v3 * l3 + _3 * p3 + w2 * y3, t3[6] = b2 * s4 + v3 * u3 + _3 * f2 + w2 * g3, t3[7] = b2 * a3 + v3 * c3 + _3 * d2 + w2 * x3, t3[8] = (b2 = r4[8]) * n3 + (v3 = r4[9]) * o3 + (_3 = r4[10]) * h2 + (w2 = r4[11]) * m2, t3[9] = b2 * i3 + v3 * l3 + _3 * p3 + w2 * y3, t3[10] = b2 * s4 + v3 * u3 + _3 * f2 + w2 * g3, t3[11] = b2 * a3 + v3 * c3 + _3 * d2 + w2 * x3, t3[12] = (b2 = r4[12]) * n3 + (v3 = r4[13]) * o3 + (_3 = r4[14]) * h2 + (w2 = r4[15]) * m2, t3[13] = b2 * i3 + v3 * l3 + _3 * p3 + w2 * y3, t3[14] = b2 * s4 + v3 * u3 + _3 * f2 + w2 * g3, t3[15] = b2 * a3 + v3 * c3 + _3 * d2 + w2 * x3, t3;
        }
        function j2(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = n3 + n3, l3 = i3 + i3, u3 = s4 + s4, c3 = n3 * o3, h2 = n3 * l3, p3 = n3 * u3, f2 = i3 * l3, d2 = i3 * u3, m2 = s4 * u3, y3 = a3 * o3, g3 = a3 * l3, x3 = a3 * u3;
          return t3[0] = 1 - (f2 + m2), t3[1] = h2 + x3, t3[2] = p3 - g3, t3[3] = 0, t3[4] = h2 - x3, t3[5] = 1 - (c3 + m2), t3[6] = d2 + y3, t3[7] = 0, t3[8] = p3 + g3, t3[9] = d2 - y3, t3[10] = 1 - (c3 + f2), t3[11] = 0, t3[12] = r4[0], t3[13] = r4[1], t3[14] = r4[2], t3[15] = 1, t3;
        }
        function q2(t3, e4) {
          var r4 = e4[4], n3 = e4[5], i3 = e4[6], s4 = e4[8], a3 = e4[9], o3 = e4[10];
          return t3[0] = Math.hypot(e4[0], e4[1], e4[2]), t3[1] = Math.hypot(r4, n3, i3), t3[2] = Math.hypot(s4, a3, o3), t3;
        }
        function $(t3, e4, r4, n3, i3) {
          var s4, a3 = 1 / Math.tan(e4 / 2);
          return t3[0] = a3 / r4, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = (i3 + n3) * (s4 = 1 / (n3 - i3)), t3[14] = 2 * i3 * n3 * s4) : (t3[10] = -1, t3[14] = -2 * n3), t3;
        }
        function G(t3, e4, r4, n3, i3, s4, a3) {
          var o3 = 1 / (e4 - r4), l3 = 1 / (n3 - i3), u3 = 1 / (s4 - a3);
          return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e4 + r4) * o3, t3[13] = (i3 + n3) * l3, t3[14] = (a3 + s4) * u3, t3[15] = 1, t3;
        }
        function Q(t3, e4, r4) {
          return t3[0] = e4[0] - r4[0], t3[1] = e4[1] - r4[1], t3[2] = e4[2] - r4[2], t3[3] = e4[3] - r4[3], t3[4] = e4[4] - r4[4], t3[5] = e4[5] - r4[5], t3[6] = e4[6] - r4[6], t3[7] = e4[7] - r4[7], t3[8] = e4[8] - r4[8], t3[9] = e4[9] - r4[9], t3[10] = e4[10] - r4[10], t3[11] = e4[11] - r4[11], t3[12] = e4[12] - r4[12], t3[13] = e4[13] - r4[13], t3[14] = e4[14] - r4[14], t3[15] = e4[15] - r4[15], t3;
        }
        D.perspective = $, D.ortho = G, D.mul = N, D.sub = Q;
        var Y = {}, X2 = {};
        function Z2(t3) {
          return Z2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, Z2(t3);
        }
        Object.defineProperty(X2, "__esModule", { value: true }), X2.create = H, X2.clone = function(t3) {
          var e4 = new K.ARRAY_TYPE(3);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4;
        }, X2.length = J, X2.fromValues = function(t3, e4, r4) {
          var n3 = new K.ARRAY_TYPE(3);
          return n3[0] = t3, n3[1] = e4, n3[2] = r4, n3;
        }, X2.copy = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3;
        }, X2.set = function(t3, e4, r4, n3) {
          return t3[0] = e4, t3[1] = r4, t3[2] = n3, t3;
        }, X2.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3[2] = e4[2] + r4[2], t3;
        }, X2.subtract = tt, X2.multiply = et, X2.divide = rt, X2.ceil = function(t3, e4) {
          return t3[0] = Math.ceil(e4[0]), t3[1] = Math.ceil(e4[1]), t3[2] = Math.ceil(e4[2]), t3;
        }, X2.floor = function(t3, e4) {
          return t3[0] = Math.floor(e4[0]), t3[1] = Math.floor(e4[1]), t3[2] = Math.floor(e4[2]), t3;
        }, X2.min = function(t3, e4, r4) {
          return t3[0] = Math.min(e4[0], r4[0]), t3[1] = Math.min(e4[1], r4[1]), t3[2] = Math.min(e4[2], r4[2]), t3;
        }, X2.max = function(t3, e4, r4) {
          return t3[0] = Math.max(e4[0], r4[0]), t3[1] = Math.max(e4[1], r4[1]), t3[2] = Math.max(e4[2], r4[2]), t3;
        }, X2.round = function(t3, e4) {
          return t3[0] = Math.round(e4[0]), t3[1] = Math.round(e4[1]), t3[2] = Math.round(e4[2]), t3;
        }, X2.scale = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3[2] = e4[2] * r4, t3;
        }, X2.scaleAndAdd = function(t3, e4, r4, n3) {
          return t3[0] = e4[0] + r4[0] * n3, t3[1] = e4[1] + r4[1] * n3, t3[2] = e4[2] + r4[2] * n3, t3;
        }, X2.distance = nt, X2.squaredDistance = it, X2.squaredLength = st, X2.negate = function(t3, e4) {
          return t3[0] = -e4[0], t3[1] = -e4[1], t3[2] = -e4[2], t3;
        }, X2.inverse = function(t3, e4) {
          return t3[0] = 1 / e4[0], t3[1] = 1 / e4[1], t3[2] = 1 / e4[2], t3;
        }, X2.normalize = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = r4 * r4 + n3 * n3 + i3 * i3;
          return s4 > 0 && (s4 = 1 / Math.sqrt(s4)), t3[0] = e4[0] * s4, t3[1] = e4[1] * s4, t3[2] = e4[2] * s4, t3;
        }, X2.dot = at, X2.cross = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = r4[0], o3 = r4[1], l3 = r4[2];
          return t3[0] = i3 * l3 - s4 * o3, t3[1] = s4 * a3 - n3 * l3, t3[2] = n3 * o3 - i3 * a3, t3;
        }, X2.lerp = function(t3, e4, r4, n3) {
          var i3 = e4[0], s4 = e4[1], a3 = e4[2];
          return t3[0] = i3 + n3 * (r4[0] - i3), t3[1] = s4 + n3 * (r4[1] - s4), t3[2] = a3 + n3 * (r4[2] - a3), t3;
        }, X2.hermite = function(t3, e4, r4, n3, i3, s4) {
          var a3 = s4 * s4, o3 = a3 * (2 * s4 - 3) + 1, l3 = a3 * (s4 - 2) + s4, u3 = a3 * (s4 - 1), c3 = a3 * (3 - 2 * s4);
          return t3[0] = e4[0] * o3 + r4[0] * l3 + n3[0] * u3 + i3[0] * c3, t3[1] = e4[1] * o3 + r4[1] * l3 + n3[1] * u3 + i3[1] * c3, t3[2] = e4[2] * o3 + r4[2] * l3 + n3[2] * u3 + i3[2] * c3, t3;
        }, X2.bezier = function(t3, e4, r4, n3, i3, s4) {
          var a3 = 1 - s4, o3 = a3 * a3, l3 = s4 * s4, u3 = o3 * a3, c3 = 3 * s4 * o3, h2 = 3 * l3 * a3, p3 = l3 * s4;
          return t3[0] = e4[0] * u3 + r4[0] * c3 + n3[0] * h2 + i3[0] * p3, t3[1] = e4[1] * u3 + r4[1] * c3 + n3[1] * h2 + i3[1] * p3, t3[2] = e4[2] * u3 + r4[2] * c3 + n3[2] * h2 + i3[2] * p3, t3;
        }, X2.random = function(t3, e4) {
          e4 = e4 || 1;
          var r4 = 2 * K.RANDOM() * Math.PI, n3 = 2 * K.RANDOM() - 1, i3 = Math.sqrt(1 - n3 * n3) * e4;
          return t3[0] = Math.cos(r4) * i3, t3[1] = Math.sin(r4) * i3, t3[2] = n3 * e4, t3;
        }, X2.transformMat4 = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = r4[3] * n3 + r4[7] * i3 + r4[11] * s4 + r4[15];
          return t3[0] = (r4[0] * n3 + r4[4] * i3 + r4[8] * s4 + r4[12]) / (a3 = a3 || 1), t3[1] = (r4[1] * n3 + r4[5] * i3 + r4[9] * s4 + r4[13]) / a3, t3[2] = (r4[2] * n3 + r4[6] * i3 + r4[10] * s4 + r4[14]) / a3, t3;
        }, X2.transformMat3 = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2];
          return t3[0] = n3 * r4[0] + i3 * r4[3] + s4 * r4[6], t3[1] = n3 * r4[1] + i3 * r4[4] + s4 * r4[7], t3[2] = n3 * r4[2] + i3 * r4[5] + s4 * r4[8], t3;
        }, X2.transformQuat = function(t3, e4, r4) {
          var n3 = r4[0], i3 = r4[1], s4 = r4[2], a3 = e4[0], o3 = e4[1], l3 = e4[2], u3 = i3 * l3 - s4 * o3, c3 = s4 * a3 - n3 * l3, h2 = n3 * o3 - i3 * a3, p3 = i3 * h2 - s4 * c3, f2 = s4 * u3 - n3 * h2, d2 = n3 * c3 - i3 * u3, m2 = 2 * r4[3];
          return c3 *= m2, h2 *= m2, f2 *= 2, d2 *= 2, t3[0] = a3 + (u3 *= m2) + (p3 *= 2), t3[1] = o3 + c3 + f2, t3[2] = l3 + h2 + d2, t3;
        }, X2.rotateX = function(t3, e4, r4, n3) {
          var i3 = [], s4 = [];
          return i3[0] = e4[0] - r4[0], i3[1] = e4[1] - r4[1], i3[2] = e4[2] - r4[2], s4[0] = i3[0], s4[1] = i3[1] * Math.cos(n3) - i3[2] * Math.sin(n3), s4[2] = i3[1] * Math.sin(n3) + i3[2] * Math.cos(n3), t3[0] = s4[0] + r4[0], t3[1] = s4[1] + r4[1], t3[2] = s4[2] + r4[2], t3;
        }, X2.rotateY = function(t3, e4, r4, n3) {
          var i3 = [], s4 = [];
          return i3[0] = e4[0] - r4[0], i3[1] = e4[1] - r4[1], i3[2] = e4[2] - r4[2], s4[0] = i3[2] * Math.sin(n3) + i3[0] * Math.cos(n3), s4[1] = i3[1], s4[2] = i3[2] * Math.cos(n3) - i3[0] * Math.sin(n3), t3[0] = s4[0] + r4[0], t3[1] = s4[1] + r4[1], t3[2] = s4[2] + r4[2], t3;
        }, X2.rotateZ = function(t3, e4, r4, n3) {
          var i3 = [], s4 = [];
          return i3[0] = e4[0] - r4[0], i3[1] = e4[1] - r4[1], i3[2] = e4[2] - r4[2], s4[0] = i3[0] * Math.cos(n3) - i3[1] * Math.sin(n3), s4[1] = i3[0] * Math.sin(n3) + i3[1] * Math.cos(n3), s4[2] = i3[2], t3[0] = s4[0] + r4[0], t3[1] = s4[1] + r4[1], t3[2] = s4[2] + r4[2], t3;
        }, X2.angle = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = e4[0], a3 = e4[1], o3 = e4[2], l3 = Math.sqrt(r4 * r4 + n3 * n3 + i3 * i3) * Math.sqrt(s4 * s4 + a3 * a3 + o3 * o3), u3 = l3 && at(t3, e4) / l3;
          return Math.acos(Math.min(Math.max(u3, -1), 1));
        }, X2.zero = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3;
        }, X2.str = function(t3) {
          return "vec3(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ")";
        }, X2.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1] && t3[2] === e4[2];
        }, X2.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = e4[0], a3 = e4[1], o3 = e4[2];
          return Math.abs(r4 - s4) <= K.EPSILON * Math.max(1, Math.abs(r4), Math.abs(s4)) && Math.abs(n3 - a3) <= K.EPSILON * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i3 - o3) <= K.EPSILON * Math.max(1, Math.abs(i3), Math.abs(o3));
        }, X2.forEach = X2.sqrLen = X2.len = X2.sqrDist = X2.dist = X2.div = X2.mul = X2.sub = void 0;
        var K = function(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== Z2(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = W(void 0);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }(f);
        function W(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (W = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function H() {
          var t3 = new K.ARRAY_TYPE(3);
          return K.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3;
        }
        function J(t3) {
          return Math.hypot(t3[0], t3[1], t3[2]);
        }
        function tt(t3, e4, r4) {
          return t3[0] = e4[0] - r4[0], t3[1] = e4[1] - r4[1], t3[2] = e4[2] - r4[2], t3;
        }
        function et(t3, e4, r4) {
          return t3[0] = e4[0] * r4[0], t3[1] = e4[1] * r4[1], t3[2] = e4[2] * r4[2], t3;
        }
        function rt(t3, e4, r4) {
          return t3[0] = e4[0] / r4[0], t3[1] = e4[1] / r4[1], t3[2] = e4[2] / r4[2], t3;
        }
        function nt(t3, e4) {
          return Math.hypot(e4[0] - t3[0], e4[1] - t3[1], e4[2] - t3[2]);
        }
        function it(t3, e4) {
          var r4 = e4[0] - t3[0], n3 = e4[1] - t3[1], i3 = e4[2] - t3[2];
          return r4 * r4 + n3 * n3 + i3 * i3;
        }
        function st(t3) {
          var e4 = t3[0], r4 = t3[1], n3 = t3[2];
          return e4 * e4 + r4 * r4 + n3 * n3;
        }
        function at(t3, e4) {
          return t3[0] * e4[0] + t3[1] * e4[1] + t3[2] * e4[2];
        }
        X2.sub = tt, X2.mul = et, X2.div = rt, X2.dist = nt, X2.sqrDist = it, X2.len = J, X2.sqrLen = st;
        var ot, lt = (ot = H(), function(t3, e4, r4, n3, i3, s4) {
          var a3, o3;
          for (e4 || (e4 = 3), r4 || (r4 = 0), o3 = n3 ? Math.min(n3 * e4 + r4, t3.length) : t3.length, a3 = r4; a3 < o3; a3 += e4)
            ot[0] = t3[a3], ot[1] = t3[a3 + 1], ot[2] = t3[a3 + 2], i3(ot, ot, s4), t3[a3] = ot[0], t3[a3 + 1] = ot[1], t3[a3 + 2] = ot[2];
          return t3;
        });
        X2.forEach = lt;
        var ut = {};
        function ct(t3) {
          return ct = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, ct(t3);
        }
        Object.defineProperty(ut, "__esModule", { value: true }), ut.create = ft, ut.clone = function(t3) {
          var e4 = new ht.ARRAY_TYPE(4);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4;
        }, ut.fromValues = function(t3, e4, r4, n3) {
          var i3 = new ht.ARRAY_TYPE(4);
          return i3[0] = t3, i3[1] = e4, i3[2] = r4, i3[3] = n3, i3;
        }, ut.copy = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3;
        }, ut.set = function(t3, e4, r4, n3, i3) {
          return t3[0] = e4, t3[1] = r4, t3[2] = n3, t3[3] = i3, t3;
        }, ut.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3[2] = e4[2] + r4[2], t3[3] = e4[3] + r4[3], t3;
        }, ut.subtract = dt, ut.multiply = mt, ut.divide = yt, ut.ceil = function(t3, e4) {
          return t3[0] = Math.ceil(e4[0]), t3[1] = Math.ceil(e4[1]), t3[2] = Math.ceil(e4[2]), t3[3] = Math.ceil(e4[3]), t3;
        }, ut.floor = function(t3, e4) {
          return t3[0] = Math.floor(e4[0]), t3[1] = Math.floor(e4[1]), t3[2] = Math.floor(e4[2]), t3[3] = Math.floor(e4[3]), t3;
        }, ut.min = function(t3, e4, r4) {
          return t3[0] = Math.min(e4[0], r4[0]), t3[1] = Math.min(e4[1], r4[1]), t3[2] = Math.min(e4[2], r4[2]), t3[3] = Math.min(e4[3], r4[3]), t3;
        }, ut.max = function(t3, e4, r4) {
          return t3[0] = Math.max(e4[0], r4[0]), t3[1] = Math.max(e4[1], r4[1]), t3[2] = Math.max(e4[2], r4[2]), t3[3] = Math.max(e4[3], r4[3]), t3;
        }, ut.round = function(t3, e4) {
          return t3[0] = Math.round(e4[0]), t3[1] = Math.round(e4[1]), t3[2] = Math.round(e4[2]), t3[3] = Math.round(e4[3]), t3;
        }, ut.scale = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3[2] = e4[2] * r4, t3[3] = e4[3] * r4, t3;
        }, ut.scaleAndAdd = function(t3, e4, r4, n3) {
          return t3[0] = e4[0] + r4[0] * n3, t3[1] = e4[1] + r4[1] * n3, t3[2] = e4[2] + r4[2] * n3, t3[3] = e4[3] + r4[3] * n3, t3;
        }, ut.distance = gt, ut.squaredDistance = xt, ut.length = bt, ut.squaredLength = vt, ut.negate = function(t3, e4) {
          return t3[0] = -e4[0], t3[1] = -e4[1], t3[2] = -e4[2], t3[3] = -e4[3], t3;
        }, ut.inverse = function(t3, e4) {
          return t3[0] = 1 / e4[0], t3[1] = 1 / e4[1], t3[2] = 1 / e4[2], t3[3] = 1 / e4[3], t3;
        }, ut.normalize = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = r4 * r4 + n3 * n3 + i3 * i3 + s4 * s4;
          return a3 > 0 && (a3 = 1 / Math.sqrt(a3)), t3[0] = r4 * a3, t3[1] = n3 * a3, t3[2] = i3 * a3, t3[3] = s4 * a3, t3;
        }, ut.dot = function(t3, e4) {
          return t3[0] * e4[0] + t3[1] * e4[1] + t3[2] * e4[2] + t3[3] * e4[3];
        }, ut.cross = function(t3, e4, r4, n3) {
          var i3 = r4[0] * n3[1] - r4[1] * n3[0], s4 = r4[0] * n3[2] - r4[2] * n3[0], a3 = r4[0] * n3[3] - r4[3] * n3[0], o3 = r4[1] * n3[2] - r4[2] * n3[1], l3 = r4[1] * n3[3] - r4[3] * n3[1], u3 = r4[2] * n3[3] - r4[3] * n3[2], c3 = e4[0], h2 = e4[1], p3 = e4[2], f2 = e4[3];
          return t3[0] = h2 * u3 - p3 * l3 + f2 * o3, t3[1] = -c3 * u3 + p3 * a3 - f2 * s4, t3[2] = c3 * l3 - h2 * a3 + f2 * i3, t3[3] = -c3 * o3 + h2 * s4 - p3 * i3, t3;
        }, ut.lerp = function(t3, e4, r4, n3) {
          var i3 = e4[0], s4 = e4[1], a3 = e4[2], o3 = e4[3];
          return t3[0] = i3 + n3 * (r4[0] - i3), t3[1] = s4 + n3 * (r4[1] - s4), t3[2] = a3 + n3 * (r4[2] - a3), t3[3] = o3 + n3 * (r4[3] - o3), t3;
        }, ut.random = function(t3, e4) {
          var r4, n3, i3, s4, a3, o3;
          e4 = e4 || 1;
          do {
            a3 = (r4 = 2 * ht.RANDOM() - 1) * r4 + (n3 = 2 * ht.RANDOM() - 1) * n3;
          } while (a3 >= 1);
          do {
            o3 = (i3 = 2 * ht.RANDOM() - 1) * i3 + (s4 = 2 * ht.RANDOM() - 1) * s4;
          } while (o3 >= 1);
          var l3 = Math.sqrt((1 - a3) / o3);
          return t3[0] = e4 * r4, t3[1] = e4 * n3, t3[2] = e4 * i3 * l3, t3[3] = e4 * s4 * l3, t3;
        }, ut.transformMat4 = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3];
          return t3[0] = r4[0] * n3 + r4[4] * i3 + r4[8] * s4 + r4[12] * a3, t3[1] = r4[1] * n3 + r4[5] * i3 + r4[9] * s4 + r4[13] * a3, t3[2] = r4[2] * n3 + r4[6] * i3 + r4[10] * s4 + r4[14] * a3, t3[3] = r4[3] * n3 + r4[7] * i3 + r4[11] * s4 + r4[15] * a3, t3;
        }, ut.transformQuat = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = r4[0], o3 = r4[1], l3 = r4[2], u3 = r4[3], c3 = u3 * n3 + o3 * s4 - l3 * i3, h2 = u3 * i3 + l3 * n3 - a3 * s4, p3 = u3 * s4 + a3 * i3 - o3 * n3, f2 = -a3 * n3 - o3 * i3 - l3 * s4;
          return t3[0] = c3 * u3 + f2 * -a3 + h2 * -l3 - p3 * -o3, t3[1] = h2 * u3 + f2 * -o3 + p3 * -a3 - c3 * -l3, t3[2] = p3 * u3 + f2 * -l3 + c3 * -o3 - h2 * -a3, t3[3] = e4[3], t3;
        }, ut.zero = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3;
        }, ut.str = function(t3) {
          return "vec4(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
        }, ut.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1] && t3[2] === e4[2] && t3[3] === e4[3];
        }, ut.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = t3[3], a3 = e4[0], o3 = e4[1], l3 = e4[2], u3 = e4[3];
          return Math.abs(r4 - a3) <= ht.EPSILON * Math.max(1, Math.abs(r4), Math.abs(a3)) && Math.abs(n3 - o3) <= ht.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i3 - l3) <= ht.EPSILON * Math.max(1, Math.abs(i3), Math.abs(l3)) && Math.abs(s4 - u3) <= ht.EPSILON * Math.max(1, Math.abs(s4), Math.abs(u3));
        }, ut.forEach = ut.sqrLen = ut.len = ut.sqrDist = ut.dist = ut.div = ut.mul = ut.sub = void 0;
        var ht = function(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== ct(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = pt2(void 0);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }(f);
        function pt2(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (pt2 = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function ft() {
          var t3 = new ht.ARRAY_TYPE(4);
          return ht.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0), t3;
        }
        function dt(t3, e4, r4) {
          return t3[0] = e4[0] - r4[0], t3[1] = e4[1] - r4[1], t3[2] = e4[2] - r4[2], t3[3] = e4[3] - r4[3], t3;
        }
        function mt(t3, e4, r4) {
          return t3[0] = e4[0] * r4[0], t3[1] = e4[1] * r4[1], t3[2] = e4[2] * r4[2], t3[3] = e4[3] * r4[3], t3;
        }
        function yt(t3, e4, r4) {
          return t3[0] = e4[0] / r4[0], t3[1] = e4[1] / r4[1], t3[2] = e4[2] / r4[2], t3[3] = e4[3] / r4[3], t3;
        }
        function gt(t3, e4) {
          return Math.hypot(e4[0] - t3[0], e4[1] - t3[1], e4[2] - t3[2], e4[3] - t3[3]);
        }
        function xt(t3, e4) {
          var r4 = e4[0] - t3[0], n3 = e4[1] - t3[1], i3 = e4[2] - t3[2], s4 = e4[3] - t3[3];
          return r4 * r4 + n3 * n3 + i3 * i3 + s4 * s4;
        }
        function bt(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
        }
        function vt(t3) {
          var e4 = t3[0], r4 = t3[1], n3 = t3[2], i3 = t3[3];
          return e4 * e4 + r4 * r4 + n3 * n3 + i3 * i3;
        }
        ut.sub = dt, ut.mul = mt, ut.div = yt, ut.dist = gt, ut.sqrDist = xt, ut.len = bt, ut.sqrLen = vt;
        var _t = function() {
          var t3 = ft();
          return function(e4, r4, n3, i3, s4, a3) {
            var o3, l3;
            for (r4 || (r4 = 4), n3 || (n3 = 0), l3 = i3 ? Math.min(i3 * r4 + n3, e4.length) : e4.length, o3 = n3; o3 < l3; o3 += r4)
              t3[0] = e4[o3], t3[1] = e4[o3 + 1], t3[2] = e4[o3 + 2], t3[3] = e4[o3 + 3], s4(t3, t3, a3), e4[o3] = t3[0], e4[o3 + 1] = t3[1], e4[o3 + 2] = t3[2], e4[o3 + 3] = t3[3];
            return e4;
          };
        }();
        function wt(t3) {
          return wt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, wt(t3);
        }
        ut.forEach = _t, Object.defineProperty(Y, "__esModule", { value: true }), Y.create = Et, Y.identity = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
        }, Y.setAxisAngle = zt, Y.getAxisAngle = function(t3, e4) {
          var r4 = 2 * Math.acos(e4[3]), n3 = Math.sin(r4 / 2);
          return n3 > Mt.EPSILON ? (t3[0] = e4[0] / n3, t3[1] = e4[1] / n3, t3[2] = e4[2] / n3) : (t3[0] = 1, t3[1] = 0, t3[2] = 0), r4;
        }, Y.getAngle = function(t3, e4) {
          var r4 = Lt(t3, e4);
          return Math.acos(2 * r4 * r4 - 1);
        }, Y.multiply = Tt, Y.rotateX = function(t3, e4, r4) {
          r4 *= 0.5;
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = Math.sin(r4), l3 = Math.cos(r4);
          return t3[0] = n3 * l3 + a3 * o3, t3[1] = i3 * l3 + s4 * o3, t3[2] = s4 * l3 - i3 * o3, t3[3] = a3 * l3 - n3 * o3, t3;
        }, Y.rotateY = function(t3, e4, r4) {
          r4 *= 0.5;
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = Math.sin(r4), l3 = Math.cos(r4);
          return t3[0] = n3 * l3 - s4 * o3, t3[1] = i3 * l3 + a3 * o3, t3[2] = s4 * l3 + n3 * o3, t3[3] = a3 * l3 - i3 * o3, t3;
        }, Y.rotateZ = function(t3, e4, r4) {
          r4 *= 0.5;
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = Math.sin(r4), l3 = Math.cos(r4);
          return t3[0] = n3 * l3 + i3 * o3, t3[1] = i3 * l3 - n3 * o3, t3[2] = s4 * l3 + a3 * o3, t3[3] = a3 * l3 - s4 * o3, t3;
        }, Y.calculateW = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2];
          return t3[0] = r4, t3[1] = n3, t3[2] = i3, t3[3] = Math.sqrt(Math.abs(1 - r4 * r4 - n3 * n3 - i3 * i3)), t3;
        }, Y.exp = Bt, Y.ln = Ct, Y.pow = function(t3, e4, r4) {
          return Ct(t3, e4), Dt(t3, t3, r4), Bt(t3, t3), t3;
        }, Y.slerp = Rt, Y.random = function(t3) {
          var e4 = Mt.RANDOM(), r4 = Mt.RANDOM(), n3 = Mt.RANDOM(), i3 = Math.sqrt(1 - e4), s4 = Math.sqrt(e4);
          return t3[0] = i3 * Math.sin(2 * Math.PI * r4), t3[1] = i3 * Math.cos(2 * Math.PI * r4), t3[2] = s4 * Math.sin(2 * Math.PI * n3), t3[3] = s4 * Math.cos(2 * Math.PI * n3), t3;
        }, Y.invert = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = r4 * r4 + n3 * n3 + i3 * i3 + s4 * s4, o3 = a3 ? 1 / a3 : 0;
          return t3[0] = -r4 * o3, t3[1] = -n3 * o3, t3[2] = -i3 * o3, t3[3] = s4 * o3, t3;
        }, Y.conjugate = function(t3, e4) {
          return t3[0] = -e4[0], t3[1] = -e4[1], t3[2] = -e4[2], t3[3] = e4[3], t3;
        }, Y.fromMat3 = Vt, Y.fromEuler = function(t3, e4, r4, n3) {
          var i3 = 0.5 * Math.PI / 180;
          e4 *= i3, r4 *= i3, n3 *= i3;
          var s4 = Math.sin(e4), a3 = Math.cos(e4), o3 = Math.sin(r4), l3 = Math.cos(r4), u3 = Math.sin(n3), c3 = Math.cos(n3);
          return t3[0] = s4 * l3 * c3 - a3 * o3 * u3, t3[1] = a3 * o3 * c3 + s4 * l3 * u3, t3[2] = a3 * l3 * u3 - s4 * o3 * c3, t3[3] = a3 * l3 * c3 + s4 * o3 * u3, t3;
        }, Y.str = function(t3) {
          return "quat(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
        }, Y.setAxes = Y.sqlerp = Y.rotationTo = Y.equals = Y.exactEquals = Y.normalize = Y.sqrLen = Y.squaredLength = Y.len = Y.length = Y.lerp = Y.dot = Y.scale = Y.mul = Y.add = Y.set = Y.copy = Y.fromValues = Y.clone = void 0;
        var Mt = Pt(f), At = Pt(z2), St = Pt(X2), It = Pt(ut);
        function kt(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (kt = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function Pt(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== wt(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = kt(e4);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }
        function Et() {
          var t3 = new Mt.ARRAY_TYPE(4);
          return Mt.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3[3] = 1, t3;
        }
        function zt(t3, e4, r4) {
          r4 *= 0.5;
          var n3 = Math.sin(r4);
          return t3[0] = n3 * e4[0], t3[1] = n3 * e4[1], t3[2] = n3 * e4[2], t3[3] = Math.cos(r4), t3;
        }
        function Tt(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = r4[0], l3 = r4[1], u3 = r4[2], c3 = r4[3];
          return t3[0] = n3 * c3 + a3 * o3 + i3 * u3 - s4 * l3, t3[1] = i3 * c3 + a3 * l3 + s4 * o3 - n3 * u3, t3[2] = s4 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[3] = a3 * c3 - n3 * o3 - i3 * l3 - s4 * u3, t3;
        }
        function Bt(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = Math.sqrt(r4 * r4 + n3 * n3 + i3 * i3), o3 = Math.exp(s4), l3 = a3 > 0 ? o3 * Math.sin(a3) / a3 : 0;
          return t3[0] = r4 * l3, t3[1] = n3 * l3, t3[2] = i3 * l3, t3[3] = o3 * Math.cos(a3), t3;
        }
        function Ct(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = e4[2], s4 = e4[3], a3 = Math.sqrt(r4 * r4 + n3 * n3 + i3 * i3), o3 = a3 > 0 ? Math.atan2(a3, s4) / a3 : 0;
          return t3[0] = r4 * o3, t3[1] = n3 * o3, t3[2] = i3 * o3, t3[3] = 0.5 * Math.log(r4 * r4 + n3 * n3 + i3 * i3 + s4 * s4), t3;
        }
        function Rt(t3, e4, r4, n3) {
          var i3, s4, a3, o3, l3, u3 = e4[0], c3 = e4[1], h2 = e4[2], p3 = e4[3], f2 = r4[0], d2 = r4[1], m2 = r4[2], y3 = r4[3];
          return (s4 = u3 * f2 + c3 * d2 + h2 * m2 + p3 * y3) < 0 && (s4 = -s4, f2 = -f2, d2 = -d2, m2 = -m2, y3 = -y3), 1 - s4 > Mt.EPSILON ? (i3 = Math.acos(s4), a3 = Math.sin(i3), o3 = Math.sin((1 - n3) * i3) / a3, l3 = Math.sin(n3 * i3) / a3) : (o3 = 1 - n3, l3 = n3), t3[0] = o3 * u3 + l3 * f2, t3[1] = o3 * c3 + l3 * d2, t3[2] = o3 * h2 + l3 * m2, t3[3] = o3 * p3 + l3 * y3, t3;
        }
        function Vt(t3, e4) {
          var r4, n3 = e4[0] + e4[4] + e4[8];
          if (n3 > 0)
            r4 = Math.sqrt(n3 + 1), t3[3] = 0.5 * r4, t3[0] = (e4[5] - e4[7]) * (r4 = 0.5 / r4), t3[1] = (e4[6] - e4[2]) * r4, t3[2] = (e4[1] - e4[3]) * r4;
          else {
            var i3 = 0;
            e4[4] > e4[0] && (i3 = 1), e4[8] > e4[3 * i3 + i3] && (i3 = 2);
            var s4 = (i3 + 1) % 3, a3 = (i3 + 2) % 3;
            r4 = Math.sqrt(e4[3 * i3 + i3] - e4[3 * s4 + s4] - e4[3 * a3 + a3] + 1), t3[i3] = 0.5 * r4, t3[3] = (e4[3 * s4 + a3] - e4[3 * a3 + s4]) * (r4 = 0.5 / r4), t3[s4] = (e4[3 * s4 + i3] + e4[3 * i3 + s4]) * r4, t3[a3] = (e4[3 * a3 + i3] + e4[3 * i3 + a3]) * r4;
          }
          return t3;
        }
        Y.clone = It.clone, Y.fromValues = It.fromValues, Y.copy = It.copy, Y.set = It.set, Y.add = It.add, Y.mul = Tt;
        var Dt = It.scale;
        Y.scale = Dt;
        var Lt = It.dot;
        Y.dot = Lt, Y.lerp = It.lerp;
        var Ft = It.length;
        Y.length = Ft, Y.len = Ft;
        var Ot = It.squaredLength;
        Y.squaredLength = Ot, Y.sqrLen = Ot;
        var Ut = It.normalize;
        Y.normalize = Ut, Y.exactEquals = It.exactEquals, Y.equals = It.equals;
        var Nt, jt, qt, $t = (Nt = St.create(), jt = St.fromValues(1, 0, 0), qt = St.fromValues(0, 1, 0), function(t3, e4, r4) {
          var n3 = St.dot(e4, r4);
          return n3 < -0.999999 ? (St.cross(Nt, jt, e4), St.len(Nt) < 1e-6 && St.cross(Nt, qt, e4), St.normalize(Nt, Nt), zt(t3, Nt, Math.PI), t3) : n3 > 0.999999 ? (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3) : (St.cross(Nt, e4, r4), t3[0] = Nt[0], t3[1] = Nt[1], t3[2] = Nt[2], t3[3] = 1 + n3, Ut(t3, t3));
        });
        Y.rotationTo = $t;
        var Gt, Qt, Yt = (Gt = Et(), Qt = Et(), function(t3, e4, r4, n3, i3, s4) {
          return Rt(Gt, e4, i3, s4), Rt(Qt, r4, n3, s4), Rt(t3, Gt, Qt, 2 * s4 * (1 - s4)), t3;
        });
        Y.sqlerp = Yt;
        var Xt, Zt = (Xt = At.create(), function(t3, e4, r4, n3) {
          return Xt[0] = r4[0], Xt[3] = r4[1], Xt[6] = r4[2], Xt[1] = n3[0], Xt[4] = n3[1], Xt[7] = n3[2], Xt[2] = -e4[0], Xt[5] = -e4[1], Xt[8] = -e4[2], Ut(t3, Vt(t3, Xt));
        });
        Y.setAxes = Zt;
        var Kt = {};
        function Wt(t3) {
          return Wt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, Wt(t3);
        }
        Object.defineProperty(Kt, "__esModule", { value: true }), Kt.create = function() {
          var t3 = new Ht.ARRAY_TYPE(8);
          return Ht.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[3] = 1, t3;
        }, Kt.clone = function(t3) {
          var e4 = new Ht.ARRAY_TYPE(8);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4;
        }, Kt.fromValues = function(t3, e4, r4, n3, i3, s4, a3, o3) {
          var l3 = new Ht.ARRAY_TYPE(8);
          return l3[0] = t3, l3[1] = e4, l3[2] = r4, l3[3] = n3, l3[4] = i3, l3[5] = s4, l3[6] = a3, l3[7] = o3, l3;
        }, Kt.fromRotationTranslationValues = function(t3, e4, r4, n3, i3, s4, a3) {
          var o3 = new Ht.ARRAY_TYPE(8);
          o3[0] = t3, o3[1] = e4, o3[2] = r4, o3[3] = n3;
          var l3 = 0.5 * i3, u3 = 0.5 * s4, c3 = 0.5 * a3;
          return o3[4] = l3 * n3 + u3 * r4 - c3 * e4, o3[5] = u3 * n3 + c3 * t3 - l3 * r4, o3[6] = c3 * n3 + l3 * e4 - u3 * t3, o3[7] = -l3 * t3 - u3 * e4 - c3 * r4, o3;
        }, Kt.fromRotationTranslation = ne, Kt.fromTranslation = function(t3, e4) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0.5 * e4[0], t3[5] = 0.5 * e4[1], t3[6] = 0.5 * e4[2], t3[7] = 0, t3;
        }, Kt.fromRotation = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3;
        }, Kt.fromMat4 = function(t3, e4) {
          var r4 = Jt.create();
          te.getRotation(r4, e4);
          var n3 = new Ht.ARRAY_TYPE(3);
          return te.getTranslation(n3, e4), ne(t3, r4, n3), t3;
        }, Kt.copy = ie2, Kt.identity = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3;
        }, Kt.set = function(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          return t3[0] = e4, t3[1] = r4, t3[2] = n3, t3[3] = i3, t3[4] = s4, t3[5] = a3, t3[6] = o3, t3[7] = l3, t3;
        }, Kt.getDual = function(t3, e4) {
          return t3[0] = e4[4], t3[1] = e4[5], t3[2] = e4[6], t3[3] = e4[7], t3;
        }, Kt.setDual = function(t3, e4) {
          return t3[4] = e4[0], t3[5] = e4[1], t3[6] = e4[2], t3[7] = e4[3], t3;
        }, Kt.getTranslation = function(t3, e4) {
          var r4 = e4[4], n3 = e4[5], i3 = e4[6], s4 = e4[7], a3 = -e4[0], o3 = -e4[1], l3 = -e4[2], u3 = e4[3];
          return t3[0] = 2 * (r4 * u3 + s4 * a3 + n3 * l3 - i3 * o3), t3[1] = 2 * (n3 * u3 + s4 * o3 + i3 * a3 - r4 * l3), t3[2] = 2 * (i3 * u3 + s4 * l3 + r4 * o3 - n3 * a3), t3;
        }, Kt.translate = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = 0.5 * r4[0], l3 = 0.5 * r4[1], u3 = 0.5 * r4[2], c3 = e4[4], h2 = e4[5], p3 = e4[6], f2 = e4[7];
          return t3[0] = n3, t3[1] = i3, t3[2] = s4, t3[3] = a3, t3[4] = a3 * o3 + i3 * u3 - s4 * l3 + c3, t3[5] = a3 * l3 + s4 * o3 - n3 * u3 + h2, t3[6] = a3 * u3 + n3 * l3 - i3 * o3 + p3, t3[7] = -n3 * o3 - i3 * l3 - s4 * u3 + f2, t3;
        }, Kt.rotateX = function(t3, e4, r4) {
          var n3 = -e4[0], i3 = -e4[1], s4 = -e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = o3 * a3 + c3 * n3 + l3 * s4 - u3 * i3, p3 = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s4, f2 = u3 * a3 + c3 * s4 + o3 * i3 - l3 * n3, d2 = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s4;
          return Jt.rotateX(t3, e4, r4), t3[4] = h2 * (a3 = t3[3]) + d2 * (n3 = t3[0]) + p3 * (s4 = t3[2]) - f2 * (i3 = t3[1]), t3[5] = p3 * a3 + d2 * i3 + f2 * n3 - h2 * s4, t3[6] = f2 * a3 + d2 * s4 + h2 * i3 - p3 * n3, t3[7] = d2 * a3 - h2 * n3 - p3 * i3 - f2 * s4, t3;
        }, Kt.rotateY = function(t3, e4, r4) {
          var n3 = -e4[0], i3 = -e4[1], s4 = -e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = o3 * a3 + c3 * n3 + l3 * s4 - u3 * i3, p3 = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s4, f2 = u3 * a3 + c3 * s4 + o3 * i3 - l3 * n3, d2 = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s4;
          return Jt.rotateY(t3, e4, r4), t3[4] = h2 * (a3 = t3[3]) + d2 * (n3 = t3[0]) + p3 * (s4 = t3[2]) - f2 * (i3 = t3[1]), t3[5] = p3 * a3 + d2 * i3 + f2 * n3 - h2 * s4, t3[6] = f2 * a3 + d2 * s4 + h2 * i3 - p3 * n3, t3[7] = d2 * a3 - h2 * n3 - p3 * i3 - f2 * s4, t3;
        }, Kt.rotateZ = function(t3, e4, r4) {
          var n3 = -e4[0], i3 = -e4[1], s4 = -e4[2], a3 = e4[3], o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = o3 * a3 + c3 * n3 + l3 * s4 - u3 * i3, p3 = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s4, f2 = u3 * a3 + c3 * s4 + o3 * i3 - l3 * n3, d2 = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s4;
          return Jt.rotateZ(t3, e4, r4), t3[4] = h2 * (a3 = t3[3]) + d2 * (n3 = t3[0]) + p3 * (s4 = t3[2]) - f2 * (i3 = t3[1]), t3[5] = p3 * a3 + d2 * i3 + f2 * n3 - h2 * s4, t3[6] = f2 * a3 + d2 * s4 + h2 * i3 - p3 * n3, t3[7] = d2 * a3 - h2 * n3 - p3 * i3 - f2 * s4, t3;
        }, Kt.rotateByQuatAppend = function(t3, e4, r4) {
          var n3 = r4[0], i3 = r4[1], s4 = r4[2], a3 = r4[3], o3 = e4[0], l3 = e4[1], u3 = e4[2], c3 = e4[3];
          return t3[0] = o3 * a3 + c3 * n3 + l3 * s4 - u3 * i3, t3[1] = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s4, t3[2] = u3 * a3 + c3 * s4 + o3 * i3 - l3 * n3, t3[3] = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s4, t3[4] = (o3 = e4[4]) * a3 + (c3 = e4[7]) * n3 + (l3 = e4[5]) * s4 - (u3 = e4[6]) * i3, t3[5] = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s4, t3[6] = u3 * a3 + c3 * s4 + o3 * i3 - l3 * n3, t3[7] = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s4, t3;
        }, Kt.rotateByQuatPrepend = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = r4[0], l3 = r4[1], u3 = r4[2], c3 = r4[3];
          return t3[0] = n3 * c3 + a3 * o3 + i3 * u3 - s4 * l3, t3[1] = i3 * c3 + a3 * l3 + s4 * o3 - n3 * u3, t3[2] = s4 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[3] = a3 * c3 - n3 * o3 - i3 * l3 - s4 * u3, t3[4] = n3 * (c3 = r4[7]) + a3 * (o3 = r4[4]) + i3 * (u3 = r4[6]) - s4 * (l3 = r4[5]), t3[5] = i3 * c3 + a3 * l3 + s4 * o3 - n3 * u3, t3[6] = s4 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[7] = a3 * c3 - n3 * o3 - i3 * l3 - s4 * u3, t3;
        }, Kt.rotateAroundAxis = function(t3, e4, r4, n3) {
          if (Math.abs(n3) < Ht.EPSILON)
            return ie2(t3, e4);
          var i3 = Math.hypot(r4[0], r4[1], r4[2]);
          n3 *= 0.5;
          var s4 = Math.sin(n3), a3 = s4 * r4[0] / i3, o3 = s4 * r4[1] / i3, l3 = s4 * r4[2] / i3, u3 = Math.cos(n3), c3 = e4[0], h2 = e4[1], p3 = e4[2], f2 = e4[3];
          t3[0] = c3 * u3 + f2 * a3 + h2 * l3 - p3 * o3, t3[1] = h2 * u3 + f2 * o3 + p3 * a3 - c3 * l3, t3[2] = p3 * u3 + f2 * l3 + c3 * o3 - h2 * a3, t3[3] = f2 * u3 - c3 * a3 - h2 * o3 - p3 * l3;
          var d2 = e4[4], m2 = e4[5], y3 = e4[6], g3 = e4[7];
          return t3[4] = d2 * u3 + g3 * a3 + m2 * l3 - y3 * o3, t3[5] = m2 * u3 + g3 * o3 + y3 * a3 - d2 * l3, t3[6] = y3 * u3 + g3 * l3 + d2 * o3 - m2 * a3, t3[7] = g3 * u3 - d2 * a3 - m2 * o3 - y3 * l3, t3;
        }, Kt.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3[2] = e4[2] + r4[2], t3[3] = e4[3] + r4[3], t3[4] = e4[4] + r4[4], t3[5] = e4[5] + r4[5], t3[6] = e4[6] + r4[6], t3[7] = e4[7] + r4[7], t3;
        }, Kt.multiply = se, Kt.scale = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3[2] = e4[2] * r4, t3[3] = e4[3] * r4, t3[4] = e4[4] * r4, t3[5] = e4[5] * r4, t3[6] = e4[6] * r4, t3[7] = e4[7] * r4, t3;
        }, Kt.lerp = function(t3, e4, r4, n3) {
          var i3 = 1 - n3;
          return ae(e4, r4) < 0 && (n3 = -n3), t3[0] = e4[0] * i3 + r4[0] * n3, t3[1] = e4[1] * i3 + r4[1] * n3, t3[2] = e4[2] * i3 + r4[2] * n3, t3[3] = e4[3] * i3 + r4[3] * n3, t3[4] = e4[4] * i3 + r4[4] * n3, t3[5] = e4[5] * i3 + r4[5] * n3, t3[6] = e4[6] * i3 + r4[6] * n3, t3[7] = e4[7] * i3 + r4[7] * n3, t3;
        }, Kt.invert = function(t3, e4) {
          var r4 = le(e4);
          return t3[0] = -e4[0] / r4, t3[1] = -e4[1] / r4, t3[2] = -e4[2] / r4, t3[3] = e4[3] / r4, t3[4] = -e4[4] / r4, t3[5] = -e4[5] / r4, t3[6] = -e4[6] / r4, t3[7] = e4[7] / r4, t3;
        }, Kt.conjugate = function(t3, e4) {
          return t3[0] = -e4[0], t3[1] = -e4[1], t3[2] = -e4[2], t3[3] = e4[3], t3[4] = -e4[4], t3[5] = -e4[5], t3[6] = -e4[6], t3[7] = e4[7], t3;
        }, Kt.normalize = function(t3, e4) {
          var r4 = le(e4);
          if (r4 > 0) {
            r4 = Math.sqrt(r4);
            var n3 = e4[0] / r4, i3 = e4[1] / r4, s4 = e4[2] / r4, a3 = e4[3] / r4, o3 = e4[4], l3 = e4[5], u3 = e4[6], c3 = e4[7], h2 = n3 * o3 + i3 * l3 + s4 * u3 + a3 * c3;
            t3[0] = n3, t3[1] = i3, t3[2] = s4, t3[3] = a3, t3[4] = (o3 - n3 * h2) / r4, t3[5] = (l3 - i3 * h2) / r4, t3[6] = (u3 - s4 * h2) / r4, t3[7] = (c3 - a3 * h2) / r4;
          }
          return t3;
        }, Kt.str = function(t3) {
          return "quat2(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ")";
        }, Kt.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1] && t3[2] === e4[2] && t3[3] === e4[3] && t3[4] === e4[4] && t3[5] === e4[5] && t3[6] === e4[6] && t3[7] === e4[7];
        }, Kt.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = t3[2], s4 = t3[3], a3 = t3[4], o3 = t3[5], l3 = t3[6], u3 = t3[7], c3 = e4[0], h2 = e4[1], p3 = e4[2], f2 = e4[3], d2 = e4[4], m2 = e4[5], y3 = e4[6], g3 = e4[7];
          return Math.abs(r4 - c3) <= Ht.EPSILON * Math.max(1, Math.abs(r4), Math.abs(c3)) && Math.abs(n3 - h2) <= Ht.EPSILON * Math.max(1, Math.abs(n3), Math.abs(h2)) && Math.abs(i3 - p3) <= Ht.EPSILON * Math.max(1, Math.abs(i3), Math.abs(p3)) && Math.abs(s4 - f2) <= Ht.EPSILON * Math.max(1, Math.abs(s4), Math.abs(f2)) && Math.abs(a3 - d2) <= Ht.EPSILON * Math.max(1, Math.abs(a3), Math.abs(d2)) && Math.abs(o3 - m2) <= Ht.EPSILON * Math.max(1, Math.abs(o3), Math.abs(m2)) && Math.abs(l3 - y3) <= Ht.EPSILON * Math.max(1, Math.abs(l3), Math.abs(y3)) && Math.abs(u3 - g3) <= Ht.EPSILON * Math.max(1, Math.abs(u3), Math.abs(g3));
        }, Kt.sqrLen = Kt.squaredLength = Kt.len = Kt.length = Kt.dot = Kt.mul = Kt.setReal = Kt.getReal = void 0;
        var Ht = re(f), Jt = re(Y), te = re(D);
        function ee(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (ee = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function re(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== Wt(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = ee(e4);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }
        function ne(t3, e4, r4) {
          var n3 = 0.5 * r4[0], i3 = 0.5 * r4[1], s4 = 0.5 * r4[2], a3 = e4[0], o3 = e4[1], l3 = e4[2], u3 = e4[3];
          return t3[0] = a3, t3[1] = o3, t3[2] = l3, t3[3] = u3, t3[4] = n3 * u3 + i3 * l3 - s4 * o3, t3[5] = i3 * u3 + s4 * a3 - n3 * l3, t3[6] = s4 * u3 + n3 * o3 - i3 * a3, t3[7] = -n3 * a3 - i3 * o3 - s4 * l3, t3;
        }
        function ie2(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3;
        }
        function se(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1], s4 = e4[2], a3 = e4[3], o3 = r4[4], l3 = r4[5], u3 = r4[6], c3 = r4[7], h2 = e4[4], p3 = e4[5], f2 = e4[6], d2 = e4[7], m2 = r4[0], y3 = r4[1], g3 = r4[2], x3 = r4[3];
          return t3[0] = n3 * x3 + a3 * m2 + i3 * g3 - s4 * y3, t3[1] = i3 * x3 + a3 * y3 + s4 * m2 - n3 * g3, t3[2] = s4 * x3 + a3 * g3 + n3 * y3 - i3 * m2, t3[3] = a3 * x3 - n3 * m2 - i3 * y3 - s4 * g3, t3[4] = n3 * c3 + a3 * o3 + i3 * u3 - s4 * l3 + h2 * x3 + d2 * m2 + p3 * g3 - f2 * y3, t3[5] = i3 * c3 + a3 * l3 + s4 * o3 - n3 * u3 + p3 * x3 + d2 * y3 + f2 * m2 - h2 * g3, t3[6] = s4 * c3 + a3 * u3 + n3 * l3 - i3 * o3 + f2 * x3 + d2 * g3 + h2 * y3 - p3 * m2, t3[7] = a3 * c3 - n3 * o3 - i3 * l3 - s4 * u3 + d2 * x3 - h2 * m2 - p3 * y3 - f2 * g3, t3;
        }
        Kt.getReal = Jt.copy, Kt.setReal = Jt.copy, Kt.mul = se;
        var ae = Jt.dot;
        Kt.dot = ae;
        var oe = Jt.length;
        Kt.length = oe, Kt.len = oe;
        var le = Jt.squaredLength;
        Kt.squaredLength = le, Kt.sqrLen = le;
        var ue = {};
        function ce2(t3) {
          return ce2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, ce2(t3);
        }
        Object.defineProperty(ue, "__esModule", { value: true }), ue.create = fe, ue.clone = function(t3) {
          var e4 = new he.ARRAY_TYPE(2);
          return e4[0] = t3[0], e4[1] = t3[1], e4;
        }, ue.fromValues = function(t3, e4) {
          var r4 = new he.ARRAY_TYPE(2);
          return r4[0] = t3, r4[1] = e4, r4;
        }, ue.copy = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3;
        }, ue.set = function(t3, e4, r4) {
          return t3[0] = e4, t3[1] = r4, t3;
        }, ue.add = function(t3, e4, r4) {
          return t3[0] = e4[0] + r4[0], t3[1] = e4[1] + r4[1], t3;
        }, ue.subtract = de, ue.multiply = me, ue.divide = ye, ue.ceil = function(t3, e4) {
          return t3[0] = Math.ceil(e4[0]), t3[1] = Math.ceil(e4[1]), t3;
        }, ue.floor = function(t3, e4) {
          return t3[0] = Math.floor(e4[0]), t3[1] = Math.floor(e4[1]), t3;
        }, ue.min = function(t3, e4, r4) {
          return t3[0] = Math.min(e4[0], r4[0]), t3[1] = Math.min(e4[1], r4[1]), t3;
        }, ue.max = function(t3, e4, r4) {
          return t3[0] = Math.max(e4[0], r4[0]), t3[1] = Math.max(e4[1], r4[1]), t3;
        }, ue.round = function(t3, e4) {
          return t3[0] = Math.round(e4[0]), t3[1] = Math.round(e4[1]), t3;
        }, ue.scale = function(t3, e4, r4) {
          return t3[0] = e4[0] * r4, t3[1] = e4[1] * r4, t3;
        }, ue.scaleAndAdd = function(t3, e4, r4, n3) {
          return t3[0] = e4[0] + r4[0] * n3, t3[1] = e4[1] + r4[1] * n3, t3;
        }, ue.distance = ge, ue.squaredDistance = xe, ue.length = be, ue.squaredLength = ve, ue.negate = function(t3, e4) {
          return t3[0] = -e4[0], t3[1] = -e4[1], t3;
        }, ue.inverse = function(t3, e4) {
          return t3[0] = 1 / e4[0], t3[1] = 1 / e4[1], t3;
        }, ue.normalize = function(t3, e4) {
          var r4 = e4[0], n3 = e4[1], i3 = r4 * r4 + n3 * n3;
          return i3 > 0 && (i3 = 1 / Math.sqrt(i3)), t3[0] = e4[0] * i3, t3[1] = e4[1] * i3, t3;
        }, ue.dot = function(t3, e4) {
          return t3[0] * e4[0] + t3[1] * e4[1];
        }, ue.cross = function(t3, e4, r4) {
          var n3 = e4[0] * r4[1] - e4[1] * r4[0];
          return t3[0] = t3[1] = 0, t3[2] = n3, t3;
        }, ue.lerp = function(t3, e4, r4, n3) {
          var i3 = e4[0], s4 = e4[1];
          return t3[0] = i3 + n3 * (r4[0] - i3), t3[1] = s4 + n3 * (r4[1] - s4), t3;
        }, ue.random = function(t3, e4) {
          e4 = e4 || 1;
          var r4 = 2 * he.RANDOM() * Math.PI;
          return t3[0] = Math.cos(r4) * e4, t3[1] = Math.sin(r4) * e4, t3;
        }, ue.transformMat2 = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1];
          return t3[0] = r4[0] * n3 + r4[2] * i3, t3[1] = r4[1] * n3 + r4[3] * i3, t3;
        }, ue.transformMat2d = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1];
          return t3[0] = r4[0] * n3 + r4[2] * i3 + r4[4], t3[1] = r4[1] * n3 + r4[3] * i3 + r4[5], t3;
        }, ue.transformMat3 = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1];
          return t3[0] = r4[0] * n3 + r4[3] * i3 + r4[6], t3[1] = r4[1] * n3 + r4[4] * i3 + r4[7], t3;
        }, ue.transformMat4 = function(t3, e4, r4) {
          var n3 = e4[0], i3 = e4[1];
          return t3[0] = r4[0] * n3 + r4[4] * i3 + r4[12], t3[1] = r4[1] * n3 + r4[5] * i3 + r4[13], t3;
        }, ue.rotate = function(t3, e4, r4, n3) {
          var i3 = e4[0] - r4[0], s4 = e4[1] - r4[1], a3 = Math.sin(n3), o3 = Math.cos(n3);
          return t3[0] = i3 * o3 - s4 * a3 + r4[0], t3[1] = i3 * a3 + s4 * o3 + r4[1], t3;
        }, ue.angle = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = e4[0], s4 = e4[1], a3 = Math.sqrt(r4 * r4 + n3 * n3) * Math.sqrt(i3 * i3 + s4 * s4);
          return Math.acos(Math.min(Math.max(a3 && (r4 * i3 + n3 * s4) / a3, -1), 1));
        }, ue.zero = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3;
        }, ue.str = function(t3) {
          return "vec2(" + t3[0] + ", " + t3[1] + ")";
        }, ue.exactEquals = function(t3, e4) {
          return t3[0] === e4[0] && t3[1] === e4[1];
        }, ue.equals = function(t3, e4) {
          var r4 = t3[0], n3 = t3[1], i3 = e4[0], s4 = e4[1];
          return Math.abs(r4 - i3) <= he.EPSILON * Math.max(1, Math.abs(r4), Math.abs(i3)) && Math.abs(n3 - s4) <= he.EPSILON * Math.max(1, Math.abs(n3), Math.abs(s4));
        }, ue.forEach = ue.sqrLen = ue.sqrDist = ue.dist = ue.div = ue.mul = ue.sub = ue.len = void 0;
        var he = function(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== ce2(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = pe(void 0);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }(f);
        function pe(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (pe = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function fe() {
          var t3 = new he.ARRAY_TYPE(2);
          return he.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0), t3;
        }
        function de(t3, e4, r4) {
          return t3[0] = e4[0] - r4[0], t3[1] = e4[1] - r4[1], t3;
        }
        function me(t3, e4, r4) {
          return t3[0] = e4[0] * r4[0], t3[1] = e4[1] * r4[1], t3;
        }
        function ye(t3, e4, r4) {
          return t3[0] = e4[0] / r4[0], t3[1] = e4[1] / r4[1], t3;
        }
        function ge(t3, e4) {
          return Math.hypot(e4[0] - t3[0], e4[1] - t3[1]);
        }
        function xe(t3, e4) {
          var r4 = e4[0] - t3[0], n3 = e4[1] - t3[1];
          return r4 * r4 + n3 * n3;
        }
        function be(t3) {
          return Math.hypot(t3[0], t3[1]);
        }
        function ve(t3) {
          var e4 = t3[0], r4 = t3[1];
          return e4 * e4 + r4 * r4;
        }
        ue.len = be, ue.sub = de, ue.mul = me, ue.div = ye, ue.dist = ge, ue.sqrDist = xe, ue.sqrLen = ve;
        var _e = function() {
          var t3 = fe();
          return function(e4, r4, n3, i3, s4, a3) {
            var o3, l3;
            for (r4 || (r4 = 2), n3 || (n3 = 0), l3 = i3 ? Math.min(i3 * r4 + n3, e4.length) : e4.length, o3 = n3; o3 < l3; o3 += r4)
              t3[0] = e4[o3], t3[1] = e4[o3 + 1], s4(t3, t3, a3), e4[o3] = t3[0], e4[o3 + 1] = t3[1];
            return e4;
          };
        }();
        function we(t3) {
          return we = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, we(t3);
        }
        ue.forEach = _e, Object.defineProperty(p2, "__esModule", { value: true }), t2.aa = p2.vec4 = t2.Q = p2.vec3 = p2.vec2 = p2.quat2 = t2.bl = p2.quat = t2.a9 = p2.mat4 = t2.ct = p2.mat3 = p2.mat2d = t2.b7 = p2.mat2 = p2.glMatrix = void 0;
        var Me = Re(f);
        p2.glMatrix = Me;
        var Ae = Re(x2);
        t2.b7 = p2.mat2 = Ae;
        var Se = Re(A);
        p2.mat2d = Se;
        var Ie = Re(z2);
        t2.ct = p2.mat3 = Ie;
        var ke = Re(D);
        t2.a9 = p2.mat4 = ke;
        var Pe = Re(Y);
        t2.bl = p2.quat = Pe;
        var Ee = Re(Kt);
        p2.quat2 = Ee;
        var ze = Re(ue);
        p2.vec2 = ze;
        var Te = Re(X2);
        t2.Q = p2.vec3 = Te;
        var Be = Re(ut);
        function Ce(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (Ce = function(t4) {
            return t4 ? r4 : e4;
          })(t3);
        }
        function Re(t3, e4) {
          if (t3 && t3.__esModule)
            return t3;
          if (null === t3 || "object" !== we(t3) && "function" != typeof t3)
            return { default: t3 };
          var r4 = Ce(e4);
          if (r4 && r4.has(t3))
            return r4.get(t3);
          var n3 = {}, i3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t3)
            if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t3, s4)) {
              var a3 = i3 ? Object.getOwnPropertyDescriptor(t3, s4) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, s4, a3) : n3[s4] = t3[s4];
            }
          return n3.default = t3, r4 && r4.set(t3, n3), n3;
        }
        t2.aa = p2.vec4 = Be;
        var Ve = De;
        function De(t3, e4, r4, n3) {
          this.cx = 3 * t3, this.bx = 3 * (r4 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e4, this.by = 3 * (n3 - e4) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e4, this.p2x = r4, this.p2y = n3;
        }
        De.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e4) {
          if (void 0 === e4 && (e4 = 1e-6), t3 < 0)
            return 0;
          if (t3 > 1)
            return 1;
          for (var r4 = t3, n3 = 0; n3 < 8; n3++) {
            var i3 = this.sampleCurveX(r4) - t3;
            if (Math.abs(i3) < e4)
              return r4;
            var s4 = this.sampleCurveDerivativeX(r4);
            if (Math.abs(s4) < 1e-6)
              break;
            r4 -= i3 / s4;
          }
          var a3 = 0, o3 = 1;
          for (r4 = t3, n3 = 0; n3 < 20 && (i3 = this.sampleCurveX(r4), !(Math.abs(i3 - t3) < e4)); n3++)
            t3 > i3 ? a3 = r4 : o3 = r4, r4 = 0.5 * (o3 - a3) + a3;
          return r4;
        }, solve: function(t3, e4) {
          return this.sampleCurveY(this.solveCurveX(t3, e4));
        } };
        var Le = h(Ve), Fe = Oe;
        function Oe(t3, e4) {
          this.x = t3, this.y = e4;
        }
        Oe.prototype = { clone: function() {
          return new Oe(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e4) {
          return this.clone()._rotateAround(t3, e4);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e4 = t3.x - this.x, r4 = t3.y - this.y;
          return e4 * e4 + r4 * r4;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e4) {
          return Math.atan2(this.x * e4 - this.y * t3, this.x * t3 + this.y * e4);
        }, _matMult: function(t3) {
          var e4 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e4, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e4 = Math.cos(t3), r4 = Math.sin(t3), n3 = r4 * this.x + e4 * this.y;
          return this.x = e4 * this.x - r4 * this.y, this.y = n3, this;
        }, _rotateAround: function(t3, e4) {
          var r4 = Math.cos(t3), n3 = Math.sin(t3), i3 = e4.y + n3 * (this.x - e4.x) + r4 * (this.y - e4.y);
          return this.x = e4.x + r4 * (this.x - e4.x) - n3 * (this.y - e4.y), this.y = i3, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, Oe.convert = function(t3) {
          return t3 instanceof Oe ? t3 : Array.isArray(t3) ? new Oe(t3[0], t3[1]) : t3;
        };
        var Ue = h(Fe);
        const Ne = Math.PI / 180, je = 180 / Math.PI;
        function qe(t3) {
          return t3 * Ne;
        }
        function $e(t3) {
          return t3 * je;
        }
        const Ge = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function Qe(t3) {
          if (t3 <= 0)
            return 0;
          if (t3 >= 1)
            return 1;
          const e4 = t3 * t3, r4 = e4 * t3;
          return 4 * (t3 < 0.5 ? r4 : 3 * (t3 - e4) + r4 - 0.75);
        }
        function Ye(t3, e4, r4, n3) {
          const i3 = new Le(t3, e4, r4, n3);
          return function(t4) {
            return i3.solve(t4);
          };
        }
        const Xe = Ye(0.25, 0.1, 0.25, 1);
        function Ze(t3, e4, r4) {
          return Math.min(r4, Math.max(e4, t3));
        }
        function Ke(t3, e4, r4) {
          return (r4 = Ze((r4 - t3) / (e4 - t3), 0, 1)) * r4 * (3 - 2 * r4);
        }
        function We(t3, e4, r4) {
          const n3 = r4 - e4, i3 = ((t3 - e4) % n3 + n3) % n3 + e4;
          return i3 === e4 ? r4 : i3;
        }
        function He(t3, e4, r4) {
          if (!t3.length)
            return r4(null, []);
          let n3 = t3.length;
          const i3 = new Array(t3.length);
          let s4 = null;
          t3.forEach((t4, a3) => {
            e4(t4, (t5, e5) => {
              t5 && (s4 = t5), i3[a3] = e5, 0 == --n3 && r4(s4, i3);
            });
          });
        }
        function Je(t3, ...e4) {
          for (const r4 of e4)
            for (const e5 in r4)
              t3[e5] = r4[e5];
          return t3;
        }
        let tr = 1;
        function er() {
          return tr++;
        }
        function rr() {
          return function t3(e4) {
            return e4 ? (e4 ^ Math.random() * (16 >> e4 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t3);
          }();
        }
        function nr(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
        }
        function ir(t3) {
          return !!t3 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t3);
        }
        function sr(t3, e4) {
          t3.forEach((t4) => {
            e4[t4] && (e4[t4] = e4[t4].bind(e4));
          });
        }
        function ar(t3, e4) {
          return -1 !== t3.indexOf(e4, t3.length - e4.length);
        }
        function or(t3, e4, r4) {
          const n3 = {};
          for (const r5 in t3)
            n3[r5] = e4.call(this, t3[r5], r5, t3);
          return n3;
        }
        function lr(t3, e4, r4) {
          const n3 = {};
          for (const r5 in t3)
            e4.call(this, t3[r5], r5, t3) && (n3[r5] = t3[r5]);
          return n3;
        }
        function ur(t3) {
          return Array.isArray(t3) ? t3.map(ur) : "object" == typeof t3 && t3 ? or(t3, ur) : t3;
        }
        const cr = {};
        function hr(t3) {
          cr[t3] || ("undefined" != typeof console && console.warn(t3), cr[t3] = true);
        }
        function pr(t3, e4, r4) {
          return (r4.y - t3.y) * (e4.x - t3.x) > (e4.y - t3.y) * (r4.x - t3.x);
        }
        function fr(t3) {
          let e4 = 0;
          for (let r4, n3, i3 = 0, s4 = t3.length, a3 = s4 - 1; i3 < s4; a3 = i3++)
            r4 = t3[i3], n3 = t3[a3], e4 += (n3.x - r4.x) * (r4.y + n3.y);
          return e4;
        }
        function dr([t3, e4, r4]) {
          const n3 = qe(e4 + 90), i3 = qe(r4);
          return { x: t3 * Math.cos(n3) * Math.sin(i3), y: t3 * Math.sin(n3) * Math.sin(i3), z: t3 * Math.cos(i3), azimuthal: e4, polar: r4 };
        }
        function mr() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function yr(t3) {
          const e4 = {};
          if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r4, n3, i3) => {
            const s4 = n3 || i3;
            return e4[r4] = !s4 || s4.toLowerCase(), "";
          }), e4["max-age"]) {
            const t4 = parseInt(e4["max-age"], 10);
            isNaN(t4) ? delete e4["max-age"] : e4["max-age"] = t4;
          }
          return e4;
        }
        let gr, xr, br, vr, _r, wr, Mr = null;
        function Ar(t3) {
          try {
            const e4 = self[t3];
            return e4.setItem("_mapbox_test_", 1), e4.removeItem("_mapbox_test_"), true;
          } catch (t4) {
            return false;
          }
        }
        function Sr(t3, e4) {
          return [t3[4 * e4], t3[4 * e4 + 1], t3[4 * e4 + 2], t3[4 * e4 + 3]];
        }
        function Ir(t3, e4, r4, n3) {
          for (; e4 < r4; ) {
            const i3 = e4 + r4 >> 1;
            t3[i3] < n3 ? e4 = i3 + 1 : r4 = i3;
          }
          return e4;
        }
        function kr(t3, e4, r4, n3) {
          for (; e4 < r4; ) {
            const i3 = e4 + r4 >> 1;
            t3[i3] <= n3 ? e4 = i3 + 1 : r4 = i3;
          }
          return e4;
        }
        function Pr(t3) {
          return t3 > 0 ? 1 / (1.001 - t3) : 1 + t3;
        }
        function Er(t3) {
          return t3 > 0 ? 1 - 1 / (1.001 - t3) : -t3;
        }
        function zr() {
          return null == gr && (gr = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), gr;
        }
        const Tr = { now: () => void 0 !== vr ? vr : performance.now(), setNow(t3) {
          vr = t3;
        }, restoreNow() {
          vr = void 0;
        }, frame(t3) {
          const e4 = requestAnimationFrame(t3);
          return { cancel: () => cancelAnimationFrame(e4) };
        }, getImageData(t3, e4 = 0) {
          const { width: r4, height: n3 } = t3;
          _r || (_r = document.createElement("canvas"));
          const i3 = _r.getContext("2d", { willReadFrequently: true });
          if (!i3)
            throw new Error("failed to create canvas 2d context");
          return (r4 > _r.width || n3 > _r.height) && (_r.width = r4, _r.height = n3), i3.clearRect(-e4, -e4, r4 + 2 * e4, n3 + 2 * e4), i3.drawImage(t3, 0, 0, r4, n3), i3.getImageData(-e4, -e4, r4 + 2 * e4, n3 + 2 * e4);
        }, resolveURL: (t3) => (xr || (xr = document.createElement("a")), xr.href = t3, xr.href), get devicePixelRatio() {
          return window.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!window.matchMedia && (null == br && (br = window.matchMedia("(prefers-reduced-motion: reduce)")), br.matches);
        }, hasCanvasFingerprintNoise() {
          if (void 0 !== wr)
            return wr;
          if (!zr())
            return wr = false, false;
          const t3 = new OffscreenCanvas(85, 1), e4 = t3.getContext("2d", { willReadFrequently: true });
          let r4 = 0;
          for (let n4 = 0; n4 < t3.width; ++n4)
            e4.fillStyle = `rgba(${r4++},${r4++},${r4++}, 255)`, e4.fillRect(n4, 0, 1, 1);
          const n3 = e4.getImageData(0, 0, t3.width, t3.height);
          r4 = 0;
          for (let t4 = 0; t4 < n3.data.length; ++t4)
            if (t4 % 4 != 3 && r4++ !== n3.data[t4])
              return wr = true, true;
          return wr = false, false;
        } };
        function Br(t3, e4) {
          const r4 = t3.indexOf("?");
          if (r4 < 0)
            return `${t3}?${new URLSearchParams(e4).toString()}`;
          const n3 = new URLSearchParams(t3.slice(r4));
          for (const t4 in e4)
            n3.set(t4, e4[t4]);
          return `${t3.slice(0, r4)}?${n3.toString()}`;
        }
        function Cr(t3, e4 = { persistentParams: [] }) {
          const r4 = t3.indexOf("?");
          if (r4 < 0)
            return t3;
          const n3 = new URLSearchParams(), i3 = new URLSearchParams(t3.slice(r4));
          for (const t4 of e4.persistentParams) {
            const e5 = i3.get(t4);
            e5 && n3.set(t4, e5);
          }
          const s4 = n3.toString();
          return `${t3.slice(0, r4)}${s4.length > 0 ? `?${s4}` : ""}`;
        }
        const Rr = "mapbox-tiles";
        let Vr = 500, Dr = 50;
        let Lr, Fr;
        function Or() {
          try {
            return caches;
          } catch (t3) {
          }
        }
        function Ur() {
          const t3 = Or();
          t3 && !Lr && (Lr = t3.open(Rr));
        }
        let Nr = 1 / 0;
        const jr = { supported: false, testSupport: function(t3) {
          !Gr && $r && (Qr ? Xr(t3) : qr = t3);
        } };
        let qr, $r, Gr = false, Qr = false;
        const Yr = "undefined" != typeof self ? self : {};
        function Xr(t3) {
          const e4 = t3.createTexture();
          t3.bindTexture(t3.TEXTURE_2D, e4);
          try {
            if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, $r), t3.isContextLost())
              return;
            jr.supported = true;
          } catch (t4) {
          }
          t3.deleteTexture(e4), Gr = true;
        }
        Yr.document && ($r = Yr.document.createElement("img"), $r.onload = function() {
          qr && Xr(qr), qr = null, Qr = true;
        }, $r.onerror = function() {
          Gr = true, qr = null;
        }, $r.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Zr = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image", Model: "Model" };
        "function" == typeof Object.freeze && Object.freeze(Zr);
        class Kr extends Error {
          constructor(t3, e4, r4) {
            401 === e4 && i2(r4) && (t3 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t3), this.status = e4, this.url = r4;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const Wr = mr() ? () => self.worker && self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
        const Hr = function(t3, e4) {
          if (!(/^file:/.test(r4 = t3.url) || /^file:/.test(Wr()) && !/^\w+:/.test(r4))) {
            if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
              return function(t4, e5) {
                const r5 = new AbortController(), n3 = new Request(t4.url, { method: t4.method || "GET", body: t4.body, credentials: t4.credentials, headers: t4.headers, referrer: Wr(), referrerPolicy: t4.referrerPolicy, signal: r5.signal });
                let s4 = false, a3 = false;
                const o3 = (l3 = n3.url).indexOf("sku=") > 0 && i2(l3);
                var l3;
                "json" === t4.type && n3.headers.set("Accept", "application/json");
                const u3 = (r6, i3, s5) => {
                  if (a3)
                    return;
                  if (r6 && "SecurityError" !== r6.message && hr(r6.toString()), i3 && s5)
                    return c3(i3);
                  const l4 = Date.now();
                  fetch(n3).then((r7) => {
                    if (r7.ok) {
                      const t5 = o3 ? r7.clone() : null;
                      return c3(r7, t5, l4);
                    }
                    return e5(new Kr(r7.statusText, r7.status, t4.url));
                  }).catch((r7) => {
                    "AbortError" !== r7.name && e5(new Error(`${r7.message} ${t4.url}`));
                  });
                }, c3 = (r6, i3, o4) => {
                  ("arrayBuffer" === t4.type ? r6.arrayBuffer() : "json" === t4.type ? r6.json() : r6.text()).then((t5) => {
                    a3 || (i3 && o4 && function(t6, e6, r7) {
                      if (Ur(), !Lr)
                        return;
                      const n4 = yr(e6.headers.get("Cache-Control") || "");
                      if (n4["no-store"])
                        return;
                      const i4 = { status: e6.status, statusText: e6.statusText, headers: new Headers() };
                      e6.headers.forEach((t7, e7) => i4.headers.set(e7, t7)), n4["max-age"] && i4.headers.set("Expires", new Date(r7 + 1e3 * n4["max-age"]).toUTCString());
                      const s5 = i4.headers.get("Expires");
                      if (!s5)
                        return;
                      if (new Date(s5).getTime() - r7 < 42e4)
                        return;
                      let a4 = Cr(t6.url, { persistentParams: ["language", "worldview"] });
                      if (206 === e6.status) {
                        const e7 = t6.headers.get("Range");
                        if (!e7)
                          return;
                        i4.status = 200, a4 = Br(a4, { range: e7 });
                      }
                      !function(t7, e7) {
                        if (void 0 === Fr)
                          try {
                            new Response(new ReadableStream()), Fr = true;
                          } catch (t8) {
                            Fr = false;
                          }
                        Fr ? e7(t7.body) : t7.blob().then(e7);
                      }(e6, (t7) => {
                        const e7 = new Response(t7, i4);
                        Ur(), Lr && Lr.then((t8) => t8.put(a4, e7)).catch((t8) => hr(t8.message));
                      });
                    }(n3, i3, o4), s4 = true, e5(null, t5, r6.headers.get("Cache-Control"), r6.headers.get("Expires")));
                  }).catch((t5) => {
                    a3 || e5(new Error(t5.message));
                  });
                };
                return o3 ? function(t5, e6) {
                  if (Ur(), !Lr)
                    return e6(null);
                  Lr.then((r6) => {
                    let n4 = Cr(t5.url, { persistentParams: ["language", "worldview"] });
                    const i3 = t5.headers.get("Range");
                    i3 && (n4 = Br(n4, { range: i3 })), r6.match(n4).then((t6) => {
                      const i4 = function(t7) {
                        if (!t7)
                          return false;
                        const e7 = new Date(t7.headers.get("Expires") || 0), r7 = yr(t7.headers.get("Cache-Control") || "");
                        return e7 > Date.now() && !r7["no-cache"];
                      }(t6);
                      r6.delete(n4), i4 && r6.put(n4, t6.clone()), e6(null, t6, i4);
                    }).catch(e6);
                  }).catch(e6);
                }(n3, u3) : u3(null, null), { cancel: () => {
                  a3 = true, s4 || r5.abort();
                } };
              }(t3, e4);
            if (mr() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t3, e4, void 0, true);
          }
          var r4;
          return function(t4, e5) {
            const r5 = new XMLHttpRequest();
            r5.open(t4.method || "GET", t4.url, true), "arrayBuffer" === t4.type && (r5.responseType = "arraybuffer");
            for (const e6 in t4.headers)
              r5.setRequestHeader(e6, t4.headers[e6]);
            return "json" === t4.type && (r5.responseType = "text", r5.setRequestHeader("Accept", "application/json")), r5.withCredentials = "include" === t4.credentials, r5.onerror = () => {
              e5(new Error(r5.statusText));
            }, r5.onload = () => {
              if ((r5.status >= 200 && r5.status < 300 || 0 === r5.status) && null !== r5.response) {
                let n3 = r5.response;
                if ("json" === t4.type)
                  try {
                    n3 = JSON.parse(r5.response);
                  } catch (t5) {
                    return e5(t5);
                  }
                e5(null, n3, r5.getResponseHeader("Cache-Control"), r5.getResponseHeader("Expires"));
              } else
                e5(new Kr(r5.statusText, r5.status, t4.url));
            }, r5.send(t4.body), { cancel: () => r5.abort() };
          }(t3, e4);
        }, Jr = function(t3, e4) {
          return Hr(Je(t3, { type: "arrayBuffer" }), e4);
        };
        function tn(t3) {
          const e4 = document.createElement("a");
          return e4.href = t3, e4.protocol === location.protocol && e4.host === location.host;
        }
        const en = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let rn, nn;
        rn = [], nn = 0;
        const sn = function(t3, e4) {
          if (jr.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), nn >= n2.MAX_PARALLEL_IMAGE_REQUESTS) {
            const r5 = { requestParameters: t3, callback: e4, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return rn.push(r5), r5;
          }
          nn++;
          let r4 = false;
          const i3 = () => {
            if (!r4)
              for (r4 = true, nn--; rn.length && nn < n2.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                const t4 = rn.shift(), { requestParameters: e5, callback: r5, cancelled: n3 } = t4;
                n3 || (t4.cancel = sn(e5, r5).cancel);
              }
          }, s4 = Jr(t3, (t4, r5, n3, s5) => {
            i3(), t4 ? e4(t4) : r5 && (self.createImageBitmap ? function(t5, e5) {
              const r6 = new Blob([new Uint8Array(t5)], { type: "image/png" });
              createImageBitmap(r6).then((t6) => {
                e5(null, t6);
              }).catch((t6) => {
                e5(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(r5, (t5, r6) => e4(t5, r6, n3, s5)) : function(t5, e5) {
              const r6 = new Image();
              r6.onload = () => {
                e5(null, r6), URL.revokeObjectURL(r6.src), r6.onload = null, requestAnimationFrame(() => {
                  r6.src = en;
                });
              }, r6.onerror = () => e5(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const n4 = new Blob([new Uint8Array(t5)], { type: "image/png" });
              r6.src = t5.byteLength ? URL.createObjectURL(n4) : en;
            }(r5, (t5, r6) => e4(t5, r6, n3, s5)));
          });
          return { cancel: () => {
            s4.cancel(), i3();
          } };
        }, an = "01", on = "NO_ACCESS_TOKEN", ln = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function un(t3) {
          const e4 = t3.match(ln);
          if (!e4)
            throw new Error("Unable to parse URL object");
          return { protocol: e4[1], authority: e4[2], path: e4[3] || "/", params: e4[4] ? e4[4].split("&") : [] };
        }
        function cn2(t3) {
          const e4 = t3.params.length ? `?${t3.params.join("&")}` : "";
          return `${t3.protocol}://${t3.authority}${t3.path}${e4}`;
        }
        const hn = "mapbox.eventData";
        function pn(t3) {
          if (!t3)
            return null;
          const e4 = t3.split(".");
          if (!e4 || 3 !== e4.length)
            return null;
          try {
            return JSON.parse(decodeURIComponent(atob(e4[1]).split("").map((t4) => "%" + ("00" + t4.charCodeAt(0).toString(16)).slice(-2)).join("")));
          } catch (t4) {
            return null;
          }
        }
        class fn {
          constructor(t3) {
            this.type = t3, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t3) {
            const e4 = pn(n2.ACCESS_TOKEN);
            let r4 = "";
            return r4 = e4 && e4.u ? btoa(encodeURIComponent(e4.u).replace(/%([0-9A-F]{2})/g, (t4, e5) => String.fromCharCode(Number("0x" + e5)))) : n2.ACCESS_TOKEN || "", t3 ? `${hn}.${t3}:${r4}` : `${hn}:${r4}`;
          }
          fetchEventData() {
            const t3 = Ar("localStorage"), e4 = this.getStorageKey(), r4 = this.getStorageKey("uuid");
            if (t3)
              try {
                const t4 = localStorage.getItem(e4);
                t4 && (this.eventData = JSON.parse(t4));
                const n3 = localStorage.getItem(r4);
                n3 && (this.anonId = n3);
              } catch (t4) {
                hr("Unable to read from LocalStorage");
              }
          }
          saveEventData() {
            const t3 = Ar("localStorage"), e4 = this.getStorageKey(), r4 = this.getStorageKey("uuid"), n3 = this.anonId;
            if (t3 && n3)
              try {
                localStorage.setItem(r4, n3), Object.keys(this.eventData).length >= 1 && localStorage.setItem(e4, JSON.stringify(this.eventData));
              } catch (t4) {
                hr("Unable to write to LocalStorage");
              }
          }
          processRequests(t3) {
          }
          postEvent(t3, e4, r4, i3) {
            if (!n2.EVENTS_URL)
              return;
            const s4 = un(n2.EVENTS_URL);
            s4.params.push(`access_token=${i3 || n2.ACCESS_TOKEN || ""}`);
            const a3 = { event: this.type, created: new Date(t3).toISOString() }, o3 = e4 ? Je(a3, e4) : a3, l3 = { url: cn2(s4), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o3]) };
            this.pendingRequest = function(t4, e5) {
              return Hr(Je(t4, { method: "POST" }), e5);
            }(l3, (t4) => {
              this.pendingRequest = null, r4(t4), this.saveEventData(), this.processRequests(i3);
            });
          }
          queueRequest(t3, e4) {
            this.queue.push(t3), this.processRequests(e4);
          }
        }
        const dn = new class extends fn {
          constructor(t3) {
            super("appUserTurnstile"), this._customAccessToken = t3;
          }
          postTurnstileEvent(t3, e4) {
            n2.EVENTS_URL && n2.ACCESS_TOKEN && Array.isArray(t3) && t3.some((t4) => s3(t4) || i2(t4)) && this.queueRequest(Date.now(), e4);
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const r4 = pn(n2.ACCESS_TOKEN), i3 = r4 ? r4.u : n2.ACCESS_TOKEN;
            let s4 = i3 !== this.eventData.tokenU;
            ir(this.anonId) || (this.anonId = rr(), s4 = true);
            const a3 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const t4 = new Date(this.eventData.lastSuccess), e4 = new Date(a3), r5 = (a3 - this.eventData.lastSuccess) / 864e5;
              s4 = s4 || r5 >= 1 || r5 < -1 || t4.getDate() !== e4.getDate();
            } else
              s4 = true;
            s4 ? this.postEvent(a3, { sdkIdentifier: "mapbox-gl-js", sdkVersion: e3, skuId: an, "enabled.telemetry": false, userId: this.anonId }, (t4) => {
              t4 || (this.eventData.lastSuccess = a3, this.eventData.tokenU = i3);
            }, t3) : this.processRequests();
          }
        }(), mn = dn.postTurnstileEvent.bind(dn), yn = new class extends fn {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(t3, e4, r4, i3) {
            this.skuToken = e4, this.errorCb = i3, n2.EVENTS_URL && (r4 || n2.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r4) : this.errorCb(new Error(on)));
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { id: r4, timestamp: n3 } = this.queue.shift();
            r4 && this.success[r4] || (this.anonId || this.fetchEventData(), ir(this.anonId) || (this.anonId = rr()), this.postEvent(n3, { sdkIdentifier: "mapbox-gl-js", sdkVersion: e3, skuId: an, skuToken: this.skuToken, userId: this.anonId }, (t4) => {
              t4 ? this.errorCb(t4) : r4 && (this.success[r4] = true);
            }, t3));
          }
          remove() {
            this.errorCb = null;
          }
        }(), gn = yn.postMapLoadEvent.bind(yn), xn = new class extends fn {
          constructor() {
            super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
          }
          getMapInstanceId(t3) {
            let e4 = this.mapInstanceIdMap.get(t3);
            return e4 || (e4 = rr(), this.mapInstanceIdMap.set(t3, e4)), e4;
          }
          getEventId(t3) {
            const e4 = this.eventIdPerMapInstanceMap.get(t3) || 0;
            return this.eventIdPerMapInstanceMap.set(t3, e4 + 1), e4;
          }
          postStyleLoadEvent(t3, e4) {
            const { map: r4, style: i3, importedStyles: s4 } = e4;
            if (!n2.EVENTS_URL || !t3 && !n2.ACCESS_TOKEN)
              return;
            const a3 = this.getMapInstanceId(r4), o3 = { mapInstanceId: a3, eventId: this.getEventId(a3), style: i3 };
            s4.length && (o3.importedStyles = s4), this.queueRequest({ timestamp: Date.now(), payload: o3 }, t3);
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { timestamp: e4, payload: r4 } = this.queue.shift();
            this.postEvent(e4, r4, () => {
            }, t3);
          }
        }(), bn = xn.postStyleLoadEvent.bind(xn), vn = new class extends fn {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(t3, e4) {
            n2.EVENTS_URL && (t3 || n2.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e4 }, t3);
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { timestamp: r4, performanceData: n3 } = this.queue.shift(), i3 = function(t4) {
              const r5 = performance.getEntriesByType("resource"), n4 = performance.getEntriesByType("mark"), i4 = function(t5) {
                const e4 = {};
                if (t5) {
                  for (const r6 in t5)
                    if ("other" !== r6)
                      for (const n5 of t5[r6]) {
                        const t6 = `${r6}ResolveRangeMin`, i5 = `${r6}ResolveRangeMax`, s5 = `${r6}RequestCount`, a4 = `${r6}RequestCachedCount`;
                        e4[t6] = Math.min(e4[t6] || 1 / 0, n5.startTime), e4[i5] = Math.max(e4[i5] || -1 / 0, n5.responseEnd);
                        const o4 = (t7) => {
                          void 0 === e4[t7] && (e4[t7] = 0), ++e4[t7];
                        };
                        void 0 !== n5.transferSize && 0 === n5.transferSize && o4(a4), o4(s5);
                      }
                }
                return e4;
              }(function(t5, e4) {
                const r6 = {};
                if (t5)
                  for (const n5 of t5) {
                    const t6 = e4(n5);
                    void 0 === r6[t6] && (r6[t6] = []), r6[t6].push(n5);
                  }
                return r6;
              }(r5, c2)), s4 = window.devicePixelRatio, a3 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, o3 = a3 ? a3.effectiveType : void 0, h2 = { counters: [], metadata: [], attributes: [] }, p3 = (t5, e4, r6) => {
                null != r6 && t5.push({ name: e4, value: r6.toString() });
              };
              for (const t5 in i4)
                p3(h2.counters, t5, i4[t5]);
              if (t4.interactionRange[0] !== 1 / 0 && t4.interactionRange[1] !== -1 / 0 && (p3(h2.counters, "interactionRangeMin", t4.interactionRange[0]), p3(h2.counters, "interactionRangeMax", t4.interactionRange[1])), n4)
                for (const t5 of Object.keys(u2)) {
                  const e4 = u2[t5], r6 = n4.find((t6) => t6.name === e4);
                  r6 && p3(h2.counters, e4, r6.startTime);
                }
              return p3(h2.counters, "visibilityHidden", t4.visibilityHidden), p3(h2.attributes, "style", function(t5) {
                if (t5)
                  for (const e4 of t5) {
                    const t6 = e4.name.split("?")[0];
                    if (l2(t6)) {
                      const e5 = t6.split("/").slice(-2);
                      if (2 === e5.length)
                        return `mapbox://styles/${e5[0]}/${e5[1]}`;
                    }
                  }
              }(r5)), p3(h2.attributes, "terrainEnabled", t4.terrainEnabled ? "true" : "false"), p3(h2.attributes, "fogEnabled", t4.fogEnabled ? "true" : "false"), p3(h2.attributes, "projection", t4.projection), p3(h2.attributes, "zoom", t4.zoom), p3(h2.metadata, "devicePixelRatio", s4), p3(h2.metadata, "connectionEffectiveType", o3), p3(h2.metadata, "navigatorUserAgent", navigator.userAgent), p3(h2.metadata, "screenWidth", window.screen.width), p3(h2.metadata, "screenHeight", window.screen.height), p3(h2.metadata, "windowWidth", window.innerWidth), p3(h2.metadata, "windowHeight", window.innerHeight), p3(h2.metadata, "mapWidth", t4.width / s4), p3(h2.metadata, "mapHeight", t4.height / s4), p3(h2.metadata, "webglRenderer", t4.renderer), p3(h2.metadata, "webglVendor", t4.vendor), p3(h2.metadata, "sdkVersion", e3), p3(h2.metadata, "sdkIdentifier", "mapbox-gl-js"), h2;
            }(n3);
            for (const t4 of i3.metadata)
              ;
            for (const t4 of i3.counters)
              ;
            for (const t4 of i3.attributes)
              ;
            this.postEvent(r4, i3, () => {
            }, t3);
          }
        }(), _n = vn.postPerformanceEvent.bind(vn), wn = new class extends fn {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(t3, e4, r4, i3) {
            if (!n2.API_URL || !n2.SESSION_PATH)
              return;
            const s4 = un(n2.API_URL + n2.SESSION_PATH);
            s4.params.push(`sku=${e4 || ""}`), s4.params.push(`access_token=${i3 || n2.ACCESS_TOKEN || ""}`);
            const a3 = { url: cn2(s4), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = function(t4, e5) {
              return Hr(Je(t4, { method: "GET" }), e5);
            }(a3, (t4) => {
              this.pendingRequest = null, r4(t4), this.saveEventData(), this.processRequests(i3);
            });
          }
          getSessionAPI(t3, e4, r4, i3) {
            this.skuToken = e4, this.errorCb = i3, n2.SESSION_PATH && n2.API_URL && (r4 || n2.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r4) : this.errorCb(new Error(on)));
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { id: e4, timestamp: r4 } = this.queue.shift();
            e4 && this.success[e4] || this.getSession(r4, this.skuToken, (t4) => {
              t4 ? this.errorCb(t4) : e4 && (this.success[e4] = true);
            }, t3);
          }
          remove() {
            this.errorCb = null;
          }
        }(), Mn = wn.getSessionAPI.bind(wn), An = /* @__PURE__ */ new Set();
        var Sn = { exports: {} }, In = { exports: {} };
        In.exports = function(t3, e4) {
          var r4, n3, i3, s4, a3, o3, l3, u3;
          for (n3 = t3.length - (r4 = 3 & t3.length), i3 = e4, a3 = 3432918353, o3 = 461845907, u3 = 0; u3 < n3; )
            l3 = 255 & t3.charCodeAt(u3) | (255 & t3.charCodeAt(++u3)) << 8 | (255 & t3.charCodeAt(++u3)) << 16 | (255 & t3.charCodeAt(++u3)) << 24, ++u3, i3 = 27492 + (65535 & (s4 = 5 * (65535 & (i3 = (i3 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * a3 + (((l3 >>> 16) * a3 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o3 + (((l3 >>> 16) * o3 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s4 >>> 16) & 65535) << 16);
          switch (l3 = 0, r4) {
            case 3:
              l3 ^= (255 & t3.charCodeAt(u3 + 2)) << 16;
            case 2:
              l3 ^= (255 & t3.charCodeAt(u3 + 1)) << 8;
            case 1:
              i3 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & t3.charCodeAt(u3))) * a3 + (((l3 >>> 16) * a3 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o3 + (((l3 >>> 16) * o3 & 65535) << 16) & 4294967295;
          }
          return i3 ^= t3.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
        };
        var kn = In.exports, Pn = { exports: {} };
        Pn.exports = function(t3, e4) {
          for (var r4, n3 = t3.length, i3 = e4 ^ n3, s4 = 0; n3 >= 4; )
            r4 = 1540483477 * (65535 & (r4 = 255 & t3.charCodeAt(s4) | (255 & t3.charCodeAt(++s4)) << 8 | (255 & t3.charCodeAt(++s4)) << 16 | (255 & t3.charCodeAt(++s4)) << 24)) + ((1540483477 * (r4 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r4 = 1540483477 * (65535 & (r4 ^= r4 >>> 24)) + ((1540483477 * (r4 >>> 16) & 65535) << 16)), n3 -= 4, ++s4;
          switch (n3) {
            case 3:
              i3 ^= (255 & t3.charCodeAt(s4 + 2)) << 16;
            case 2:
              i3 ^= (255 & t3.charCodeAt(s4 + 1)) << 8;
            case 1:
              i3 = 1540483477 * (65535 & (i3 ^= 255 & t3.charCodeAt(s4))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
          }
          return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
        };
        var En = kn, zn = Pn.exports;
        Sn.exports = En, Sn.exports.murmur3 = En, Sn.exports.murmur2 = zn;
        var Tn = h(Sn.exports);
        function Bn(t3, e4, r4) {
          r4[t3] && -1 !== r4[t3].indexOf(e4) || (r4[t3] = r4[t3] || [], r4[t3].push(e4));
        }
        function Cn(t3, e4, r4) {
          if (r4 && r4[t3]) {
            const n3 = r4[t3].indexOf(e4);
            -1 !== n3 && r4[t3].splice(n3, 1);
          }
        }
        class Rn {
          constructor(t3, e4 = {}) {
            Je(this, e4), this.type = t3;
          }
        }
        class Vn extends Rn {
          constructor(t3, e4 = {}) {
            super("error", Je({ error: t3 }, e4));
          }
        }
        class Dn {
          on(t3, e4) {
            return this._listeners = this._listeners || {}, Bn(t3, e4, this._listeners), this;
          }
          off(t3, e4) {
            return Cn(t3, e4, this._listeners), Cn(t3, e4, this._oneTimeListeners), this;
          }
          once(t3, e4) {
            return e4 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Bn(t3, e4, this._oneTimeListeners), this) : new Promise((e5) => this.once(t3, e5));
          }
          fire(t3, e4) {
            "string" == typeof t3 && (t3 = new Rn(t3, e4 || {}));
            const r4 = t3.type;
            if (this.listens(r4)) {
              t3.target = this;
              const e5 = this._listeners && this._listeners[r4] ? this._listeners[r4].slice() : [];
              for (const r5 of e5)
                r5.call(this, t3);
              const n3 = this._oneTimeListeners && this._oneTimeListeners[r4] ? this._oneTimeListeners[r4].slice() : [];
              for (const e6 of n3)
                Cn(r4, e6, this._oneTimeListeners), e6.call(this, t3);
              const i3 = this._eventedParent;
              i3 && (Je(t3, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i3.fire(t3));
            } else
              t3 instanceof Vn && console.error(t3.error);
            return this;
          }
          listens(t3) {
            return !!(this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3));
          }
          setEventedParent(t3, e4) {
            return this._eventedParent = t3, this._eventedParentData = e4, this;
          }
        }
        t2.z = void 0;
        var Ln = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function Fn(t3) {
          return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
        }
        function On(t3) {
          return Fn("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
        }
        function Un(t3) {
          return (e4 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e4 > 1 ? 1 : e4;
          var e4;
        }
        function Nn(t3, e4, r4) {
          return r4 < 0 ? r4 += 1 : r4 > 1 && (r4 -= 1), 6 * r4 < 1 ? t3 + (e4 - t3) * r4 * 6 : 2 * r4 < 1 ? e4 : 3 * r4 < 2 ? t3 + (e4 - t3) * (2 / 3 - r4) * 6 : t3;
        }
        try {
          t2.z = {}.parseCSSColor = function(t3) {
            var e4, r4 = t3.replace(/ /g, "").toLowerCase();
            if (r4 in Ln)
              return Ln[r4].slice();
            if ("#" === r4[0])
              return 4 === r4.length ? (e4 = parseInt(r4.substr(1), 16)) >= 0 && e4 <= 4095 ? [(3840 & e4) >> 4 | (3840 & e4) >> 8, 240 & e4 | (240 & e4) >> 4, 15 & e4 | (15 & e4) << 4, 1] : null : 7 === r4.length && (e4 = parseInt(r4.substr(1), 16)) >= 0 && e4 <= 16777215 ? [(16711680 & e4) >> 16, (65280 & e4) >> 8, 255 & e4, 1] : null;
            var n3 = r4.indexOf("("), i3 = r4.indexOf(")");
            if (-1 !== n3 && i3 + 1 === r4.length) {
              var s4 = r4.substr(0, n3), a3 = r4.substr(n3 + 1, i3 - (n3 + 1)).split(","), o3 = 1;
              switch (s4) {
                case "rgba":
                  if (4 !== a3.length)
                    return null;
                  o3 = Un(a3.pop());
                case "rgb":
                  return 3 !== a3.length ? null : [On(a3[0]), On(a3[1]), On(a3[2]), o3];
                case "hsla":
                  if (4 !== a3.length)
                    return null;
                  o3 = Un(a3.pop());
                case "hsl":
                  if (3 !== a3.length)
                    return null;
                  var l3 = (parseFloat(a3[0]) % 360 + 360) % 360 / 360, u3 = Un(a3[1]), c3 = Un(a3[2]), h2 = c3 <= 0.5 ? c3 * (u3 + 1) : c3 + u3 - c3 * u3, p3 = 2 * c3 - h2;
                  return [Fn(255 * Nn(p3, h2, l3 + 1 / 3)), Fn(255 * Nn(p3, h2, l3)), Fn(255 * Nn(p3, h2, l3 - 1 / 3)), o3];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t3) {
        }
        class jn {
          constructor(t3, e4, r4, n3 = 1) {
            this.r = t3, this.g = e4, this.b = r4, this.a = n3;
          }
          static parse(e4) {
            if (!e4)
              return;
            if (e4 instanceof jn)
              return e4;
            if ("string" != typeof e4)
              return;
            const r4 = t2.z(e4);
            return r4 ? new jn(r4[0] / 255 * r4[3], r4[1] / 255 * r4[3], r4[2] / 255 * r4[3], r4[3]) : void 0;
          }
          toString() {
            const [t3, e4, r4, n3] = this.toArray();
            return `rgba(${Math.round(t3)},${Math.round(e4)},${Math.round(r4)},${n3})`;
          }
          toArray() {
            const { r: t3, g: e4, b: r4, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [255 * t3 / n3, 255 * e4 / n3, 255 * r4 / n3, n3];
          }
          toArray01() {
            const { r: t3, g: e4, b: r4, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [t3 / n3, e4 / n3, r4 / n3, n3];
          }
          toArray01Scaled(t3) {
            const { r: e4, g: r4, b: n3, a: i3 } = this;
            return 0 === i3 ? [0, 0, 0] : [e4 / i3 * t3, r4 / i3 * t3, n3 / i3 * t3];
          }
          toArray01PremultipliedAlpha() {
            const { r: t3, g: e4, b: r4, a: n3 } = this;
            return [t3, e4, r4, n3];
          }
          toArray01Linear() {
            const { r: t3, g: e4, b: r4, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [Math.pow(t3 / n3, 2.2), Math.pow(e4 / n3, 2.2), Math.pow(r4 / n3, 2.2), n3];
          }
        }
        function qn(t3, e4, r4) {
          return t3 * (1 - r4) + e4 * r4;
        }
        function $n(t3, e4, r4) {
          return t3.map((t4, n3) => qn(t4, e4[n3], r4));
        }
        jn.black = new jn(0, 0, 0, 1), jn.white = new jn(1, 1, 1, 1), jn.transparent = new jn(0, 0, 0, 0), jn.red = new jn(1, 0, 0, 1), jn.blue = new jn(0, 0, 1, 1);
        var Gn = Object.freeze({ __proto__: null, array: $n, color: function(t3, e4, r4) {
          return new jn(qn(t3.r, e4.r, r4), qn(t3.g, e4.g, r4), qn(t3.b, e4.b, r4), qn(t3.a, e4.a, r4));
        }, number: qn });
        function Qn(t3, ...e4) {
          for (const r4 of e4)
            for (const e5 in r4)
              t3[e5] = r4[e5];
          return t3;
        }
        class Yn extends Error {
          constructor(t3, e4) {
            super(e4), this.message = e4, this.key = t3;
          }
        }
        class Xn {
          constructor(t3, e4 = []) {
            this.parent = t3, this.bindings = {};
            for (const [t4, r4] of e4)
              this.bindings[t4] = r4;
          }
          concat(t3) {
            return new Xn(this, t3);
          }
          get(t3) {
            if (this.bindings[t3])
              return this.bindings[t3];
            if (this.parent)
              return this.parent.get(t3);
            throw new Error(`${t3} not found in scope.`);
          }
          has(t3) {
            return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
          }
        }
        const Zn = { kind: "null" }, Kn = { kind: "number" }, Wn = { kind: "string" }, Hn = { kind: "boolean" }, Jn = { kind: "color" }, ti = { kind: "object" }, ei = { kind: "value" }, ri = { kind: "collator" }, ni = { kind: "formatted" }, ii = { kind: "resolvedImage" };
        function si(t3, e4) {
          return { kind: "array", itemType: t3, N: e4 };
        }
        function ai(t3) {
          if ("array" === t3.kind) {
            const e4 = ai(t3.itemType);
            return "number" == typeof t3.N ? `array<${e4}, ${t3.N}>` : "value" === t3.itemType.kind ? "array" : `array<${e4}>`;
          }
          return t3.kind;
        }
        const oi = [Zn, Kn, Wn, Hn, Jn, ni, ti, si(ei), ii];
        function li(t3, e4) {
          if ("error" === e4.kind)
            return null;
          if ("array" === t3.kind) {
            if ("array" === e4.kind && (0 === e4.N && "value" === e4.itemType.kind || !li(t3.itemType, e4.itemType)) && ("number" != typeof t3.N || t3.N === e4.N))
              return null;
          } else {
            if (t3.kind === e4.kind)
              return null;
            if ("value" === t3.kind) {
              for (const t4 of oi)
                if (!li(t4, e4))
                  return null;
            }
          }
          return `Expected ${ai(t3)} but found ${ai(e4)} instead.`;
        }
        function ui(t3, e4) {
          return e4.some((e5) => e5.kind === t3.kind);
        }
        function ci(t3, e4) {
          return e4.some((e5) => "null" === e5 ? null === t3 : "array" === e5 ? Array.isArray(t3) : "object" === e5 ? t3 && !Array.isArray(t3) && "object" == typeof t3 : e5 === typeof t3);
        }
        class hi {
          constructor(t3, e4, r4) {
            this.sensitivity = t3 ? e4 ? "variant" : "case" : e4 ? "accent" : "base", this.locale = r4, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t3, e4) {
            return this.collator.compare(t3, e4);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class pi {
          constructor(t3, e4, r4, n3, i3) {
            this.text = t3.normalize ? t3.normalize() : t3, this.image = e4, this.scale = r4, this.fontStack = n3, this.textColor = i3;
          }
        }
        class fi {
          constructor(t3) {
            this.sections = t3;
          }
          static fromString(t3) {
            return new fi([new pi(t3, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t3) => 0 !== t3.text.length || t3.image && 0 !== t3.image.namePrimary.length);
          }
          static factory(t3) {
            return t3 instanceof fi ? t3 : fi.fromString(t3);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t3) => t3.text).join("");
          }
          serialize() {
            const t3 = ["format"];
            for (const e4 of this.sections) {
              if (e4.image) {
                t3.push(["image", e4.image.namePrimary]);
                continue;
              }
              t3.push(e4.text);
              const r4 = {};
              e4.fontStack && (r4["text-font"] = ["literal", e4.fontStack.split(",")]), e4.scale && (r4["font-scale"] = e4.scale), e4.textColor && (r4["text-color"] = ["rgba"].concat(e4.textColor.toArray())), t3.push(r4);
            }
            return t3;
          }
        }
        class di {
          constructor(t3) {
            this.namePrimary = t3.namePrimary, t3.nameSecondary && (this.nameSecondary = t3.nameSecondary), this.available = t3.available;
          }
          toString() {
            return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
          }
          static fromString(t3, e4) {
            return t3 ? new di({ namePrimary: t3, nameSecondary: e4, available: false }) : null;
          }
          serialize() {
            return this.nameSecondary ? ["image", this.namePrimary, this.nameSecondary] : ["image", this.namePrimary];
          }
        }
        function mi(t3, e4, r4, n3) {
          return "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof e4 && e4 >= 0 && e4 <= 255 && "number" == typeof r4 && r4 >= 0 && r4 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t3, e4, r4, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t3, e4, r4, n3] : [t3, e4, r4]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function yi(t3) {
          if (null === t3)
            return true;
          if ("string" == typeof t3)
            return true;
          if ("boolean" == typeof t3)
            return true;
          if ("number" == typeof t3)
            return true;
          if (t3 instanceof jn)
            return true;
          if (t3 instanceof hi)
            return true;
          if (t3 instanceof fi)
            return true;
          if (t3 instanceof di)
            return true;
          if (Array.isArray(t3)) {
            for (const e4 of t3)
              if (!yi(e4))
                return false;
            return true;
          }
          if ("object" == typeof t3) {
            for (const e4 in t3)
              if (!yi(t3[e4]))
                return false;
            return true;
          }
          return false;
        }
        function gi(t3) {
          if (null === t3)
            return Zn;
          if ("string" == typeof t3)
            return Wn;
          if ("boolean" == typeof t3)
            return Hn;
          if ("number" == typeof t3)
            return Kn;
          if (t3 instanceof jn)
            return Jn;
          if (t3 instanceof hi)
            return ri;
          if (t3 instanceof fi)
            return ni;
          if (t3 instanceof di)
            return ii;
          if (Array.isArray(t3)) {
            const e4 = t3.length;
            let r4;
            for (const e5 of t3) {
              const t4 = gi(e5);
              if (r4) {
                if (r4 === t4)
                  continue;
                r4 = ei;
                break;
              }
              r4 = t4;
            }
            return si(r4 || ei, e4);
          }
          return ti;
        }
        function xi(t3) {
          const e4 = typeof t3;
          return null === t3 ? "" : "string" === e4 || "number" === e4 || "boolean" === e4 ? String(t3) : t3 instanceof jn || t3 instanceof fi || t3 instanceof di ? t3.toString() : JSON.stringify(t3);
        }
        class bi {
          constructor(t3, e4) {
            this.type = t3, this.value = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (!yi(t3[1]))
              return e4.error("invalid value");
            const r4 = t3[1];
            let n3 = gi(r4);
            const i3 = e4.expectedType;
            return "array" !== n3.kind || 0 !== n3.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n3 = i3), new bi(n3, r4);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof jn ? ["rgba"].concat(this.value.toArray()) : this.value instanceof fi ? this.value.serialize() : this.value;
          }
        }
        class vi {
          constructor(t3) {
            this.name = "ExpressionEvaluationError", this.message = t3;
          }
          toJSON() {
            return this.message;
          }
        }
        const _i = { string: Wn, number: Kn, boolean: Hn, object: ti };
        class wi {
          constructor(t3, e4) {
            this.type = t3, this.args = e4;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expected at least one argument.");
            let r4, n3 = 1;
            const i3 = t3[0];
            if ("array" === i3) {
              let i4, s5;
              if (t3.length > 2) {
                const r5 = t3[1];
                if ("string" != typeof r5 || !(r5 in _i) || "object" === r5)
                  return e4.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i4 = _i[r5], n3++;
              } else
                i4 = ei;
              if (t3.length > 3) {
                if (null !== t3[2] && ("number" != typeof t3[2] || t3[2] < 0 || t3[2] !== Math.floor(t3[2])))
                  return e4.error('The length argument to "array" must be a positive integer literal', 2);
                s5 = t3[2], n3++;
              }
              r4 = si(i4, s5);
            } else
              r4 = _i[i3];
            const s4 = [];
            for (; n3 < t3.length; n3++) {
              const r5 = e4.parse(t3[n3], n3, ei);
              if (!r5)
                return null;
              s4.push(r5);
            }
            return new wi(r4, s4);
          }
          evaluate(t3) {
            for (let e4 = 0; e4 < this.args.length; e4++) {
              const r4 = this.args[e4].evaluate(t3);
              if (!li(this.type, gi(r4)))
                return r4;
              if (e4 === this.args.length - 1)
                throw new vi(`Expected value to be of type ${ai(this.type)}, but found ${ai(gi(r4))} instead.`);
            }
            return null;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = this.type, e4 = [t3.kind];
            if ("array" === t3.kind) {
              const r4 = t3.itemType;
              if ("string" === r4.kind || "number" === r4.kind || "boolean" === r4.kind) {
                e4.push(r4.kind);
                const n3 = t3.N;
                ("number" == typeof n3 || this.args.length > 1) && e4.push(n3);
              }
            }
            return e4.concat(this.args.map((t4) => t4.serialize()));
          }
        }
        class Mi {
          constructor(t3) {
            this.type = ni, this.sections = t3;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expected at least one argument.");
            const r4 = t3[1];
            if (!Array.isArray(r4) && "object" == typeof r4)
              return e4.error("First argument must be an image or text section.");
            const n3 = [];
            let i3 = false;
            for (let r5 = 1; r5 <= t3.length - 1; ++r5) {
              const s4 = t3[r5];
              if (i3 && "object" == typeof s4 && !Array.isArray(s4)) {
                i3 = false;
                let t4 = null;
                if (s4["font-scale"] && (t4 = e4.parse(s4["font-scale"], 1, Kn), !t4))
                  return null;
                let r6 = null;
                if (s4["text-font"] && (r6 = e4.parse(s4["text-font"], 1, si(Wn)), !r6))
                  return null;
                let a3 = null;
                if (s4["text-color"] && (a3 = e4.parse(s4["text-color"], 1, Jn), !a3))
                  return null;
                const o3 = n3[n3.length - 1];
                o3.scale = t4, o3.font = r6, o3.textColor = a3;
              } else {
                const s5 = e4.parse(t3[r5], 1, ei);
                if (!s5)
                  return null;
                const a3 = s5.type.kind;
                if ("string" !== a3 && "value" !== a3 && "null" !== a3 && "resolvedImage" !== a3)
                  return e4.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i3 = true, n3.push({ content: s5, scale: null, font: null, textColor: null });
              }
            }
            return new Mi(n3);
          }
          evaluate(t3) {
            return new fi(this.sections.map((e4) => {
              const r4 = e4.content.evaluate(t3);
              return gi(r4) === ii ? new pi("", r4, null, null, null) : new pi(xi(r4), null, e4.scale ? e4.scale.evaluate(t3) : null, e4.font ? e4.font.evaluate(t3).join(",") : null, e4.textColor ? e4.textColor.evaluate(t3) : null);
            }));
          }
          eachChild(t3) {
            for (const e4 of this.sections)
              t3(e4.content), e4.scale && t3(e4.scale), e4.font && t3(e4.font), e4.textColor && t3(e4.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = ["format"];
            for (const e4 of this.sections) {
              t3.push(e4.content.serialize());
              const r4 = {};
              e4.scale && (r4["font-scale"] = e4.scale.serialize()), e4.font && (r4["text-font"] = e4.font.serialize()), e4.textColor && (r4["text-color"] = e4.textColor.serialize()), t3.push(r4);
            }
            return t3;
          }
        }
        class Ai {
          constructor(t3, e4) {
            this.type = ii, this.inputPrimary = t3, this.inputSecondary = e4;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expected two or more arguments.");
            const r4 = e4.parse(t3[1], 1, Wn);
            if (!r4)
              return e4.error("No image name provided.");
            if (2 === t3.length)
              return new Ai(r4);
            const n3 = e4.parse(t3[2], 1, Wn);
            return n3 ? new Ai(r4, n3) : e4.error("Secondary image variant is not a string.");
          }
          evaluate(t3) {
            const e4 = di.fromString(this.inputPrimary.evaluate(t3), this.inputSecondary ? this.inputSecondary.evaluate(t3) : void 0);
            return e4 && t3.availableImages && (e4.available = t3.availableImages.indexOf(e4.namePrimary) > -1, e4.nameSecondary && e4.available && t3.availableImages && (e4.available = t3.availableImages.indexOf(e4.nameSecondary) > -1)), e4;
          }
          eachChild(t3) {
            t3(this.inputPrimary), this.inputSecondary && t3(this.inputSecondary);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return this.inputSecondary ? ["image", this.inputPrimary.serialize(), this.inputSecondary.serialize()] : ["image", this.inputPrimary.serialize()];
          }
        }
        function Si(t3) {
          return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : null === t3 ? "null" : typeof t3;
        }
        const Ii = { "to-boolean": Hn, "to-color": Jn, "to-number": Kn, "to-string": Wn };
        class ki {
          constructor(t3, e4) {
            this.type = t3, this.args = e4;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expected at least one argument.");
            const r4 = t3[0], n3 = [];
            let i3 = Zn;
            if ("to-array" === r4) {
              if (!Array.isArray(t3[1]))
                return null;
              const r5 = t3[1].length;
              if (e4.expectedType) {
                if ("array" !== e4.expectedType.kind)
                  return e4.error(`Expected ${e4.expectedType.kind} but found array.`);
                i3 = si(e4.expectedType.itemType, r5);
              } else {
                if (!(r5 > 0 && yi(t3[1][0])))
                  return null;
                i3 = si(gi(t3[1][0]), r5);
              }
              for (let s4 = 0; s4 < r5; s4++) {
                const r6 = t3[1][s4];
                let a3;
                if ("array" === Si(r6))
                  a3 = e4.parse(r6, void 0, i3.itemType);
                else {
                  const t4 = Si(r6);
                  if (t4 !== i3.itemType.kind)
                    return e4.error(`Expected ${i3.itemType.kind} but found ${t4}.`);
                  a3 = e4.registry.literal.parse(["literal", void 0 === r6 ? null : r6], e4);
                }
                if (!a3)
                  return null;
                n3.push(a3);
              }
            } else {
              if (("to-boolean" === r4 || "to-string" === r4) && 2 !== t3.length)
                return e4.error("Expected one argument.");
              i3 = Ii[r4];
              for (let r5 = 1; r5 < t3.length; r5++) {
                const i4 = e4.parse(t3[r5], r5, ei);
                if (!i4)
                  return null;
                n3.push(i4);
              }
            }
            return new ki(i3, n3);
          }
          evaluate(t3) {
            if ("boolean" === this.type.kind)
              return Boolean(this.args[0].evaluate(t3));
            if ("color" === this.type.kind) {
              let e4, r4;
              for (const n3 of this.args) {
                if (e4 = n3.evaluate(t3), r4 = null, e4 instanceof jn)
                  return e4;
                if ("string" == typeof e4) {
                  const r5 = t3.parseColor(e4);
                  if (r5)
                    return r5;
                } else if (Array.isArray(e4) && (r4 = e4.length < 3 || e4.length > 4 ? `Invalid rbga value ${JSON.stringify(e4)}: expected an array containing either three or four numeric values.` : mi(e4[0], e4[1], e4[2], e4[3]), !r4))
                  return new jn(e4[0] / 255, e4[1] / 255, e4[2] / 255, e4[3]);
              }
              throw new vi(r4 || `Could not parse color from value '${"string" == typeof e4 ? e4 : String(JSON.stringify(e4))}'`);
            }
            if ("number" === this.type.kind) {
              let e4 = null;
              for (const r4 of this.args) {
                if (e4 = r4.evaluate(t3), null === e4)
                  return 0;
                const n3 = Number(e4);
                if (!isNaN(n3))
                  return n3;
              }
              throw new vi(`Could not convert ${JSON.stringify(e4)} to number.`);
            }
            return "formatted" === this.type.kind ? fi.fromString(xi(this.args[0].evaluate(t3))) : "resolvedImage" === this.type.kind ? di.fromString(xi(this.args[0].evaluate(t3))) : "array" === this.type.kind ? this.args.map((e4) => e4.evaluate(t3)) : xi(this.args[0].evaluate(t3));
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            if ("formatted" === this.type.kind)
              return new Mi([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind)
              return new Ai(this.args[0]).serialize();
            const t3 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
            return this.eachChild((e4) => {
              t3.push(e4.serialize());
            }), t3;
          }
        }
        const Pi = ["Unknown", "Point", "LineString", "Polygon"];
        class Ei {
          constructor(t3, e4) {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t3, this.options = e4;
          }
          id() {
            return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Pi[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          measureLight(t3) {
            return this.globals.brightness || 0;
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const t3 = this.featureDistanceData.center, e4 = this.featureDistanceData.scale, { x: r4, y: n3 } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (r4 * e4 - t3[0]) + this.featureDistanceData.bearing[1] * (n3 * e4 - t3[1]);
            }
            return 0;
          }
          parseColor(t3) {
            let e4 = this._parseColorCache[t3];
            return e4 || (e4 = this._parseColorCache[t3] = jn.parse(t3)), e4;
          }
          getConfig(t3) {
            return this.options ? this.options.get(t3) : null;
          }
        }
        class zi {
          constructor(t3, e4, r4, n3, i3) {
            this.name = t3, this.type = e4, this._evaluate = r4, this.args = n3, this._overloadIndex = i3;
          }
          evaluate(t3) {
            if (!this._evaluate) {
              const t4 = zi.definitions[this.name];
              this._evaluate = Array.isArray(t4) ? t4[2] : t4.overloads[this._overloadIndex][1];
            }
            return this._evaluate(t3, this.args);
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t3) => t3.serialize()));
          }
          static parse(t3, e4) {
            const r4 = t3[0], n3 = zi.definitions[r4];
            if (!n3)
              return e4.error(`Unknown expression "${r4}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i3 = Array.isArray(n3) ? n3[0] : n3.type, s4 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, a3 = [];
            let o3 = null, l3 = -1;
            for (const [n4, u3] of s4) {
              if (Array.isArray(n4) && n4.length !== t3.length - 1)
                continue;
              a3.push(n4), l3++, o3 = new qs(e4.registry, e4.path, null, e4.scope, void 0, e4._scope, e4.options);
              const s5 = [];
              let c3 = false;
              for (let e5 = 1; e5 < t3.length; e5++) {
                const r5 = t3[e5], i4 = Array.isArray(n4) ? n4[e5 - 1] : n4.type, a4 = o3.parse(r5, 1 + s5.length, i4);
                if (!a4) {
                  c3 = true;
                  break;
                }
                s5.push(a4);
              }
              if (!c3)
                if (Array.isArray(n4) && n4.length !== s5.length)
                  o3.error(`Expected ${n4.length} arguments, but found ${s5.length} instead.`);
                else {
                  for (let t4 = 0; t4 < s5.length; t4++) {
                    const e5 = Array.isArray(n4) ? n4[t4] : n4.type, r5 = s5[t4];
                    o3.concat(t4 + 1).checkSubtype(e5, r5.type);
                  }
                  if (0 === o3.errors.length)
                    return new zi(r4, i3, u3, s5, l3);
                }
            }
            if (1 === a3.length)
              e4.errors.push(...o3.errors);
            else {
              const r5 = (a3.length ? a3 : s4.map(([t4]) => t4)).map(Ti).join(" | "), n4 = [];
              for (let r6 = 1; r6 < t3.length; r6++) {
                const i4 = e4.parse(t3[r6], 1 + n4.length);
                if (!i4)
                  return null;
                n4.push(ai(i4.type));
              }
              e4.error(`Expected arguments of type ${r5}, but found (${n4.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t3, e4) {
            zi.definitions = e4;
            for (const r4 in e4)
              t3[r4] = zi;
          }
        }
        function Ti(t3) {
          return Array.isArray(t3) ? `(${t3.map(ai).join(", ")})` : `(${ai(t3.type)}...)`;
        }
        class Bi {
          constructor(t3, e4, r4) {
            this.type = ri, this.locale = r4, this.caseSensitive = t3, this.diacriticSensitive = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error("Expected one argument.");
            const r4 = t3[1];
            if ("object" != typeof r4 || Array.isArray(r4))
              return e4.error("Collator options argument must be an object.");
            const n3 = e4.parse(void 0 !== r4["case-sensitive"] && r4["case-sensitive"], 1, Hn);
            if (!n3)
              return null;
            const i3 = e4.parse(void 0 !== r4["diacritic-sensitive"] && r4["diacritic-sensitive"], 1, Hn);
            if (!i3)
              return null;
            let s4 = null;
            return r4.locale && (s4 = e4.parse(r4.locale, 1, Wn), !s4) ? null : new Bi(n3, i3, s4);
          }
          evaluate(t3) {
            return new hi(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
          }
          eachChild(t3) {
            t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = {};
            return t3["case-sensitive"] = this.caseSensitive.serialize(), t3["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t3.locale = this.locale.serialize()), ["collator", t3];
          }
        }
        var Ci = { exports: {} };
        Ci.exports = /* @__PURE__ */ function() {
          function t3(r5, n3, i3, s4, a3) {
            for (; s4 > i3; ) {
              if (s4 - i3 > 600) {
                var o3 = s4 - i3 + 1, l3 = n3 - i3 + 1, u3 = Math.log(o3), c3 = 0.5 * Math.exp(2 * u3 / 3), h2 = 0.5 * Math.sqrt(u3 * c3 * (o3 - c3) / o3) * (l3 - o3 / 2 < 0 ? -1 : 1);
                t3(r5, n3, Math.max(i3, Math.floor(n3 - l3 * c3 / o3 + h2)), Math.min(s4, Math.floor(n3 + (o3 - l3) * c3 / o3 + h2)), a3);
              }
              var p3 = r5[n3], f2 = i3, d2 = s4;
              for (e4(r5, i3, n3), a3(r5[s4], p3) > 0 && e4(r5, i3, s4); f2 < d2; ) {
                for (e4(r5, f2, d2), f2++, d2--; a3(r5[f2], p3) < 0; )
                  f2++;
                for (; a3(r5[d2], p3) > 0; )
                  d2--;
              }
              0 === a3(r5[i3], p3) ? e4(r5, i3, d2) : e4(r5, ++d2, s4), d2 <= n3 && (i3 = d2 + 1), n3 <= d2 && (s4 = d2 - 1);
            }
          }
          function e4(t4, e5, r5) {
            var n3 = t4[e5];
            t4[e5] = t4[r5], t4[r5] = n3;
          }
          function r4(t4, e5) {
            return t4 < e5 ? -1 : t4 > e5 ? 1 : 0;
          }
          return function(e5, n3, i3, s4, a3) {
            t3(e5, n3, i3 || 0, s4 || e5.length - 1, a3 || r4);
          };
        }();
        var Ri = h(Ci.exports);
        function Vi(t3) {
          let e4 = 0;
          for (let r4, n3, i3 = 0, s4 = t3.length, a3 = s4 - 1; i3 < s4; a3 = i3++)
            r4 = t3[i3], n3 = t3[a3], e4 += (n3.x - r4.x) * (r4.y + n3.y);
          return e4;
        }
        function Di(t3, e4) {
          t3[0] = Math.min(t3[0], e4[0]), t3[1] = Math.min(t3[1], e4[1]), t3[2] = Math.max(t3[2], e4[0]), t3[3] = Math.max(t3[3], e4[1]);
        }
        function Li(t3, e4) {
          return !(t3[0] <= e4[0] || t3[2] >= e4[2] || t3[1] <= e4[1] || t3[3] >= e4[3]);
        }
        function Fi(t3, e4, r4) {
          const n3 = t3[0] - e4[0], i3 = t3[1] - e4[1], s4 = t3[0] - r4[0], a3 = t3[1] - r4[1];
          return n3 * a3 - s4 * i3 == 0 && n3 * s4 <= 0 && i3 * a3 <= 0;
        }
        function Oi(t3, e4, r4 = false) {
          let n3 = false;
          for (let o3 = 0, l3 = e4.length; o3 < l3; o3++) {
            const l4 = e4[o3];
            for (let e5 = 0, o4 = l4.length, u3 = o4 - 1; e5 < o4; u3 = e5++) {
              const o5 = l4[u3], c3 = l4[e5];
              if (Fi(t3, o5, c3))
                return r4;
              (s4 = o5)[1] > (i3 = t3)[1] != (a3 = c3)[1] > i3[1] && i3[0] < (a3[0] - s4[0]) * (i3[1] - s4[1]) / (a3[1] - s4[1]) + s4[0] && (n3 = !n3);
            }
          }
          var i3, s4, a3;
          return n3;
        }
        function Ui(t3, e4, r4, n3) {
          const i3 = n3[0] - r4[0], s4 = n3[1] - r4[1], a3 = (t3[0] - r4[0]) * s4 - i3 * (t3[1] - r4[1]), o3 = (e4[0] - r4[0]) * s4 - i3 * (e4[1] - r4[1]);
          return a3 > 0 && o3 < 0 || a3 < 0 && o3 > 0;
        }
        function Ni(t3, e4, r4, n3) {
          return 0 != (i3 = [n3[0] - r4[0], n3[1] - r4[1]])[0] * (s4 = [e4[0] - t3[0], e4[1] - t3[1]])[1] - i3[1] * s4[0] && !(!Ui(t3, e4, r4, n3) || !Ui(r4, n3, t3, e4));
          var i3, s4;
        }
        const ji = 8192;
        function qi(t3, e4) {
          const r4 = (180 + t3[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e4.z);
          return [Math.round(r4 * i3 * ji), Math.round(n3 * i3 * ji)];
        }
        function $i(t3, e4) {
          for (let r4 = 0; r4 < e4.length; r4++)
            if (Oi(t3, e4[r4]))
              return true;
          return false;
        }
        function Gi(t3, e4, r4) {
          for (const n3 of r4)
            for (let r5 = 0, i3 = n3.length, s4 = i3 - 1; r5 < i3; s4 = r5++)
              if (Ni(t3, e4, n3[s4], n3[r5]))
                return true;
          return false;
        }
        function Qi(t3, e4) {
          for (let r4 = 0; r4 < t3.length; ++r4)
            if (!Oi(t3[r4], e4))
              return false;
          for (let r4 = 0; r4 < t3.length - 1; ++r4)
            if (Gi(t3[r4], t3[r4 + 1], e4))
              return false;
          return true;
        }
        function Yi(t3, e4) {
          for (let r4 = 0; r4 < e4.length; r4++)
            if (Qi(t3, e4[r4]))
              return true;
          return false;
        }
        function Xi(t3, e4, r4) {
          const n3 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const s4 = [];
            for (let n4 = 0; n4 < t3[i3].length; n4++) {
              const a3 = qi(t3[i3][n4], r4);
              Di(e4, a3), s4.push(a3);
            }
            n3.push(s4);
          }
          return n3;
        }
        function Zi(t3, e4, r4) {
          const n3 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const s4 = Xi(t3[i3], e4, r4);
            n3.push(s4);
          }
          return n3;
        }
        function Ki(t3, e4, r4, n3) {
          if (t3[0] < r4[0] || t3[0] > r4[2]) {
            const e5 = 0.5 * n3;
            let i3 = t3[0] - r4[0] > e5 ? -n3 : r4[0] - t3[0] > e5 ? n3 : 0;
            0 === i3 && (i3 = t3[0] - r4[2] > e5 ? -n3 : r4[2] - t3[0] > e5 ? n3 : 0), t3[0] += i3;
          }
          Di(e4, t3);
        }
        function Wi(t3, e4, r4, n3) {
          const i3 = Math.pow(2, n3.z) * ji, s4 = [n3.x * ji, n3.y * ji], a3 = [];
          if (!t3)
            return a3;
          for (const n4 of t3)
            for (const t4 of n4) {
              const n5 = [t4.x + s4[0], t4.y + s4[1]];
              Ki(n5, e4, r4, i3), a3.push(n5);
            }
          return a3;
        }
        function Hi(t3, e4, r4, n3) {
          const i3 = Math.pow(2, n3.z) * ji, s4 = [n3.x * ji, n3.y * ji], a3 = [];
          if (!t3)
            return a3;
          for (const r5 of t3) {
            const t4 = [];
            for (const n4 of r5) {
              const r6 = [n4.x + s4[0], n4.y + s4[1]];
              Di(e4, r6), t4.push(r6);
            }
            a3.push(t4);
          }
          if (e4[2] - e4[0] <= i3 / 2) {
            (o3 = e4)[0] = o3[1] = 1 / 0, o3[2] = o3[3] = -1 / 0;
            for (const t4 of a3)
              for (const n4 of t4)
                Ki(n4, e4, r4, i3);
          }
          var o3;
          return a3;
        }
        class Ji {
          constructor(t3, e4) {
            this.type = Hn, this.geojson = t3, this.geometries = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (yi(t3[1])) {
              const e5 = t3[1];
              if ("FeatureCollection" === e5.type)
                for (let t4 = 0; t4 < e5.features.length; ++t4) {
                  const r4 = e5.features[t4].geometry.type;
                  if ("Polygon" === r4 || "MultiPolygon" === r4)
                    return new Ji(e5, e5.features[t4].geometry);
                }
              else if ("Feature" === e5.type) {
                const t4 = e5.geometry.type;
                if ("Polygon" === t4 || "MultiPolygon" === t4)
                  return new Ji(e5, e5.geometry);
              } else if ("Polygon" === e5.type || "MultiPolygon" === e5.type)
                return new Ji(e5, e5);
            }
            return e4.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t3) {
            if (null != t3.geometry() && null != t3.canonicalID()) {
              if ("Point" === t3.geometryType())
                return function(t4, e4) {
                  const r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                  if (!i3)
                    return false;
                  if ("Polygon" === e4.type) {
                    const s4 = Xi(e4.coordinates, n3, i3), a3 = Wi(t4.geometry(), r4, n3, i3);
                    if (!Li(r4, n3))
                      return false;
                    for (const t5 of a3)
                      if (!Oi(t5, s4))
                        return false;
                  }
                  if ("MultiPolygon" === e4.type) {
                    const s4 = Zi(e4.coordinates, n3, i3), a3 = Wi(t4.geometry(), r4, n3, i3);
                    if (!Li(r4, n3))
                      return false;
                    for (const t5 of a3)
                      if (!$i(t5, s4))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
              if ("LineString" === t3.geometryType())
                return function(t4, e4) {
                  const r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                  if (!i3)
                    return false;
                  if ("Polygon" === e4.type) {
                    const s4 = Xi(e4.coordinates, n3, i3), a3 = Hi(t4.geometry(), r4, n3, i3);
                    if (!Li(r4, n3))
                      return false;
                    for (const t5 of a3)
                      if (!Qi(t5, s4))
                        return false;
                  }
                  if ("MultiPolygon" === e4.type) {
                    const s4 = Zi(e4.coordinates, n3, i3), a3 = Hi(t4.geometry(), r4, n3, i3);
                    if (!Li(r4, n3))
                      return false;
                    for (const t5 of a3)
                      if (!Yi(t5, s4))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        var ts = { exports: {} };
        !function(t3, e4) {
          t3.exports = function() {
            var t4 = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, e5 = 1 / 298.257223563, r4 = e5 * (2 - e5), n3 = Math.PI / 180, i3 = function(e6, i4) {
              if (void 0 === e6)
                throw new Error("No latitude given.");
              if (i4 && !t4[i4])
                throw new Error("Unknown unit " + i4 + ". Use one of: " + Object.keys(t4).join(", "));
              var s5 = 6378.137 * n3 * (i4 ? t4[i4] : 1), a4 = Math.cos(e6 * n3), o4 = 1 / (1 - r4 * (1 - a4 * a4)), l4 = Math.sqrt(o4);
              this.kx = s5 * l4 * a4, this.ky = s5 * l4 * o4 * (1 - r4);
            }, s4 = { units: { configurable: true } };
            function a3(t5, e6) {
              return t5[0] === e6[0] && t5[1] === e6[1];
            }
            function o3(t5, e6, r5) {
              var n4 = l3(e6[0] - t5[0]);
              return [t5[0] + n4 * r5, t5[1] + (e6[1] - t5[1]) * r5];
            }
            function l3(t5) {
              for (; t5 < -180; )
                t5 += 360;
              for (; t5 > 180; )
                t5 -= 360;
              return t5;
            }
            return i3.fromTile = function(t5, e6, r5) {
              var s5 = Math.PI * (1 - 2 * (t5 + 0.5) / Math.pow(2, e6)), a4 = Math.atan(0.5 * (Math.exp(s5) - Math.exp(-s5))) / n3;
              return new i3(a4, r5);
            }, s4.units.get = function() {
              return t4;
            }, i3.prototype.distance = function(t5, e6) {
              var r5 = l3(t5[0] - e6[0]) * this.kx, n4 = (t5[1] - e6[1]) * this.ky;
              return Math.sqrt(r5 * r5 + n4 * n4);
            }, i3.prototype.bearing = function(t5, e6) {
              var r5 = l3(e6[0] - t5[0]) * this.kx;
              return Math.atan2(r5, (e6[1] - t5[1]) * this.ky) / n3;
            }, i3.prototype.destination = function(t5, e6, r5) {
              var i4 = r5 * n3;
              return this.offset(t5, Math.sin(i4) * e6, Math.cos(i4) * e6);
            }, i3.prototype.offset = function(t5, e6, r5) {
              return [t5[0] + e6 / this.kx, t5[1] + r5 / this.ky];
            }, i3.prototype.lineDistance = function(t5) {
              for (var e6 = 0, r5 = 0; r5 < t5.length - 1; r5++)
                e6 += this.distance(t5[r5], t5[r5 + 1]);
              return e6;
            }, i3.prototype.area = function(t5) {
              for (var e6 = 0, r5 = 0; r5 < t5.length; r5++)
                for (var n4 = t5[r5], i4 = 0, s5 = n4.length, a4 = s5 - 1; i4 < s5; a4 = i4++)
                  e6 += l3(n4[i4][0] - n4[a4][0]) * (n4[i4][1] + n4[a4][1]) * (r5 ? -1 : 1);
              return Math.abs(e6) / 2 * this.kx * this.ky;
            }, i3.prototype.along = function(t5, e6) {
              var r5 = 0;
              if (e6 <= 0)
                return t5[0];
              for (var n4 = 0; n4 < t5.length - 1; n4++) {
                var i4 = t5[n4], s5 = t5[n4 + 1], a4 = this.distance(i4, s5);
                if ((r5 += a4) > e6)
                  return o3(i4, s5, (e6 - (r5 - a4)) / a4);
              }
              return t5[t5.length - 1];
            }, i3.prototype.pointToSegmentDistance = function(t5, e6, r5) {
              var n4 = e6[0], i4 = e6[1], s5 = l3(r5[0] - n4) * this.kx, a4 = (r5[1] - i4) * this.ky, o4 = 0;
              return 0 === s5 && 0 === a4 || ((o4 = (l3(t5[0] - n4) * this.kx * s5 + (t5[1] - i4) * this.ky * a4) / (s5 * s5 + a4 * a4)) > 1 ? (n4 = r5[0], i4 = r5[1]) : o4 > 0 && (n4 += s5 / this.kx * o4, i4 += a4 / this.ky * o4)), s5 = l3(t5[0] - n4) * this.kx, a4 = (t5[1] - i4) * this.ky, Math.sqrt(s5 * s5 + a4 * a4);
            }, i3.prototype.pointOnLine = function(t5, e6) {
              for (var r5, n4, i4, s5, a4 = 1 / 0, o4 = 0; o4 < t5.length - 1; o4++) {
                var u3 = t5[o4][0], c3 = t5[o4][1], h2 = l3(t5[o4 + 1][0] - u3) * this.kx, p3 = (t5[o4 + 1][1] - c3) * this.ky, f2 = 0;
                0 === h2 && 0 === p3 || ((f2 = (l3(e6[0] - u3) * this.kx * h2 + (e6[1] - c3) * this.ky * p3) / (h2 * h2 + p3 * p3)) > 1 ? (u3 = t5[o4 + 1][0], c3 = t5[o4 + 1][1]) : f2 > 0 && (u3 += h2 / this.kx * f2, c3 += p3 / this.ky * f2));
                var d2 = (h2 = l3(e6[0] - u3) * this.kx) * h2 + (p3 = (e6[1] - c3) * this.ky) * p3;
                d2 < a4 && (a4 = d2, r5 = u3, n4 = c3, i4 = o4, s5 = f2);
              }
              return { point: [r5, n4], index: i4, t: Math.max(0, Math.min(1, s5)) };
            }, i3.prototype.lineSlice = function(t5, e6, r5) {
              var n4 = this.pointOnLine(r5, t5), i4 = this.pointOnLine(r5, e6);
              if (n4.index > i4.index || n4.index === i4.index && n4.t > i4.t) {
                var s5 = n4;
                n4 = i4, i4 = s5;
              }
              var o4 = [n4.point], l4 = n4.index + 1, u3 = i4.index;
              !a3(r5[l4], o4[0]) && l4 <= u3 && o4.push(r5[l4]);
              for (var c3 = l4 + 1; c3 <= u3; c3++)
                o4.push(r5[c3]);
              return a3(r5[u3], i4.point) || o4.push(i4.point), o4;
            }, i3.prototype.lineSliceAlong = function(t5, e6, r5) {
              for (var n4 = 0, i4 = [], s5 = 0; s5 < r5.length - 1; s5++) {
                var a4 = r5[s5], l4 = r5[s5 + 1], u3 = this.distance(a4, l4);
                if ((n4 += u3) > t5 && 0 === i4.length && i4.push(o3(a4, l4, (t5 - (n4 - u3)) / u3)), n4 >= e6)
                  return i4.push(o3(a4, l4, (e6 - (n4 - u3)) / u3)), i4;
                n4 > t5 && i4.push(l4);
              }
              return i4;
            }, i3.prototype.bufferPoint = function(t5, e6) {
              var r5 = e6 / this.ky, n4 = e6 / this.kx;
              return [t5[0] - n4, t5[1] - r5, t5[0] + n4, t5[1] + r5];
            }, i3.prototype.bufferBBox = function(t5, e6) {
              var r5 = e6 / this.ky, n4 = e6 / this.kx;
              return [t5[0] - n4, t5[1] - r5, t5[2] + n4, t5[3] + r5];
            }, i3.prototype.insideBBox = function(t5, e6) {
              return l3(t5[0] - e6[0]) >= 0 && l3(t5[0] - e6[2]) <= 0 && t5[1] >= e6[1] && t5[1] <= e6[3];
            }, Object.defineProperties(i3, s4), i3;
          }();
        }(ts);
        var es = h(ts.exports), rs = { exports: {} };
        !function(t3, e4) {
          t3.exports = function() {
            var t4 = function(t5, r4) {
              if (void 0 === t5 && (t5 = []), void 0 === r4 && (r4 = e5), this.data = t5, this.length = this.data.length, this.compare = r4, this.length > 0)
                for (var n3 = (this.length >> 1) - 1; n3 >= 0; n3--)
                  this._down(n3);
            };
            function e5(t5, e6) {
              return t5 < e6 ? -1 : t5 > e6 ? 1 : 0;
            }
            return t4.prototype.push = function(t5) {
              this.data.push(t5), this.length++, this._up(this.length - 1);
            }, t4.prototype.pop = function() {
              if (0 !== this.length) {
                var t5 = this.data[0], e6 = this.data.pop();
                return this.length--, this.length > 0 && (this.data[0] = e6, this._down(0)), t5;
              }
            }, t4.prototype.peek = function() {
              return this.data[0];
            }, t4.prototype._up = function(t5) {
              for (var e6 = this.data, r4 = this.compare, n3 = e6[t5]; t5 > 0; ) {
                var i3 = t5 - 1 >> 1, s4 = e6[i3];
                if (r4(n3, s4) >= 0)
                  break;
                e6[t5] = s4, t5 = i3;
              }
              e6[t5] = n3;
            }, t4.prototype._down = function(t5) {
              for (var e6 = this.data, r4 = this.compare, n3 = this.length >> 1, i3 = e6[t5]; t5 < n3; ) {
                var s4 = 1 + (t5 << 1), a3 = e6[s4], o3 = s4 + 1;
                if (o3 < this.length && r4(e6[o3], a3) < 0 && (s4 = o3, a3 = e6[o3]), r4(a3, i3) >= 0)
                  break;
                e6[t5] = a3, t5 = s4;
              }
              e6[t5] = i3;
            }, t4;
          }();
        }(rs);
        var ns = h(rs.exports), is = 8192;
        function ss(t3, e4) {
          return e4.dist - t3.dist;
        }
        const as = 100, os = 50;
        function ls(t3) {
          const e4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (e4.length !== t3.length)
            return false;
          for (let r4 = 0; r4 < e4.length; r4++)
            if (e4[r4] !== t3[r4])
              return false;
          return true;
        }
        function us(t3) {
          return t3[1] - t3[0] + 1;
        }
        function cs(t3, e4) {
          const r4 = t3[1] >= t3[0] && t3[1] < e4;
          return r4 || console.warn("Distance Expression: Index is out of range"), r4;
        }
        function hs(t3, e4) {
          if (t3[0] > t3[1])
            return [null, null];
          const r4 = us(t3);
          if (e4) {
            if (2 === r4)
              return [t3, null];
            const e5 = Math.floor(r4 / 2);
            return [[t3[0], t3[0] + e5], [t3[0] + e5, t3[1]]];
          }
          {
            if (1 === r4)
              return [t3, null];
            const e5 = Math.floor(r4 / 2) - 1;
            return [[t3[0], t3[0] + e5], [t3[0] + e5 + 1, t3[1]]];
          }
        }
        function ps(t3, e4) {
          const r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (!cs(e4, t3.length))
            return r4;
          for (let n3 = e4[0]; n3 <= e4[1]; ++n3)
            Di(r4, t3[n3]);
          return r4;
        }
        function fs(t3) {
          const e4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let r4 = 0; r4 < t3.length; ++r4)
            for (let n3 = 0; n3 < t3[r4].length; ++n3)
              Di(e4, t3[r4][n3]);
          return e4;
        }
        function ds(t3, e4, r4) {
          if (ls(t3) || ls(e4))
            return NaN;
          let n3 = 0, i3 = 0;
          return t3[2] < e4[0] && (n3 = e4[0] - t3[2]), t3[0] > e4[2] && (n3 = t3[0] - e4[2]), t3[1] > e4[3] && (i3 = t3[1] - e4[3]), t3[3] < e4[1] && (i3 = e4[1] - t3[3]), r4.distance([0, 0], [n3, i3]);
        }
        function ms(t3) {
          return 360 * t3 - 180;
        }
        function ys(t3) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
        }
        function gs(t3, e4) {
          const r4 = Math.pow(2, e4.z), n3 = (t3.y / is + e4.y) / r4;
          return [ms((t3.x / is + e4.x) / r4), ys(n3)];
        }
        function xs(t3, e4) {
          const r4 = [];
          for (let n3 = 0; n3 < t3.length; ++n3)
            r4.push(gs(t3[n3], e4));
          return r4;
        }
        function bs(t3, e4, r4) {
          const n3 = r4.pointOnLine(e4, t3).point;
          return r4.distance(t3, n3);
        }
        function vs(t3, e4, r4, n3, i3) {
          const s4 = r4.slice(n3[0], n3[1] + 1);
          let a3 = 1 / 0;
          for (let r5 = e4[0]; r5 <= e4[1]; ++r5)
            if (0 === (a3 = Math.min(a3, bs(t3[r5], s4, i3))))
              return 0;
          return a3;
        }
        function _s(t3, e4, r4, n3, i3) {
          const s4 = Math.min(i3.pointToSegmentDistance(t3, r4, n3), i3.pointToSegmentDistance(e4, r4, n3)), a3 = Math.min(i3.pointToSegmentDistance(r4, t3, e4), i3.pointToSegmentDistance(n3, t3, e4));
          return Math.min(s4, a3);
        }
        function ws(t3, e4, r4, n3, i3) {
          if (!cs(e4, t3.length) || !cs(n3, r4.length))
            return NaN;
          let s4 = 1 / 0;
          for (let a3 = e4[0]; a3 < e4[1]; ++a3)
            for (let e5 = n3[0]; e5 < n3[1]; ++e5) {
              if (Ni(t3[a3], t3[a3 + 1], r4[e5], r4[e5 + 1]))
                return 0;
              s4 = Math.min(s4, _s(t3[a3], t3[a3 + 1], r4[e5], r4[e5 + 1], i3));
            }
          return s4;
        }
        function Ms(t3, e4, r4, n3, i3) {
          if (!cs(e4, t3.length) || !cs(n3, r4.length))
            return NaN;
          let s4 = 1 / 0;
          for (let a3 = e4[0]; a3 <= e4[1]; ++a3)
            for (let e5 = n3[0]; e5 <= n3[1]; ++e5)
              if (0 === (s4 = Math.min(s4, i3.distance(t3[a3], r4[e5]))))
                return s4;
          return s4;
        }
        function As(t3, e4, r4) {
          if (Oi(t3, e4, true))
            return 0;
          let n3 = 1 / 0;
          for (const i3 of e4) {
            const e5 = i3.length;
            if (e5 < 2)
              return console.warn("Distance Expression: Invalid polygon!"), NaN;
            if (i3[0] !== i3[e5 - 1] && 0 === (n3 = Math.min(n3, r4.pointToSegmentDistance(t3, i3[e5 - 1], i3[0]))))
              return n3;
            if (0 === (n3 = Math.min(n3, bs(t3, i3, r4))))
              return n3;
          }
          return n3;
        }
        function Ss(t3, e4, r4, n3) {
          if (!cs(e4, t3.length))
            return NaN;
          for (let n4 = e4[0]; n4 <= e4[1]; ++n4)
            if (Oi(t3[n4], r4, true))
              return 0;
          let i3 = 1 / 0;
          for (let s4 = e4[0]; s4 < e4[1]; ++s4)
            for (const e5 of r4)
              for (let r5 = 0, a3 = e5.length, o3 = a3 - 1; r5 < a3; o3 = r5++) {
                if (Ni(t3[s4], t3[s4 + 1], e5[o3], e5[r5]))
                  return 0;
                i3 = Math.min(i3, _s(t3[s4], t3[s4 + 1], e5[o3], e5[r5], n3));
              }
          return i3;
        }
        function Is(t3, e4) {
          for (const r4 of t3)
            for (let t4 = 0; t4 <= r4.length - 1; ++t4)
              if (Oi(r4[t4], e4, true))
                return true;
          return false;
        }
        function ks(t3, e4, r4, n3 = 1 / 0) {
          const i3 = fs(t3), s4 = fs(e4);
          if (n3 !== 1 / 0 && ds(i3, s4, r4) >= n3)
            return n3;
          if (Li(i3, s4)) {
            if (Is(t3, e4))
              return 0;
          } else if (Is(e4, t3))
            return 0;
          let a3 = n3;
          for (const n4 of t3)
            for (let t4 = 0, i4 = n4.length, s5 = i4 - 1; t4 < i4; s5 = t4++)
              for (const i5 of e4)
                for (let e5 = 0, o3 = i5.length, l3 = o3 - 1; e5 < o3; l3 = e5++) {
                  if (Ni(n4[s5], n4[t4], i5[l3], i5[e5]))
                    return 0;
                  a3 = Math.min(a3, _s(n4[s5], n4[t4], i5[l3], i5[e5], r4));
                }
          return a3;
        }
        function Ps(t3, e4, r4, n3, i3, s4, a3) {
          if (null === s4 || null === a3)
            return;
          const o3 = ds(ps(n3, s4), ps(i3, a3), r4);
          o3 < e4 && t3.push({ dist: o3, range1: s4, range2: a3 });
        }
        function Es(t3, e4, r4, n3, i3 = 1 / 0) {
          let s4 = Math.min(n3.distance(t3[0], r4[0][0]), i3);
          if (0 === s4)
            return s4;
          const a3 = new ns([{ dist: 0, range1: [0, t3.length - 1], range2: [0, 0] }], ss), o3 = e4 ? os : as, l3 = fs(r4);
          for (; a3.length; ) {
            const i4 = a3.pop();
            if (i4.dist >= s4)
              continue;
            const u3 = i4.range1;
            if (us(u3) <= o3) {
              if (!cs(u3, t3.length))
                return NaN;
              if (e4) {
                const e5 = Ss(t3, u3, r4, n3);
                if (0 === (s4 = Math.min(s4, e5)))
                  return s4;
              } else
                for (let e5 = u3[0]; e5 <= u3[1]; ++e5) {
                  const i5 = As(t3[e5], r4, n3);
                  if (0 === (s4 = Math.min(s4, i5)))
                    return s4;
                }
            } else {
              const r5 = hs(u3, e4);
              if (null !== r5[0]) {
                const e5 = ds(ps(t3, r5[0]), l3, n3);
                e5 < s4 && a3.push({ dist: e5, range1: r5[0], range2: [0, 0] });
              }
              if (null !== r5[1]) {
                const e5 = ds(ps(t3, r5[1]), l3, n3);
                e5 < s4 && a3.push({ dist: e5, range1: r5[1], range2: [0, 0] });
              }
            }
          }
          return s4;
        }
        function zs(t3, e4, r4, n3, i3, s4 = 1 / 0) {
          let a3 = Math.min(s4, i3.distance(t3[0], r4[0]));
          if (0 === a3)
            return a3;
          const o3 = new ns([{ dist: 0, range1: [0, t3.length - 1], range2: [0, r4.length - 1] }], ss), l3 = e4 ? os : as, u3 = n3 ? os : as;
          for (; o3.length; ) {
            const s5 = o3.pop();
            if (s5.dist >= a3)
              continue;
            const c3 = s5.range1, h2 = s5.range2;
            if (us(c3) <= l3 && us(h2) <= u3) {
              if (!cs(c3, t3.length) || !cs(h2, r4.length))
                return NaN;
              if (e4 && n3 ? a3 = Math.min(a3, ws(t3, c3, r4, h2, i3)) : e4 || n3 ? e4 && !n3 ? a3 = Math.min(a3, vs(r4, h2, t3, c3, i3)) : !e4 && n3 && (a3 = Math.min(a3, vs(t3, c3, r4, h2, i3))) : a3 = Math.min(a3, Ms(t3, c3, r4, h2, i3)), 0 === a3)
                return a3;
            } else {
              const s6 = hs(c3, e4), l4 = hs(h2, n3);
              Ps(o3, a3, i3, t3, r4, s6[0], l4[0]), Ps(o3, a3, i3, t3, r4, s6[0], l4[1]), Ps(o3, a3, i3, t3, r4, s6[1], l4[0]), Ps(o3, a3, i3, t3, r4, s6[1], l4[1]);
            }
          }
          return a3;
        }
        function Ts(t3, e4, r4, n3, i3 = 1 / 0) {
          let s4 = i3;
          const a3 = ps(t3, [0, t3.length - 1]);
          for (const i4 of r4)
            if (!(s4 !== 1 / 0 && ds(a3, ps(i4, [0, i4.length - 1]), n3) >= s4) && (s4 = Math.min(s4, zs(t3, e4, i4, true, n3, s4)), 0 === s4))
              return s4;
          return s4;
        }
        function Bs(t3, e4, r4, n3, i3 = 1 / 0) {
          let s4 = i3;
          const a3 = ps(t3, [0, t3.length - 1]);
          for (const i4 of r4) {
            if (s4 !== 1 / 0 && ds(a3, fs(i4), n3) >= s4)
              continue;
            const r5 = Es(t3, e4, i4, n3, s4);
            if (isNaN(r5))
              return r5;
            if (0 === (s4 = Math.min(s4, r5)))
              return s4;
          }
          return s4;
        }
        function Cs(t3) {
          return "Point" === t3 || "MultiPoint" === t3 || "LineString" === t3 || "MultiLineString" === t3 || "Polygon" === t3 || "MultiPolygon" === t3;
        }
        class Rs {
          constructor(t3, e4) {
            this.type = Kn, this.geojson = t3, this.geometries = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error(`'distance' expression requires either one argument, but found ' ${t3.length - 1} instead.`);
            if (yi(t3[1])) {
              const e5 = t3[1];
              if ("FeatureCollection" === e5.type) {
                for (let t4 = 0; t4 < e5.features.length; ++t4)
                  if (Cs(e5.features[t4].geometry.type))
                    return new Rs(e5, e5.features[t4].geometry);
              } else if ("Feature" === e5.type) {
                if (Cs(e5.geometry.type))
                  return new Rs(e5, e5.geometry);
              } else if (Cs(e5.type))
                return new Rs(e5, e5);
            }
            return e4.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
          }
          evaluate(t3) {
            const e4 = t3.geometry(), r4 = t3.canonicalID();
            if (null != e4 && null != r4) {
              if ("Point" === t3.geometryType())
                return function(t4, e5, r5) {
                  const n3 = [];
                  for (const r6 of t4)
                    for (const t5 of r6)
                      n3.push(gs(t5, e5));
                  const i3 = new es(n3[0][1], "meters");
                  return "Point" === r5.type || "MultiPoint" === r5.type || "LineString" === r5.type ? zs(n3, false, "Point" === r5.type ? [r5.coordinates] : r5.coordinates, "LineString" === r5.type, i3) : "MultiLineString" === r5.type ? Ts(n3, false, r5.coordinates, i3) : "Polygon" === r5.type || "MultiPolygon" === r5.type ? Bs(n3, false, "Polygon" === r5.type ? [r5.coordinates] : r5.coordinates, i3) : null;
                }(e4, r4, this.geometries);
              if ("LineString" === t3.geometryType())
                return function(t4, e5, r5) {
                  const n3 = [];
                  for (const r6 of t4) {
                    const t5 = [];
                    for (const n4 of r6)
                      t5.push(gs(n4, e5));
                    n3.push(t5);
                  }
                  const i3 = new es(n3[0][0][1], "meters");
                  if ("Point" === r5.type || "MultiPoint" === r5.type || "LineString" === r5.type)
                    return Ts("Point" === r5.type ? [r5.coordinates] : r5.coordinates, "LineString" === r5.type, n3, i3);
                  if ("MultiLineString" === r5.type) {
                    let t5 = 1 / 0;
                    for (let e6 = 0; e6 < r5.coordinates.length; e6++) {
                      const s4 = Ts(r5.coordinates[e6], true, n3, i3, t5);
                      if (isNaN(s4))
                        return s4;
                      if (0 === (t5 = Math.min(t5, s4)))
                        return t5;
                    }
                    return t5;
                  }
                  if ("Polygon" === r5.type || "MultiPolygon" === r5.type) {
                    let t5 = 1 / 0;
                    for (let e6 = 0; e6 < n3.length; e6++) {
                      const s4 = Bs(n3[e6], true, "Polygon" === r5.type ? [r5.coordinates] : r5.coordinates, i3, t5);
                      if (isNaN(s4))
                        return s4;
                      if (0 === (t5 = Math.min(t5, s4)))
                        return t5;
                    }
                    return t5;
                  }
                  return null;
                }(e4, r4, this.geometries);
              if ("Polygon" === t3.geometryType())
                return function(t4, e5, r5) {
                  const n3 = [];
                  for (const r6 of function(t5, e6) {
                    const r7 = t5.length;
                    if (r7 <= 1)
                      return [t5];
                    const n4 = [];
                    let i4, s4;
                    for (let e7 = 0; e7 < r7; e7++) {
                      const r8 = Vi(t5[e7]);
                      0 !== r8 && (t5[e7].area = Math.abs(r8), void 0 === s4 && (s4 = r8 < 0), s4 === r8 < 0 ? (i4 && n4.push(i4), i4 = [t5[e7]]) : i4.push(t5[e7]));
                    }
                    return i4 && n4.push(i4), n4;
                  }(t4)) {
                    const t5 = [];
                    for (let n4 = 0; n4 < r6.length; ++n4)
                      t5.push(xs(r6[n4], e5));
                    n3.push(t5);
                  }
                  const i3 = new es(n3[0][0][0][1], "meters");
                  if ("Point" === r5.type || "MultiPoint" === r5.type || "LineString" === r5.type)
                    return Bs("Point" === r5.type ? [r5.coordinates] : r5.coordinates, "LineString" === r5.type, n3, i3);
                  if ("MultiLineString" === r5.type) {
                    let t5 = 1 / 0;
                    for (let e6 = 0; e6 < r5.coordinates.length; e6++) {
                      const s4 = Bs(r5.coordinates[e6], true, n3, i3, t5);
                      if (isNaN(s4))
                        return s4;
                      if (0 === (t5 = Math.min(t5, s4)))
                        return t5;
                    }
                    return t5;
                  }
                  return "Polygon" === r5.type || "MultiPolygon" === r5.type ? function(t5, e6, r6) {
                    let n4 = 1 / 0;
                    for (const i4 of t5)
                      for (const t6 of e6) {
                        const e7 = ks(i4, t6, r6, n4);
                        if (isNaN(e7))
                          return e7;
                        if (0 === (n4 = Math.min(n4, e7)))
                          return n4;
                      }
                    return n4;
                  }("Polygon" === r5.type ? [r5.coordinates] : r5.coordinates, n3, i3) : null;
                }(e4, r4, this.geometries);
              console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
            } else
              console.warn("Distance Expression: requirs valid feature and canonical information.");
            return null;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["distance", this.geojson];
          }
        }
        function Vs(t3, e4) {
          switch (t3) {
            case "string":
              return xi(e4);
            case "number":
              return +e4;
            case "boolean":
              return !!e4;
            case "color":
              return jn.parse(e4);
            case "formatted":
              return fi.fromString(xi(e4));
            case "resolvedImage":
              return di.fromString(xi(e4));
          }
          return e4;
        }
        function Ds(t3, e4, r4, n3) {
          return void 0 !== n3 && (t3 = n3 * Math.round(t3 / n3)), void 0 !== e4 && t3 < e4 && (t3 = e4), void 0 !== r4 && t3 > r4 && (t3 = r4), t3;
        }
        class Ls {
          constructor(t3, e4, r4) {
            this.type = t3, this.key = e4, this.scope = r4;
          }
          static parse(t3, e4) {
            let r4 = e4.expectedType;
            if (null == r4 && (r4 = ei), t3.length < 2 || t3.length > 3)
              return e4.error("Invalid number of arguments for 'config' expression.");
            const n3 = e4.parse(t3[1], 1);
            if (!(n3 instanceof bi))
              return e4.error("Key name of 'config' expression must be a string literal.");
            if (t3.length >= 3) {
              const i3 = e4.parse(t3[2], 2);
              return i3 instanceof bi ? new Ls(r4, xi(n3.value), xi(i3.value)) : e4.error("Scope of 'config' expression must be a string literal.");
            }
            return new Ls(r4, xi(n3.value));
          }
          evaluate(t3) {
            const e4 = [this.key, this.scope, t3.scope].filter(Boolean).join(""), r4 = t3.getConfig(e4);
            if (!r4)
              return null;
            const { type: n3, value: i3, values: s4, minValue: a3, maxValue: o3, stepValue: l3 } = r4, u3 = r4.default.evaluate(t3);
            let c3 = u3;
            if (i3) {
              const e5 = t3.scope;
              t3.scope = (e5 || "").split("").slice(1).join(""), c3 = i3.evaluate(t3), t3.scope = e5;
            }
            return n3 && (c3 = Vs(n3, c3)), void 0 === c3 || void 0 === a3 && void 0 === o3 && void 0 === l3 || ("number" == typeof c3 ? c3 = Ds(c3, a3, o3, l3) : Array.isArray(c3) && (c3 = c3.map((t4) => "number" == typeof t4 ? Ds(t4, a3, o3, l3) : t4))), void 0 !== i3 && void 0 !== c3 && s4 && !s4.includes(c3) && (c3 = u3, n3 && (c3 = Vs(n3, c3))), (n3 && n3 !== this.type || void 0 !== c3 && gi(c3) !== this.type) && (c3 = Vs(this.type.kind, c3)), c3;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = ["config", this.key];
            return this.scope && t3.concat(this.key), t3;
          }
        }
        function Fs(t3) {
          if (t3 instanceof zi) {
            if ("get" === t3.name && 1 === t3.args.length)
              return false;
            if ("feature-state" === t3.name)
              return false;
            if ("has" === t3.name && 1 === t3.args.length)
              return false;
            if ("properties" === t3.name || "geometry-type" === t3.name || "id" === t3.name)
              return false;
            if (/^filter-/.test(t3.name))
              return false;
          }
          if (t3 instanceof Ji)
            return false;
          if (t3 instanceof Rs)
            return false;
          let e4 = true;
          return t3.eachChild((t4) => {
            e4 && !Fs(t4) && (e4 = false);
          }), e4;
        }
        function Os(t3) {
          if (t3 instanceof zi && "feature-state" === t3.name)
            return false;
          let e4 = true;
          return t3.eachChild((t4) => {
            e4 && !Os(t4) && (e4 = false);
          }), e4;
        }
        function Us(t3) {
          if (t3 instanceof Ls)
            return false;
          let e4 = true;
          return t3.eachChild((t4) => {
            e4 && !Us(t4) && (e4 = false);
          }), e4;
        }
        function Ns(t3, e4) {
          if (t3 instanceof zi && e4.indexOf(t3.name) >= 0)
            return false;
          let r4 = true;
          return t3.eachChild((t4) => {
            r4 && !Ns(t4, e4) && (r4 = false);
          }), r4;
        }
        class js {
          constructor(t3, e4) {
            this.type = e4.type, this.name = t3, this.boundExpression = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length || "string" != typeof t3[1])
              return e4.error("'var' expression requires exactly one string literal argument.");
            const r4 = t3[1];
            return e4.scope.has(r4) ? new js(r4, e4.scope.get(r4)) : e4.error(`Unknown variable "${r4}". Make sure "${r4}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t3) {
            return this.boundExpression.evaluate(t3);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        class qs {
          constructor(t3, e4 = [], r4, n3 = new Xn(), i3 = [], s4, a3) {
            this.registry = t3, this.path = e4, this.key = e4.map((t4) => `[${t4}]`).join(""), this.scope = n3, this.errors = i3, this.expectedType = r4, this._scope = s4, this.options = a3;
          }
          parse(t3, e4, r4, n3, i3 = {}) {
            return e4 || r4 ? this.concat(e4, r4, n3)._parse(t3, i3) : this._parse(t3, i3);
          }
          _parse(t3, e4) {
            function r4(t4, e5, r5) {
              return "assert" === r5 ? new wi(e5, [t4]) : "coerce" === r5 ? new ki(e5, [t4]) : t4;
            }
            if (null !== t3 && "string" != typeof t3 && "boolean" != typeof t3 && "number" != typeof t3 || (t3 = ["literal", t3]), Array.isArray(t3)) {
              if (0 === t3.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n3 = "string" == typeof t3[0] ? this.registry[t3[0]] : void 0;
              if (n3) {
                let i3 = n3.parse(t3, this);
                if (!i3)
                  return null;
                if (this.expectedType) {
                  const t4 = this.expectedType, n4 = i3.type;
                  if ("string" !== t4.kind && "number" !== t4.kind && "boolean" !== t4.kind && "object" !== t4.kind && "array" !== t4.kind || "value" !== n4.kind)
                    if ("color" !== t4.kind && "formatted" !== t4.kind && "resolvedImage" !== t4.kind || "value" !== n4.kind && "string" !== n4.kind) {
                      if (this.checkSubtype(t4, n4))
                        return null;
                    } else
                      i3 = r4(i3, t4, e4.typeAnnotation || "coerce");
                  else
                    i3 = r4(i3, t4, e4.typeAnnotation || "assert");
                }
                if (!(i3 instanceof bi) && "resolvedImage" !== i3.type.kind && $s(i3)) {
                  const t4 = new Ei(this._scope, this.options);
                  try {
                    i3 = new bi(i3.type, i3.evaluate(t4));
                  } catch (t5) {
                    return this.error(t5.message), null;
                  }
                }
                return i3;
              }
              return ki.parse(["to-array", t3], this);
            }
            return this.error(void 0 === t3 ? "'undefined' value invalid. Use null instead." : "object" == typeof t3 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
          }
          concat(t3, e4, r4) {
            const n3 = "number" == typeof t3 ? this.path.concat(t3) : this.path, i3 = r4 ? this.scope.concat(r4) : this.scope;
            return new qs(this.registry, n3, e4 || null, i3, this.errors, this._scope, this.options);
          }
          error(t3, ...e4) {
            const r4 = `${this.key}${e4.map((t4) => `[${t4}]`).join("")}`;
            this.errors.push(new Yn(r4, t3));
          }
          checkSubtype(t3, e4) {
            const r4 = li(t3, e4);
            return r4 && this.error(r4), r4;
          }
        }
        function $s(t3) {
          if (t3 instanceof js)
            return $s(t3.boundExpression);
          if (t3 instanceof zi && "error" === t3.name)
            return false;
          if (t3 instanceof Bi)
            return false;
          if (t3 instanceof Ji)
            return false;
          if (t3 instanceof Rs)
            return false;
          if (t3 instanceof Ls)
            return false;
          const e4 = t3 instanceof ki || t3 instanceof wi;
          let r4 = true;
          return t3.eachChild((t4) => {
            r4 = e4 ? r4 && $s(t4) : r4 && t4 instanceof bi;
          }), !!r4 && Fs(t3) && Ns(t3, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
        }
        function Gs(t3, e4) {
          const r4 = t3.length - 1;
          let n3, i3, s4 = 0, a3 = r4, o3 = 0;
          for (; s4 <= a3; )
            if (o3 = Math.floor((s4 + a3) / 2), n3 = t3[o3], i3 = t3[o3 + 1], n3 <= e4) {
              if (o3 === r4 || e4 < i3)
                return o3;
              s4 = o3 + 1;
            } else {
              if (!(n3 > e4))
                throw new vi("Input is not a number.");
              a3 = o3 - 1;
            }
          return 0;
        }
        class Qs {
          constructor(t3, e4, r4) {
            this.type = t3, this.input = e4, this.labels = [], this.outputs = [];
            for (const [t4, e5] of r4)
              this.labels.push(t4), this.outputs.push(e5);
          }
          static parse(t3, e4) {
            if (t3.length - 1 < 4)
              return e4.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e4.error("Expected an even number of arguments.");
            const r4 = e4.parse(t3[1], 1, Kn);
            if (!r4)
              return null;
            const n3 = [];
            let i3 = null;
            e4.expectedType && "value" !== e4.expectedType.kind && (i3 = e4.expectedType);
            for (let r5 = 1; r5 < t3.length; r5 += 2) {
              const s4 = 1 === r5 ? -1 / 0 : t3[r5], a3 = t3[r5 + 1], o3 = r5, l3 = r5 + 1;
              if ("number" != typeof s4)
                return e4.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o3);
              if (n3.length && n3[n3.length - 1][0] >= s4)
                return e4.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o3);
              const u3 = e4.parse(a3, l3, i3);
              if (!u3)
                return null;
              i3 = i3 || u3.type, n3.push([s4, u3]);
            }
            return new Qs(i3, r4, n3);
          }
          evaluate(t3) {
            const e4 = this.labels, r4 = this.outputs;
            if (1 === e4.length)
              return r4[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e4[0])
              return r4[0].evaluate(t3);
            const i3 = e4.length;
            return n3 >= e4[i3 - 1] ? r4[i3 - 1].evaluate(t3) : r4[Gs(e4, n3)].evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input);
            for (const e4 of this.outputs)
              t3(e4);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = ["step", this.input.serialize()];
            for (let e4 = 0; e4 < this.labels.length; e4++)
              e4 > 0 && t3.push(this.labels[e4]), t3.push(this.outputs[e4].serialize());
            return t3;
          }
        }
        const Ys = 0.95047, Xs = 1.08883, Zs = 4 / 29, Ks = 6 / 29, Ws = 3 * Ks * Ks, Hs = Ks * Ks * Ks, Js = Math.PI / 180, ta = 180 / Math.PI;
        function ea(t3) {
          return t3 > Hs ? Math.pow(t3, 1 / 3) : t3 / Ws + Zs;
        }
        function ra(t3) {
          return t3 > Ks ? t3 * t3 * t3 : Ws * (t3 - Zs);
        }
        function na(t3) {
          return 255 * (t3 <= 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055);
        }
        function ia(t3) {
          return (t3 /= 255) <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
        }
        function sa(t3) {
          const e4 = ia(t3.r), r4 = ia(t3.g), n3 = ia(t3.b), i3 = ea((0.4124564 * e4 + 0.3575761 * r4 + 0.1804375 * n3) / Ys), s4 = ea((0.2126729 * e4 + 0.7151522 * r4 + 0.072175 * n3) / 1);
          return { l: 116 * s4 - 16, a: 500 * (i3 - s4), b: 200 * (s4 - ea((0.0193339 * e4 + 0.119192 * r4 + 0.9503041 * n3) / Xs)), alpha: t3.a };
        }
        function aa(t3) {
          let e4 = (t3.l + 16) / 116, r4 = isNaN(t3.a) ? e4 : e4 + t3.a / 500, n3 = isNaN(t3.b) ? e4 : e4 - t3.b / 200;
          return e4 = 1 * ra(e4), r4 = Ys * ra(r4), n3 = Xs * ra(n3), new jn(na(3.2404542 * r4 - 1.5371385 * e4 - 0.4985314 * n3), na(-0.969266 * r4 + 1.8760108 * e4 + 0.041556 * n3), na(0.0556434 * r4 - 0.2040259 * e4 + 1.0572252 * n3), t3.alpha);
        }
        function oa(t3, e4, r4) {
          const n3 = e4 - t3;
          return t3 + r4 * (n3 > 180 || n3 < -180 ? n3 - 360 * Math.round(n3 / 360) : n3);
        }
        const la = { forward: sa, reverse: aa, interpolate: function(t3, e4, r4) {
          return { l: qn(t3.l, e4.l, r4), a: qn(t3.a, e4.a, r4), b: qn(t3.b, e4.b, r4), alpha: qn(t3.alpha, e4.alpha, r4) };
        } }, ua = { forward: function(t3) {
          const { l: e4, a: r4, b: n3 } = sa(t3), i3 = Math.atan2(n3, r4) * ta;
          return { h: i3 < 0 ? i3 + 360 : i3, c: Math.sqrt(r4 * r4 + n3 * n3), l: e4, alpha: t3.a };
        }, reverse: function(t3) {
          const e4 = t3.h * Js, r4 = t3.c;
          return aa({ l: t3.l, a: Math.cos(e4) * r4, b: Math.sin(e4) * r4, alpha: t3.alpha });
        }, interpolate: function(t3, e4, r4) {
          return { h: oa(t3.h, e4.h, r4), c: qn(t3.c, e4.c, r4), l: qn(t3.l, e4.l, r4), alpha: qn(t3.alpha, e4.alpha, r4) };
        } };
        var ca = Object.freeze({ __proto__: null, hcl: ua, lab: la });
        class ha {
          constructor(t3, e4, r4, n3, i3) {
            this.type = t3, this.operator = e4, this.interpolation = r4, this.input = n3, this.labels = [], this.outputs = [];
            for (const [t4, e5] of i3)
              this.labels.push(t4), this.outputs.push(e5);
          }
          static interpolationFactor(t3, e4, r4, n3) {
            let i3 = 0;
            if ("exponential" === t3.name)
              i3 = pa(e4, t3.base, r4, n3);
            else if ("linear" === t3.name)
              i3 = pa(e4, 1, r4, n3);
            else if ("cubic-bezier" === t3.name) {
              const s4 = t3.controlPoints;
              i3 = new Le(s4[0], s4[1], s4[2], s4[3]).solve(pa(e4, 1, r4, n3));
            }
            return i3;
          }
          static parse(t3, e4) {
            let [r4, n3, i3, ...s4] = t3;
            if (!Array.isArray(n3) || 0 === n3.length)
              return e4.error("Expected an interpolation type expression.", 1);
            if ("linear" === n3[0])
              n3 = { name: "linear" };
            else if ("exponential" === n3[0]) {
              const t4 = n3[1];
              if ("number" != typeof t4)
                return e4.error("Exponential interpolation requires a numeric base.", 1, 1);
              n3 = { name: "exponential", base: t4 };
            } else {
              if ("cubic-bezier" !== n3[0])
                return e4.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
              {
                const t4 = n3.slice(1);
                if (4 !== t4.length || t4.some((t5) => "number" != typeof t5 || t5 < 0 || t5 > 1))
                  return e4.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n3 = { name: "cubic-bezier", controlPoints: t4 };
              }
            }
            if (t3.length - 1 < 4)
              return e4.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e4.error("Expected an even number of arguments.");
            if (i3 = e4.parse(i3, 2, Kn), !i3)
              return null;
            const a3 = [];
            let o3 = null;
            "interpolate-hcl" === r4 || "interpolate-lab" === r4 ? o3 = Jn : e4.expectedType && "value" !== e4.expectedType.kind && (o3 = e4.expectedType);
            for (let t4 = 0; t4 < s4.length; t4 += 2) {
              const r5 = s4[t4], n4 = s4[t4 + 1], i4 = t4 + 3, l3 = t4 + 4;
              if ("number" != typeof r5)
                return e4.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i4);
              if (a3.length && a3[a3.length - 1][0] >= r5)
                return e4.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i4);
              const u3 = e4.parse(n4, l3, o3);
              if (!u3)
                return null;
              o3 = o3 || u3.type, a3.push([r5, u3]);
            }
            return "number" === o3.kind || "color" === o3.kind || "array" === o3.kind && "number" === o3.itemType.kind && "number" == typeof o3.N ? new ha(o3, r4, n3, i3, a3) : e4.error(`Type ${ai(o3)} is not interpolatable.`);
          }
          evaluate(t3) {
            const e4 = this.labels, r4 = this.outputs;
            if (1 === e4.length)
              return r4[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e4[0])
              return r4[0].evaluate(t3);
            const i3 = e4.length;
            if (n3 >= e4[i3 - 1])
              return r4[i3 - 1].evaluate(t3);
            const s4 = Gs(e4, n3), a3 = ha.interpolationFactor(this.interpolation, n3, e4[s4], e4[s4 + 1]), o3 = r4[s4].evaluate(t3), l3 = r4[s4 + 1].evaluate(t3);
            return "interpolate" === this.operator ? Gn[this.type.kind.toLowerCase()](o3, l3, a3) : "interpolate-hcl" === this.operator ? ua.reverse(ua.interpolate(ua.forward(o3), ua.forward(l3), a3)) : la.reverse(la.interpolate(la.forward(o3), la.forward(l3), a3));
          }
          eachChild(t3) {
            t3(this.input);
            for (const e4 of this.outputs)
              t3(e4);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
          serialize() {
            let t3;
            t3 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const e4 = [this.operator, t3, this.input.serialize()];
            for (let t4 = 0; t4 < this.labels.length; t4++)
              e4.push(this.labels[t4], this.outputs[t4].serialize());
            return e4;
          }
        }
        function pa(t3, e4, r4, n3) {
          const i3 = n3 - r4, s4 = t3 - r4;
          return 0 === i3 ? 0 : 1 === e4 ? s4 / i3 : (Math.pow(e4, s4) - 1) / (Math.pow(e4, i3) - 1);
        }
        class fa {
          constructor(t3, e4) {
            this.type = t3, this.args = e4;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expectected at least one argument.");
            let r4 = null;
            const n3 = e4.expectedType;
            n3 && "value" !== n3.kind && (r4 = n3);
            const i3 = [];
            for (const n4 of t3.slice(1)) {
              const t4 = e4.parse(n4, 1 + i3.length, r4, void 0, { typeAnnotation: "omit" });
              if (!t4)
                return null;
              r4 = r4 || t4.type, i3.push(t4);
            }
            const s4 = n3 && i3.some((t4) => li(n3, t4.type));
            return new fa(s4 ? ei : r4, i3);
          }
          evaluate(t3) {
            let e4, r4 = null, n3 = 0;
            for (const i3 of this.args) {
              if (n3++, r4 = i3.evaluate(t3), r4 && r4 instanceof di && !r4.available && (e4 || (e4 = r4), r4 = null, n3 === this.args.length))
                return e4;
              if (null !== r4)
                break;
            }
            return r4;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = ["coalesce"];
            return this.eachChild((e4) => {
              t3.push(e4.serialize());
            }), t3;
          }
        }
        class da {
          constructor(t3, e4) {
            this.type = e4.type, this.bindings = [].concat(t3), this.result = e4;
          }
          evaluate(t3) {
            return this.result.evaluate(t3);
          }
          eachChild(t3) {
            for (const e4 of this.bindings)
              t3(e4[1]);
            t3(this.result);
          }
          static parse(t3, e4) {
            if (t3.length < 4)
              return e4.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
            const r4 = [];
            for (let n4 = 1; n4 < t3.length - 1; n4 += 2) {
              const i3 = t3[n4];
              if ("string" != typeof i3)
                return e4.error(`Expected string, but found ${typeof i3} instead.`, n4);
              if (/[^a-zA-Z0-9_]/.test(i3))
                return e4.error("Variable names must contain only alphanumeric characters or '_'.", n4);
              const s4 = e4.parse(t3[n4 + 1], n4 + 1);
              if (!s4)
                return null;
              r4.push([i3, s4]);
            }
            const n3 = e4.parse(t3[t3.length - 1], t3.length - 1, e4.expectedType, r4);
            return n3 ? new da(r4, n3) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t3 = ["let"];
            for (const [e4, r4] of this.bindings)
              t3.push(e4, r4.serialize());
            return t3.push(this.result.serialize()), t3;
          }
        }
        class ma {
          constructor(t3, e4, r4) {
            this.type = t3, this.index = e4, this.input = r4;
          }
          static parse(t3, e4) {
            if (3 !== t3.length)
              return e4.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r4 = e4.parse(t3[1], 1, Kn), n3 = e4.parse(t3[2], 2, si(e4.expectedType || ei));
            return r4 && n3 ? new ma(n3.type.itemType, r4, n3) : null;
          }
          evaluate(t3) {
            const e4 = this.index.evaluate(t3), r4 = this.input.evaluate(t3);
            if (e4 < 0)
              throw new vi(`Array index out of bounds: ${e4} < 0.`);
            if (e4 >= r4.length)
              throw new vi(`Array index out of bounds: ${e4} > ${r4.length - 1}.`);
            if (e4 !== Math.floor(e4))
              throw new vi(`Array index must be an integer, but found ${e4} instead.`);
            return r4[e4];
          }
          eachChild(t3) {
            t3(this.index), t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        class ya {
          constructor(t3, e4) {
            this.type = Hn, this.needle = t3, this.haystack = e4;
          }
          static parse(t3, e4) {
            if (3 !== t3.length)
              return e4.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r4 = e4.parse(t3[1], 1, ei), n3 = e4.parse(t3[2], 2, ei);
            return r4 && n3 ? ui(r4.type, [Hn, Wn, Kn, Zn, ei]) ? new ya(r4, n3) : e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${ai(r4.type)} instead`) : null;
          }
          evaluate(t3) {
            const e4 = this.needle.evaluate(t3), r4 = this.haystack.evaluate(t3);
            if (null == r4)
              return false;
            if (!ci(e4, ["boolean", "string", "number", "null"]))
              throw new vi(`Expected first argument to be of type boolean, string, number or null, but found ${ai(gi(e4))} instead.`);
            if (!ci(r4, ["string", "array"]))
              throw new vi(`Expected second argument to be of type array or string, but found ${ai(gi(r4))} instead.`);
            return r4.indexOf(e4) >= 0;
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class ga {
          constructor(t3, e4, r4) {
            this.type = Kn, this.needle = t3, this.haystack = e4, this.fromIndex = r4;
          }
          static parse(t3, e4) {
            if (t3.length <= 2 || t3.length >= 5)
              return e4.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r4 = e4.parse(t3[1], 1, ei), n3 = e4.parse(t3[2], 2, ei);
            if (!r4 || !n3)
              return null;
            if (!ui(r4.type, [Hn, Wn, Kn, Zn, ei]))
              return e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${ai(r4.type)} instead`);
            if (4 === t3.length) {
              const i3 = e4.parse(t3[3], 3, Kn);
              return i3 ? new ga(r4, n3, i3) : null;
            }
            return new ga(r4, n3);
          }
          evaluate(t3) {
            const e4 = this.needle.evaluate(t3), r4 = this.haystack.evaluate(t3);
            if (!ci(e4, ["boolean", "string", "number", "null"]))
              throw new vi(`Expected first argument to be of type boolean, string, number or null, but found ${ai(gi(e4))} instead.`);
            if (!ci(r4, ["string", "array"]))
              throw new vi(`Expected second argument to be of type array or string, but found ${ai(gi(r4))} instead.`);
            if (this.fromIndex) {
              const n3 = this.fromIndex.evaluate(t3);
              return r4.indexOf(e4, n3);
            }
            return r4.indexOf(e4);
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              const t3 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t3];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class xa {
          constructor(t3, e4, r4, n3, i3, s4) {
            this.inputType = t3, this.type = e4, this.input = r4, this.cases = n3, this.outputs = i3, this.otherwise = s4;
          }
          static parse(t3, e4) {
            if (t3.length < 5)
              return e4.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 1)
              return e4.error("Expected an even number of arguments.");
            let r4, n3;
            e4.expectedType && "value" !== e4.expectedType.kind && (n3 = e4.expectedType);
            const i3 = {}, s4 = [];
            for (let a4 = 2; a4 < t3.length - 1; a4 += 2) {
              let o4 = t3[a4];
              const l3 = t3[a4 + 1];
              Array.isArray(o4) || (o4 = [o4]);
              const u3 = e4.concat(a4);
              if (0 === o4.length)
                return u3.error("Expected at least one branch label.");
              for (const t4 of o4) {
                if ("number" != typeof t4 && "string" != typeof t4)
                  return u3.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t4 && Math.abs(t4) > Number.MAX_SAFE_INTEGER)
                  return u3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t4 && Math.floor(t4) !== t4)
                  return u3.error("Numeric branch labels must be integer values.");
                if (r4) {
                  if (u3.checkSubtype(r4, gi(t4)))
                    return null;
                } else
                  r4 = gi(t4);
                if (void 0 !== i3[String(t4)])
                  return u3.error("Branch labels must be unique.");
                i3[String(t4)] = s4.length;
              }
              const c3 = e4.parse(l3, a4, n3);
              if (!c3)
                return null;
              n3 = n3 || c3.type, s4.push(c3);
            }
            const a3 = e4.parse(t3[1], 1, ei);
            if (!a3)
              return null;
            const o3 = e4.parse(t3[t3.length - 1], t3.length - 1, n3);
            return o3 ? "value" !== a3.type.kind && e4.concat(1).checkSubtype(r4, a3.type) ? null : new xa(r4, n3, a3, i3, s4, o3) : null;
          }
          evaluate(t3) {
            const e4 = this.input.evaluate(t3);
            return (gi(e4) === this.inputType && this.outputs[this.cases[e4]] || this.otherwise).evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t3 = ["match", this.input.serialize()], e4 = Object.keys(this.cases).sort(), r4 = [], n3 = {};
            for (const t4 of e4) {
              const e5 = n3[this.cases[t4]];
              void 0 === e5 ? (n3[this.cases[t4]] = r4.length, r4.push([this.cases[t4], [t4]])) : r4[e5][1].push(t4);
            }
            const i3 = (t4) => "number" === this.inputType.kind ? Number(t4) : t4;
            for (const [e5, n4] of r4)
              t3.push(1 === n4.length ? i3(n4[0]) : n4.map(i3)), t3.push(this.outputs[e5].serialize());
            return t3.push(this.otherwise.serialize()), t3;
          }
        }
        class ba {
          constructor(t3, e4, r4) {
            this.type = t3, this.branches = e4, this.otherwise = r4;
          }
          static parse(t3, e4) {
            if (t3.length < 4)
              return e4.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 0)
              return e4.error("Expected an odd number of arguments.");
            let r4;
            e4.expectedType && "value" !== e4.expectedType.kind && (r4 = e4.expectedType);
            const n3 = [];
            for (let i4 = 1; i4 < t3.length - 1; i4 += 2) {
              const s4 = e4.parse(t3[i4], i4, Hn);
              if (!s4)
                return null;
              const a3 = e4.parse(t3[i4 + 1], i4 + 1, r4);
              if (!a3)
                return null;
              n3.push([s4, a3]), r4 = r4 || a3.type;
            }
            const i3 = e4.parse(t3[t3.length - 1], t3.length - 1, r4);
            return i3 ? new ba(r4, n3, i3) : null;
          }
          evaluate(t3) {
            for (const [e4, r4] of this.branches)
              if (e4.evaluate(t3))
                return r4.evaluate(t3);
            return this.otherwise.evaluate(t3);
          }
          eachChild(t3) {
            for (const [e4, r4] of this.branches)
              t3(e4), t3(r4);
            t3(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t3, e4]) => e4.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t3 = ["case"];
            return this.eachChild((e4) => {
              t3.push(e4.serialize());
            }), t3;
          }
        }
        class va {
          constructor(t3, e4, r4, n3) {
            this.type = t3, this.input = e4, this.beginIndex = r4, this.endIndex = n3;
          }
          static parse(t3, e4) {
            if (t3.length <= 2 || t3.length >= 5)
              return e4.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r4 = e4.parse(t3[1], 1, ei), n3 = e4.parse(t3[2], 2, Kn);
            if (!r4 || !n3)
              return null;
            if (!ui(r4.type, [si(ei), Wn, ei]))
              return e4.error(`Expected first argument to be of type array or string, but found ${ai(r4.type)} instead`);
            if (4 === t3.length) {
              const i3 = e4.parse(t3[3], 3, Kn);
              return i3 ? new va(r4.type, r4, n3, i3) : null;
            }
            return new va(r4.type, r4, n3);
          }
          evaluate(t3) {
            const e4 = this.input.evaluate(t3), r4 = this.beginIndex.evaluate(t3);
            if (!ci(e4, ["string", "array"]))
              throw new vi(`Expected first argument to be of type array or string, but found ${ai(gi(e4))} instead.`);
            if (this.endIndex) {
              const n3 = this.endIndex.evaluate(t3);
              return e4.slice(r4, n3);
            }
            return e4.slice(r4);
          }
          eachChild(t3) {
            t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              const t3 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t3];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        function _a(t3, e4) {
          return "==" === t3 || "!=" === t3 ? "boolean" === e4.kind || "string" === e4.kind || "number" === e4.kind || "null" === e4.kind || "value" === e4.kind : "string" === e4.kind || "number" === e4.kind || "value" === e4.kind;
        }
        function wa(t3, e4, r4, n3) {
          return 0 === n3.compare(e4, r4);
        }
        function Ma(t3, e4, r4) {
          const n3 = "==" !== t3 && "!=" !== t3;
          return class i3 {
            constructor(t4, e5, r5) {
              this.type = Hn, this.lhs = t4, this.rhs = e5, this.collator = r5, this.hasUntypedArgument = "value" === t4.type.kind || "value" === e5.type.kind;
            }
            static parse(t4, e5) {
              if (3 !== t4.length && 4 !== t4.length)
                return e5.error("Expected two or three arguments.");
              const r5 = t4[0];
              let s4 = e5.parse(t4[1], 1, ei);
              if (!s4)
                return null;
              if (!_a(r5, s4.type))
                return e5.concat(1).error(`"${r5}" comparisons are not supported for type '${ai(s4.type)}'.`);
              let a3 = e5.parse(t4[2], 2, ei);
              if (!a3)
                return null;
              if (!_a(r5, a3.type))
                return e5.concat(2).error(`"${r5}" comparisons are not supported for type '${ai(a3.type)}'.`);
              if (s4.type.kind !== a3.type.kind && "value" !== s4.type.kind && "value" !== a3.type.kind)
                return e5.error(`Cannot compare types '${ai(s4.type)}' and '${ai(a3.type)}'.`);
              n3 && ("value" === s4.type.kind && "value" !== a3.type.kind ? s4 = new wi(a3.type, [s4]) : "value" !== s4.type.kind && "value" === a3.type.kind && (a3 = new wi(s4.type, [a3])));
              let o3 = null;
              if (4 === t4.length) {
                if ("string" !== s4.type.kind && "string" !== a3.type.kind && "value" !== s4.type.kind && "value" !== a3.type.kind)
                  return e5.error("Cannot use collator to compare non-string types.");
                if (o3 = e5.parse(t4[3], 3, ri), !o3)
                  return null;
              }
              return new i3(s4, a3, o3);
            }
            evaluate(i4) {
              const s4 = this.lhs.evaluate(i4), a3 = this.rhs.evaluate(i4);
              if (n3 && this.hasUntypedArgument) {
                const e5 = gi(s4), r5 = gi(a3);
                if (e5.kind !== r5.kind || "string" !== e5.kind && "number" !== e5.kind)
                  throw new vi(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e5.kind}, ${r5.kind}) instead.`);
              }
              if (this.collator && !n3 && this.hasUntypedArgument) {
                const t4 = gi(s4), r5 = gi(a3);
                if ("string" !== t4.kind || "string" !== r5.kind)
                  return e4(i4, s4, a3);
              }
              return this.collator ? r4(i4, s4, a3, this.collator.evaluate(i4)) : e4(i4, s4, a3);
            }
            eachChild(t4) {
              t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e5 = [t3];
              return this.eachChild((t4) => {
                e5.push(t4.serialize());
              }), e5;
            }
          };
        }
        const Aa = Ma("==", function(t3, e4, r4) {
          return e4 === r4;
        }, wa), Sa = Ma("!=", function(t3, e4, r4) {
          return e4 !== r4;
        }, function(t3, e4, r4, n3) {
          return !wa(0, e4, r4, n3);
        }), Ia = Ma("<", function(t3, e4, r4) {
          return e4 < r4;
        }, function(t3, e4, r4, n3) {
          return n3.compare(e4, r4) < 0;
        }), ka = Ma(">", function(t3, e4, r4) {
          return e4 > r4;
        }, function(t3, e4, r4, n3) {
          return n3.compare(e4, r4) > 0;
        }), Pa = Ma("<=", function(t3, e4, r4) {
          return e4 <= r4;
        }, function(t3, e4, r4, n3) {
          return n3.compare(e4, r4) <= 0;
        }), Ea = Ma(">=", function(t3, e4, r4) {
          return e4 >= r4;
        }, function(t3, e4, r4, n3) {
          return n3.compare(e4, r4) >= 0;
        });
        class za {
          constructor(t3, e4, r4, n3, i3, s4) {
            this.type = Wn, this.number = t3, this.locale = e4, this.currency = r4, this.unit = n3, this.minFractionDigits = i3, this.maxFractionDigits = s4;
          }
          static parse(t3, e4) {
            if (3 !== t3.length)
              return e4.error("Expected two arguments.");
            const r4 = e4.parse(t3[1], 1, Kn);
            if (!r4)
              return null;
            const n3 = t3[2];
            if ("object" != typeof n3 || Array.isArray(n3))
              return e4.error("NumberFormat options argument must be an object.");
            let i3 = null;
            if (n3.locale && (i3 = e4.parse(n3.locale, 1, Wn), !i3))
              return null;
            let s4 = null;
            if (n3.currency && (s4 = e4.parse(n3.currency, 1, Wn), !s4))
              return null;
            let a3 = null;
            if (n3.unit && (a3 = e4.parse(n3.unit, 1, Wn), !a3))
              return null;
            let o3 = null;
            if (n3["min-fraction-digits"] && (o3 = e4.parse(n3["min-fraction-digits"], 1, Kn), !o3))
              return null;
            let l3 = null;
            return n3["max-fraction-digits"] && (l3 = e4.parse(n3["max-fraction-digits"], 1, Kn), !l3) ? null : new za(r4, i3, s4, a3, o3, l3);
          }
          evaluate(t3) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, unit: this.unit ? this.unit.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
          }
          eachChild(t3) {
            t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.unit && t3(this.unit), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = {};
            return this.locale && (t3.locale = this.locale.serialize()), this.currency && (t3.currency = this.currency.serialize()), this.unit && (t3.unit = this.unit.serialize()), this.minFractionDigits && (t3["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t3["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t3];
          }
        }
        class Ta {
          constructor(t3) {
            this.type = Kn, this.input = t3;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
            const r4 = e4.parse(t3[1], 1);
            return r4 ? "array" !== r4.type.kind && "string" !== r4.type.kind && "value" !== r4.type.kind ? e4.error(`Expected argument of type string or array, but found ${ai(r4.type)} instead.`) : new Ta(r4) : null;
          }
          evaluate(t3) {
            const e4 = this.input.evaluate(t3);
            if ("string" == typeof e4)
              return e4.length;
            if (Array.isArray(e4))
              return e4.length;
            throw new vi(`Expected value to be of type string or array, but found ${ai(gi(e4))} instead.`);
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = ["length"];
            return this.eachChild((e4) => {
              t3.push(e4.serialize());
            }), t3;
          }
        }
        function Ba(t3) {
          return function() {
            t3 = 1831565813 + (t3 |= 0) | 0;
            let e4 = Math.imul(t3 ^ t3 >>> 15, 1 | t3);
            return e4 = e4 + Math.imul(e4 ^ e4 >>> 7, 61 | e4) ^ e4, ((e4 ^ e4 >>> 14) >>> 0) / 4294967296;
          };
        }
        const Ca = { "==": Aa, "!=": Sa, ">": ka, "<": Ia, ">=": Ea, "<=": Pa, array: wi, at: ma, boolean: wi, case: ba, coalesce: fa, collator: Bi, format: Mi, image: Ai, in: ya, "index-of": ga, interpolate: ha, "interpolate-hcl": ha, "interpolate-lab": ha, length: Ta, let: da, literal: bi, match: xa, number: wi, "number-format": za, object: wi, slice: va, step: Qs, string: wi, "to-boolean": ki, "to-color": ki, "to-number": ki, "to-string": ki, var: js, within: Ji, distance: Rs, config: Ls };
        function Ra(t3, [e4, r4, n3, i3]) {
          e4 = e4.evaluate(t3), r4 = r4.evaluate(t3), n3 = n3.evaluate(t3);
          const s4 = i3 ? i3.evaluate(t3) : 1, a3 = mi(e4, r4, n3, s4);
          if (a3)
            throw new vi(a3);
          return new jn(e4 / 255 * s4, r4 / 255 * s4, n3 / 255 * s4, s4);
        }
        function Va(t3, [e4, r4, n3, i3]) {
          e4 = e4.evaluate(t3), r4 = r4.evaluate(t3), n3 = n3.evaluate(t3);
          const s4 = i3 ? i3.evaluate(t3) : 1, a3 = function(t4, e5, r5, n4) {
            return "number" == typeof t4 && t4 >= 0 && t4 <= 360 ? "number" == typeof e5 && e5 >= 0 && e5 <= 100 && "number" == typeof r5 && r5 >= 0 && r5 <= 100 ? void 0 === n4 || "number" == typeof n4 && n4 >= 0 && n4 <= 1 ? null : `Invalid hsla value [${[t4, e5, r5, n4].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n4 ? [t4, e5, r5, n4] : [t4, e5, r5]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n4 ? [t4, e5, r5, n4] : [t4, e5, r5]).join(", ")}]: 'h' must be between 0 and 360.`;
          }(e4, r4, n3, s4);
          if (a3)
            throw new vi(a3);
          const o3 = `hsla(${e4}, ${r4}%, ${n3}%, ${s4})`, l3 = jn.parse(o3);
          if (!l3)
            throw new vi(`Failed to parse HSLA color: ${o3}`);
          return l3;
        }
        function Da(t3, e4) {
          return t3 in e4;
        }
        function La(t3, e4) {
          const r4 = e4[t3];
          return void 0 === r4 ? null : r4;
        }
        function Fa(t3) {
          return { type: t3 };
        }
        function Oa(t3) {
          return { result: "success", value: t3 };
        }
        function Ua(t3) {
          return { result: "error", value: t3 };
        }
        function Na(t3, e4) {
          return !!t3 && !!t3.parameters && t3.parameters.indexOf(e4) > -1;
        }
        function ja(t3) {
          return "data-driven" === t3["property-type"];
        }
        function qa(t3) {
          return Na(t3.expression, "measure-light");
        }
        function $a(t3) {
          return Na(t3.expression, "zoom");
        }
        function Ga(t3) {
          return !!t3.expression && t3.expression.interpolated;
        }
        function Qa(t3) {
          return "object" == typeof t3 && null !== t3 && !Array.isArray(t3);
        }
        function Ya(t3) {
          return t3;
        }
        function Xa(t3, e4) {
          const r4 = "color" === e4.type, n3 = t3.stops && "object" == typeof t3.stops[0][0], i3 = n3 || !(n3 || void 0 !== t3.property), s4 = t3.type || (Ga(e4) ? "exponential" : "interval");
          if (r4 && ((t3 = Qn({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], jn.parse(t4[1])])), t3.default = jn.parse(t3.default ? t3.default : e4.default)), t3.colorSpace && "rgb" !== t3.colorSpace && !ca[t3.colorSpace])
            throw new Error(`Unknown color space: ${t3.colorSpace}`);
          let a3, o3, l3;
          if ("exponential" === s4)
            a3 = Ha;
          else if ("interval" === s4)
            a3 = Wa;
          else if ("categorical" === s4) {
            a3 = Ka, o3 = /* @__PURE__ */ Object.create(null);
            for (const e5 of t3.stops)
              o3[e5[0]] = e5[1];
            l3 = typeof t3.stops[0][0];
          } else {
            if ("identity" !== s4)
              throw new Error(`Unknown function type "${s4}"`);
            a3 = Ja;
          }
          if (n3) {
            const r5 = {}, n4 = [];
            for (let e5 = 0; e5 < t3.stops.length; e5++) {
              const i5 = t3.stops[e5], s6 = i5[0].zoom;
              void 0 === r5[s6] && (r5[s6] = { zoom: s6, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n4.push(s6)), r5[s6].stops.push([i5[0].value, i5[1]]);
            }
            const i4 = [];
            for (const t4 of n4)
              i4.push([r5[t4].zoom, Xa(r5[t4], e4)]);
            const s5 = { name: "linear" };
            return { kind: "composite", interpolationType: s5, interpolationFactor: ha.interpolationFactor.bind(void 0, s5), zoomStops: i4.map((t4) => t4[0]), evaluate: ({ zoom: r6 }, n5) => Ha({ stops: i4, base: t3.base }, e4, r6).evaluate(r6, n5) };
          }
          if (i3) {
            const r5 = "exponential" === s4 ? { name: "exponential", base: void 0 !== t3.base ? t3.base : 1 } : null;
            return { kind: "camera", interpolationType: r5, interpolationFactor: ha.interpolationFactor.bind(void 0, r5), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r6 }) => a3(t3, e4, r6, o3, l3) };
          }
          return { kind: "source", evaluate(r5, n4) {
            const i4 = n4 && n4.properties ? n4.properties[t3.property] : void 0;
            return void 0 === i4 ? Za(t3.default, e4.default) : a3(t3, e4, i4, o3, l3);
          } };
        }
        function Za(t3, e4, r4) {
          return void 0 !== t3 ? t3 : void 0 !== e4 ? e4 : void 0 !== r4 ? r4 : void 0;
        }
        function Ka(t3, e4, r4, n3, i3) {
          return Za(typeof r4 === i3 ? n3[r4] : void 0, t3.default, e4.default);
        }
        function Wa(t3, e4, r4) {
          if ("number" !== Si(r4))
            return Za(t3.default, e4.default);
          const n3 = t3.stops.length;
          if (1 === n3)
            return t3.stops[0][1];
          if (r4 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r4 >= t3.stops[n3 - 1][0])
            return t3.stops[n3 - 1][1];
          const i3 = Gs(t3.stops.map((t4) => t4[0]), r4);
          return t3.stops[i3][1];
        }
        function Ha(t3, e4, r4) {
          const n3 = void 0 !== t3.base ? t3.base : 1;
          if ("number" !== Si(r4))
            return Za(t3.default, e4.default);
          const i3 = t3.stops.length;
          if (1 === i3)
            return t3.stops[0][1];
          if (r4 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r4 >= t3.stops[i3 - 1][0])
            return t3.stops[i3 - 1][1];
          const s4 = Gs(t3.stops.map((t4) => t4[0]), r4), a3 = function(t4, e5, r5, n4) {
            const i4 = n4 - r5, s5 = t4 - r5;
            return 0 === i4 ? 0 : 1 === e5 ? s5 / i4 : (Math.pow(e5, s5) - 1) / (Math.pow(e5, i4) - 1);
          }(r4, n3, t3.stops[s4][0], t3.stops[s4 + 1][0]), o3 = t3.stops[s4][1], l3 = t3.stops[s4 + 1][1];
          let u3 = Gn[e4.type] || Ya;
          if (t3.colorSpace && "rgb" !== t3.colorSpace) {
            const e5 = ca[t3.colorSpace];
            u3 = (t4, r5) => e5.reverse(e5.interpolate(e5.forward(t4), e5.forward(r5), a3));
          }
          return "function" == typeof o3.evaluate ? { evaluate(...t4) {
            const e5 = o3.evaluate.apply(void 0, t4), r5 = l3.evaluate.apply(void 0, t4);
            if (void 0 !== e5 && void 0 !== r5)
              return u3(e5, r5, a3);
          } } : u3(o3, l3, a3);
        }
        function Ja(t3, e4, r4) {
          return "color" === e4.type ? r4 = jn.parse(r4) : "formatted" === e4.type ? r4 = fi.fromString(r4.toString()) : "resolvedImage" === e4.type ? r4 = di.fromString(r4.toString()) : Si(r4) === e4.type || "enum" === e4.type && e4.values[r4] || (r4 = void 0), Za(r4, t3.default, e4.default);
        }
        zi.register(Ca, { error: [{ kind: "error" }, [Wn], (t3, [e4]) => {
          throw new vi(e4.evaluate(t3));
        }], typeof: [Wn, [ei], (t3, [e4]) => ai(gi(e4.evaluate(t3)))], "to-rgba": [si(Kn, 4), [Jn], (t3, [e4]) => e4.evaluate(t3).toArray()], rgb: [Jn, [Kn, Kn, Kn], Ra], rgba: [Jn, [Kn, Kn, Kn, Kn], Ra], hsl: [Jn, [Kn, Kn, Kn], Va], hsla: [Jn, [Kn, Kn, Kn, Kn], Va], has: { type: Hn, overloads: [[[Wn], (t3, [e4]) => Da(e4.evaluate(t3), t3.properties())], [[Wn, ti], (t3, [e4, r4]) => Da(e4.evaluate(t3), r4.evaluate(t3))]] }, get: { type: ei, overloads: [[[Wn], (t3, [e4]) => La(e4.evaluate(t3), t3.properties())], [[Wn, ti], (t3, [e4, r4]) => La(e4.evaluate(t3), r4.evaluate(t3))]] }, "feature-state": [ei, [Wn], (t3, [e4]) => La(e4.evaluate(t3), t3.featureState || {})], properties: [ti, [], (t3) => t3.properties()], "geometry-type": [Wn, [], (t3) => t3.geometryType()], id: [ei, [], (t3) => t3.id()], zoom: [Kn, [], (t3) => t3.globals.zoom], pitch: [Kn, [], (t3) => t3.globals.pitch || 0], "distance-from-center": [Kn, [], (t3) => t3.distanceFromCenter()], "measure-light": [Kn, [Wn], (t3, [e4]) => t3.measureLight(e4.evaluate(t3))], "heatmap-density": [Kn, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [Kn, [], (t3) => t3.globals.lineProgress || 0], "raster-value": [Kn, [], (t3) => t3.globals.rasterValue || 0], "raster-particle-speed": [Kn, [], (t3) => t3.globals.rasterParticleSpeed || 0], "sky-radial-progress": [Kn, [], (t3) => t3.globals.skyRadialProgress || 0], accumulated: [ei, [], (t3) => void 0 === t3.globals.accumulated ? null : t3.globals.accumulated], "+": [Kn, Fa(Kn), (t3, e4) => {
          let r4 = 0;
          for (const n3 of e4)
            r4 += n3.evaluate(t3);
          return r4;
        }], "*": [Kn, Fa(Kn), (t3, e4) => {
          let r4 = 1;
          for (const n3 of e4)
            r4 *= n3.evaluate(t3);
          return r4;
        }], "-": { type: Kn, overloads: [[[Kn, Kn], (t3, [e4, r4]) => e4.evaluate(t3) - r4.evaluate(t3)], [[Kn], (t3, [e4]) => -e4.evaluate(t3)]] }, "/": [Kn, [Kn, Kn], (t3, [e4, r4]) => e4.evaluate(t3) / r4.evaluate(t3)], "%": [Kn, [Kn, Kn], (t3, [e4, r4]) => e4.evaluate(t3) % r4.evaluate(t3)], ln2: [Kn, [], () => Math.LN2], pi: [Kn, [], () => Math.PI], e: [Kn, [], () => Math.E], "^": [Kn, [Kn, Kn], (t3, [e4, r4]) => Math.pow(e4.evaluate(t3), r4.evaluate(t3))], sqrt: [Kn, [Kn], (t3, [e4]) => Math.sqrt(e4.evaluate(t3))], log10: [Kn, [Kn], (t3, [e4]) => Math.log(e4.evaluate(t3)) / Math.LN10], ln: [Kn, [Kn], (t3, [e4]) => Math.log(e4.evaluate(t3))], log2: [Kn, [Kn], (t3, [e4]) => Math.log(e4.evaluate(t3)) / Math.LN2], sin: [Kn, [Kn], (t3, [e4]) => Math.sin(e4.evaluate(t3))], cos: [Kn, [Kn], (t3, [e4]) => Math.cos(e4.evaluate(t3))], tan: [Kn, [Kn], (t3, [e4]) => Math.tan(e4.evaluate(t3))], asin: [Kn, [Kn], (t3, [e4]) => Math.asin(e4.evaluate(t3))], acos: [Kn, [Kn], (t3, [e4]) => Math.acos(e4.evaluate(t3))], atan: [Kn, [Kn], (t3, [e4]) => Math.atan(e4.evaluate(t3))], min: [Kn, Fa(Kn), (t3, e4) => Math.min(...e4.map((e5) => e5.evaluate(t3)))], max: [Kn, Fa(Kn), (t3, e4) => Math.max(...e4.map((e5) => e5.evaluate(t3)))], abs: [Kn, [Kn], (t3, [e4]) => Math.abs(e4.evaluate(t3))], round: [Kn, [Kn], (t3, [e4]) => {
          const r4 = e4.evaluate(t3);
          return r4 < 0 ? -Math.round(-r4) : Math.round(r4);
        }], floor: [Kn, [Kn], (t3, [e4]) => Math.floor(e4.evaluate(t3))], ceil: [Kn, [Kn], (t3, [e4]) => Math.ceil(e4.evaluate(t3))], "filter-==": [Hn, [Wn, ei], (t3, [e4, r4]) => t3.properties()[e4.value] === r4.value], "filter-id-==": [Hn, [ei], (t3, [e4]) => t3.id() === e4.value], "filter-type-==": [Hn, [Wn], (t3, [e4]) => t3.geometryType() === e4.value], "filter-<": [Hn, [Wn, ei], (t3, [e4, r4]) => {
          const n3 = t3.properties()[e4.value], i3 = r4.value;
          return typeof n3 == typeof i3 && n3 < i3;
        }], "filter-id-<": [Hn, [ei], (t3, [e4]) => {
          const r4 = t3.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 < n3;
        }], "filter->": [Hn, [Wn, ei], (t3, [e4, r4]) => {
          const n3 = t3.properties()[e4.value], i3 = r4.value;
          return typeof n3 == typeof i3 && n3 > i3;
        }], "filter-id->": [Hn, [ei], (t3, [e4]) => {
          const r4 = t3.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 > n3;
        }], "filter-<=": [Hn, [Wn, ei], (t3, [e4, r4]) => {
          const n3 = t3.properties()[e4.value], i3 = r4.value;
          return typeof n3 == typeof i3 && n3 <= i3;
        }], "filter-id-<=": [Hn, [ei], (t3, [e4]) => {
          const r4 = t3.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 <= n3;
        }], "filter->=": [Hn, [Wn, ei], (t3, [e4, r4]) => {
          const n3 = t3.properties()[e4.value], i3 = r4.value;
          return typeof n3 == typeof i3 && n3 >= i3;
        }], "filter-id->=": [Hn, [ei], (t3, [e4]) => {
          const r4 = t3.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 >= n3;
        }], "filter-has": [Hn, [ei], (t3, [e4]) => e4.value in t3.properties()], "filter-has-id": [Hn, [], (t3) => null !== t3.id() && void 0 !== t3.id()], "filter-type-in": [Hn, [si(Wn)], (t3, [e4]) => e4.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [Hn, [si(ei)], (t3, [e4]) => e4.value.indexOf(t3.id()) >= 0], "filter-in-small": [Hn, [Wn, si(ei)], (t3, [e4, r4]) => r4.value.indexOf(t3.properties()[e4.value]) >= 0], "filter-in-large": [Hn, [Wn, si(ei)], (t3, [e4, r4]) => function(t4, e5, r5, n3) {
          for (; r5 <= n3; ) {
            const i3 = r5 + n3 >> 1;
            if (e5[i3] === t4)
              return true;
            e5[i3] > t4 ? n3 = i3 - 1 : r5 = i3 + 1;
          }
          return false;
        }(t3.properties()[e4.value], r4.value, 0, r4.value.length - 1)], all: { type: Hn, overloads: [[[Hn, Hn], (t3, [e4, r4]) => e4.evaluate(t3) && r4.evaluate(t3)], [Fa(Hn), (t3, e4) => {
          for (const r4 of e4)
            if (!r4.evaluate(t3))
              return false;
          return true;
        }]] }, any: { type: Hn, overloads: [[[Hn, Hn], (t3, [e4, r4]) => e4.evaluate(t3) || r4.evaluate(t3)], [Fa(Hn), (t3, e4) => {
          for (const r4 of e4)
            if (r4.evaluate(t3))
              return true;
          return false;
        }]] }, "!": [Hn, [Hn], (t3, [e4]) => !e4.evaluate(t3)], "is-supported-script": [Hn, [Wn], (t3, [e4]) => {
          const r4 = t3.globals && t3.globals.isSupportedScript;
          return !r4 || r4(e4.evaluate(t3));
        }], upcase: [Wn, [Wn], (t3, [e4]) => e4.evaluate(t3).toUpperCase()], downcase: [Wn, [Wn], (t3, [e4]) => e4.evaluate(t3).toLowerCase()], concat: [Wn, Fa(ei), (t3, e4) => e4.map((e5) => xi(e5.evaluate(t3))).join("")], "resolved-locale": [Wn, [ri], (t3, [e4]) => e4.evaluate(t3).resolvedLocale()], random: [Kn, [Kn, Kn, ei], (t3, e4) => {
          const [r4, n3, i3] = e4.map((e5) => e5.evaluate(t3));
          if (r4 > n3)
            return r4;
          if (r4 === n3)
            return r4;
          let s4;
          if ("string" == typeof i3)
            s4 = function(t4) {
              let e5 = 0;
              if (0 === t4.length)
                return e5;
              for (let r5 = 0; r5 < t4.length; r5++)
                e5 = (e5 << 5) - e5 + t4.charCodeAt(r5), e5 |= 0;
              return e5;
            }(i3);
          else {
            if ("number" != typeof i3)
              throw new vi(`Invalid seed input: ${i3}`);
            s4 = i3;
          }
          return r4 + Ba(s4)() * (n3 - r4);
        }] });
        class to {
          constructor(t3, e4, r4, n3) {
            this.expression = t3, this._warningHistory = {}, this._evaluator = new Ei(r4, n3), this._defaultValue = e4 ? function(t4) {
              return "color" === t4.type && (Qa(t4.default) || Array.isArray(t4.default)) ? new jn(0, 0, 0, 0) : "color" === t4.type ? jn.parse(t4.default) || null : void 0 === t4.default ? null : t4.default;
            }(e4) : null, this._enumValues = e4 && "enum" === e4.type ? e4.values : null;
          }
          evaluateWithoutErrorHandling(t3, e4, r4, n3, i3, s4, a3, o3) {
            return this._evaluator.globals = t3, this._evaluator.feature = e4, this._evaluator.featureState = r4, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = s4, this._evaluator.featureTileCoord = a3 || null, this._evaluator.featureDistanceData = o3 || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(t3, e4, r4, n3, i3, s4, a3, o3) {
            this._evaluator.globals = t3, this._evaluator.feature = e4 || null, this._evaluator.featureState = r4 || null, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = s4 || null, this._evaluator.featureTileCoord = a3 || null, this._evaluator.featureDistanceData = o3 || null;
            try {
              const t4 = this.expression.evaluate(this._evaluator);
              if (null == t4 || "number" == typeof t4 && t4 != t4)
                return this._defaultValue;
              if (this._enumValues && !(t4 in this._enumValues))
                throw new vi(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
              return t4;
            } catch (t4) {
              return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, "undefined" != typeof console && console.warn(t4.message)), this._defaultValue;
            }
          }
        }
        function eo(t3) {
          return Array.isArray(t3) && t3.length > 0 && "string" == typeof t3[0] && t3[0] in Ca;
        }
        function ro(t3, e4, r4, n3) {
          const i3 = new qs(Ca, [], e4 ? function(t4) {
            const e5 = { color: Jn, string: Wn, number: Kn, enum: Wn, boolean: Hn, formatted: ni, resolvedImage: ii };
            return "array" === t4.type ? si(e5[t4.value] || ei, t4.length) : e5[t4.type];
          }(e4) : void 0, void 0, void 0, r4, n3), s4 = i3.parse(t3, void 0, void 0, void 0, e4 && "string" === e4.type ? { typeAnnotation: "coerce" } : void 0);
          return s4 ? Oa(new to(s4, e4, r4, n3)) : Ua(i3.errors);
        }
        class no {
          constructor(t3, e4, r4) {
            this.kind = t3, this._styleExpression = e4, this.isLightConstant = r4, this.isStateDependent = "constant" !== t3 && !Os(e4.expression), this.isConfigDependent = !Us(e4.expression);
          }
          evaluateWithoutErrorHandling(t3, e4, r4, n3, i3, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e4, r4, n3, i3, s4);
          }
          evaluate(t3, e4, r4, n3, i3, s4) {
            return this._styleExpression.evaluate(t3, e4, r4, n3, i3, s4);
          }
        }
        class io {
          constructor(t3, e4, r4, n3, i3) {
            this.kind = t3, this.zoomStops = r4, this._styleExpression = e4, this.isStateDependent = "camera" !== t3 && !Os(e4.expression), this.isLightConstant = i3, this.isConfigDependent = !Us(e4.expression), this.interpolationType = n3;
          }
          evaluateWithoutErrorHandling(t3, e4, r4, n3, i3, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e4, r4, n3, i3, s4);
          }
          evaluate(t3, e4, r4, n3, i3, s4) {
            return this._styleExpression.evaluate(t3, e4, r4, n3, i3, s4);
          }
          interpolationFactor(t3, e4, r4) {
            return this.interpolationType ? ha.interpolationFactor(this.interpolationType, t3, e4, r4) : 0;
          }
        }
        function so(t3, e4, r4, n3) {
          if ("error" === (t3 = ro(t3, e4, r4, n3)).result)
            return t3;
          const i3 = t3.value.expression, s4 = Fs(i3);
          if (!s4 && !ja(e4))
            return Ua([new Yn("", "data expressions not supported")]);
          const a3 = Ns(i3, ["zoom", "pitch", "distance-from-center"]);
          if (!a3 && !$a(e4))
            return Ua([new Yn("", "zoom expressions not supported")]);
          const o3 = Ns(i3, ["measure-light"]);
          if (!o3 && !qa(e4))
            return Ua([new Yn("", "measure-light expression not supported")]);
          const l3 = e4.expression && e4.expression.relaxZoomRestriction, u3 = oo(i3);
          return u3 || a3 || l3 ? u3 instanceof Yn ? Ua([u3]) : u3 instanceof ha && !Ga(e4) ? Ua([new Yn("", '"interpolate" expressions cannot be used with this property')]) : Oa(u3 ? new io(s4 ? "camera" : "composite", t3.value, u3.labels, u3 instanceof ha ? u3.interpolation : void 0, o3) : new no(s4 ? "constant" : "source", t3.value, o3)) : Ua([new Yn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
        }
        class ao {
          constructor(t3, e4) {
            this._parameters = t3, this._specification = e4, Qn(this, Xa(this._parameters, this._specification));
          }
          static deserialize(t3) {
            return new ao(t3._parameters, t3._specification);
          }
          static serialize(t3) {
            return { _parameters: t3._parameters, _specification: t3._specification };
          }
        }
        function oo(t3) {
          let e4 = null;
          if (t3 instanceof da)
            e4 = oo(t3.result);
          else if (t3 instanceof fa) {
            for (const r4 of t3.args)
              if (e4 = oo(r4), e4)
                break;
          } else
            (t3 instanceof Qs || t3 instanceof ha) && t3.input instanceof zi && "zoom" === t3.input.name && (e4 = t3);
          return e4 instanceof Yn || t3.eachChild((t4) => {
            const r4 = oo(t4);
            r4 instanceof Yn ? e4 = r4 : e4 && r4 && e4 !== r4 && (e4 = new Yn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e4;
        }
        var lo = co, uo = 3;
        function co(t3, e4, r4) {
          var n3 = this.cells = [];
          if (t3 instanceof ArrayBuffer) {
            this.arrayBuffer = t3;
            var i3 = new Int32Array(this.arrayBuffer);
            t3 = i3[0], this.d = (e4 = i3[1]) + 2 * (r4 = i3[2]);
            for (var s4 = 0; s4 < this.d * this.d; s4++) {
              var a3 = i3[uo + s4], o3 = i3[uo + s4 + 1];
              n3.push(a3 === o3 ? null : i3.subarray(a3, o3));
            }
            var l3 = i3[uo + n3.length + 1];
            this.keys = i3.subarray(i3[uo + n3.length], l3), this.bboxes = i3.subarray(l3), this.insert = this._insertReadonly;
          } else {
            this.d = e4 + 2 * r4;
            for (var u3 = 0; u3 < this.d * this.d; u3++)
              n3.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e4, this.extent = t3, this.padding = r4, this.scale = e4 / t3, this.uid = 0;
          var c3 = r4 / e4 * t3;
          this.min = -c3, this.max = t3 + c3;
        }
        co.prototype.insert = function(t3, e4, r4, n3, i3) {
          this._forEachCell(e4, r4, n3, i3, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e4), this.bboxes.push(r4), this.bboxes.push(n3), this.bboxes.push(i3);
        }, co.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, co.prototype._insertCell = function(t3, e4, r4, n3, i3, s4) {
          this.cells[i3].push(s4);
        }, co.prototype.query = function(t3, e4, r4, n3, i3) {
          var s4 = this.min, a3 = this.max;
          if (t3 <= s4 && e4 <= s4 && a3 <= r4 && a3 <= n3 && !i3)
            return Array.prototype.slice.call(this.keys);
          var o3 = [];
          return this._forEachCell(t3, e4, r4, n3, this._queryCell, o3, {}, i3), o3;
        }, co.prototype._queryCell = function(t3, e4, r4, n3, i3, s4, a3, o3) {
          var l3 = this.cells[i3];
          if (null !== l3)
            for (var u3 = this.keys, c3 = this.bboxes, h2 = 0; h2 < l3.length; h2++) {
              var p3 = l3[h2];
              if (void 0 === a3[p3]) {
                var f2 = 4 * p3;
                (o3 ? o3(c3[f2 + 0], c3[f2 + 1], c3[f2 + 2], c3[f2 + 3]) : t3 <= c3[f2 + 2] && e4 <= c3[f2 + 3] && r4 >= c3[f2 + 0] && n3 >= c3[f2 + 1]) ? (a3[p3] = true, s4.push(u3[p3])) : a3[p3] = false;
              }
            }
        }, co.prototype._forEachCell = function(t3, e4, r4, n3, i3, s4, a3, o3) {
          for (var l3 = this._convertToCellCoord(t3), u3 = this._convertToCellCoord(e4), c3 = this._convertToCellCoord(r4), h2 = this._convertToCellCoord(n3), p3 = l3; p3 <= c3; p3++)
            for (var f2 = u3; f2 <= h2; f2++) {
              var d2 = this.d * f2 + p3;
              if ((!o3 || o3(this._convertFromCellCoord(p3), this._convertFromCellCoord(f2), this._convertFromCellCoord(p3 + 1), this._convertFromCellCoord(f2 + 1))) && i3.call(this, t3, e4, r4, n3, d2, s4, a3, o3))
                return;
            }
        }, co.prototype._convertFromCellCoord = function(t3) {
          return (t3 - this.padding) / this.scale;
        }, co.prototype._convertToCellCoord = function(t3) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
        }, co.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var t3 = this.cells, e4 = uo + this.cells.length + 1 + 1, r4 = 0, n3 = 0; n3 < this.cells.length; n3++)
            r4 += this.cells[n3].length;
          var i3 = new Int32Array(e4 + r4 + this.keys.length + this.bboxes.length);
          i3[0] = this.extent, i3[1] = this.n, i3[2] = this.padding;
          for (var s4 = e4, a3 = 0; a3 < t3.length; a3++) {
            var o3 = t3[a3];
            i3[uo + a3] = s4, i3.set(o3, s4), s4 += o3.length;
          }
          return i3[uo + t3.length] = s4, i3.set(this.keys, s4), i3[uo + t3.length + 1] = s4 += this.keys.length, i3.set(this.bboxes, s4), s4 += this.bboxes.length, i3.buffer;
        };
        var ho = h(lo);
        const po = {};
        function fo(t3, e4, r4 = {}) {
          Object.defineProperty(t3, "_classRegistryKey", { value: e4, writeable: false }), po[e4] = { klass: t3, omit: r4.omit || [] };
        }
        fo(Object, "Object"), ho.serialize = function(t3, e4) {
          const r4 = t3.toArrayBuffer();
          return e4 && e4.add(r4), { buffer: r4 };
        }, ho.deserialize = function(t3) {
          return new ho(t3.buffer);
        }, Object.defineProperty(ho, "name", { value: "Grid" }), fo(ho, "Grid"), fo(jn, "Color"), fo(Error, "Error"), fo(fi, "Formatted"), fo(pi, "FormattedSection"), fo(Kr, "AJAXError"), fo(di, "ResolvedImage"), fo(ao, "StylePropertyFunction"), fo(to, "StyleExpression", { omit: ["_evaluator"] }), fo(io, "ZoomDependentExpression"), fo(no, "ZoomConstantExpression"), fo(zi, "CompoundExpression", { omit: ["_evaluate"] });
        for (const t3 in Ca)
          po[Ca[t3]._classRegistryKey] || fo(Ca[t3], `Expression${t3}`);
        function mo(t3) {
          return t3 && "undefined" != typeof ArrayBuffer && (t3 instanceof ArrayBuffer || t3.constructor && "ArrayBuffer" === t3.constructor.name);
        }
        function yo(t3) {
          return self.ImageBitmap && t3 instanceof ImageBitmap;
        }
        function go(t3, e4) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp)
            return t3;
          if (mo(t3) || yo(t3))
            return e4 && e4.add(t3), t3;
          if (ArrayBuffer.isView(t3)) {
            const r4 = t3;
            return e4 && e4.add(r4.buffer), r4;
          }
          if (t3 instanceof ImageData)
            return e4 && e4.add(t3.data.buffer), t3;
          if (Array.isArray(t3)) {
            const r4 = [];
            for (const n3 of t3)
              r4.push(go(n3, e4));
            return r4;
          }
          if (t3 instanceof Map) {
            const e5 = { $name: "Map" };
            for (const [r4, n3] of t3.entries())
              e5[r4] = go(n3);
            return e5;
          }
          if ("object" == typeof t3) {
            const r4 = t3.constructor, n3 = r4._classRegistryKey;
            if (!n3)
              throw new Error(`can't serialize object of unregistered class ${n3}`);
            const i3 = r4.serialize ? r4.serialize(t3, e4) : {};
            if (!r4.serialize) {
              for (const r5 in t3)
                t3.hasOwnProperty(r5) && (po[n3].omit.indexOf(r5) >= 0 || (i3[r5] = go(t3[r5], e4)));
              t3 instanceof Error && (i3.message = t3.message);
            }
            if (i3.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n3 && (i3.$name = n3), i3;
          }
          throw new Error("can't serialize object of type " + typeof t3);
        }
        function xo(t3) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || mo(t3) || yo(t3) || ArrayBuffer.isView(t3) || t3 instanceof ImageData)
            return t3;
          if (Array.isArray(t3))
            return t3.map(xo);
          if ("object" == typeof t3) {
            const e4 = t3.$name || "Object";
            if ("Map" === e4) {
              const e5 = /* @__PURE__ */ new Map();
              for (const r5 of Object.keys(t3))
                "$name" !== r5 && e5.set(r5, xo(t3[r5]));
              return e5;
            }
            const { klass: r4 } = po[e4];
            if (!r4)
              throw new Error(`can't deserialize unregistered class ${e4}`);
            if (r4.deserialize)
              return r4.deserialize(t3);
            const n3 = Object.create(r4.prototype);
            for (const e5 of Object.keys(t3))
              "$name" !== e5 && (n3[e5] = xo(t3[e5]));
            return n3;
          }
          throw new Error("can't deserialize object of type " + typeof t3);
        }
        const bo = { "Latin-1 Supplement": (t3) => t3 >= 128 && t3 <= 255, Arabic: (t3) => t3 >= 1536 && t3 <= 1791, "Arabic Supplement": (t3) => t3 >= 1872 && t3 <= 1919, "Arabic Extended-A": (t3) => t3 >= 2208 && t3 <= 2303, "Hangul Jamo": (t3) => t3 >= 4352 && t3 <= 4607, "Unified Canadian Aboriginal Syllabics": (t3) => t3 >= 5120 && t3 <= 5759, Khmer: (t3) => t3 >= 6016 && t3 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t3) => t3 >= 6320 && t3 <= 6399, "General Punctuation": (t3) => t3 >= 8192 && t3 <= 8303, "Letterlike Symbols": (t3) => t3 >= 8448 && t3 <= 8527, "Number Forms": (t3) => t3 >= 8528 && t3 <= 8591, "Miscellaneous Technical": (t3) => t3 >= 8960 && t3 <= 9215, "Control Pictures": (t3) => t3 >= 9216 && t3 <= 9279, "Optical Character Recognition": (t3) => t3 >= 9280 && t3 <= 9311, "Enclosed Alphanumerics": (t3) => t3 >= 9312 && t3 <= 9471, "Geometric Shapes": (t3) => t3 >= 9632 && t3 <= 9727, "Miscellaneous Symbols": (t3) => t3 >= 9728 && t3 <= 9983, "Miscellaneous Symbols and Arrows": (t3) => t3 >= 11008 && t3 <= 11263, "CJK Radicals Supplement": (t3) => t3 >= 11904 && t3 <= 12031, "Kangxi Radicals": (t3) => t3 >= 12032 && t3 <= 12255, "Ideographic Description Characters": (t3) => t3 >= 12272 && t3 <= 12287, "CJK Symbols and Punctuation": (t3) => t3 >= 12288 && t3 <= 12351, Hiragana: (t3) => t3 >= 12352 && t3 <= 12447, Katakana: (t3) => t3 >= 12448 && t3 <= 12543, Bopomofo: (t3) => t3 >= 12544 && t3 <= 12591, "Hangul Compatibility Jamo": (t3) => t3 >= 12592 && t3 <= 12687, Kanbun: (t3) => t3 >= 12688 && t3 <= 12703, "Bopomofo Extended": (t3) => t3 >= 12704 && t3 <= 12735, "CJK Strokes": (t3) => t3 >= 12736 && t3 <= 12783, "Katakana Phonetic Extensions": (t3) => t3 >= 12784 && t3 <= 12799, "Enclosed CJK Letters and Months": (t3) => t3 >= 12800 && t3 <= 13055, "CJK Compatibility": (t3) => t3 >= 13056 && t3 <= 13311, "CJK Unified Ideographs Extension A": (t3) => t3 >= 13312 && t3 <= 19903, "Yijing Hexagram Symbols": (t3) => t3 >= 19904 && t3 <= 19967, "CJK Unified Ideographs": (t3) => t3 >= 19968 && t3 <= 40959, "Yi Syllables": (t3) => t3 >= 40960 && t3 <= 42127, "Yi Radicals": (t3) => t3 >= 42128 && t3 <= 42191, "Hangul Jamo Extended-A": (t3) => t3 >= 43360 && t3 <= 43391, "Hangul Syllables": (t3) => t3 >= 44032 && t3 <= 55215, "Hangul Jamo Extended-B": (t3) => t3 >= 55216 && t3 <= 55295, "Private Use Area": (t3) => t3 >= 57344 && t3 <= 63743, "CJK Compatibility Ideographs": (t3) => t3 >= 63744 && t3 <= 64255, "Arabic Presentation Forms-A": (t3) => t3 >= 64336 && t3 <= 65023, "Vertical Forms": (t3) => t3 >= 65040 && t3 <= 65055, "CJK Compatibility Forms": (t3) => t3 >= 65072 && t3 <= 65103, "Small Form Variants": (t3) => t3 >= 65104 && t3 <= 65135, "Arabic Presentation Forms-B": (t3) => t3 >= 65136 && t3 <= 65279, "Halfwidth and Fullwidth Forms": (t3) => t3 >= 65280 && t3 <= 65519, "CJK Unified Ideographs Extension B": (t3) => t3 >= 131072 && t3 <= 173791 };
        function vo(t3) {
          for (const e4 of t3)
            if (Mo(e4.charCodeAt(0)))
              return true;
          return false;
        }
        function _o(t3) {
          for (const e4 of t3)
            if (!wo(e4.charCodeAt(0)))
              return false;
          return true;
        }
        function wo(t3) {
          return !(bo.Arabic(t3) || bo["Arabic Supplement"](t3) || bo["Arabic Extended-A"](t3) || bo["Arabic Presentation Forms-A"](t3) || bo["Arabic Presentation Forms-B"](t3));
        }
        function Mo(t3) {
          return !(746 !== t3 && 747 !== t3 && (t3 < 4352 || !(bo["Bopomofo Extended"](t3) || bo.Bopomofo(t3) || bo["CJK Compatibility Forms"](t3) && !(t3 >= 65097 && t3 <= 65103) || bo["CJK Compatibility Ideographs"](t3) || bo["CJK Compatibility"](t3) || bo["CJK Radicals Supplement"](t3) || bo["CJK Strokes"](t3) || !(!bo["CJK Symbols and Punctuation"](t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || 12336 === t3) || bo["CJK Unified Ideographs Extension A"](t3) || bo["CJK Unified Ideographs"](t3) || bo["Enclosed CJK Letters and Months"](t3) || bo["Hangul Compatibility Jamo"](t3) || bo["Hangul Jamo Extended-A"](t3) || bo["Hangul Jamo Extended-B"](t3) || bo["Hangul Jamo"](t3) || bo["Hangul Syllables"](t3) || bo.Hiragana(t3) || bo["Ideographic Description Characters"](t3) || bo.Kanbun(t3) || bo["Kangxi Radicals"](t3) || bo["Katakana Phonetic Extensions"](t3) || bo.Katakana(t3) && 12540 !== t3 || !(!bo["Halfwidth and Fullwidth Forms"](t3) || 65288 === t3 || 65289 === t3 || 65293 === t3 || t3 >= 65306 && t3 <= 65310 || 65339 === t3 || 65341 === t3 || 65343 === t3 || t3 >= 65371 && t3 <= 65503 || 65507 === t3 || t3 >= 65512 && t3 <= 65519) || !(!bo["Small Form Variants"](t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || bo["Unified Canadian Aboriginal Syllabics"](t3) || bo["Unified Canadian Aboriginal Syllabics Extended"](t3) || bo["Vertical Forms"](t3) || bo["Yijing Hexagram Symbols"](t3) || bo["Yi Syllables"](t3) || bo["Yi Radicals"](t3))));
        }
        function Ao(t3) {
          return !(Mo(t3) || function(t4) {
            return !!(bo["Latin-1 Supplement"](t4) && (167 === t4 || 169 === t4 || 174 === t4 || 177 === t4 || 188 === t4 || 189 === t4 || 190 === t4 || 215 === t4 || 247 === t4) || bo["General Punctuation"](t4) && (8214 === t4 || 8224 === t4 || 8225 === t4 || 8240 === t4 || 8241 === t4 || 8251 === t4 || 8252 === t4 || 8258 === t4 || 8263 === t4 || 8264 === t4 || 8265 === t4 || 8273 === t4) || bo["Letterlike Symbols"](t4) || bo["Number Forms"](t4) || bo["Miscellaneous Technical"](t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || 9003 === t4 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || 9167 === t4 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || bo["Control Pictures"](t4) && 9251 !== t4 || bo["Optical Character Recognition"](t4) || bo["Enclosed Alphanumerics"](t4) || bo["Geometric Shapes"](t4) || bo["Miscellaneous Symbols"](t4) && !(t4 >= 9754 && t4 <= 9759) || bo["Miscellaneous Symbols and Arrows"](t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || bo["CJK Symbols and Punctuation"](t4) || bo.Katakana(t4) || bo["Private Use Area"](t4) || bo["CJK Compatibility Forms"](t4) || bo["Small Form Variants"](t4) || bo["Halfwidth and Fullwidth Forms"](t4) || 8734 === t4 || 8756 === t4 || 8757 === t4 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || 65532 === t4 || 65533 === t4);
          }(t3));
        }
        function So(t3) {
          return t3 >= 1424 && t3 <= 2303 || bo["Arabic Presentation Forms-A"](t3) || bo["Arabic Presentation Forms-B"](t3);
        }
        function Io(t3, e4) {
          return !(!e4 && So(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || bo.Khmer(t3));
        }
        function ko(t3) {
          for (const e4 of t3)
            if (So(e4.charCodeAt(0)))
              return true;
          return false;
        }
        const Po = "deferred", Eo = "loading", zo = "loaded";
        let To = null, Bo = "unavailable", Co = null;
        const Ro = function(t3) {
          t3 && "string" == typeof t3 && t3.indexOf("NetworkError") > -1 && (Bo = "error"), To && To(t3);
        };
        function Vo() {
          Do.fire(new Rn("pluginStateChange", { pluginStatus: Bo, pluginURL: Co }));
        }
        const Do = new Dn(), Lo = function() {
          return Bo;
        }, Fo = function() {
          if (Bo !== Po || !Co)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Bo = Eo, Vo(), Co && Jr({ url: Co }, (t3) => {
            t3 ? Ro(t3) : (Bo = zo, Vo());
          });
        }, Oo = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Bo === zo || null != Oo.applyArabicShaping, isLoading: () => Bo === Eo, setState(t3) {
          Bo = t3.pluginStatus, Co = t3.pluginURL;
        }, isParsed: () => null != Oo.applyArabicShaping && null != Oo.processBidirectionalText && null != Oo.processStyledBidirectionalText, getPluginURL: () => Co };
        class Uo {
          constructor(t3, e4) {
            this.zoom = t3, e4 ? (this.now = e4.now, this.fadeDuration = e4.fadeDuration, this.transition = e4.transition, this.pitch = e4.pitch, this.brightness = e4.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
          }
          isSupportedScript(t3) {
            return function(t4, e4) {
              for (const r4 of t4)
                if (!Io(r4.charCodeAt(0), e4))
                  return false;
              return true;
            }(t3, Oo.isLoaded());
          }
        }
        class No {
          constructor(t3, e4, r4, n3) {
            this.property = t3, this.value = e4, this.expression = function(t4, e5, r5, n4) {
              if (Qa(t4))
                return new ao(t4, e5);
              if (eo(t4) || Array.isArray(t4) && t4.length > 0) {
                const i3 = so(t4, e5, r5, n4);
                if ("error" === i3.result)
                  throw new Error(i3.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
                return i3.value;
              }
              {
                let r6 = t4;
                return "string" == typeof t4 && "color" === e5.type && (r6 = jn.parse(t4)), { kind: "constant", isConfigDependent: false, evaluate: () => r6 };
              }
            }(void 0 === e4 ? t3.specification.default : e4, t3.specification, r4, n3);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t3, e4, r4) {
            return this.property.possiblyEvaluate(this, t3, e4, r4);
          }
        }
        class jo {
          constructor(t3, e4, r4) {
            this.property = t3, this.value = new No(t3, void 0, e4, r4);
          }
          transitioned(t3, e4) {
            return new $o(this.property, this.value, e4, Je({}, t3.transition, this.transition), t3.now);
          }
          untransitioned() {
            return new $o(this.property, this.value, null, {}, 0);
          }
        }
        class qo {
          constructor(t3, e4, r4) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues), this._scope = e4, this._options = r4, this.isConfigDependent = false;
          }
          getValue(t3) {
            return ur(this._values[t3].value.value);
          }
          setValue(t3, e4) {
            this._values.hasOwnProperty(t3) || (this._values[t3] = new jo(this._values[t3].property, this._scope, this._options)), this._values[t3].value = new No(this._values[t3].property, null === e4 ? void 0 : ur(e4), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t3].value.expression.isConfigDependent;
          }
          setTransitionOrValue(t3, e4) {
            e4 && (this._options = e4);
            const r4 = this._properties.properties;
            if (t3)
              for (const e5 in t3) {
                const n3 = t3[e5];
                if (ar(e5, "-transition")) {
                  const t4 = e5.slice(0, -11);
                  r4[t4] && this.setTransition(t4, n3);
                } else
                  r4[e5] && this.setValue(e5, n3);
              }
          }
          getTransition(t3) {
            return ur(this._values[t3].transition);
          }
          setTransition(t3, e4) {
            this._values.hasOwnProperty(t3) || (this._values[t3] = new jo(this._values[t3].property)), this._values[t3].transition = ur(e4) || void 0;
          }
          serialize() {
            const t3 = {};
            for (const e4 of Object.keys(this._values)) {
              const r4 = this.getValue(e4);
              void 0 !== r4 && (t3[e4] = r4);
              const n3 = this.getTransition(e4);
              void 0 !== n3 && (t3[`${e4}-transition`] = n3);
            }
            return t3;
          }
          transitioned(t3, e4) {
            const r4 = new Go(this._properties);
            for (const n3 of Object.keys(this._values))
              r4._values[n3] = this._values[n3].transitioned(t3, e4._values[n3]);
            return r4;
          }
          untransitioned() {
            const t3 = new Go(this._properties);
            for (const e4 of Object.keys(this._values))
              t3._values[e4] = this._values[e4].untransitioned();
            return t3;
          }
        }
        class $o {
          constructor(t3, e4, r4, n3, i3) {
            const s4 = n3.delay || 0, a3 = n3.duration || 0;
            i3 = i3 || 0, this.property = t3, this.value = e4, this.begin = i3 + s4, this.end = this.begin + a3, t3.specification.transition && (n3.delay || n3.duration) && (this.prior = r4);
          }
          possiblyEvaluate(t3, e4, r4) {
            const n3 = t3.now || 0, i3 = this.value.possiblyEvaluate(t3, e4, r4), s4 = this.prior;
            if (s4) {
              if (n3 > this.end)
                return this.prior = null, i3;
              if (this.value.isDataDriven())
                return this.prior = null, i3;
              if (n3 < this.begin)
                return s4.possiblyEvaluate(t3, e4, r4);
              {
                const a3 = (n3 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s4.possiblyEvaluate(t3, e4, r4), i3, Qe(a3));
              }
            }
            return i3;
          }
        }
        class Go {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t3, e4, r4) {
            const n3 = new Xo(this._properties);
            for (const i3 of Object.keys(this._values))
              n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e4, r4);
            return n3;
          }
          hasTransition() {
            for (const t3 of Object.keys(this._values))
              if (this._values[t3].prior)
                return true;
            return false;
          }
        }
        class Qo {
          constructor(t3, e4, r4) {
            this._properties = t3, this._values = Object.create(t3.defaultPropertyValues), this._scope = e4, this._options = r4, this.isConfigDependent = false;
          }
          getValue(t3) {
            return ur(this._values[t3].value);
          }
          setValue(t3, e4) {
            this._values[t3] = new No(this._values[t3].property, null === e4 ? void 0 : ur(e4), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t3].expression.isConfigDependent;
          }
          serialize() {
            const t3 = {};
            for (const e4 of Object.keys(this._values)) {
              const r4 = this.getValue(e4);
              void 0 !== r4 && (t3[e4] = r4);
            }
            return t3;
          }
          possiblyEvaluate(t3, e4, r4) {
            const n3 = new Xo(this._properties);
            for (const i3 of Object.keys(this._values))
              n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e4, r4);
            return n3;
          }
        }
        class Yo {
          constructor(t3, e4, r4) {
            this.property = t3, this.value = e4, this.parameters = r4;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t3) {
            return "constant" === this.value.kind ? this.value.value : t3;
          }
          evaluate(t3, e4, r4, n3) {
            return this.property.evaluate(this.value, this.parameters, t3, e4, r4, n3);
          }
        }
        class Xo {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
          }
          get(t3) {
            return this._values[t3];
          }
        }
        class Zo {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e4) {
            return t3.expression.evaluate(e4);
          }
          interpolate(t3, e4, r4) {
            const n3 = Gn[this.specification.type];
            return n3 ? n3(t3, e4, r4) : t3;
          }
        }
        class Ko {
          constructor(t3, e4) {
            this.specification = t3, this.overrides = e4;
          }
          possiblyEvaluate(t3, e4, r4, n3) {
            return new Yo(this, "constant" === t3.expression.kind || "camera" === t3.expression.kind ? { kind: "constant", value: t3.expression.evaluate(e4, null, {}, r4, n3) } : t3.expression, e4);
          }
          interpolate(t3, e4, r4) {
            if ("constant" !== t3.value.kind || "constant" !== e4.value.kind)
              return t3;
            if (void 0 === t3.value.value || void 0 === e4.value.value)
              return new Yo(this, { kind: "constant", value: void 0 }, t3.parameters);
            const n3 = Gn[this.specification.type];
            return n3 ? new Yo(this, { kind: "constant", value: n3(t3.value.value, e4.value.value, r4) }, t3.parameters) : t3;
          }
          evaluate(t3, e4, r4, n3, i3, s4) {
            return "constant" === t3.kind ? t3.value : t3.evaluate(e4, r4, n3, i3, s4);
          }
        }
        class Wo {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e4, r4, n3) {
            return !!t3.expression.evaluate(e4, null, {}, r4, n3);
          }
          interpolate() {
            return false;
          }
        }
        class Ho {
          constructor(t3) {
            this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const e4 = new Uo(0, {});
            for (const r4 in t3) {
              const n3 = t3[r4];
              n3.specification.overridable && this.overridableProperties.push(r4);
              const i3 = this.defaultPropertyValues[r4] = new No(n3, void 0), s4 = this.defaultTransitionablePropertyValues[r4] = new jo(n3);
              this.defaultTransitioningPropertyValues[r4] = s4.untransitioned(), this.defaultPossiblyEvaluatedValues[r4] = i3.possiblyEvaluate(e4);
            }
          }
        }
        function Jo(t3) {
          return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
        }
        function tl(t3) {
          if (Array.isArray(t3))
            return t3.map(tl);
          if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
            const e4 = {};
            for (const r4 in t3)
              e4[r4] = tl(t3[r4]);
            return e4;
          }
          return Jo(t3);
        }
        fo(Ko, "DataDrivenProperty"), fo(Zo, "DataConstantProperty"), fo(Wo, "ColorRampProperty");
        var el = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function rl(t3) {
          if (true === t3 || false === t3)
            return true;
          if (!Array.isArray(t3) || 0 === t3.length)
            return false;
          switch (t3[0]) {
            case "has":
              return t3.length >= 2 && "$id" !== t3[1] && "$type" !== t3[1];
            case "in":
              return t3.length >= 3 && ("string" != typeof t3[1] || Array.isArray(t3[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t3.length || Array.isArray(t3[1]) || Array.isArray(t3[2]);
            case "any":
            case "all":
              for (const e4 of t3.slice(1))
                if (!rl(e4) && "boolean" != typeof e4)
                  return false;
              return true;
            default:
              return true;
          }
        }
        function nl(t3, e4 = "fill") {
          if (null == t3)
            return { filter: () => true, needGeometry: false, needFeature: false };
          rl(t3) || (t3 = cl(t3));
          const r4 = t3;
          let n3 = true;
          try {
            n3 = function(t4) {
              if (!al(t4))
                return t4;
              let e5 = tl(t4);
              return sl(e5), e5 = il(e5), e5;
            }(r4);
          } catch (t4) {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r4, null, 2)}
        `);
          }
          const i3 = el[`filter_${e4}`], s4 = ro(n3, i3);
          let a3 = null;
          if ("error" === s4.result)
            throw new Error(s4.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          a3 = (t4, e5, r5) => s4.value.evaluate(t4, e5, {}, r5);
          let o3 = null, l3 = null;
          if (n3 !== r4) {
            const t4 = ro(r4, i3);
            if ("error" === t4.result)
              throw new Error(t4.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
            o3 = (e5, r5, n4, i4, s5) => t4.value.evaluate(e5, r5, {}, n4, void 0, void 0, i4, s5), l3 = !Fs(t4.value.expression);
          }
          return { filter: a3, dynamicFilter: o3 || void 0, needGeometry: ul(n3), needFeature: !!l3 };
        }
        function il(t3) {
          if (!Array.isArray(t3))
            return t3;
          const e4 = function(t4) {
            if (ol.has(t4[0])) {
              for (let e5 = 1; e5 < t4.length; e5++)
                if (al(t4[e5]))
                  return true;
            }
            return t4;
          }(t3);
          return true === e4 ? e4 : e4.map((t4) => il(t4));
        }
        function sl(t3) {
          let e4 = false;
          const r4 = [];
          if ("case" === t3[0]) {
            for (let n3 = 1; n3 < t3.length - 1; n3 += 2)
              e4 = e4 || al(t3[n3]), r4.push(t3[n3 + 1]);
            r4.push(t3[t3.length - 1]);
          } else if ("match" === t3[0]) {
            e4 = e4 || al(t3[1]);
            for (let e5 = 2; e5 < t3.length - 1; e5 += 2)
              r4.push(t3[e5 + 1]);
            r4.push(t3[t3.length - 1]);
          } else if ("step" === t3[0]) {
            e4 = e4 || al(t3[1]);
            for (let e5 = 1; e5 < t3.length - 1; e5 += 2)
              r4.push(t3[e5 + 1]);
          }
          e4 && (t3.length = 0, t3.push("any", ...r4));
          for (let e5 = 1; e5 < t3.length; e5++)
            sl(t3[e5]);
        }
        function al(t3) {
          if (!Array.isArray(t3))
            return false;
          if ("pitch" === (e4 = t3[0]) || "distance-from-center" === e4)
            return true;
          var e4;
          for (let e5 = 1; e5 < t3.length; e5++)
            if (al(t3[e5]))
              return true;
          return false;
        }
        const ol = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function ll(t3, e4) {
          return t3 < e4 ? -1 : t3 > e4 ? 1 : 0;
        }
        function ul(t3) {
          if (!Array.isArray(t3))
            return false;
          if ("within" === t3[0] || "distance" === t3[0])
            return true;
          for (let e4 = 1; e4 < t3.length; e4++)
            if (ul(t3[e4]))
              return true;
          return false;
        }
        function cl(t3) {
          if (!t3)
            return true;
          const e4 = t3[0];
          return t3.length <= 1 ? "any" !== e4 : "==" === e4 ? hl(t3[1], t3[2], "==") : "!=" === e4 ? dl(hl(t3[1], t3[2], "==")) : "<" === e4 || ">" === e4 || "<=" === e4 || ">=" === e4 ? hl(t3[1], t3[2], e4) : "any" === e4 ? (r4 = t3.slice(1), ["any"].concat(r4.map(cl))) : "all" === e4 ? ["all"].concat(t3.slice(1).map(cl)) : "none" === e4 ? ["all"].concat(t3.slice(1).map(cl).map(dl)) : "in" === e4 ? pl(t3[1], t3.slice(2)) : "!in" === e4 ? dl(pl(t3[1], t3.slice(2))) : "has" === e4 ? fl(t3[1]) : "!has" !== e4 || dl(fl(t3[1]));
          var r4;
        }
        function hl(t3, e4, r4) {
          switch (t3) {
            case "$type":
              return [`filter-type-${r4}`, e4];
            case "$id":
              return [`filter-id-${r4}`, e4];
            default:
              return [`filter-${r4}`, t3, e4];
          }
        }
        function pl(t3, e4) {
          if (0 === e4.length)
            return false;
          switch (t3) {
            case "$type":
              return ["filter-type-in", ["literal", e4]];
            case "$id":
              return ["filter-id-in", ["literal", e4]];
            default:
              return e4.length > 200 && !e4.some((t4) => typeof t4 != typeof e4[0]) ? ["filter-in-large", t3, ["literal", e4.sort(ll)]] : ["filter-in-small", t3, ["literal", e4]];
          }
        }
        function fl(t3) {
          switch (t3) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t3];
          }
        }
        function dl(t3) {
          return ["!", t3];
        }
        const ml = "";
        function yl(t3, e4) {
          return e4 ? `${t3}${ml}${e4}` : t3;
        }
        const gl = "-transition", xl = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
        class bl extends Dn {
          constructor(t3, e4, r4, n3) {
            if (super(), this.id = t3.id, this.fqid = yl(this.id, r4), this.type = t3.type, this.scope = r4, this.options = n3, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.isConfigDependent = false, "custom" !== t3.type && (this.metadata = t3.metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, "background" !== t3.type && "sky" !== t3.type && "slot" !== t3.type && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), t3.slot && (this.slot = t3.slot), e4.layout && (this._unevaluatedLayout = new Qo(e4.layout, this.scope, n3), this.isConfigDependent = this.isConfigDependent || this._unevaluatedLayout.isConfigDependent), e4.paint)) {
              this._transitionablePaint = new qo(e4.paint, this.scope, n3);
              for (const e5 in t3.paint)
                this.setPaintProperty(e5, t3.paint[e5]);
              for (const e5 in t3.layout)
                this.setLayoutProperty(e5, t3.layout[e5]);
              this.isConfigDependent = this.isConfigDependent || this._transitionablePaint.isConfigDependent, this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Xo(e4.paint);
            }
          }
          onAdd(t3) {
          }
          onRemove(t3) {
          }
          isDraped(t3) {
            return xl.has(this.type);
          }
          getLayoutProperty(t3) {
            return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
          }
          setLayoutProperty(t3, e4) {
            if ("custom" === this.type && "visibility" === t3)
              return void (this.visibility = e4);
            const r4 = this._unevaluatedLayout;
            r4._properties.properties[t3] && (r4.setValue(t3, e4), this.isConfigDependent = this.isConfigDependent || r4.isConfigDependent, "visibility" === t3 && this.possiblyEvaluateVisibility());
          }
          possiblyEvaluateVisibility() {
            this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 });
          }
          getPaintProperty(t3) {
            return ar(t3, gl) ? this._transitionablePaint.getTransition(t3.slice(0, -11)) : this._transitionablePaint.getValue(t3);
          }
          setPaintProperty(t3, e4) {
            const r4 = this._transitionablePaint, n3 = r4._properties.properties;
            if (ar(t3, gl)) {
              const i4 = t3.slice(0, -11);
              return n3[i4] && r4.setTransition(i4, e4 || void 0), false;
            }
            if (!n3[t3])
              return false;
            const i3 = r4._values[t3], s4 = i3.value.isDataDriven(), a3 = i3.value;
            r4.setValue(t3, e4), this.isConfigDependent = this.isConfigDependent || r4.isConfigDependent, this._handleSpecialPaintPropertyUpdate(t3);
            const o3 = r4._values[t3].value, l3 = o3.isDataDriven(), u3 = ar(t3, "pattern") || "line-dasharray" === t3;
            return l3 || s4 || u3 || this._handleOverridablePaintPropertyUpdate(t3, a3, o3);
          }
          _handleSpecialPaintPropertyUpdate(t3) {
          }
          getProgramIds() {
            return null;
          }
          getDefaultProgramParams(t3, e4) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(t3, e4, r4) {
            return false;
          }
          isHidden(t3) {
            return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t3) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t3, e4) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e4)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e4);
          }
          serialize() {
            return lr({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t3, e4) => !(void 0 === t3 || "layout" === e4 && !Object.keys(t3).length || "paint" === e4 && !Object.keys(t3).length));
          }
          is3D() {
            return false;
          }
          isSky() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          hasShadowPass() {
            return false;
          }
          canCastShadows() {
            return false;
          }
          hasLightBeamPass() {
            return false;
          }
          cutoffRange() {
            return 0;
          }
          tileCoverLift() {
            return 0;
          }
          resize() {
          }
          isStateDependent() {
            for (const t3 in this.paint._values) {
              const e4 = this.paint.get(t3);
              if (e4 instanceof Yo && ja(e4.property.specification) && ("source" === e4.value.kind || "composite" === e4.value.kind) && e4.value.isStateDependent)
                return true;
            }
            return false;
          }
          compileFilter() {
            this._filterCompiled || (this._featureFilter = nl(this.filter), this._filterCompiled = true);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = false;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
          getLayerRenderingStats() {
            return this._stats;
          }
          resetLayerRenderingStats(t3) {
            this._stats && ("shadow" === t3.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
          }
          queryRadius(t3) {
          }
          queryIntersectsFeature(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          }
          queryIntersectsMatchingFeature(t3, e4, r4, n3) {
          }
        }
        const vl = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class _l {
          constructor(t3, e4) {
            this._structArray = t3, this._pos1 = e4 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class wl {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t3, e4) {
            return t3._trim(), e4 && (t3.isTransferred = true, e4.add(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
          }
          static deserialize(t3) {
            const e4 = Object.create(this.prototype);
            return e4.arrayBuffer = t3.arrayBuffer, e4.length = t3.length, e4.capacity = t3.arrayBuffer.byteLength / e4.bytesPerElement, e4._refreshViews(), e4;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t3) {
            this.reserve(t3), this.length = t3;
          }
          reserve(t3) {
            if (t3 > this.capacity) {
              this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e4 = this.uint8;
              this._refreshViews(), e4 && this.uint8.set(e4);
            }
          }
          _refreshViews() {
            throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
          }
          emplace(...t3) {
            throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
          }
          emplaceBack(...t3) {
            throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function Ml(t3, e4 = 1) {
          let r4 = 0, n3 = 0;
          return { members: t3.map((t4) => {
            const i3 = vl[t4.type].BYTES_PER_ELEMENT, s4 = r4 = Al(r4, Math.max(e4, i3)), a3 = t4.components || 1;
            return n3 = Math.max(n3, i3), r4 += i3 * a3, { name: t4.name, type: t4.type, components: a3, offset: s4 };
          }), size: Al(r4, Math.max(n3, e4)), alignment: e4 };
        }
        function Al(t3, e4) {
          return Math.ceil(t3 / e4) * e4;
        }
        class Sl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4) {
            const r4 = this.length;
            return this.resize(r4 + 1), this.emplace(r4, t3, e4);
          }
          emplace(t3, e4, r4) {
            const n3 = 2 * t3;
            return this.int16[n3 + 0] = e4, this.int16[n3 + 1] = r4, t3;
          }
        }
        Sl.prototype.bytesPerElement = 4, fo(Sl, "StructArrayLayout2i4");
        class Il extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r4);
          }
          emplace(t3, e4, r4, n3) {
            const i3 = 3 * t3;
            return this.int16[i3 + 0] = e4, this.int16[i3 + 1] = r4, this.int16[i3 + 2] = n3, t3;
          }
        }
        Il.prototype.bytesPerElement = 6, fo(Il, "StructArrayLayout3i6");
        class kl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e4, r4, n3);
          }
          emplace(t3, e4, r4, n3, i3) {
            const s4 = 4 * t3;
            return this.int16[s4 + 0] = e4, this.int16[s4 + 1] = r4, this.int16[s4 + 2] = n3, this.int16[s4 + 3] = i3, t3;
          }
        }
        kl.prototype.bytesPerElement = 8, fo(kl, "StructArrayLayout4i8");
        class Pl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t3, e4, r4, n3, i3);
          }
          emplace(t3, e4, r4, n3, i3, s4) {
            const a3 = 5 * t3;
            return this.int16[a3 + 0] = e4, this.int16[a3 + 1] = r4, this.int16[a3 + 2] = n3, this.int16[a3 + 3] = i3, this.int16[a3 + 4] = s4, t3;
          }
        }
        Pl.prototype.bytesPerElement = 10, fo(Pl, "StructArrayLayout5i10");
        class El extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t3, e4, r4, n3, i3, s4, a3);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = 6 * t3, u3 = 12 * t3, c3 = 3 * t3;
            return this.int16[l3 + 0] = e4, this.int16[l3 + 1] = r4, this.uint8[u3 + 4] = n3, this.uint8[u3 + 5] = i3, this.uint8[u3 + 6] = s4, this.uint8[u3 + 7] = a3, this.float32[c3 + 2] = o3, t3;
          }
        }
        El.prototype.bytesPerElement = 12, fo(El, "StructArrayLayout2i4ub1f12");
        class zl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e4, r4, n3);
          }
          emplace(t3, e4, r4, n3, i3) {
            const s4 = 4 * t3;
            return this.float32[s4 + 0] = e4, this.float32[s4 + 1] = r4, this.float32[s4 + 2] = n3, this.float32[s4 + 3] = i3, t3;
          }
        }
        zl.prototype.bytesPerElement = 16, fo(zl, "StructArrayLayout4f16");
        class Tl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4) {
            const r4 = this.length;
            return this.resize(r4 + 1), this.emplace(r4, t3, e4);
          }
          emplace(t3, e4, r4) {
            const n3 = 2 * t3;
            return this.float32[n3 + 0] = e4, this.float32[n3 + 1] = r4, t3;
          }
        }
        Tl.prototype.bytesPerElement = 8, fo(Tl, "StructArrayLayout2f8");
        class Bl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t3, e4, r4, n3, i3);
          }
          emplace(t3, e4, r4, n3, i3, s4) {
            const a3 = 6 * t3, o3 = 3 * t3;
            return this.uint16[a3 + 0] = e4, this.uint16[a3 + 1] = r4, this.uint16[a3 + 2] = n3, this.uint16[a3 + 3] = i3, this.float32[o3 + 2] = s4, t3;
          }
        }
        Bl.prototype.bytesPerElement = 12, fo(Bl, "StructArrayLayout4ui1f12");
        class Cl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e4, r4, n3);
          }
          emplace(t3, e4, r4, n3, i3) {
            const s4 = 4 * t3;
            return this.uint16[s4 + 0] = e4, this.uint16[s4 + 1] = r4, this.uint16[s4 + 2] = n3, this.uint16[s4 + 3] = i3, t3;
          }
        }
        Cl.prototype.bytesPerElement = 8, fo(Cl, "StructArrayLayout4ui8");
        class Rl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e4, r4, n3, i3, s4);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = 6 * t3;
            return this.int16[o3 + 0] = e4, this.int16[o3 + 1] = r4, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i3, this.int16[o3 + 4] = s4, this.int16[o3 + 5] = a3, t3;
          }
        }
        Rl.prototype.bytesPerElement = 12, fo(Rl, "StructArrayLayout6i12");
        class Vl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2) {
            const p3 = this.length;
            return this.resize(p3 + 1), this.emplace(p3, t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3) {
            const f2 = 12 * t3;
            return this.int16[f2 + 0] = e4, this.int16[f2 + 1] = r4, this.int16[f2 + 2] = n3, this.int16[f2 + 3] = i3, this.uint16[f2 + 4] = s4, this.uint16[f2 + 5] = a3, this.uint16[f2 + 6] = o3, this.uint16[f2 + 7] = l3, this.int16[f2 + 8] = u3, this.int16[f2 + 9] = c3, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p3, t3;
          }
        }
        Vl.prototype.bytesPerElement = 24, fo(Vl, "StructArrayLayout4i4ui4i24");
        class Dl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e4, r4, n3, i3, s4);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = 10 * t3, l3 = 5 * t3;
            return this.int16[o3 + 0] = e4, this.int16[o3 + 1] = r4, this.int16[o3 + 2] = n3, this.float32[l3 + 2] = i3, this.float32[l3 + 3] = s4, this.float32[l3 + 4] = a3, t3;
          }
        }
        Dl.prototype.bytesPerElement = 20, fo(Dl, "StructArrayLayout3i3f20");
        class Ll extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.uint32[1 * t3 + 0] = e4, t3;
          }
        }
        Ll.prototype.bytesPerElement = 4, fo(Ll, "StructArrayLayout1ul4");
        class Fl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4) {
            const r4 = this.length;
            return this.resize(r4 + 1), this.emplace(r4, t3, e4);
          }
          emplace(t3, e4, r4) {
            const n3 = 2 * t3;
            return this.uint16[n3 + 0] = e4, this.uint16[n3 + 1] = r4, t3;
          }
        }
        Fl.prototype.bytesPerElement = 4, fo(Fl, "StructArrayLayout2ui4");
        class Ol extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3) {
            const f2 = this.length;
            return this.resize(f2 + 1), this.emplace(f2, t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2) {
            const d2 = 20 * t3, m2 = 10 * t3;
            return this.int16[d2 + 0] = e4, this.int16[d2 + 1] = r4, this.int16[d2 + 2] = n3, this.int16[d2 + 3] = i3, this.int16[d2 + 4] = s4, this.float32[m2 + 3] = a3, this.float32[m2 + 4] = o3, this.float32[m2 + 5] = l3, this.float32[m2 + 6] = u3, this.int16[d2 + 14] = c3, this.uint32[m2 + 8] = h2, this.uint16[d2 + 18] = p3, this.uint16[d2 + 19] = f2, t3;
          }
        }
        Ol.prototype.bytesPerElement = 40, fo(Ol, "StructArrayLayout5i4f1i1ul2ui40");
        class Ul extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t3, e4, r4, n3, i3, s4, a3);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = 8 * t3;
            return this.int16[l3 + 0] = e4, this.int16[l3 + 1] = r4, this.int16[l3 + 2] = n3, this.int16[l3 + 4] = i3, this.int16[l3 + 5] = s4, this.int16[l3 + 6] = a3, this.int16[l3 + 7] = o3, t3;
          }
        }
        Ul.prototype.bytesPerElement = 16, fo(Ul, "StructArrayLayout3i2i2i16");
        class Nl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t3, e4, r4, n3, i3);
          }
          emplace(t3, e4, r4, n3, i3, s4) {
            const a3 = 4 * t3, o3 = 8 * t3;
            return this.float32[a3 + 0] = e4, this.float32[a3 + 1] = r4, this.float32[a3 + 2] = n3, this.int16[o3 + 6] = i3, this.int16[o3 + 7] = s4, t3;
          }
        }
        Nl.prototype.bytesPerElement = 16, fo(Nl, "StructArrayLayout2f1f2i16");
        class jl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e4, r4, n3);
          }
          emplace(t3, e4, r4, n3, i3) {
            const s4 = 12 * t3, a3 = 3 * t3;
            return this.uint8[s4 + 0] = e4, this.uint8[s4 + 1] = r4, this.float32[a3 + 1] = n3, this.float32[a3 + 2] = i3, t3;
          }
        }
        jl.prototype.bytesPerElement = 12, fo(jl, "StructArrayLayout2ub2f12");
        class ql extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r4);
          }
          emplace(t3, e4, r4, n3) {
            const i3 = 3 * t3;
            return this.uint16[i3 + 0] = e4, this.uint16[i3 + 1] = r4, this.uint16[i3 + 2] = n3, t3;
          }
        }
        ql.prototype.bytesPerElement = 6, fo(ql, "StructArrayLayout3ui6");
        class $l extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3, x3, b2, v3) {
            const _3 = this.length;
            return this.resize(_3 + 1), this.emplace(_3, t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3, x3, b2, v3);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3, x3, b2, v3, _3) {
            const w2 = 30 * t3, M3 = 15 * t3, A2 = 60 * t3;
            return this.int16[w2 + 0] = e4, this.int16[w2 + 1] = r4, this.int16[w2 + 2] = n3, this.float32[M3 + 2] = i3, this.float32[M3 + 3] = s4, this.uint16[w2 + 8] = a3, this.uint16[w2 + 9] = o3, this.uint32[M3 + 5] = l3, this.uint32[M3 + 6] = u3, this.uint32[M3 + 7] = c3, this.uint16[w2 + 16] = h2, this.uint16[w2 + 17] = p3, this.uint16[w2 + 18] = f2, this.float32[M3 + 10] = d2, this.float32[M3 + 11] = m2, this.uint8[A2 + 48] = y3, this.uint8[A2 + 49] = g3, this.uint8[A2 + 50] = x3, this.uint32[M3 + 13] = b2, this.int16[w2 + 28] = v3, this.uint8[A2 + 58] = _3, t3;
          }
        }
        $l.prototype.bytesPerElement = 60, fo($l, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Gl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3, x3, b2, v3, _3, w2, M3, A2, S2, I2, k2, P2, E2, z3, T2) {
            const B2 = this.length;
            return this.resize(B2 + 1), this.emplace(B2, t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3, x3, b2, v3, _3, w2, M3, A2, S2, I2, k2, P2, E2, z3, T2);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3, x3, b2, v3, _3, w2, M3, A2, S2, I2, k2, P2, E2, z3, T2, B2) {
            const C2 = 20 * t3, R3 = 40 * t3, V2 = 80 * t3;
            return this.float32[C2 + 0] = e4, this.float32[C2 + 1] = r4, this.int16[R3 + 4] = n3, this.int16[R3 + 5] = i3, this.int16[R3 + 6] = s4, this.int16[R3 + 7] = a3, this.int16[R3 + 8] = o3, this.int16[R3 + 9] = l3, this.int16[R3 + 10] = u3, this.int16[R3 + 11] = c3, this.int16[R3 + 12] = h2, this.uint16[R3 + 13] = p3, this.uint16[R3 + 14] = f2, this.uint16[R3 + 15] = d2, this.uint16[R3 + 16] = m2, this.uint16[R3 + 17] = y3, this.uint16[R3 + 18] = g3, this.uint16[R3 + 19] = x3, this.uint16[R3 + 20] = b2, this.uint16[R3 + 21] = v3, this.uint16[R3 + 22] = _3, this.uint16[R3 + 23] = w2, this.uint16[R3 + 24] = M3, this.uint16[R3 + 25] = A2, this.uint16[R3 + 26] = S2, this.uint16[R3 + 27] = I2, this.uint32[C2 + 14] = k2, this.float32[C2 + 15] = P2, this.float32[C2 + 16] = E2, this.float32[C2 + 17] = z3, this.float32[C2 + 18] = T2, this.uint8[V2 + 76] = B2, t3;
          }
        }
        Gl.prototype.bytesPerElement = 80, fo(Gl, "StructArrayLayout2f9i15ui1ul4f1ub80");
        class Ql extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.float32[1 * t3 + 0] = e4, t3;
          }
        }
        Ql.prototype.bytesPerElement = 4, fo(Ql, "StructArrayLayout1f4");
        class Yl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t3, e4, r4, n3, i3);
          }
          emplace(t3, e4, r4, n3, i3, s4) {
            const a3 = 5 * t3;
            return this.float32[a3 + 0] = e4, this.float32[a3 + 1] = r4, this.float32[a3 + 2] = n3, this.float32[a3 + 3] = i3, this.float32[a3 + 4] = s4, t3;
          }
        }
        Yl.prototype.bytesPerElement = 20, fo(Yl, "StructArrayLayout5f20");
        class Xl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t3, e4, r4, n3, i3, s4, a3);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = 7 * t3;
            return this.float32[l3 + 0] = e4, this.float32[l3 + 1] = r4, this.float32[l3 + 2] = n3, this.float32[l3 + 3] = i3, this.float32[l3 + 4] = s4, this.float32[l3 + 5] = a3, this.float32[l3 + 6] = o3, t3;
          }
        }
        Xl.prototype.bytesPerElement = 28, fo(Xl, "StructArrayLayout7f28");
        class Zl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e4, r4, n3);
          }
          emplace(t3, e4, r4, n3, i3) {
            const s4 = 6 * t3;
            return this.uint32[3 * t3 + 0] = e4, this.uint16[s4 + 2] = r4, this.uint16[s4 + 3] = n3, this.uint16[s4 + 4] = i3, t3;
          }
        }
        Zl.prototype.bytesPerElement = 12, fo(Zl, "StructArrayLayout1ul3ui12");
        class Kl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.uint16[1 * t3 + 0] = e4, t3;
          }
        }
        Kl.prototype.bytesPerElement = 2, fo(Kl, "StructArrayLayout1ui2");
        class Wl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r4);
          }
          emplace(t3, e4, r4, n3) {
            const i3 = 3 * t3;
            return this.float32[i3 + 0] = e4, this.float32[i3 + 1] = r4, this.float32[i3 + 2] = n3, t3;
          }
        }
        Wl.prototype.bytesPerElement = 12, fo(Wl, "StructArrayLayout3f12");
        class Hl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2) {
            const y3 = this.length;
            return this.resize(y3 + 1), this.emplace(y3, t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3) {
            const g3 = 16 * t3;
            return this.float32[g3 + 0] = e4, this.float32[g3 + 1] = r4, this.float32[g3 + 2] = n3, this.float32[g3 + 3] = i3, this.float32[g3 + 4] = s4, this.float32[g3 + 5] = a3, this.float32[g3 + 6] = o3, this.float32[g3 + 7] = l3, this.float32[g3 + 8] = u3, this.float32[g3 + 9] = c3, this.float32[g3 + 10] = h2, this.float32[g3 + 11] = p3, this.float32[g3 + 12] = f2, this.float32[g3 + 13] = d2, this.float32[g3 + 14] = m2, this.float32[g3 + 15] = y3, t3;
          }
        }
        Hl.prototype.bytesPerElement = 64, fo(Hl, "StructArrayLayout16f64");
        class Jl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t3, e4, r4, n3, i3, s4, a3);
          }
          emplace(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = 10 * t3, u3 = 5 * t3;
            return this.uint16[l3 + 0] = e4, this.uint16[l3 + 1] = r4, this.uint16[l3 + 2] = n3, this.uint16[l3 + 3] = i3, this.float32[u3 + 2] = s4, this.float32[u3 + 3] = a3, this.float32[u3 + 4] = o3, t3;
          }
        }
        Jl.prototype.bytesPerElement = 20, fo(Jl, "StructArrayLayout4ui3f20");
        class tu extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.int16[1 * t3 + 0] = e4, t3;
          }
        }
        tu.prototype.bytesPerElement = 2, fo(tu, "StructArrayLayout1i2");
        class eu extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.uint8[1 * t3 + 0] = e4, t3;
          }
        }
        eu.prototype.bytesPerElement = 1, fo(eu, "StructArrayLayout1ub1");
        class ru extends _l {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        ru.prototype.size = 40;
        class nu extends Ol {
          get(t3) {
            return new ru(this, t3);
          }
        }
        fo(nu, "CollisionBoxArray");
        class iu extends _l {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(t3) {
            this._structArray.uint8[this._pos1 + 49] = t3;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(t3) {
            this._structArray.uint8[this._pos1 + 50] = t3;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 13] = t3;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(t3) {
            this._structArray.uint8[this._pos1 + 58] = t3;
          }
        }
        iu.prototype.size = 60;
        class su extends $l {
          get(t3) {
            return new iu(this, t3);
          }
        }
        fo(su, "PlacedSymbolArray");
        class au extends _l {
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 0];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 14];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 14] = t3;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 15];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get zOffset() {
            return this._structArray.float32[this._pos4 + 18];
          }
          set zOffset(t3) {
            this._structArray.float32[this._pos4 + 18] = t3;
          }
          get hasIconTextFit() {
            return this._structArray.uint8[this._pos1 + 76];
          }
        }
        au.prototype.size = 80;
        class ou extends Gl {
          get(t3) {
            return new au(this, t3);
          }
        }
        fo(ou, "SymbolInstanceArray");
        class lu extends Ql {
          getoffsetX(t3) {
            return this.float32[1 * t3 + 0];
          }
        }
        fo(lu, "GlyphOffsetArray");
        class uu extends Sl {
          getx(t3) {
            return this.int16[2 * t3 + 0];
          }
          gety(t3) {
            return this.int16[2 * t3 + 1];
          }
        }
        fo(uu, "SymbolLineVertexArray");
        class cu extends _l {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        cu.prototype.size = 12;
        class hu extends Zl {
          get(t3) {
            return new cu(this, t3);
          }
        }
        fo(hu, "FeatureIndexArray");
        class pu extends Fl {
          geta_centroid_pos0(t3) {
            return this.uint16[2 * t3 + 0];
          }
          geta_centroid_pos1(t3) {
            return this.uint16[2 * t3 + 1];
          }
        }
        fo(pu, "FillExtrusionCentroidArray");
        const fu = Ml([{ name: "a_pos", components: 2, type: "Int16" }], 4), du = Ml([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class mu {
          constructor(t3 = []) {
            this.segments = t3;
          }
          _prepareSegment(t3, e4, r4, n3) {
            let i3 = this.segments[this.segments.length - 1];
            return t3 > mu.MAX_VERTEX_ARRAY_LENGTH && hr(`Max vertices per segment is ${mu.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i3 || i3.vertexLength + t3 > mu.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n3) && (i3 = { vertexOffset: e4, primitiveOffset: r4, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i3.sortKey = n3), this.segments.push(i3)), i3;
          }
          prepareSegment(t3, e4, r4, n3) {
            return this._prepareSegment(t3, e4.length, r4.length, n3);
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t3 of this.segments)
              for (const e4 in t3.vaos)
                t3.vaos[e4].destroy();
          }
          static simpleSegment(t3, e4, r4, n3) {
            return new mu([{ vertexOffset: t3, primitiveOffset: e4, vertexLength: r4, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
          }
        }
        function yu(t3, e4) {
          return 256 * (t3 = Ze(Math.floor(t3), 0, 255)) + Ze(Math.floor(e4), 0, 255);
        }
        mu.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, fo(mu, "SegmentVector");
        const gu = Ml([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), xu = Ml([{ name: "a_dash", components: 4, type: "Uint16" }]);
        class bu {
          constructor() {
            this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
          }
          add(t3, e4, r4, n3) {
            this.ids.push(vu(t3)), this.positions.push(e4, r4, n3);
          }
          eachPosition(t3, e4) {
            const r4 = vu(t3);
            let n3 = 0, i3 = this.ids.length - 1;
            for (; n3 < i3; ) {
              const t4 = n3 + i3 >> 1;
              this.ids[t4] >= r4 ? i3 = t4 : n3 = t4 + 1;
            }
            for (; this.ids[n3] === r4; )
              e4(this.positions[3 * n3], this.positions[3 * n3 + 1], this.positions[3 * n3 + 2]), n3++;
          }
          static serialize(t3, e4) {
            const r4 = new Float64Array(t3.ids), n3 = new Uint32Array(t3.positions);
            return _u(r4, n3, 0, r4.length - 1), e4 && (e4.add(r4.buffer), e4.add(n3.buffer)), { ids: r4, positions: n3 };
          }
          static deserialize(t3) {
            const e4 = new bu();
            let r4;
            e4.ids = t3.ids, e4.positions = t3.positions;
            for (const t4 of e4.ids)
              t4 !== r4 && e4.uniqueIds.push(t4), r4 = t4;
            return e4.indexed = true, e4;
          }
        }
        function vu(t3) {
          const e4 = +t3;
          return !isNaN(e4) && Number.MIN_SAFE_INTEGER <= e4 && e4 <= Number.MAX_SAFE_INTEGER ? e4 : Tn(String(t3));
        }
        function _u(t3, e4, r4, n3) {
          for (; r4 < n3; ) {
            const i3 = t3[r4 + n3 >> 1];
            let s4 = r4 - 1, a3 = n3 + 1;
            for (; ; ) {
              do {
                s4++;
              } while (t3[s4] < i3);
              do {
                a3--;
              } while (t3[a3] > i3);
              if (s4 >= a3)
                break;
              wu(t3, s4, a3), wu(e4, 3 * s4, 3 * a3), wu(e4, 3 * s4 + 1, 3 * a3 + 1), wu(e4, 3 * s4 + 2, 3 * a3 + 2);
            }
            a3 - r4 < n3 - a3 ? (_u(t3, e4, r4, a3), r4 = a3 + 1) : (_u(t3, e4, a3 + 1, n3), n3 = a3);
          }
        }
        function wu(t3, e4, r4) {
          const n3 = t3[e4];
          t3[e4] = t3[r4], t3[r4] = n3;
        }
        fo(bu, "FeaturePositionMap");
        class Mu {
          constructor(t3) {
            this.gl = t3.gl, this.initialized = false;
          }
          fetchUniformLocation(t3, e4) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t3, e4), this.initialized = true), !!this.location;
          }
          set(t3, e4, r4) {
            throw new Error("Uniform#set() must be implemented by each concrete Uniform");
          }
        }
        class Au extends Mu {
          constructor(t3) {
            super(t3), this.current = 0;
          }
          set(t3, e4, r4) {
            this.fetchUniformLocation(t3, e4) && this.current !== r4 && (this.current = r4, this.gl.uniform1i(this.location, r4));
          }
        }
        class Su extends Mu {
          constructor(t3) {
            super(t3), this.current = 0;
          }
          set(t3, e4, r4) {
            this.fetchUniformLocation(t3, e4) && this.current !== r4 && (this.current = r4, this.gl.uniform1f(this.location, r4));
          }
        }
        class Iu extends Mu {
          constructor(t3) {
            super(t3), this.current = [0, 0];
          }
          set(t3, e4, r4) {
            this.fetchUniformLocation(t3, e4) && (r4[0] === this.current[0] && r4[1] === this.current[1] || (this.current = r4, this.gl.uniform2f(this.location, r4[0], r4[1])));
          }
        }
        class ku extends Mu {
          constructor(t3) {
            super(t3), this.current = [0, 0, 0];
          }
          set(t3, e4, r4) {
            this.fetchUniformLocation(t3, e4) && (r4[0] === this.current[0] && r4[1] === this.current[1] && r4[2] === this.current[2] || (this.current = r4, this.gl.uniform3f(this.location, r4[0], r4[1], r4[2])));
          }
        }
        class Pu extends Mu {
          constructor(t3) {
            super(t3), this.current = [0, 0, 0, 0];
          }
          set(t3, e4, r4) {
            this.fetchUniformLocation(t3, e4) && (r4[0] === this.current[0] && r4[1] === this.current[1] && r4[2] === this.current[2] && r4[3] === this.current[3] || (this.current = r4, this.gl.uniform4f(this.location, r4[0], r4[1], r4[2], r4[3])));
          }
        }
        class Eu extends Mu {
          constructor(t3) {
            super(t3), this.current = jn.transparent;
          }
          set(t3, e4, r4) {
            this.fetchUniformLocation(t3, e4) && (r4.r === this.current.r && r4.g === this.current.g && r4.b === this.current.b && r4.a === this.current.a || (this.current = r4, this.gl.uniform4f(this.location, r4.r, r4.g, r4.b, r4.a)));
          }
        }
        const zu = new Float32Array(16);
        class Tu extends Mu {
          constructor(t3) {
            super(t3), this.current = zu;
          }
          set(t3, e4, r4) {
            if (this.fetchUniformLocation(t3, e4)) {
              if (r4[12] !== this.current[12] || r4[0] !== this.current[0])
                return this.current = r4, void this.gl.uniformMatrix4fv(this.location, false, r4);
              for (let t4 = 1; t4 < 16; t4++)
                if (r4[t4] !== this.current[t4]) {
                  this.current = r4, this.gl.uniformMatrix4fv(this.location, false, r4);
                  break;
                }
            }
          }
        }
        const Bu = new Float32Array(9), Cu = new Float32Array(4);
        class Ru extends Mu {
          constructor(t3) {
            super(t3), this.current = Cu;
          }
          set(t3, e4, r4) {
            if (this.fetchUniformLocation(t3, e4)) {
              for (let t4 = 0; t4 < 4; t4++)
                if (r4[t4] !== this.current[t4]) {
                  this.current = r4, this.gl.uniformMatrix2fv(this.location, false, r4);
                  break;
                }
            }
          }
        }
        function Vu(t3) {
          return [yu(255 * t3.r, 255 * t3.g), yu(255 * t3.b, 255 * t3.a)];
        }
        class Du {
          constructor(t3, e4, r4) {
            this.value = t3, this.uniformNames = e4.map((t4) => `u_${t4}`), this.type = r4;
          }
          setUniform(t3, e4, r4, n3, i3) {
            e4.set(t3, i3, n3.constantOr(this.value));
          }
          getBinding(t3, e4) {
            return "color" === this.type ? new Eu(t3) : new Su(t3);
          }
        }
        class Lu {
          constructor(t3, e4) {
            this.uniformNames = e4.map((t4) => `u_${t4}`), this.pattern = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(t3) {
            this.pixelRatio = t3.pixelRatio || 1, this.pattern = t3.tl.concat(t3.br);
          }
          setUniform(t3, e4, r4, n3, i3) {
            const s4 = "u_pattern" === i3 || "u_dash" === i3 ? this.pattern : "u_pixel_ratio" === i3 ? this.pixelRatio : null;
            s4 && e4.set(t3, i3, s4);
          }
          getBinding(t3, e4) {
            return "u_pattern" === e4 || "u_dash" === e4 ? new Pu(t3) : new Su(t3);
          }
        }
        class Fu {
          constructor(t3, e4, r4, n3) {
            this.expression = t3, this.type = r4, this.maxValue = 0, this.paintVertexAttributes = e4.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r4 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
          }
          populatePaintArray(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.paintVertexArray.length, l3 = this.expression.evaluate(new Uo(0, { brightness: s4 }), e4, {}, i3, n3, a3);
            this.paintVertexArray.resize(t3), this._setPaintValue(o3, t3, l3);
          }
          updatePaintArray(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.expression.evaluate({ zoom: 0, brightness: a3 }, r4, n3, void 0, i3);
            this._setPaintValue(t3, e4, o3);
          }
          _setPaintValue(t3, e4, r4) {
            if ("color" === this.type) {
              const n3 = Vu(r4);
              for (let r5 = t3; r5 < e4; r5++)
                this.paintVertexArray.emplace(r5, n3[0], n3[1]);
            } else {
              for (let n3 = t3; n3 < e4; n3++)
                this.paintVertexArray.emplace(n3, r4);
              this.maxValue = Math.max(this.maxValue, Math.abs(r4));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Ou {
          constructor(t3, e4, r4, n3, i3, s4) {
            this.expression = t3, this.uniformNames = e4.map((t4) => `u_${t4}_t`), this.type = r4, this.useIntegerZoom = n3, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e4.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r4 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s4();
          }
          populatePaintArray(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.expression.evaluate(new Uo(this.zoom, { brightness: s4 }), e4, {}, i3, n3, a3), l3 = this.expression.evaluate(new Uo(this.zoom + 1, { brightness: s4 }), e4, {}, i3, n3, a3), u3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t3), this._setPaintValue(u3, t3, o3, l3);
          }
          updatePaintArray(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.expression.evaluate({ zoom: this.zoom, brightness: a3 }, r4, n3, void 0, i3), l3 = this.expression.evaluate({ zoom: this.zoom + 1, brightness: a3 }, r4, n3, void 0, i3);
            this._setPaintValue(t3, e4, o3, l3);
          }
          _setPaintValue(t3, e4, r4, n3) {
            if ("color" === this.type) {
              const i3 = Vu(r4), s4 = Vu(n3);
              for (let r5 = t3; r5 < e4; r5++)
                this.paintVertexArray.emplace(r5, i3[0], i3[1], s4[0], s4[1]);
            } else {
              for (let i3 = t3; i3 < e4; i3++)
                this.paintVertexArray.emplace(i3, r4, n3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r4), Math.abs(n3));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t3, e4, r4, n3, i3) {
            const s4 = this.useIntegerZoom ? Math.floor(r4.zoom) : r4.zoom, a3 = Ze(this.expression.interpolationFactor(s4, this.zoom, this.zoom + 1), 0, 1);
            e4.set(t3, i3, a3);
          }
          getBinding(t3, e4) {
            return new Su(t3);
          }
        }
        class Uu {
          constructor(t3, e4, r4, n3, i3) {
            this.expression = t3, this.layerId = i3, this.paintVertexAttributes = ("array" === r4 ? xu : gu).members;
            for (let t4 = 0; t4 < e4.length; ++t4)
              ;
            this.paintVertexArray = new n3();
          }
          populatePaintArray(t3, e4, r4) {
            const n3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t3), this._setPaintValues(n3, t3, e4.patterns && e4.patterns[this.layerId], r4);
          }
          updatePaintArray(t3, e4, r4, n3, i3, s4, a3) {
            this._setPaintValues(t3, e4, r4.patterns && r4.patterns[this.layerId], s4);
          }
          _setPaintValues(t3, e4, r4, n3) {
            if (!n3 || !r4)
              return;
            const i3 = n3[r4];
            if (!i3)
              return;
            const { tl: s4, br: a3, pixelRatio: o3 } = i3;
            for (let r5 = t3; r5 < e4; r5++)
              this.paintVertexArray.emplace(r5, s4[0], s4[1], a3[0], a3[1], o3);
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Nu {
          constructor(t3, e4, r4 = () => true) {
            this.binders = {}, this._buffers = [];
            const n3 = [];
            for (const i3 in t3.paint._values) {
              const s4 = t3.paint.get(i3);
              if (!r4(i3))
                continue;
              if (!(s4 instanceof Yo && ja(s4.property.specification)))
                continue;
              const a3 = $u(i3, t3.type), o3 = s4.value, l3 = s4.property.specification.type, u3 = !!s4.property.useIntegerZoom, c3 = "line-dasharray" === i3 || i3.endsWith("pattern"), h2 = "line-dasharray" === i3 && "constant" !== t3.layout.get("line-cap").value.kind;
              if ("constant" !== o3.kind || h2)
                if ("source" === o3.kind || h2 || c3) {
                  const e5 = Yu(i3, l3, "source");
                  this.binders[i3] = c3 ? new Uu(o3, a3, l3, e5, t3.id) : new Fu(o3, a3, l3, e5), n3.push(`/a_${i3}`);
                } else {
                  const t4 = Yu(i3, l3, "composite");
                  this.binders[i3] = new Ou(o3, a3, l3, u3, e4, t4), n3.push(`/z_${i3}`);
                }
              else
                this.binders[i3] = c3 ? new Lu(o3.value, a3) : new Du(o3.value, a3, l3), n3.push(`/u_${i3}`);
            }
            this.cacheKey = n3.sort().join("");
          }
          getMaxValue(t3) {
            const e4 = this.binders[t3];
            return e4 instanceof Fu || e4 instanceof Ou ? e4.maxValue : 0;
          }
          populatePaintArrays(t3, e4, r4, n3, i3, s4, a3) {
            for (const o3 in this.binders) {
              const l3 = this.binders[o3];
              (l3 instanceof Fu || l3 instanceof Ou || l3 instanceof Uu) && l3.populatePaintArray(t3, e4, r4, n3, i3, s4, a3);
            }
          }
          setConstantPatternPositions(t3) {
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              r4 instanceof Lu && r4.setConstantPatternPositions(t3);
            }
          }
          updatePaintArrays(t3, e4, r4, n3, i3, s4, a3, o3) {
            let l3 = false;
            const u3 = Object.keys(t3), c3 = 0 !== u3.length, h2 = c3 ? u3 : e4.uniqueIds;
            for (const u4 in this.binders) {
              const p3 = this.binders[u4];
              if ((p3 instanceof Fu || p3 instanceof Ou || p3 instanceof Uu) && (true === p3.expression.isStateDependent || false === p3.expression.isLightConstant)) {
                const f2 = i3.paint.get(u4);
                p3.expression = f2.value;
                for (const r5 of h2) {
                  const i4 = t3[r5.toString()];
                  e4.eachPosition(r5, (t4, e5, r6) => {
                    const l4 = n3.feature(t4);
                    p3.updatePaintArray(e5, r6, l4, i4, s4, a3, o3);
                  });
                }
                if (!c3)
                  for (const e5 of r4.uniqueIds) {
                    const i4 = t3[e5.toString()];
                    r4.eachPosition(e5, (t4, e6, r5) => {
                      const l4 = n3.feature(t4);
                      p3.updatePaintArray(e6, r5, l4, i4, s4, a3, o3);
                    });
                  }
                l3 = true;
              }
            }
            return l3;
          }
          defines() {
            const t3 = [];
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              (r4 instanceof Du || r4 instanceof Lu) && t3.push(...r4.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
            }
            return t3;
          }
          getBinderAttributes() {
            const t3 = [];
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              if (r4 instanceof Fu || r4 instanceof Ou || r4 instanceof Uu)
                for (let e5 = 0; e5 < r4.paintVertexAttributes.length; e5++)
                  t3.push(r4.paintVertexAttributes[e5].name);
            }
            return t3;
          }
          getBinderUniforms() {
            const t3 = [];
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              if (r4 instanceof Du || r4 instanceof Lu || r4 instanceof Ou)
                for (const e5 of r4.uniformNames)
                  t3.push(e5);
            }
            return t3;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t3) {
            const e4 = [];
            for (const r4 in this.binders) {
              const n3 = this.binders[r4];
              if (n3 instanceof Du || n3 instanceof Lu || n3 instanceof Ou)
                for (const i3 of n3.uniformNames)
                  e4.push({ name: i3, property: r4, binding: n3.getBinding(t3, i3) });
            }
            return e4;
          }
          setUniforms(t3, e4, r4, n3, i3) {
            for (const { name: e5, property: s4, binding: a3 } of r4)
              this.binders[s4].setUniform(t3, a3, i3, n3.get(s4), e5);
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const t3 in this.binders) {
              const e4 = this.binders[t3];
              (e4 instanceof Fu || e4 instanceof Ou || e4 instanceof Uu) && e4.paintVertexBuffer && this._buffers.push(e4.paintVertexBuffer);
            }
          }
          upload(t3) {
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              (r4 instanceof Fu || r4 instanceof Ou || r4 instanceof Uu) && r4.upload(t3);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t3 in this.binders) {
              const e4 = this.binders[t3];
              (e4 instanceof Fu || e4 instanceof Ou || e4 instanceof Uu) && e4.destroy();
            }
          }
        }
        class ju {
          constructor(t3, e4, r4 = () => true) {
            this.programConfigurations = {};
            for (const n3 of t3)
              this.programConfigurations[n3.id] = new Nu(n3, e4, r4);
            this.needsUpload = false, this._featureMap = new bu(), this._featureMapWithoutIds = new bu(), this._bufferOffset = 0, this._idlessCounter = 0;
          }
          populatePaintArrays(t3, e4, r4, n3, i3, s4, a3, o3) {
            for (const r5 in this.programConfigurations)
              this.programConfigurations[r5].populatePaintArrays(t3, e4, n3, i3, s4, a3, o3);
            void 0 !== e4.id ? this._featureMap.add(e4.id, r4, this._bufferOffset, t3) : (this._featureMapWithoutIds.add(this._idlessCounter, r4, this._bufferOffset, t3), this._idlessCounter += 1), this._bufferOffset = t3, this.needsUpload = true;
          }
          updatePaintArrays(t3, e4, r4, n3, i3, s4) {
            for (const a3 of r4)
              this.needsUpload = this.programConfigurations[a3.id].updatePaintArrays(t3, this._featureMap, this._featureMapWithoutIds, e4, a3, n3, i3, s4 || 0) || this.needsUpload;
          }
          get(t3) {
            return this.programConfigurations[t3];
          }
          upload(t3) {
            if (this.needsUpload) {
              for (const e4 in this.programConfigurations)
                this.programConfigurations[e4].upload(t3);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t3 in this.programConfigurations)
              this.programConfigurations[t3].destroy();
          }
        }
        const qu = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
        function $u(t3, e4) {
          return qu[t3] || [t3.replace(`${e4}-`, "").replace(/-/g, "_")];
        }
        const Gu = { "line-pattern": { source: Bl, composite: Bl }, "fill-pattern": { source: Bl, composite: Bl }, "fill-extrusion-pattern": { source: Bl, composite: Bl }, "line-dasharray": { source: Cl, composite: Cl } }, Qu = { color: { source: Tl, composite: zl }, number: { source: Ql, composite: Tl } };
        function Yu(t3, e4, r4) {
          const n3 = Gu[t3];
          return n3 && n3[r4] || Qu[e4][r4];
        }
        fo(Du, "ConstantBinder"), fo(Lu, "PatternConstantBinder"), fo(Fu, "SourceExpressionBinder"), fo(Uu, "PatternCompositeBinder"), fo(Ou, "CompositeExpressionBinder"), fo(Nu, "ProgramConfiguration", { omit: ["_buffers"] }), fo(ju, "ProgramConfigurationSet");
        const Xu = is / Math.PI / 2, Zu = 5, Ku = 6, Wu = 16383, Hu = 64, Ju = [Hu, 32, 16], tc = -Xu, ec = Xu;
        function rc(t3, e4, r4, n3 = Xu) {
          return r4 = qe(r4), [t3 * Math.sin(r4) * n3, -e4 * n3, t3 * Math.cos(r4) * n3];
        }
        function nc(t3, e4, r4) {
          return rc(Math.cos(qe(t3)), Math.sin(qe(t3)), e4, r4);
        }
        const ic = 63710088e-1, sc = 2 * Math.PI * ic;
        class ac {
          constructor(t3, e4) {
            if (isNaN(t3) || isNaN(e4))
              throw new Error(`Invalid LngLat object: (${t3}, ${e4})`);
            if (this.lng = +t3, this.lat = +e4, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ac(We(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t3) {
            const e4 = Math.PI / 180, r4 = this.lat * e4, n3 = t3.lat * e4, i3 = Math.sin(r4) * Math.sin(n3) + Math.cos(r4) * Math.cos(n3) * Math.cos((t3.lng - this.lng) * e4);
            return ic * Math.acos(Math.min(i3, 1));
          }
          toBounds(t3 = 0) {
            const e4 = 360 * t3 / 40075017, r4 = e4 / Math.cos(Math.PI / 180 * this.lat);
            return new oc({ lng: this.lng - r4, lat: this.lat - e4 }, { lng: this.lng + r4, lat: this.lat + e4 });
          }
          toEcef(t3) {
            return nc(this.lat, this.lng, Xu + t3 * Xu / ic);
          }
          static convert(t3) {
            if (t3 instanceof ac)
              return t3;
            if (Array.isArray(t3) && (2 === t3.length || 3 === t3.length))
              return new ac(Number(t3[0]), Number(t3[1]));
            if (!Array.isArray(t3) && "object" == typeof t3 && null !== t3)
              return new ac(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        class oc {
          constructor(t3, e4) {
            if (t3)
              if (e4)
                this.setSouthWest(t3).setNorthEast(e4);
              else if (4 === t3.length) {
                const e5 = t3;
                this.setSouthWest([e5[0], e5[1]]).setNorthEast([e5[2], e5[3]]);
              } else {
                const e5 = t3;
                this.setSouthWest(e5[0]).setNorthEast(e5[1]);
              }
          }
          setNorthEast(t3) {
            return this._ne = t3 instanceof ac ? new ac(t3.lng, t3.lat) : ac.convert(t3), this;
          }
          setSouthWest(t3) {
            return this._sw = t3 instanceof ac ? new ac(t3.lng, t3.lat) : ac.convert(t3), this;
          }
          extend(t3) {
            const e4 = this._sw, r4 = this._ne;
            let n3, i3;
            if (t3 instanceof ac)
              n3 = t3, i3 = t3;
            else {
              if (!(t3 instanceof oc))
                return Array.isArray(t3) ? 4 === t3.length || t3.every(Array.isArray) ? this.extend(oc.convert(t3)) : this.extend(ac.convert(t3)) : "object" == typeof t3 && null !== t3 && t3.hasOwnProperty("lat") && (t3.hasOwnProperty("lon") || t3.hasOwnProperty("lng")) ? this.extend(ac.convert(t3)) : this;
              if (n3 = t3._sw, i3 = t3._ne, !n3 || !i3)
                return this;
            }
            return e4 || r4 ? (e4.lng = Math.min(n3.lng, e4.lng), e4.lat = Math.min(n3.lat, e4.lat), r4.lng = Math.max(i3.lng, r4.lng), r4.lat = Math.max(i3.lat, r4.lat)) : (this._sw = new ac(n3.lng, n3.lat), this._ne = new ac(i3.lng, i3.lat)), this;
          }
          getCenter() {
            return new ac((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new ac(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new ac(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t3) {
            const { lng: e4, lat: r4 } = ac.convert(t3);
            let n3 = this._sw.lng <= e4 && e4 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n3 = this._sw.lng >= e4 && e4 >= this._ne.lng), this._sw.lat <= r4 && r4 <= this._ne.lat && n3;
          }
          static convert(t3) {
            return !t3 || t3 instanceof oc ? t3 : new oc(t3);
          }
        }
        var lc = {};
        !function(t3, e4) {
          !function(t4) {
            function e5(t5, e6, n3) {
              var i3 = r4(256 * t5, 256 * (e6 = Math.pow(2, n3) - e6 - 1), n3), s4 = r4(256 * (t5 + 1), 256 * (e6 + 1), n3);
              return i3[0] + "," + i3[1] + "," + s4[0] + "," + s4[1];
            }
            function r4(t5, e6, r5) {
              var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r5);
              return [t5 * n3 - 2 * Math.PI * 6378137 / 2, e6 * n3 - 2 * Math.PI * 6378137 / 2];
            }
            t4.getURL = function(t5, r5, n3, i3, s4, a3) {
              return a3 = a3 || {}, t5 + "?" + ["bbox=" + e5(n3, i3, s4), "format=" + (a3.format || "image/png"), "service=" + (a3.service || "WMS"), "version=" + (a3.version || "1.1.1"), "request=" + (a3.request || "GetMap"), "srs=" + (a3.srs || "EPSG:3857"), "width=" + (a3.width || 256), "height=" + (a3.height || 256), "layers=" + r5].join("&");
            }, t4.getTileBBox = e5, t4.getMercCoords = r4, Object.defineProperty(t4, "__esModule", { value: true });
          }(e4);
        }(0, lc);
        var uc = lc;
        class cc {
          constructor(t3, e4, r4) {
            this.z = t3, this.x = e4, this.y = r4, this.key = fc(0, t3, t3, e4, r4);
          }
          equals(t3) {
            return this.z === t3.z && this.x === t3.x && this.y === t3.y;
          }
          url(t3, e4) {
            const r4 = uc.getTileBBox(this.x, this.y, this.z), n3 = function(t4, e5, r5) {
              let n4, i3 = "";
              for (let s4 = t4; s4 > 0; s4--)
                n4 = 1 << s4 - 1, i3 += (e5 & n4 ? 1 : 0) + (r5 & n4 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t3[(this.x + this.y) % t3.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e4 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n3).replace("{bbox-epsg-3857}", r4);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class hc {
          constructor(t3, e4) {
            this.wrap = t3, this.canonical = e4, this.key = fc(t3, e4.z, e4.z, e4.x, e4.y);
          }
        }
        class pc {
          constructor(t3, e4, r4, n3, i3) {
            this.overscaledZ = t3, this.wrap = e4, this.canonical = new cc(r4, +n3, +i3), this.key = 0 === e4 && t3 === r4 ? this.canonical.key : fc(e4, t3, r4, n3, i3);
          }
          equals(t3) {
            return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
          }
          scaledTo(t3) {
            const e4 = this.canonical.z - t3;
            return t3 > this.canonical.z ? new pc(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new pc(t3, this.wrap, t3, this.canonical.x >> e4, this.canonical.y >> e4);
          }
          calculateScaledKey(t3, e4 = true) {
            if (this.overscaledZ === t3 && e4)
              return this.key;
            if (t3 > this.canonical.z)
              return fc(this.wrap * +e4, t3, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const r4 = this.canonical.z - t3;
              return fc(this.wrap * +e4, t3, t3, this.canonical.x >> r4, this.canonical.y >> r4);
            }
          }
          isChildOf(t3) {
            if (t3.wrap !== this.wrap)
              return false;
            const e4 = this.canonical.z - t3.canonical.z;
            return 0 === t3.overscaledZ || t3.overscaledZ < this.overscaledZ && t3.canonical.z < this.canonical.z && t3.canonical.x === this.canonical.x >> e4 && t3.canonical.y === this.canonical.y >> e4;
          }
          children(t3) {
            if (this.overscaledZ >= t3)
              return [new pc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e4 = this.canonical.z + 1, r4 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
            return [new pc(e4, this.wrap, e4, r4, n3), new pc(e4, this.wrap, e4, r4 + 1, n3), new pc(e4, this.wrap, e4, r4, n3 + 1), new pc(e4, this.wrap, e4, r4 + 1, n3 + 1)];
          }
          isLessThan(t3) {
            return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
          }
          wrapped() {
            return new pc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t3) {
            return new pc(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new hc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function fc(t3, e4, r4, n3, i3) {
          const s4 = 1 << Math.min(r4, 22);
          let a3 = s4 * (i3 % s4) + n3 % s4;
          return t3 && r4 < 22 && (a3 += s4 * s4 * ((t3 < 0 ? -2 * t3 - 1 : 2 * t3) % (1 << 2 * (22 - r4)))), 16 * (32 * a3 + r4) + (e4 - r4);
        }
        const dc = [(t3) => {
          let e4 = t3.canonical.x - 1, r4 = t3.wrap;
          return e4 < 0 && (e4 = (1 << t3.canonical.z) - 1, r4--), new pc(t3.overscaledZ, r4, t3.canonical.z, e4, t3.canonical.y);
        }, (t3) => {
          let e4 = t3.canonical.x + 1, r4 = t3.wrap;
          return e4 === 1 << t3.canonical.z && (e4 = 0, r4++), new pc(t3.overscaledZ, r4, t3.canonical.z, e4, t3.canonical.y);
        }, (t3) => new pc(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, (0 === t3.canonical.y ? 1 << t3.canonical.z : t3.canonical.y) - 1), (t3) => new pc(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y === (1 << t3.canonical.z) - 1 ? 0 : t3.canonical.y + 1)];
        fo(cc, "CanonicalTileID"), fo(pc, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
        const mc = 0, yc = 25.5;
        function gc(t3) {
          return sc * Math.cos(t3 * Math.PI / 180);
        }
        function xc(t3) {
          return (180 + t3) / 360;
        }
        function bc(t3) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
        }
        function vc(t3, e4) {
          return t3 / gc(e4);
        }
        function _c(t3) {
          return 360 * t3 - 180;
        }
        function wc(t3) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
        }
        function Mc(t3, e4) {
          return t3 * gc(wc(e4));
        }
        const Ac = 85.051129;
        function Sc(t3) {
          return Math.cos(qe(Ze(t3, -Ac, Ac)));
        }
        function Ic(t3, e4) {
          const r4 = Ze(e4, mc, yc), n3 = Math.pow(2, r4);
          return Sc(t3) * sc / (512 * n3);
        }
        function kc(t3) {
          return 1 / Math.cos(t3 * Math.PI / 180);
        }
        function Pc(t3, e4 = 0) {
          const r4 = Math.exp(Math.PI * (1 - (t3.y + e4 / is) / (1 << t3.z) * 2));
          return 80150034 * r4 / (r4 * r4 + 1) / is / (1 << t3.z);
        }
        class Ec {
          constructor(t3, e4, r4 = 0) {
            this.x = +t3, this.y = +e4, this.z = +r4;
          }
          static fromLngLat(t3, e4 = 0) {
            const r4 = ac.convert(t3);
            return new Ec(xc(r4.lng), bc(r4.lat), vc(e4, r4.lat));
          }
          toLngLat() {
            return new ac(_c(this.x), wc(this.y));
          }
          toAltitude() {
            return Mc(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / sc * kc(wc(this.y));
          }
        }
        function zc(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          const u3 = (e4 + n3) / 2, c3 = (r4 + i3) / 2, h2 = new Ue(u3, c3);
          o3(h2), function(t4, e5, r5, n4, i4, s5) {
            const a4 = r5 - i4, o4 = n4 - s5;
            return Math.abs((n4 - e5) * a4 - (r5 - t4) * o4) / Math.hypot(a4, o4);
          }(h2.x, h2.y, s4.x, s4.y, a3.x, a3.y) >= l3 ? (zc(t3, e4, r4, u3, c3, s4, h2, o3, l3), zc(t3, u3, c3, n3, i3, h2, a3, o3, l3)) : t3.push(a3);
        }
        function Tc(t3, e4, r4) {
          let n3 = t3[0], i3 = n3.x, s4 = n3.y;
          e4(n3);
          const a3 = [n3];
          for (let o3 = 1; o3 < t3.length; o3++) {
            const l3 = t3[o3], { x: u3, y: c3 } = l3;
            e4(l3), zc(a3, i3, s4, u3, c3, n3, l3, e4, r4), i3 = u3, s4 = c3, n3 = l3;
          }
          return a3;
        }
        function Bc(t3, e4, r4, n3) {
          if (n3(e4, r4)) {
            const i3 = e4.add(r4)._mult(0.5);
            Bc(t3, e4, i3, n3), Bc(t3, i3, r4, n3);
          } else
            t3.push(r4);
        }
        function Cc(t3, e4) {
          let r4 = t3[0];
          const n3 = [r4];
          for (let i3 = 1; i3 < t3.length; i3++) {
            const s4 = t3[i3];
            Bc(n3, r4, s4, e4), r4 = s4;
          }
          return n3;
        }
        const Rc = Math.pow(2, 14) - 1, Vc = -Rc - 1;
        function Dc(t3, e4) {
          const r4 = Math.round(t3.x * e4), n3 = Math.round(t3.y * e4);
          return t3.x = Ze(r4, Vc, Rc), t3.y = Ze(n3, Vc, Rc), (r4 < t3.x || r4 > t3.x + 1 || n3 < t3.y || n3 > t3.y + 1) && hr("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t3;
        }
        function Lc(t3, e4, r4) {
          const n3 = t3.loadGeometry(), i3 = t3.extent, s4 = is / i3;
          if (e4 && r4 && r4.projection.isReprojectedInTileSpace) {
            const s5 = 1 << e4.z, { scale: a3, x: o3, y: l3, projection: u3 } = r4, c3 = (t4) => {
              const r5 = _c((e4.x + t4.x / i3) / s5), n4 = wc((e4.y + t4.y / i3) / s5), c4 = u3.project(r5, n4);
              t4.x = (c4.x * a3 - o3) * i3, t4.y = (c4.y * a3 - l3) * i3;
            };
            for (let e5 = 0; e5 < n3.length; e5++)
              if (1 !== t3.type)
                n3[e5] = Tc(n3[e5], c3, 1);
              else {
                const t4 = [];
                for (const r5 of n3[e5])
                  r5.x < 0 || r5.x >= i3 || r5.y < 0 || r5.y >= i3 || (c3(r5), t4.push(r5));
                n3[e5] = t4;
              }
          }
          for (const t4 of n3)
            for (const e5 of t4)
              Dc(e5, s4);
          return n3;
        }
        function Fc(t3, e4) {
          return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e4 ? Lc(t3) : [] };
        }
        function Oc(t3, e4, r4, n3, i3) {
          t3.emplaceBack(2 * e4 + (n3 + 1) / 2, 2 * r4 + (i3 + 1) / 2);
        }
        function Uc(t3, e4, r4) {
          const n3 = 16384;
          t3.emplaceBack(e4.x, e4.y, e4.z, r4[0] * n3, r4[1] * n3, r4[2] * n3);
        }
        class Nc {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.fqid), this.index = t3.index, this.hasPattern = false, this.projection = t3.projection, this.layoutVertexArray = new Sl(), this.indexArray = new ql(), this.segments = new mu(), this.programConfigurations = new ju(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e4, r4, n3) {
            const i3 = this.layers[0], s4 = [];
            let a3 = null;
            "circle" === i3.type && (a3 = i3.layout.get("circle-sort-key"));
            for (const { feature: e5, id: i4, index: o4, sourceLayerIndex: l3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = Fc(e5, t4);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), u3, r4))
                continue;
              const c3 = a3 ? a3.evaluate(u3, {}, r4) : void 0, h2 = { id: i4, properties: e5.properties, type: e5.type, sourceLayerIndex: l3, index: o4, geometry: t4 ? u3.geometry : Lc(e5, r4, n3), patterns: {}, sortKey: c3 };
              s4.push(h2);
            }
            a3 && s4.sort((t4, e5) => t4.sortKey - e5.sortKey);
            let o3 = null;
            "globe" === n3.projection.name && (this.globeExtVertexArray = new Rl(), o3 = n3.projection);
            for (const n4 of s4) {
              const { geometry: i4, index: s5, sourceLayerIndex: a4 } = n4, l3 = t3[s5].feature;
              this.addFeature(n4, i4, s5, e4.availableImages, r4, o3, e4.brightness), e4.featureIndex.insert(l3, i4, s5, a4, this.index);
            }
          }
          update(t3, e4, r4, n3, i3) {
            const s4 = 0 !== Object.keys(t3).length;
            s4 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t3, e4, s4 ? this.stateDependentLayers : this.layers, r4, n3, i3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, fu.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t3.createVertexBuffer(this.globeExtVertexArray, du.members))), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
          addFeature(t3, e4, r4, n3, i3, s4, a3) {
            for (const r5 of e4)
              for (const e5 of r5) {
                const r6 = e5.x, n4 = e5.y;
                if (r6 < 0 || r6 >= is || n4 < 0 || n4 >= is)
                  continue;
                if (s4) {
                  const t4 = s4.projectTilePoint(r6, n4, i3), e6 = s4.upVector(i3, r6, n4), a5 = this.globeExtVertexArray;
                  Uc(a5, t4, e6), Uc(a5, t4, e6), Uc(a5, t4, e6), Uc(a5, t4, e6);
                }
                const a4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), o3 = a4.vertexLength;
                Oc(this.layoutVertexArray, r6, n4, -1, -1), Oc(this.layoutVertexArray, r6, n4, 1, -1), Oc(this.layoutVertexArray, r6, n4, 1, 1), Oc(this.layoutVertexArray, r6, n4, -1, 1), this.indexArray.emplaceBack(o3, o3 + 1, o3 + 2), this.indexArray.emplaceBack(o3, o3 + 2, o3 + 3), a4.vertexLength += 4, a4.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r4, {}, n3, i3, a3);
          }
        }
        function jc(t3, e4) {
          for (let r4 = 0; r4 < t3.length; r4++)
            if (Wc(e4, t3[r4]))
              return true;
          for (let r4 = 0; r4 < e4.length; r4++)
            if (Wc(t3, e4[r4]))
              return true;
          return !!Qc(t3, e4);
        }
        function qc(t3, e4, r4) {
          return !!Wc(t3, e4) || !!Xc(e4, t3, r4);
        }
        function $c(t3, e4) {
          if (1 === t3.length)
            return Kc(e4, t3[0]);
          for (let r4 = 0; r4 < e4.length; r4++) {
            const n3 = e4[r4];
            for (let e5 = 0; e5 < n3.length; e5++)
              if (Wc(t3, n3[e5]))
                return true;
          }
          for (let r4 = 0; r4 < t3.length; r4++)
            if (Kc(e4, t3[r4]))
              return true;
          for (let r4 = 0; r4 < e4.length; r4++)
            if (Qc(t3, e4[r4]))
              return true;
          return false;
        }
        function Gc(t3, e4, r4) {
          if (t3.length > 1) {
            if (Qc(t3, e4))
              return true;
            for (let n3 = 0; n3 < e4.length; n3++)
              if (Xc(e4[n3], t3, r4))
                return true;
          }
          for (let n3 = 0; n3 < t3.length; n3++)
            if (Xc(t3[n3], e4, r4))
              return true;
          return false;
        }
        function Qc(t3, e4) {
          if (0 === t3.length || 0 === e4.length)
            return false;
          for (let r4 = 0; r4 < t3.length - 1; r4++) {
            const n3 = t3[r4], i3 = t3[r4 + 1];
            for (let t4 = 0; t4 < e4.length - 1; t4++)
              if (Yc(n3, i3, e4[t4], e4[t4 + 1]))
                return true;
          }
          return false;
        }
        function Yc(t3, e4, r4, n3) {
          return pr(t3, r4, n3) !== pr(e4, r4, n3) && pr(t3, e4, r4) !== pr(t3, e4, n3);
        }
        function Xc(t3, e4, r4) {
          const n3 = r4 * r4;
          if (1 === e4.length)
            return t3.distSqr(e4[0]) < n3;
          for (let r5 = 1; r5 < e4.length; r5++)
            if (Zc(t3, e4[r5 - 1], e4[r5]) < n3)
              return true;
          return false;
        }
        function Zc(t3, e4, r4) {
          const n3 = e4.distSqr(r4);
          if (0 === n3)
            return t3.distSqr(e4);
          const i3 = ((t3.x - e4.x) * (r4.x - e4.x) + (t3.y - e4.y) * (r4.y - e4.y)) / n3;
          return t3.distSqr(i3 < 0 ? e4 : i3 > 1 ? r4 : r4.sub(e4)._mult(i3)._add(e4));
        }
        function Kc(t3, e4) {
          let r4, n3, i3, s4 = false;
          for (let a3 = 0; a3 < t3.length; a3++) {
            r4 = t3[a3];
            for (let t4 = 0, a4 = r4.length - 1; t4 < r4.length; a4 = t4++)
              n3 = r4[t4], i3 = r4[a4], n3.y > e4.y != i3.y > e4.y && e4.x < (i3.x - n3.x) * (e4.y - n3.y) / (i3.y - n3.y) + n3.x && (s4 = !s4);
          }
          return s4;
        }
        function Wc(t3, e4) {
          let r4 = false;
          for (let n3 = 0, i3 = t3.length - 1; n3 < t3.length; i3 = n3++) {
            const s4 = t3[n3], a3 = t3[i3];
            s4.y > e4.y != a3.y > e4.y && e4.x < (a3.x - s4.x) * (e4.y - s4.y) / (a3.y - s4.y) + s4.x && (r4 = !r4);
          }
          return r4;
        }
        function Hc(t3, e4, r4, n3, i3) {
          for (const s5 of t3)
            if (e4 <= s5.x && r4 <= s5.y && n3 >= s5.x && i3 >= s5.y)
              return true;
          const s4 = [new Ue(e4, r4), new Ue(e4, i3), new Ue(n3, i3), new Ue(n3, r4)];
          if (t3.length > 2) {
            for (const e5 of s4)
              if (Wc(t3, e5))
                return true;
          }
          for (let e5 = 0; e5 < t3.length - 1; e5++)
            if (Jc(t3[e5], t3[e5 + 1], s4))
              return true;
          return false;
        }
        function Jc(t3, e4, r4) {
          const n3 = r4[0], i3 = r4[2];
          if (t3.x < n3.x && e4.x < n3.x || t3.x > i3.x && e4.x > i3.x || t3.y < n3.y && e4.y < n3.y || t3.y > i3.y && e4.y > i3.y)
            return false;
          const s4 = pr(t3, e4, r4[0]);
          return s4 !== pr(t3, e4, r4[1]) || s4 !== pr(t3, e4, r4[2]) || s4 !== pr(t3, e4, r4[3]);
        }
        function th(t3, e4, r4, n3, i3, s4) {
          let a3 = e4.y - t3.y, o3 = t3.x - e4.x;
          if (s4 = s4 || 0) {
            const t4 = a3 * a3 + o3 * o3;
            if (0 === t4)
              return true;
            const e5 = Math.sqrt(t4);
            a3 /= e5, o3 /= e5;
          }
          return !((r4.x - t3.x) * a3 + (r4.y - t3.y) * o3 - s4 < 0 || (n3.x - t3.x) * a3 + (n3.y - t3.y) * o3 - s4 < 0 || (i3.x - t3.x) * a3 + (i3.y - t3.y) * o3 - s4 < 0);
        }
        function eh(t3, e4, r4, n3, i3, s4, a3) {
          return !(th(t3, e4, n3, i3, s4, a3) || th(e4, r4, n3, i3, s4, a3) || th(r4, t3, n3, i3, s4, a3) || th(n3, i3, t3, e4, r4, a3) || th(i3, s4, t3, e4, r4, a3) || th(s4, n3, t3, e4, r4, a3));
        }
        function rh(t3, e4, r4) {
          const n3 = e4.paint.get(t3).value;
          return "constant" === n3.kind ? n3.value : r4.programConfigurations.get(e4.id).getMaxValue(t3);
        }
        function nh(t3) {
          return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
        }
        function ih(t3, e4, r4, n3, i3) {
          if (!e4[0] && !e4[1])
            return t3;
          const s4 = Ue.convert(e4)._mult(i3);
          "viewport" === r4 && s4._rotate(-n3);
          const a3 = [];
          for (let e5 = 0; e5 < t3.length; e5++)
            a3.push(t3[e5].sub(s4));
          return a3;
        }
        function sh(t3, e4, r4, n3) {
          const i3 = Ue.convert(t3)._mult(n3);
          return "viewport" === e4 && i3._rotate(-r4), i3;
        }
        fo(Nc, "CircleBucket", { omit: ["layers"] });
        const ah = new Ho({ "circle-sort-key": new Ko(el.layout_circle["circle-sort-key"]), visibility: new Zo(el.layout_circle.visibility) });
        var oh = { paint: new Ho({ "circle-radius": new Ko(el.paint_circle["circle-radius"]), "circle-color": new Ko(el.paint_circle["circle-color"]), "circle-blur": new Ko(el.paint_circle["circle-blur"]), "circle-opacity": new Ko(el.paint_circle["circle-opacity"]), "circle-translate": new Zo(el.paint_circle["circle-translate"]), "circle-translate-anchor": new Zo(el.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Zo(el.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Zo(el.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ko(el.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ko(el.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ko(el.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Zo(el.paint_circle["circle-emissive-strength"]) }), layout: ah };
        class lh {
          constructor(t3, e4) {
            this.pos = t3, this.dir = e4;
          }
          intersectsPlane(e4, r4, n3) {
            const i3 = t2.Q.dot(r4, this.dir);
            if (Math.abs(i3) < 1e-6)
              return false;
            const s4 = ((e4[0] - this.pos[0]) * r4[0] + (e4[1] - this.pos[1]) * r4[1] + (e4[2] - this.pos[2]) * r4[2]) / i3;
            return n3[0] = this.pos[0] + this.dir[0] * s4, n3[1] = this.pos[1] + this.dir[1] * s4, n3[2] = this.pos[2] + this.dir[2] * s4, true;
          }
          closestPointOnSphere(e4, r4, n3) {
            if (t2.Q.equals(this.pos, e4) || 0 === r4)
              return n3[0] = n3[1] = n3[2] = 0, false;
            const [i3, s4, a3] = this.dir, o3 = this.pos[0] - e4[0], l3 = this.pos[1] - e4[1], u3 = this.pos[2] - e4[2], c3 = i3 * i3 + s4 * s4 + a3 * a3, h2 = 2 * (o3 * i3 + l3 * s4 + u3 * a3), p3 = h2 * h2 - 4 * c3 * (o3 * o3 + l3 * l3 + u3 * u3 - r4 * r4);
            if (p3 < 0) {
              const t3 = Math.max(-h2 / 2, 0), e5 = o3 + i3 * t3, c4 = l3 + s4 * t3, p4 = u3 + a3 * t3, f2 = Math.hypot(e5, c4, p4);
              return n3[0] = e5 * r4 / f2, n3[1] = c4 * r4 / f2, n3[2] = p4 * r4 / f2, false;
            }
            {
              const t3 = (-h2 - Math.sqrt(p3)) / (2 * c3);
              if (t3 < 0) {
                const t4 = Math.hypot(o3, l3, u3);
                return n3[0] = o3 * r4 / t4, n3[1] = l3 * r4 / t4, n3[2] = u3 * r4 / t4, false;
              }
              return n3[0] = o3 + i3 * t3, n3[1] = l3 + s4 * t3, n3[2] = u3 + a3 * t3, true;
            }
          }
        }
        class uh {
          constructor(t3, e4, r4, n3, i3) {
            this.TL = t3, this.TR = e4, this.BR = r4, this.BL = n3, this.horizon = i3;
          }
          static fromInvProjectionMatrix(e4, r4, n3) {
            const i3 = [-1, 1, 1], s4 = [1, 1, 1], a3 = [1, -1, 1], o3 = [-1, -1, 1], l3 = t2.Q.transformMat4(i3, i3, e4), u3 = t2.Q.transformMat4(s4, s4, e4), c3 = t2.Q.transformMat4(a3, a3, e4), h2 = t2.Q.transformMat4(o3, o3, e4);
            return new uh(l3, u3, c3, h2, r4 / n3);
          }
        }
        function ch(e4, r4, n3) {
          let i3 = 1 / 0, s4 = -1 / 0;
          const a3 = [];
          for (const o3 of e4) {
            t2.Q.sub(a3, o3, r4);
            const e5 = t2.Q.dot(a3, n3);
            i3 = Math.min(i3, e5), s4 = Math.max(s4, e5);
          }
          return [i3, s4];
        }
        function hh(e4, r4) {
          let n3 = true;
          for (let i3 = 0; i3 < e4.planes.length; i3++) {
            const s4 = e4.planes[i3];
            let a3 = 0;
            for (let e5 = 0; e5 < r4.length; e5++)
              a3 += t2.Q.dot(s4, r4[e5]) + s4[3] >= 0;
            if (0 === a3)
              return 0;
            a3 !== r4.length && (n3 = false);
          }
          return n3 ? 2 : 1;
        }
        function ph(t3, e4) {
          for (const r4 of t3.projections) {
            const n3 = ch(e4, t3.points[0], r4.axis);
            if (r4.projection[1] < n3[0] || r4.projection[0] > n3[1])
              return 0;
          }
          return 1;
        }
        function fh(e4, r4) {
          let n3 = 0;
          const i3 = [0, 0, 0, 0];
          for (let s4 = 0; s4 < e4.length; s4++)
            i3[0] = e4[s4][0], i3[1] = e4[s4][1], i3[2] = e4[s4][2], i3[3] = 1, t2.aa.dot(i3, r4) >= 0 && n3++;
          return n3;
        }
        class dh {
          constructor(e4, r4) {
            this.points = e4 || new Array(8).fill([0, 0, 0]), this.planes = r4 || new Array(6).fill([0, 0, 0, 0]), this.bounds = mh.fromPoints(this.points), this.projections = [], this.frustumEdges = [t2.Q.sub([], this.points[2], this.points[3]), t2.Q.sub([], this.points[0], this.points[3]), t2.Q.sub([], this.points[4], this.points[0]), t2.Q.sub([], this.points[5], this.points[1]), t2.Q.sub([], this.points[6], this.points[2]), t2.Q.sub([], this.points[7], this.points[3])];
            for (const t3 of this.frustumEdges) {
              const e5 = [0, -t3[2], t3[1]], r5 = [t3[2], 0, -t3[0]];
              this.projections.push({ axis: e5, projection: ch(this.points, this.points[0], e5) }), this.projections.push({ axis: r5, projection: ch(this.points, this.points[0], r5) });
            }
          }
          static fromInvProjectionMatrix(e4, r4, n3, i3) {
            const s4 = Math.pow(2, n3), a3 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((n4) => {
              const a4 = t2.aa.transformMat4([], n4, e4), o4 = 1 / a4[3] / r4 * s4;
              return t2.aa.mul(a4, a4, [o4, o4, i3 ? 1 / a4[3] : o4, o4]);
            }), o3 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e5) => {
              const r5 = t2.Q.sub([], a3[e5[0]], a3[e5[1]]), n4 = t2.Q.sub([], a3[e5[2]], a3[e5[1]]), i4 = t2.Q.normalize([], t2.Q.cross([], r5, n4)), s5 = -t2.Q.dot(i4, a3[e5[1]]);
              return i4.concat(s5);
            }), l3 = [];
            for (let t3 = 0; t3 < a3.length; t3++)
              l3.push([a3[t3][0], a3[t3][1], a3[t3][2]]);
            return new dh(l3, o3);
          }
          intersectsPrecise(e4, r4, n3) {
            for (let t3 = 0; t3 < r4.length; t3++)
              if (!fh(e4, r4[t3]))
                return 0;
            for (let t3 = 0; t3 < this.planes.length; t3++)
              if (!fh(e4, this.planes[t3]))
                return 0;
            for (const r5 of n3)
              for (const n4 of this.frustumEdges) {
                const i3 = t2.Q.cross([], r5, n4), s4 = t2.Q.length(i3);
                if (0 === s4)
                  continue;
                t2.Q.scale(i3, i3, 1 / s4);
                const a3 = ch(this.points, this.points[0], i3), o3 = ch(e4, this.points[0], i3);
                if (a3[0] > o3[1] || o3[0] > a3[1])
                  return 0;
              }
            return 1;
          }
        }
        class mh {
          static fromPoints(e4) {
            const r4 = [1 / 0, 1 / 0, 1 / 0], n3 = [-1 / 0, -1 / 0, -1 / 0];
            for (const i3 of e4)
              t2.Q.min(r4, r4, i3), t2.Q.max(n3, n3, i3);
            return new mh(r4, n3);
          }
          static fromTileIdAndHeight(t3, e4, r4) {
            const n3 = 1 << t3.canonical.z, i3 = t3.canonical.x, s4 = t3.canonical.y;
            return new mh([i3 / n3, s4 / n3, e4], [(i3 + 1) / n3, (s4 + 1) / n3, r4]);
          }
          static applyTransform(e4, r4) {
            const n3 = e4.getCorners();
            for (let e5 = 0; e5 < n3.length; ++e5)
              t2.Q.transformMat4(n3[e5], n3[e5], r4);
            return mh.fromPoints(n3);
          }
          static projectAabbCorners(e4, r4) {
            const n3 = e4.getCorners();
            for (let e5 = 0; e5 < n3.length; ++e5)
              t2.Q.transformMat4(n3[e5], n3[e5], r4);
            return n3;
          }
          constructor(e4, r4) {
            this.min = e4, this.max = r4, this.center = t2.Q.scale([], t2.Q.add([], this.min, this.max), 0.5);
          }
          quadrant(e4) {
            const r4 = [e4 % 2 == 0, e4 < 2], n3 = t2.Q.clone(this.min), i3 = t2.Q.clone(this.max);
            for (let t3 = 0; t3 < r4.length; t3++)
              n3[t3] = r4[t3] ? this.min[t3] : this.center[t3], i3[t3] = r4[t3] ? this.center[t3] : this.max[t3];
            return i3[2] = this.max[2], new mh(n3, i3);
          }
          distanceX(t3) {
            return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
          }
          distanceY(t3) {
            return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
          }
          distanceZ(t3) {
            return Math.max(Math.min(this.max[2], t3[2]), this.min[2]) - t3[2];
          }
          getCorners() {
            const t3 = this.min, e4 = this.max;
            return [[t3[0], t3[1], t3[2]], [e4[0], t3[1], t3[2]], [e4[0], e4[1], t3[2]], [t3[0], e4[1], t3[2]], [t3[0], t3[1], e4[2]], [e4[0], t3[1], e4[2]], [e4[0], e4[1], e4[2]], [t3[0], e4[1], e4[2]]];
          }
          intersects(t3) {
            return this.intersectsAabb(t3.bounds) ? hh(t3, this.getCorners()) : 0;
          }
          intersectsFlat(t3) {
            return this.intersectsAabb(t3.bounds) ? hh(t3, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsPrecise(t3, e4) {
            return e4 || this.intersects(t3) ? ph(t3, this.getCorners()) : 0;
          }
          intersectsPreciseFlat(t3, e4) {
            return e4 || this.intersectsFlat(t3) ? ph(t3, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsAabb(t3) {
            for (let e4 = 0; e4 < 3; ++e4)
              if (this.min[e4] > t3.max[e4] || t3.min[e4] > this.max[e4])
                return false;
            return true;
          }
          intersectsAabbXY(t3) {
            return !(this.min[0] > t3.max[0] || t3.min[0] > this.max[0] || this.min[1] > t3.max[1] || t3.min[1] > this.max[1]);
          }
          encapsulate(t3) {
            for (let e4 = 0; e4 < 3; e4++)
              this.min[e4] = Math.min(this.min[e4], t3.min[e4]), this.max[e4] = Math.max(this.max[e4], t3.max[e4]);
          }
          encapsulatePoint(t3) {
            for (let e4 = 0; e4 < 3; e4++)
              this.min[e4] = Math.min(this.min[e4], t3[e4]), this.max[e4] = Math.max(this.max[e4], t3[e4]);
          }
          closestPoint(t3) {
            return [Math.max(Math.min(this.max[0], t3[0]), this.min[0]), Math.max(Math.min(this.max[1], t3[1]), this.min[1]), Math.max(Math.min(this.max[2], t3[2]), this.min[2])];
          }
        }
        fo(mh, "Aabb");
        const yh = Ml([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: gh } = yh, xh = Ml([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var bh = Ml([{ name: "a_pos", type: "Int16", components: 2 }]);
        function vh(t3) {
          return t3 * Xu / ic;
        }
        const _h = [new mh([tc, tc, tc], [ec, ec, ec]), new mh([tc, tc, tc], [0, 0, ec]), new mh([0, tc, tc], [ec, 0, ec]), new mh([tc, 0, tc], [0, ec, ec]), new mh([0, 0, tc], [ec, ec, ec])];
        function wh(e4, r4, n3, i3 = true) {
          const s4 = t2.Q.scale([], e4._camera.position, e4.worldSize), a3 = [r4, n3, 1, 1];
          t2.aa.transformMat4(a3, a3, e4.pixelMatrixInverse), t2.aa.scale(a3, a3, 1 / a3[3]);
          const o3 = t2.Q.sub([], a3, s4), l3 = t2.Q.normalize([], o3), u3 = e4.globeMatrix, c3 = [u3[12], u3[13], u3[14]], h2 = t2.Q.sub([], c3, s4), p3 = t2.Q.length(h2), f2 = t2.Q.normalize([], h2), d2 = e4.worldSize / (2 * Math.PI), m2 = t2.Q.dot(f2, l3), y3 = Math.asin(d2 / p3);
          if (y3 < Math.acos(m2)) {
            if (!i3)
              return null;
            const e5 = [], r5 = [];
            t2.Q.scale(e5, l3, p3 / m2), t2.Q.normalize(r5, t2.Q.sub(r5, e5, h2)), t2.Q.normalize(l3, t2.Q.add(l3, h2, t2.Q.scale(l3, r5, Math.tan(y3) * p3)));
          }
          const g3 = [];
          new lh(s4, l3).closestPointOnSphere(c3, d2, g3);
          const x3 = t2.Q.normalize([], Sr(u3, 0)), b2 = t2.Q.normalize([], Sr(u3, 1)), v3 = t2.Q.normalize([], Sr(u3, 2)), _3 = t2.Q.dot(x3, g3), w2 = t2.Q.dot(b2, g3), M3 = t2.Q.dot(v3, g3), A2 = $e(Math.asin(-w2 / d2));
          let S2 = $e(Math.atan2(_3, M3));
          S2 = e4.center.lng + function(t3, e5) {
            const r5 = (e5 - t3 + 180) % 360 - 180;
            return r5 < -180 ? r5 + 360 : r5;
          }(e4.center.lng, S2);
          const I2 = xc(S2), k2 = Ze(bc(A2), 0, 1);
          return new Ec(I2, k2);
        }
        class Mh {
          constructor(e4, r4, n3) {
            this.a = t2.Q.sub([], e4, n3), this.b = t2.Q.sub([], r4, n3), this.center = n3;
            const i3 = t2.Q.normalize([], this.a), s4 = t2.Q.normalize([], this.b);
            this.angle = Math.acos(t2.Q.dot(i3, s4));
          }
        }
        function Ah(t3, e4) {
          if (0 === t3.angle)
            return null;
          let r4;
          return r4 = 0 === t3.a[e4] ? 1 / t3.angle * 0.5 * Math.PI : 1 / t3.angle * Math.atan(t3.b[e4] / t3.a[e4] / Math.sin(t3.angle) - 1 / Math.tan(t3.angle)), r4 < 0 || r4 > 1 ? null : function(t4, e5, r5, n3) {
            const i3 = Math.sin(r5);
            return t4 * (Math.sin((1 - n3) * r5) / i3) + e5 * (Math.sin(n3 * r5) / i3);
          }(t3.a[e4], t3.b[e4], t3.angle, Ze(r4, 0, 1)) + t3.center[e4];
        }
        function Sh(t3) {
          if (t3.z <= 1)
            return _h[t3.z + 2 * t3.y + t3.x];
          const e4 = zh(Eh(t3));
          return mh.fromPoints(e4);
        }
        function Ih(e4, r4, n3) {
          return t2.Q.scale(e4, e4, 1 - n3), t2.Q.scaleAndAdd(e4, e4, r4, n3);
        }
        function kh(e4, r4, n3) {
          for (const i3 of e4)
            t2.Q.transformMat4(i3, i3, r4), t2.Q.scale(i3, i3, n3);
        }
        function Ph(e4, r4, n3, i3) {
          const s4 = r4 / e4.worldSize, a3 = e4.globeMatrix;
          if (n3.z <= 1) {
            const t3 = Sh(n3).getCorners();
            return kh(t3, a3, s4), mh.fromPoints(t3);
          }
          const o3 = Eh(n3, i3), l3 = zh(o3, Xu + vh(e4._tileCoverLift));
          kh(l3, a3, s4);
          const u3 = Number.MAX_VALUE, c3 = [-u3, -u3, -u3], h2 = [u3, u3, u3];
          if (o3.contains(e4.center)) {
            for (const e5 of l3)
              t2.Q.min(h2, h2, e5), t2.Q.max(c3, c3, e5);
            c3[2] = 0;
            const r5 = e4.point, n4 = [r5.x * s4, r5.y * s4, 0];
            return t2.Q.min(h2, h2, n4), t2.Q.max(c3, c3, n4), new mh(h2, c3);
          }
          if (e4._tileCoverLift > 0) {
            for (const e5 of l3)
              t2.Q.min(h2, h2, e5), t2.Q.max(c3, c3, e5);
            return new mh(h2, c3);
          }
          const p3 = [a3[12] * s4, a3[13] * s4, a3[14] * s4], f2 = o3.getCenter(), d2 = Ze(e4.center.lat, -Ac, Ac), m2 = Ze(f2.lat, -Ac, Ac), y3 = xc(e4.center.lng), g3 = bc(d2);
          let x3 = y3 - xc(f2.lng);
          const b2 = g3 - bc(m2);
          x3 > 0.5 ? x3 -= 1 : x3 < -0.5 && (x3 += 1);
          let v3 = 0;
          if (Math.abs(x3) > Math.abs(b2))
            v3 = x3 >= 0 ? 1 : 3;
          else {
            v3 = b2 >= 0 ? 0 : 2;
            const e5 = [a3[4] * s4, a3[5] * s4, a3[6] * s4], r5 = -Math.sin(qe(b2 >= 0 ? o3.getSouth() : o3.getNorth())) * Xu;
            t2.Q.scaleAndAdd(p3, p3, e5, r5);
          }
          const _3 = l3[v3], w2 = l3[(v3 + 1) % 4], M3 = new Mh(_3, w2, p3), A2 = [Ah(M3, 0) || _3[0], Ah(M3, 1) || _3[1], Ah(M3, 2) || _3[2]], S2 = Oh(e4.zoom);
          if (S2 > 0) {
            const i4 = function({ x: t3, y: e5, z: r5 }, n4, i5, s6, a4) {
              const o4 = 1 / (1 << r5);
              let l4 = t3 * o4, u4 = l4 + o4, c4 = e5 * o4, h3 = c4 + o4, p4 = 0;
              const f3 = (l4 + u4) / 2 - s6;
              return f3 > 0.5 ? p4 = -1 : f3 < -0.5 && (p4 = 1), l4 = ((l4 + p4) * n4 - (s6 *= n4)) * i5 + s6, u4 = ((u4 + p4) * n4 - s6) * i5 + s6, c4 = (c4 * n4 - (a4 *= n4)) * i5 + a4, h3 = (h3 * n4 - a4) * i5 + a4, [[l4, h3, 0], [u4, h3, 0], [u4, c4, 0], [l4, c4, 0]];
            }(n3, r4, e4._pixelsPerMercatorPixel, y3, g3);
            for (let t3 = 0; t3 < l3.length; t3++)
              Ih(l3[t3], i4[t3], S2);
            const s5 = t2.Q.add([], i4[v3], i4[(v3 + 1) % 4]);
            t2.Q.scale(s5, s5, 0.5), Ih(A2, s5, S2);
          }
          for (const e5 of l3)
            t2.Q.min(h2, h2, e5), t2.Q.max(c3, c3, e5);
          return h2[2] = Math.min(_3[2], w2[2]), t2.Q.min(h2, h2, A2), t2.Q.max(c3, c3, A2), new mh(h2, c3);
        }
        function Eh({ x: t3, y: e4, z: r4 }, n3 = false) {
          const i3 = 1 / (1 << r4), s4 = new ac(_c(t3 * i3), e4 === (1 << r4) - 1 && n3 ? -90 : wc((e4 + 1) * i3)), a3 = new ac(_c((t3 + 1) * i3), 0 === e4 && n3 ? 90 : wc(e4 * i3));
          return new oc(s4, a3);
        }
        function zh(t3, e4 = Xu) {
          const r4 = qe(t3.getNorth()), n3 = qe(t3.getSouth()), i3 = Math.cos(r4), s4 = Math.cos(n3), a3 = Math.sin(r4), o3 = Math.sin(n3), l3 = t3.getWest(), u3 = t3.getEast();
          return [rc(s4, o3, l3, e4), rc(s4, o3, u3, e4), rc(i3, a3, u3, e4), rc(i3, a3, l3, e4)];
        }
        function Th(t3, e4, r4, n3) {
          const i3 = 1 << r4.z, s4 = (t3 / is + r4.x) / i3;
          return nc(wc((e4 / is + r4.y) / i3), _c(s4), n3);
        }
        function Bh({ min: t3, max: e4 }) {
          return Wu / Math.max(e4[0] - t3[0], e4[1] - t3[1], e4[2] - t3[2]);
        }
        const Ch = new Float64Array(16);
        function Rh(e4) {
          const r4 = Bh(e4), n3 = t2.a9.fromScaling(Ch, [r4, r4, r4]);
          return t2.a9.translate(n3, n3, t2.Q.negate([], e4.min));
        }
        function Vh(e4) {
          const r4 = t2.a9.fromTranslation(Ch, e4.min), n3 = 1 / Bh(e4);
          return t2.a9.scale(r4, r4, [n3, n3, n3]);
        }
        function Dh(t3) {
          const e4 = is / (2 * Math.PI);
          return t3 / (2 * Math.PI) / e4;
        }
        function Lh(t3, e4) {
          return is / (512 * Math.pow(2, t3)) * Bh(Sh(e4));
        }
        function Fh(e4, r4, n3, i3, s4) {
          const a3 = Dh(n3), o3 = [e4, r4, -n3 / (2 * Math.PI)], l3 = t2.a9.identity(new Float64Array(16));
          return t2.a9.translate(l3, l3, o3), t2.a9.scale(l3, l3, [a3, a3, a3]), t2.a9.rotateX(l3, l3, qe(-s4)), t2.a9.rotateY(l3, l3, qe(-i3)), l3;
        }
        function Oh(t3) {
          return Ke(Zu, Ku, t3);
        }
        function Uh(e4, r4) {
          const n3 = nc(r4.lat, r4.lng), i3 = function(e5) {
            const r5 = nc(e5._center.lat, e5._center.lng), n4 = t2.Q.fromValues(0, 1, 0);
            let i4 = t2.Q.cross([], n4, r5);
            const s5 = t2.a9.fromRotation([], -e5.angle, r5);
            i4 = t2.Q.transformMat4(i4, i4, s5), t2.a9.fromRotation(s5, -e5._pitch, i4);
            const a3 = t2.Q.normalize([], r5);
            return t2.Q.scale(a3, a3, vh(e5.cameraToCenterDistance / e5.pixelsPerMeter)), t2.Q.transformMat4(a3, a3, s5), t2.Q.add([], r5, a3);
          }(e4), s4 = t2.Q.subtract([], i3, n3);
          return t2.Q.angle(s4, n3);
        }
        function Nh(t3, e4) {
          return Uh(t3, e4) > Math.PI / 2 * 1.01;
        }
        const jh = qe(85), qh = Math.cos(jh), $h = Math.sin(jh), Gh = t2.a9.create(), Qh = (t3) => {
          const e4 = [];
          return "map" === t3.paint.get("circle-pitch-alignment") && e4.push("PITCH_WITH_MAP"), "map" === t3.paint.get("circle-pitch-scale") && e4.push("SCALE_WITH_MAP"), e4;
        };
        function Yh(e4, r4, n3, i3, s4, a3, o3, l3, u3) {
          if (a3 && e4.queryGeometry.isAboveHorizon)
            return false;
          a3 && (u3 *= e4.pixelToTileUnitsFactor);
          const c3 = e4.tileID.canonical, h2 = n3.projection.upVectorScale(c3, n3.center.lat, n3.worldSize).metersToTile;
          for (const p3 of r4)
            for (const r5 of p3) {
              const p4 = r5.add(l3), f2 = s4 && n3.elevation ? n3.elevation.exaggeration() * s4.getElevationAt(p4.x, p4.y, true) : 0, d2 = n3.projection.projectTilePoint(p4.x, p4.y, c3);
              if (f2 > 0) {
                const t3 = n3.projection.upVector(c3, p4.x, p4.y);
                d2.x += t3[0] * h2 * f2, d2.y += t3[1] * h2 * f2, d2.z += t3[2] * h2 * f2;
              }
              const m2 = a3 ? p4 : Xh(d2.x, d2.y, d2.z, i3), y3 = a3 ? e4.tilespaceRays.map((t3) => Wh(t3, f2)) : e4.queryGeometry.screenGeometry, g3 = t2.aa.transformMat4([], [d2.x, d2.y, d2.z, 1], i3);
              if (!o3 && a3 ? u3 *= g3[3] / n3.cameraToCenterDistance : o3 && !a3 && (u3 *= n3.cameraToCenterDistance / g3[3]), a3) {
                const t3 = wc((r5.y / is + c3.y) / (1 << c3.z));
                u3 /= n3.projection.pixelsPerMeter(t3, 1) / vc(1, t3);
              }
              if (qc(y3, m2, u3))
                return true;
            }
          return false;
        }
        function Xh(e4, r4, n3, i3) {
          const s4 = t2.aa.transformMat4([], [e4, r4, n3, 1], i3);
          return new Ue(s4[0] / s4[3], s4[1] / s4[3]);
        }
        const Zh = t2.Q.fromValues(0, 0, 0), Kh = t2.Q.fromValues(0, 0, 1);
        function Wh(e4, r4) {
          const n3 = t2.Q.create();
          return Zh[2] = r4, e4.intersectsPlane(Zh, Kh, n3), new Ue(n3[0], n3[1]);
        }
        class Hh extends Nc {
        }
        function Jh(t3, { width: e4, height: r4 }, n3, i3) {
          if (i3) {
            if (i3 instanceof Uint8ClampedArray)
              i3 = new Uint8Array(i3.buffer);
            else if (i3.length !== e4 * r4 * n3)
              throw new RangeError("mismatched image size");
          } else
            i3 = new Uint8Array(e4 * r4 * n3);
          return t3.width = e4, t3.height = r4, t3.data = i3, t3;
        }
        function tp(t3, e4, r4) {
          const { width: n3, height: i3 } = e4;
          n3 === t3.width && i3 === t3.height || (ep(t3, e4, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, n3), height: Math.min(t3.height, i3) }, r4), t3.width = n3, t3.height = i3, t3.data = e4.data);
        }
        function ep(t3, e4, r4, n3, i3, s4, a3) {
          if (0 === i3.width || 0 === i3.height)
            return e4;
          if (i3.width > t3.width || i3.height > t3.height || r4.x > t3.width - i3.width || r4.y > t3.height - i3.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i3.width > e4.width || i3.height > e4.height || n3.x > e4.width - i3.width || n3.y > e4.height - i3.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const o3 = t3.data, l3 = e4.data, u3 = 4 === s4 && a3;
          for (let a4 = 0; a4 < i3.height; a4++) {
            const c3 = ((r4.y + a4) * t3.width + r4.x) * s4, h2 = ((n3.y + a4) * e4.width + n3.x) * s4;
            if (u3)
              for (let t4 = 0; t4 < i3.width; t4++) {
                const e5 = c3 + t4 * s4 + 3, r5 = h2 + t4 * s4;
                l3[r5 + 0] = 255, l3[r5 + 1] = 255, l3[r5 + 2] = 255, l3[r5 + 3] = o3[e5];
              }
            else
              for (let t4 = 0; t4 < i3.width * s4; t4++)
                l3[h2 + t4] = o3[c3 + t4];
          }
          return e4;
        }
        fo(Hh, "HeatmapBucket", { omit: ["layers"] });
        class rp {
          constructor(t3, e4) {
            Jh(this, t3, 1, e4);
          }
          resize(t3) {
            tp(this, new rp(t3), 1);
          }
          clone() {
            return new rp({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e4, r4, n3, i3) {
            ep(t3, e4, r4, n3, i3, 1);
          }
        }
        class np {
          constructor(t3, e4) {
            Jh(this, t3, 4, e4);
          }
          resize(t3) {
            tp(this, new np(t3), 4);
          }
          replace(t3, e4) {
            e4 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
          }
          clone() {
            return new np({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e4, r4, n3, i3, s4) {
            ep(t3, e4, r4, n3, i3, 4, s4);
          }
        }
        class ip {
          constructor(t3, e4) {
            this.width = t3.width, this.height = t3.height, this.data = e4 instanceof Uint8Array ? new Float32Array(e4.buffer) : e4;
          }
        }
        fo(rp, "AlphaImage"), fo(np, "RGBAImage");
        const sp = new Ho({ visibility: new Zo(el.layout_heatmap.visibility) });
        var ap = { paint: new Ho({ "heatmap-radius": new Ko(el.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ko(el.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Zo(el.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Wo(el.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Zo(el.paint_heatmap["heatmap-opacity"]) }), layout: sp };
        function op(t3) {
          const e4 = {}, r4 = t3.resolution || 256, n3 = t3.clips ? t3.clips.length : 1, i3 = t3.image || new np({ width: r4, height: n3 }), s4 = (r5, n4, s5) => {
            e4[t3.evaluationKey] = s5;
            const a3 = t3.expression.evaluate(e4);
            a3 && (i3.data[r5 + n4 + 0] = Math.floor(255 * a3.r / a3.a), i3.data[r5 + n4 + 1] = Math.floor(255 * a3.g / a3.a), i3.data[r5 + n4 + 2] = Math.floor(255 * a3.b / a3.a), i3.data[r5 + n4 + 3] = Math.floor(255 * a3.a));
          };
          if (t3.clips)
            for (let e5 = 0, i4 = 0; e5 < n3; ++e5, i4 += 4 * r4)
              for (let n4 = 0, a3 = 0; n4 < r4; n4++, a3 += 4) {
                const o3 = n4 / (r4 - 1), { start: l3, end: u3 } = t3.clips[e5];
                s4(i4, a3, l3 * (1 - o3) + u3 * o3);
              }
          else
            for (let t4 = 0, e5 = 0; t4 < r4; t4++, e5 += 4)
              s4(0, e5, t4 / (r4 - 1));
          return i3;
        }
        const lp = new Ho({ visibility: new Zo(el.layout_hillshade.visibility) });
        var up = { paint: new Ho({ "hillshade-illumination-direction": new Zo(el.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Zo(el.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Zo(el.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Zo(el.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Zo(el.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Zo(el.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Zo(el.paint_hillshade["hillshade-emissive-strength"]) }), layout: lp };
        const cp = Ml([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: hp } = cp;
        var pp = { exports: {} };
        function fp(t3, e4, r4) {
          r4 = r4 || 2;
          var n3, i3, s4, a3, o3, l3, u3, c3 = e4 && e4.length, h2 = c3 ? e4[0] * r4 : t3.length, p3 = dp(t3, 0, h2, r4, true), f2 = [];
          if (!p3 || p3.next === p3.prev)
            return f2;
          if (c3 && (p3 = function(t4, e5, r5, n4) {
            var i4, s5, a4, o4 = [];
            for (i4 = 0, s5 = e5.length; i4 < s5; i4++)
              (a4 = dp(t4, e5[i4] * n4, i4 < s5 - 1 ? e5[i4 + 1] * n4 : t4.length, n4, false)) === a4.next && (a4.steiner = true), o4.push(Sp(a4));
            for (o4.sort(_p), i4 = 0; i4 < o4.length; i4++)
              r5 = wp(o4[i4], r5);
            return r5;
          }(t3, e4, p3, r4)), t3.length > 80 * r4) {
            n3 = s4 = t3[0], i3 = a3 = t3[1];
            for (var d2 = r4; d2 < h2; d2 += r4)
              (o3 = t3[d2]) < n3 && (n3 = o3), (l3 = t3[d2 + 1]) < i3 && (i3 = l3), o3 > s4 && (s4 = o3), l3 > a3 && (a3 = l3);
            u3 = 0 !== (u3 = Math.max(s4 - n3, a3 - i3)) ? 32767 / u3 : 0;
          }
          return yp(p3, f2, r4, n3, i3, u3, 0), f2;
        }
        function dp(t3, e4, r4, n3, i3) {
          var s4, a3;
          if (i3 === Fp(t3, e4, r4, n3) > 0)
            for (s4 = e4; s4 < r4; s4 += n3)
              a3 = Vp(s4, t3[s4], t3[s4 + 1], a3);
          else
            for (s4 = r4 - n3; s4 >= e4; s4 -= n3)
              a3 = Vp(s4, t3[s4], t3[s4 + 1], a3);
          return a3 && Ep(a3, a3.next) && (Dp(a3), a3 = a3.next), a3;
        }
        function mp(t3, e4) {
          if (!t3)
            return t3;
          e4 || (e4 = t3);
          var r4, n3 = t3;
          do {
            if (r4 = false, n3.steiner || !Ep(n3, n3.next) && 0 !== Pp(n3.prev, n3, n3.next))
              n3 = n3.next;
            else {
              if (Dp(n3), (n3 = e4 = n3.prev) === n3.next)
                break;
              r4 = true;
            }
          } while (r4 || n3 !== e4);
          return e4;
        }
        function yp(t3, e4, r4, n3, i3, s4, a3) {
          if (t3) {
            !a3 && s4 && function(t4, e5, r5, n4) {
              var i4 = t4;
              do {
                0 === i4.z && (i4.z = Ap(i4.x, i4.y, e5, r5, n4)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
              } while (i4 !== t4);
              i4.prevZ.nextZ = null, i4.prevZ = null, function(t5) {
                var e6, r6, n5, i5, s5, a4, o4, l4, u4 = 1;
                do {
                  for (r6 = t5, t5 = null, s5 = null, a4 = 0; r6; ) {
                    for (a4++, n5 = r6, o4 = 0, e6 = 0; e6 < u4 && (o4++, n5 = n5.nextZ); e6++)
                      ;
                    for (l4 = u4; o4 > 0 || l4 > 0 && n5; )
                      0 !== o4 && (0 === l4 || !n5 || r6.z <= n5.z) ? (i5 = r6, r6 = r6.nextZ, o4--) : (i5 = n5, n5 = n5.nextZ, l4--), s5 ? s5.nextZ = i5 : t5 = i5, i5.prevZ = s5, s5 = i5;
                    r6 = n5;
                  }
                  s5.nextZ = null, u4 *= 2;
                } while (a4 > 1);
              }(i4);
            }(t3, n3, i3, s4);
            for (var o3, l3, u3 = t3; t3.prev !== t3.next; )
              if (o3 = t3.prev, l3 = t3.next, s4 ? xp(t3, n3, i3, s4) : gp(t3))
                e4.push(o3.i / r4 | 0), e4.push(t3.i / r4 | 0), e4.push(l3.i / r4 | 0), Dp(t3), t3 = l3.next, u3 = l3.next;
              else if ((t3 = l3) === u3) {
                a3 ? 1 === a3 ? yp(t3 = bp(mp(t3), e4, r4), e4, r4, n3, i3, s4, 2) : 2 === a3 && vp(t3, e4, r4, n3, i3, s4) : yp(mp(t3), e4, r4, n3, i3, s4, 1);
                break;
              }
          }
        }
        function gp(t3) {
          var e4 = t3.prev, r4 = t3, n3 = t3.next;
          if (Pp(e4, r4, n3) >= 0)
            return false;
          for (var i3 = e4.x, s4 = r4.x, a3 = n3.x, o3 = e4.y, l3 = r4.y, u3 = n3.y, c3 = i3 < s4 ? i3 < a3 ? i3 : a3 : s4 < a3 ? s4 : a3, h2 = o3 < l3 ? o3 < u3 ? o3 : u3 : l3 < u3 ? l3 : u3, p3 = i3 > s4 ? i3 > a3 ? i3 : a3 : s4 > a3 ? s4 : a3, f2 = o3 > l3 ? o3 > u3 ? o3 : u3 : l3 > u3 ? l3 : u3, d2 = n3.next; d2 !== e4; ) {
            if (d2.x >= c3 && d2.x <= p3 && d2.y >= h2 && d2.y <= f2 && Ip(i3, o3, s4, l3, a3, u3, d2.x, d2.y) && Pp(d2.prev, d2, d2.next) >= 0)
              return false;
            d2 = d2.next;
          }
          return true;
        }
        function xp(t3, e4, r4, n3) {
          var i3 = t3.prev, s4 = t3, a3 = t3.next;
          if (Pp(i3, s4, a3) >= 0)
            return false;
          for (var o3 = i3.x, l3 = s4.x, u3 = a3.x, c3 = i3.y, h2 = s4.y, p3 = a3.y, f2 = o3 < l3 ? o3 < u3 ? o3 : u3 : l3 < u3 ? l3 : u3, d2 = c3 < h2 ? c3 < p3 ? c3 : p3 : h2 < p3 ? h2 : p3, m2 = o3 > l3 ? o3 > u3 ? o3 : u3 : l3 > u3 ? l3 : u3, y3 = c3 > h2 ? c3 > p3 ? c3 : p3 : h2 > p3 ? h2 : p3, g3 = Ap(f2, d2, e4, r4, n3), x3 = Ap(m2, y3, e4, r4, n3), b2 = t3.prevZ, v3 = t3.nextZ; b2 && b2.z >= g3 && v3 && v3.z <= x3; ) {
            if (b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y3 && b2 !== i3 && b2 !== a3 && Ip(o3, c3, l3, h2, u3, p3, b2.x, b2.y) && Pp(b2.prev, b2, b2.next) >= 0)
              return false;
            if (b2 = b2.prevZ, v3.x >= f2 && v3.x <= m2 && v3.y >= d2 && v3.y <= y3 && v3 !== i3 && v3 !== a3 && Ip(o3, c3, l3, h2, u3, p3, v3.x, v3.y) && Pp(v3.prev, v3, v3.next) >= 0)
              return false;
            v3 = v3.nextZ;
          }
          for (; b2 && b2.z >= g3; ) {
            if (b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y3 && b2 !== i3 && b2 !== a3 && Ip(o3, c3, l3, h2, u3, p3, b2.x, b2.y) && Pp(b2.prev, b2, b2.next) >= 0)
              return false;
            b2 = b2.prevZ;
          }
          for (; v3 && v3.z <= x3; ) {
            if (v3.x >= f2 && v3.x <= m2 && v3.y >= d2 && v3.y <= y3 && v3 !== i3 && v3 !== a3 && Ip(o3, c3, l3, h2, u3, p3, v3.x, v3.y) && Pp(v3.prev, v3, v3.next) >= 0)
              return false;
            v3 = v3.nextZ;
          }
          return true;
        }
        function bp(t3, e4, r4) {
          var n3 = t3;
          do {
            var i3 = n3.prev, s4 = n3.next.next;
            !Ep(i3, s4) && zp(i3, n3, n3.next, s4) && Cp(i3, s4) && Cp(s4, i3) && (e4.push(i3.i / r4 | 0), e4.push(n3.i / r4 | 0), e4.push(s4.i / r4 | 0), Dp(n3), Dp(n3.next), n3 = t3 = s4), n3 = n3.next;
          } while (n3 !== t3);
          return mp(n3);
        }
        function vp(t3, e4, r4, n3, i3, s4) {
          var a3 = t3;
          do {
            for (var o3 = a3.next.next; o3 !== a3.prev; ) {
              if (a3.i !== o3.i && kp(a3, o3)) {
                var l3 = Rp(a3, o3);
                return a3 = mp(a3, a3.next), l3 = mp(l3, l3.next), yp(a3, e4, r4, n3, i3, s4, 0), void yp(l3, e4, r4, n3, i3, s4, 0);
              }
              o3 = o3.next;
            }
            a3 = a3.next;
          } while (a3 !== t3);
        }
        function _p(t3, e4) {
          return t3.x - e4.x;
        }
        function wp(t3, e4) {
          var r4 = function(t4, e5) {
            var r5, n4 = e5, i3 = t4.x, s4 = t4.y, a3 = -1 / 0;
            do {
              if (s4 <= n4.y && s4 >= n4.next.y && n4.next.y !== n4.y) {
                var o3 = n4.x + (s4 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                if (o3 <= i3 && o3 > a3 && (a3 = o3, r5 = n4.x < n4.next.x ? n4 : n4.next, o3 === i3))
                  return r5;
              }
              n4 = n4.next;
            } while (n4 !== e5);
            if (!r5)
              return null;
            var l3, u3 = r5, c3 = r5.x, h2 = r5.y, p3 = 1 / 0;
            n4 = r5;
            do {
              i3 >= n4.x && n4.x >= c3 && i3 !== n4.x && Ip(s4 < h2 ? i3 : a3, s4, c3, h2, s4 < h2 ? a3 : i3, s4, n4.x, n4.y) && (l3 = Math.abs(s4 - n4.y) / (i3 - n4.x), Cp(n4, t4) && (l3 < p3 || l3 === p3 && (n4.x > r5.x || n4.x === r5.x && Mp(r5, n4))) && (r5 = n4, p3 = l3)), n4 = n4.next;
            } while (n4 !== u3);
            return r5;
          }(t3, e4);
          if (!r4)
            return e4;
          var n3 = Rp(r4, t3);
          return mp(n3, n3.next), mp(r4, r4.next);
        }
        function Mp(t3, e4) {
          return Pp(t3.prev, t3, e4.prev) < 0 && Pp(e4.next, t3, t3.next) < 0;
        }
        function Ap(t3, e4, r4, n3, i3) {
          return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r4) * i3 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e4 = 1431655765 & ((e4 = 858993459 & ((e4 = 252645135 & ((e4 = 16711935 & ((e4 = (e4 - n3) * i3 | 0) | e4 << 8)) | e4 << 4)) | e4 << 2)) | e4 << 1)) << 1;
        }
        function Sp(t3) {
          var e4 = t3, r4 = t3;
          do {
            (e4.x < r4.x || e4.x === r4.x && e4.y < r4.y) && (r4 = e4), e4 = e4.next;
          } while (e4 !== t3);
          return r4;
        }
        function Ip(t3, e4, r4, n3, i3, s4, a3, o3) {
          return (i3 - a3) * (e4 - o3) >= (t3 - a3) * (s4 - o3) && (t3 - a3) * (n3 - o3) >= (r4 - a3) * (e4 - o3) && (r4 - a3) * (s4 - o3) >= (i3 - a3) * (n3 - o3);
        }
        function kp(t3, e4) {
          return t3.next.i !== e4.i && t3.prev.i !== e4.i && !function(t4, e5) {
            var r4 = t4;
            do {
              if (r4.i !== t4.i && r4.next.i !== t4.i && r4.i !== e5.i && r4.next.i !== e5.i && zp(r4, r4.next, t4, e5))
                return true;
              r4 = r4.next;
            } while (r4 !== t4);
            return false;
          }(t3, e4) && (Cp(t3, e4) && Cp(e4, t3) && function(t4, e5) {
            var r4 = t4, n3 = false, i3 = (t4.x + e5.x) / 2, s4 = (t4.y + e5.y) / 2;
            do {
              r4.y > s4 != r4.next.y > s4 && r4.next.y !== r4.y && i3 < (r4.next.x - r4.x) * (s4 - r4.y) / (r4.next.y - r4.y) + r4.x && (n3 = !n3), r4 = r4.next;
            } while (r4 !== t4);
            return n3;
          }(t3, e4) && (Pp(t3.prev, t3, e4.prev) || Pp(t3, e4.prev, e4)) || Ep(t3, e4) && Pp(t3.prev, t3, t3.next) > 0 && Pp(e4.prev, e4, e4.next) > 0);
        }
        function Pp(t3, e4, r4) {
          return (e4.y - t3.y) * (r4.x - e4.x) - (e4.x - t3.x) * (r4.y - e4.y);
        }
        function Ep(t3, e4) {
          return t3.x === e4.x && t3.y === e4.y;
        }
        function zp(t3, e4, r4, n3) {
          var i3 = Bp(Pp(t3, e4, r4)), s4 = Bp(Pp(t3, e4, n3)), a3 = Bp(Pp(r4, n3, t3)), o3 = Bp(Pp(r4, n3, e4));
          return i3 !== s4 && a3 !== o3 || !(0 !== i3 || !Tp(t3, r4, e4)) || !(0 !== s4 || !Tp(t3, n3, e4)) || !(0 !== a3 || !Tp(r4, t3, n3)) || !(0 !== o3 || !Tp(r4, e4, n3));
        }
        function Tp(t3, e4, r4) {
          return e4.x <= Math.max(t3.x, r4.x) && e4.x >= Math.min(t3.x, r4.x) && e4.y <= Math.max(t3.y, r4.y) && e4.y >= Math.min(t3.y, r4.y);
        }
        function Bp(t3) {
          return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
        }
        function Cp(t3, e4) {
          return Pp(t3.prev, t3, t3.next) < 0 ? Pp(t3, e4, t3.next) >= 0 && Pp(t3, t3.prev, e4) >= 0 : Pp(t3, e4, t3.prev) < 0 || Pp(t3, t3.next, e4) < 0;
        }
        function Rp(t3, e4) {
          var r4 = new Lp(t3.i, t3.x, t3.y), n3 = new Lp(e4.i, e4.x, e4.y), i3 = t3.next, s4 = e4.prev;
          return t3.next = e4, e4.prev = t3, r4.next = i3, i3.prev = r4, n3.next = r4, r4.prev = n3, s4.next = n3, n3.prev = s4, n3;
        }
        function Vp(t3, e4, r4, n3) {
          var i3 = new Lp(t3, e4, r4);
          return n3 ? (i3.next = n3.next, i3.prev = n3, n3.next.prev = i3, n3.next = i3) : (i3.prev = i3, i3.next = i3), i3;
        }
        function Dp(t3) {
          t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
        }
        function Lp(t3, e4, r4) {
          this.i = t3, this.x = e4, this.y = r4, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Fp(t3, e4, r4, n3) {
          for (var i3 = 0, s4 = e4, a3 = r4 - n3; s4 < r4; s4 += n3)
            i3 += (t3[a3] - t3[s4]) * (t3[s4 + 1] + t3[a3 + 1]), a3 = s4;
          return i3;
        }
        pp.exports = fp, pp.exports.default = fp, fp.deviation = function(t3, e4, r4, n3) {
          var i3 = e4 && e4.length, s4 = Math.abs(Fp(t3, 0, i3 ? e4[0] * r4 : t3.length, r4));
          if (i3)
            for (var a3 = 0, o3 = e4.length; a3 < o3; a3++)
              s4 -= Math.abs(Fp(t3, e4[a3] * r4, a3 < o3 - 1 ? e4[a3 + 1] * r4 : t3.length, r4));
          var l3 = 0;
          for (a3 = 0; a3 < n3.length; a3 += 3) {
            var u3 = n3[a3] * r4, c3 = n3[a3 + 1] * r4, h2 = n3[a3 + 2] * r4;
            l3 += Math.abs((t3[u3] - t3[h2]) * (t3[c3 + 1] - t3[u3 + 1]) - (t3[u3] - t3[c3]) * (t3[h2 + 1] - t3[u3 + 1]));
          }
          return 0 === s4 && 0 === l3 ? 0 : Math.abs((l3 - s4) / s4);
        }, fp.flatten = function(t3) {
          for (var e4 = t3[0][0].length, r4 = { vertices: [], holes: [], dimensions: e4 }, n3 = 0, i3 = 0; i3 < t3.length; i3++) {
            for (var s4 = 0; s4 < t3[i3].length; s4++)
              for (var a3 = 0; a3 < e4; a3++)
                r4.vertices.push(t3[i3][s4][a3]);
            i3 > 0 && r4.holes.push(n3 += t3[i3 - 1].length);
          }
          return r4;
        };
        var Op = h(pp.exports);
        function Up(t3, e4) {
          const r4 = t3.length;
          if (r4 <= 1)
            return [t3];
          const n3 = [];
          let i3, s4;
          for (let e5 = 0; e5 < r4; e5++) {
            const r5 = fr(t3[e5]);
            0 !== r5 && (t3[e5].area = Math.abs(r5), void 0 === s4 && (s4 = r5 < 0), s4 === r5 < 0 ? (i3 && n3.push(i3), i3 = [t3[e5]]) : i3.push(t3[e5]));
          }
          if (i3 && n3.push(i3), e4 > 1)
            for (let t4 = 0; t4 < n3.length; t4++)
              n3[t4].length <= e4 || (Ri(n3[t4], e4, 1, n3[t4].length - 1, Np), n3[t4] = n3[t4].slice(0, e4));
          return n3;
        }
        function Np(t3, e4) {
          return e4.area - t3.area;
        }
        function jp(t3, e4, r4) {
          const n3 = r4.patternDependencies;
          let i3 = false;
          for (const r5 of e4) {
            const e5 = r5.paint.get(`${t3}-pattern`);
            e5.isConstant() || (i3 = true);
            const s4 = e5.constantOr(null);
            s4 && (i3 = true, n3[s4] = true);
          }
          return i3;
        }
        function qp(t3, e4, r4, n3, i3) {
          const s4 = i3.patternDependencies;
          for (const a3 of e4) {
            const e5 = a3.paint.get(`${t3}-pattern`).value;
            if ("constant" !== e5.kind) {
              let t4 = e5.evaluate({ zoom: n3 }, r4, {}, i3.availableImages);
              t4 = t4 && t4.name ? t4.name : t4, s4[t4] = true, r4.patterns[a3.id] = t4;
            }
          }
          return r4;
        }
        class $p {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.fqid), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Sl(), this.indexArray = new ql(), this.indexArray2 = new Fl(), this.programConfigurations = new ju(t3.layers, t3.zoom), this.segments = new mu(), this.segments2 = new mu(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.projection = t3.projection;
          }
          populate(t3, e4, r4, n3) {
            this.hasPattern = jp("fill", this.layers, e4);
            const i3 = this.layers[0].layout.get("fill-sort-key"), s4 = [];
            for (const { feature: a3, id: o3, index: l3, sourceLayerIndex: u3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, c3 = Fc(a3, t4);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), c3, r4))
                continue;
              const h2 = i3 ? i3.evaluate(c3, {}, r4, e4.availableImages) : void 0, p3 = { id: o3, properties: a3.properties, type: a3.type, sourceLayerIndex: u3, index: l3, geometry: t4 ? c3.geometry : Lc(a3, r4, n3), patterns: {}, sortKey: h2 };
              s4.push(p3);
            }
            i3 && s4.sort((t4, e5) => t4.sortKey - e5.sortKey);
            for (const n4 of s4) {
              const { geometry: i4, index: s5, sourceLayerIndex: a3 } = n4;
              if (this.hasPattern) {
                const t4 = qp("fill", this.layers, n4, this.zoom, e4);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n4, i4, s5, r4, {}, e4.availableImages, e4.brightness);
              e4.featureIndex.insert(t3[s5].feature, i4, s5, a3, this.index);
            }
          }
          update(t3, e4, r4, n3, i3) {
            const s4 = 0 !== Object.keys(t3).length;
            s4 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t3, e4, s4 ? this.stateDependentLayers : this.layers, r4, n3, i3);
          }
          addFeatures(t3, e4, r4, n3, i3, s4) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e4, r4, n3, s4);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, hp), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t3, e4, r4, n3, i3, s4 = [], a3) {
            for (const t4 of Up(e4, 500)) {
              let e5 = 0;
              for (const r6 of t4)
                e5 += r6.length;
              const r5 = this.segments.prepareSegment(e5, this.layoutVertexArray, this.indexArray), n4 = r5.vertexLength, i4 = [], s5 = [];
              for (const e6 of t4) {
                if (0 === e6.length)
                  continue;
                e6 !== t4[0] && s5.push(i4.length / 2);
                const r6 = this.segments2.prepareSegment(e6.length, this.layoutVertexArray, this.indexArray2), n5 = r6.vertexLength;
                this.layoutVertexArray.emplaceBack(e6[0].x, e6[0].y), this.indexArray2.emplaceBack(n5 + e6.length - 1, n5), i4.push(e6[0].x), i4.push(e6[0].y);
                for (let t5 = 1; t5 < e6.length; t5++)
                  this.layoutVertexArray.emplaceBack(e6[t5].x, e6[t5].y), this.indexArray2.emplaceBack(n5 + t5 - 1, n5 + t5), i4.push(e6[t5].x), i4.push(e6[t5].y);
                r6.vertexLength += e6.length, r6.primitiveLength += e6.length;
              }
              const a4 = Op(i4, s5);
              for (let t5 = 0; t5 < a4.length; t5 += 3)
                this.indexArray.emplaceBack(n4 + a4[t5], n4 + a4[t5 + 1], n4 + a4[t5 + 2]);
              r5.vertexLength += e5, r5.primitiveLength += a4.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r4, i3, s4, n3, a3);
          }
        }
        fo($p, "FillBucket", { omit: ["layers", "patternFeatures"] });
        const Gp = new Ho({ "fill-sort-key": new Ko(el.layout_fill["fill-sort-key"]), visibility: new Zo(el.layout_fill.visibility) });
        var Qp = { paint: new Ho({ "fill-antialias": new Zo(el.paint_fill["fill-antialias"]), "fill-opacity": new Ko(el.paint_fill["fill-opacity"]), "fill-color": new Ko(el.paint_fill["fill-color"]), "fill-outline-color": new Ko(el.paint_fill["fill-outline-color"]), "fill-translate": new Zo(el.paint_fill["fill-translate"]), "fill-translate-anchor": new Zo(el.paint_fill["fill-translate-anchor"]), "fill-pattern": new Ko(el.paint_fill["fill-pattern"]), "fill-emissive-strength": new Zo(el.paint_fill["fill-emissive-strength"]) }), layout: Gp };
        const Yp = Ml([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Xp = Ml([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Zp = Ml([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Kp = Ml([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Wp = Ml([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Hp } = Yp;
        var Jp = {}, tf = Fe, ef = rf;
        function rf(t3, e4, r4, n3, i3) {
          this.properties = {}, this.extent = r4, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n3, this._values = i3, t3.readFields(nf, this, e4);
        }
        function nf(t3, e4, r4) {
          1 == t3 ? e4.id = r4.readVarint() : 2 == t3 ? function(t4, e5) {
            for (var r5 = t4.readVarint() + t4.pos; t4.pos < r5; ) {
              var n3 = e5._keys[t4.readVarint()], i3 = e5._values[t4.readVarint()];
              e5.properties[n3] = i3;
            }
          }(r4, e4) : 3 == t3 ? e4.type = r4.readVarint() : 4 == t3 && (e4._geometry = r4.pos);
        }
        function sf(t3) {
          for (var e4, r4, n3 = 0, i3 = 0, s4 = t3.length, a3 = s4 - 1; i3 < s4; a3 = i3++)
            n3 += ((r4 = t3[a3]).x - (e4 = t3[i3]).x) * (e4.y + r4.y);
          return n3;
        }
        rf.types = ["Unknown", "Point", "LineString", "Polygon"], rf.prototype.loadGeometry = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e4, r4 = t3.readVarint() + t3.pos, n3 = 1, i3 = 0, s4 = 0, a3 = 0, o3 = []; t3.pos < r4; ) {
            if (i3 <= 0) {
              var l3 = t3.readVarint();
              n3 = 7 & l3, i3 = l3 >> 3;
            }
            if (i3--, 1 === n3 || 2 === n3)
              s4 += t3.readSVarint(), a3 += t3.readSVarint(), 1 === n3 && (e4 && o3.push(e4), e4 = []), e4.push(new tf(s4, a3));
            else {
              if (7 !== n3)
                throw new Error("unknown command " + n3);
              e4 && e4.push(e4[0].clone());
            }
          }
          return e4 && o3.push(e4), o3;
        }, rf.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e4 = t3.readVarint() + t3.pos, r4 = 1, n3 = 0, i3 = 0, s4 = 0, a3 = 1 / 0, o3 = -1 / 0, l3 = 1 / 0, u3 = -1 / 0; t3.pos < e4; ) {
            if (n3 <= 0) {
              var c3 = t3.readVarint();
              r4 = 7 & c3, n3 = c3 >> 3;
            }
            if (n3--, 1 === r4 || 2 === r4)
              (i3 += t3.readSVarint()) < a3 && (a3 = i3), i3 > o3 && (o3 = i3), (s4 += t3.readSVarint()) < l3 && (l3 = s4), s4 > u3 && (u3 = s4);
            else if (7 !== r4)
              throw new Error("unknown command " + r4);
          }
          return [a3, l3, o3, u3];
        }, rf.prototype.toGeoJSON = function(t3, e4, r4) {
          var n3, i3, s4 = this.extent * Math.pow(2, r4), a3 = this.extent * t3, o3 = this.extent * e4, l3 = this.loadGeometry(), u3 = rf.types[this.type];
          function c3(t4) {
            for (var e5 = 0; e5 < t4.length; e5++) {
              var r5 = t4[e5];
              t4[e5] = [360 * (r5.x + a3) / s4 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r5.y + o3) / s4) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n3 = 0; n3 < l3.length; n3++)
                h2[n3] = l3[n3][0];
              c3(l3 = h2);
              break;
            case 2:
              for (n3 = 0; n3 < l3.length; n3++)
                c3(l3[n3]);
              break;
            case 3:
              for (l3 = function(t4) {
                var e5 = t4.length;
                if (e5 <= 1)
                  return [t4];
                for (var r5, n4, i4 = [], s5 = 0; s5 < e5; s5++) {
                  var a4 = sf(t4[s5]);
                  0 !== a4 && (void 0 === n4 && (n4 = a4 < 0), n4 === a4 < 0 ? (r5 && i4.push(r5), r5 = [t4[s5]]) : r5.push(t4[s5]));
                }
                return r5 && i4.push(r5), i4;
              }(l3), n3 = 0; n3 < l3.length; n3++)
                for (i3 = 0; i3 < l3[n3].length; i3++)
                  c3(l3[n3][i3]);
          }
          1 === l3.length ? l3 = l3[0] : u3 = "Multi" + u3;
          var p3 = { type: "Feature", geometry: { type: u3, coordinates: l3 }, properties: this.properties };
          return "id" in this && (p3.id = this.id), p3;
        };
        var af = ef, of = lf;
        function lf(t3, e4) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(uf, this, e4), this.length = this._features.length;
        }
        function uf(t3, e4, r4) {
          15 === t3 ? e4.version = r4.readVarint() : 1 === t3 ? e4.name = r4.readString() : 5 === t3 ? e4.extent = r4.readVarint() : 2 === t3 ? e4._features.push(r4.pos) : 3 === t3 ? e4._keys.push(r4.readString()) : 4 === t3 && e4._values.push(function(t4) {
            for (var e5 = null, r5 = t4.readVarint() + t4.pos; t4.pos < r5; ) {
              var n3 = t4.readVarint() >> 3;
              e5 = 1 === n3 ? t4.readString() : 2 === n3 ? t4.readFloat() : 3 === n3 ? t4.readDouble() : 4 === n3 ? t4.readVarint64() : 5 === n3 ? t4.readVarint() : 6 === n3 ? t4.readSVarint() : 7 === n3 ? t4.readBoolean() : null;
            }
            return e5;
          }(r4));
        }
        lf.prototype.feature = function(t3) {
          if (t3 < 0 || t3 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t3];
          var e4 = this._pbf.readVarint() + this._pbf.pos;
          return new af(this._pbf, e4, this.extent, this._keys, this._values);
        };
        var cf = of;
        function hf(t3, e4, r4) {
          if (3 === t3) {
            var n3 = new cf(r4, r4.readVarint() + r4.pos);
            n3.length && (e4[n3.name] = n3);
          }
        }
        var pf = Jp.VectorTile = function(t3, e4) {
          this.layers = t3.readFields(hf, {}, e4);
        }, ff = Jp.VectorTileFeature = ef;
        function df(t3, e4, r4, n3) {
          const i3 = [], s4 = 0 === n3 ? (t4, e5, r5, n4, i4, s5) => {
            t4.push(new Ue(s5, r5 + (s5 - e5) / (n4 - e5) * (i4 - r5)));
          } : (t4, e5, r5, n4, i4, s5) => {
            t4.push(new Ue(e5 + (s5 - r5) / (i4 - r5) * (n4 - e5), s5));
          };
          for (const a3 of t3) {
            const t4 = [];
            for (const i4 of a3) {
              if (i4.length <= 2)
                continue;
              const a4 = [];
              for (let t5 = 0; t5 < i4.length - 1; t5++) {
                const o4 = i4[t5].x, l4 = i4[t5].y, u3 = i4[t5 + 1].x, c3 = i4[t5 + 1].y, h2 = 0 === n3 ? o4 : l4, p3 = 0 === n3 ? u3 : c3;
                h2 < e4 ? p3 > e4 && s4(a4, o4, l4, u3, c3, e4) : h2 > r4 ? p3 < r4 && s4(a4, o4, l4, u3, c3, r4) : a4.push(i4[t5]), p3 < e4 && h2 >= e4 && s4(a4, o4, l4, u3, c3, e4), p3 > r4 && h2 <= r4 && s4(a4, o4, l4, u3, c3, r4);
              }
              let o3 = i4[i4.length - 1];
              const l3 = 0 === n3 ? o3.x : o3.y;
              l3 >= e4 && l3 <= r4 && a4.push(o3), a4.length && (o3 = a4[a4.length - 1], a4[0].x === o3.x && a4[0].y === o3.y || a4.push(a4[0]), t4.push(a4));
            }
            t4.length && i3.push(t4);
          }
          return i3;
        }
        function mf(t3, e4) {
          return t3.x - e4.x || t3.y - e4.y;
        }
        function yf(t3, e4) {
          return 0 === mf(t3.min, e4.min) && 0 === mf(t3.max, e4.max);
        }
        function gf(t3, e4) {
          return !(t3.min.x > e4.max.x || t3.max.x < e4.min.x || t3.min.y > e4.max.y || t3.max.y < e4.min.y);
        }
        function xf(t3, e4, r4) {
          const n3 = 1 / is, i3 = 1 / (1 << r4.canonical.z), s4 = (e4.x * n3 + r4.canonical.x) * i3 + r4.wrap, a3 = (e4.y * n3 + r4.canonical.y) * i3;
          return { min: new Ue((t3.x * n3 + r4.canonical.x) * i3 + r4.wrap, (t3.y * n3 + r4.canonical.y) * i3), max: new Ue(s4, a3) };
        }
        function bf(t3, e4, r4) {
          const n3 = 1 << r4.canonical.z, i3 = ((e4.x - r4.wrap) * n3 - r4.canonical.x) * is, s4 = (e4.y * n3 - r4.canonical.y) * is;
          return { min: new Ue(((t3.x - r4.wrap) * n3 - r4.canonical.x) * is, (t3.y * n3 - r4.canonical.y) * is), max: new Ue(i3, s4) };
        }
        function vf(t3, e4, r4, n3, i3, s4, a3) {
          const o3 = t3.indices, l3 = t3.vertices, u3 = [];
          for (let c3 = n3; c3 < n3 + i3; c3 += 3) {
            const n4 = e4[r4[c3 + 0] + s4], i4 = e4[r4[c3 + 1] + s4], h2 = e4[r4[c3 + 2] + s4], p3 = Math.min(n4.x, i4.x, h2.x), f2 = Math.max(n4.x, i4.x, h2.x), d2 = Math.min(n4.y, i4.y, h2.y), m2 = Math.max(n4.y, i4.y, h2.y);
            u3.length = 0, t3.grid.query(new Ue(p3, d2), new Ue(f2, m2), u3);
            for (let t4 = 0; t4 < u3.length; t4++) {
              const e5 = u3[t4];
              if (eh(l3[o3[3 * e5 + 0]], l3[o3[3 * e5 + 1]], l3[o3[3 * e5 + 2]], n4, i4, h2, a3))
                return true;
            }
          }
          return false;
        }
        function _f(t3, e4, r4, n3) {
          if (!t3 || !r4)
            return false;
          let i3 = t3.vertices;
          if (!e4.canonical.equals(n3.canonical) || e4.wrap !== n3.wrap) {
            if (r4.vertices.length < t3.vertices.length)
              return _f(r4, n3, t3, e4);
            const s4 = e4.canonical, a3 = n3.canonical, o3 = Math.pow(2, a3.z - s4.z);
            i3 = t3.vertices.map((t4) => new Ue((t4.x + s4.x * is) * o3 - a3.x * is, (t4.y + s4.y * is) * o3 - a3.y * is));
          }
          return vf(r4, i3, t3.indices, 0, t3.indices.length, 0, 0);
        }
        Jp.VectorTileLayer = of;
        class wf {
          constructor(t3) {
            this.size = t3, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(t3, e4) {
            const r4 = this.toIdx(t3, e4);
            return { min: this.minimums[r4], max: this.maximums[r4] };
          }
          isLeaf(t3, e4) {
            return this.leaves[this.toIdx(t3, e4)];
          }
          toIdx(t3, e4) {
            return e4 * this.size + t3;
          }
        }
        function Mf(t3, e4, r4, n3) {
          let i3 = 0, s4 = Number.MAX_VALUE;
          for (let a3 = 0; a3 < 3; a3++)
            if (Math.abs(n3[a3]) < 1e-15) {
              if (r4[a3] < t3[a3] || r4[a3] > e4[a3])
                return null;
            } else {
              const o3 = 1 / n3[a3];
              let l3 = (t3[a3] - r4[a3]) * o3, u3 = (e4[a3] - r4[a3]) * o3;
              if (l3 > u3) {
                const t4 = l3;
                l3 = u3, u3 = t4;
              }
              if (l3 > i3 && (i3 = l3), u3 < s4 && (s4 = u3), i3 > s4)
                return null;
            }
          return i3;
        }
        function Af(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3) {
          const h2 = n3 - t3, p3 = i3 - e4, f2 = s4 - r4, d2 = a3 - t3, m2 = o3 - e4, y3 = l3 - r4, g3 = c3[1] * y3 - c3[2] * m2, x3 = c3[2] * d2 - c3[0] * y3, b2 = c3[0] * m2 - c3[1] * d2, v3 = h2 * g3 + p3 * x3 + f2 * b2;
          if (Math.abs(v3) < 1e-15)
            return null;
          const _3 = 1 / v3, w2 = u3[0] - t3, M3 = u3[1] - e4, A2 = u3[2] - r4, S2 = (w2 * g3 + M3 * x3 + A2 * b2) * _3;
          if (S2 < 0 || S2 > 1)
            return null;
          const I2 = M3 * f2 - A2 * p3, k2 = A2 * h2 - w2 * f2, P2 = w2 * p3 - M3 * h2, E2 = (c3[0] * I2 + c3[1] * k2 + c3[2] * P2) * _3;
          return E2 < 0 || S2 + E2 > 1 ? null : (d2 * I2 + m2 * k2 + y3 * P2) * _3;
        }
        function Sf(t3, e4, r4) {
          return (t3 - e4) / (r4 - e4);
        }
        function If(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          const u3 = 1 << r4, c3 = s4 - n3, h2 = a3 - i3, p3 = (t3 + 1) / u3 * c3 + n3, f2 = (e4 + 0) / u3 * h2 + i3, d2 = (e4 + 1) / u3 * h2 + i3;
          o3[0] = (t3 + 0) / u3 * c3 + n3, o3[1] = f2, l3[0] = p3, l3[1] = d2;
        }
        class kf {
          constructor(t3) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t3, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
              return;
            const e4 = function(t4) {
              const e5 = Math.ceil(Math.log2(t4.dim / 8)), r5 = [];
              let n4 = Math.ceil(Math.pow(2, e5));
              const i3 = 1 / n4, s4 = (t5, e6, r6, n5, i4) => {
                const s5 = n5 ? 1 : 0, a4 = (t5 + 1) * r6 - s5, o4 = e6 * r6, l3 = (e6 + 1) * r6 - s5;
                i4[0] = t5 * r6, i4[1] = o4, i4[2] = a4, i4[3] = l3;
              };
              let a3 = new wf(n4);
              const o3 = [];
              for (let e6 = 0; e6 < n4 * n4; e6++) {
                s4(e6 % n4, Math.floor(e6 / n4), i3, false, o3);
                const r6 = Ef(o3[0], o3[1], t4), l3 = Ef(o3[2], o3[1], t4), u3 = Ef(o3[2], o3[3], t4), c3 = Ef(o3[0], o3[3], t4);
                a3.minimums.push(Math.min(r6, l3, u3, c3)), a3.maximums.push(Math.max(r6, l3, u3, c3)), a3.leaves.push(1);
              }
              for (r5.push(a3), n4 /= 2; n4 >= 1; n4 /= 2) {
                const t5 = r5[r5.length - 1];
                a3 = new wf(n4);
                for (let e6 = 0; e6 < n4 * n4; e6++) {
                  s4(e6 % n4, Math.floor(e6 / n4), 2, true, o3);
                  const r6 = t5.getElevation(o3[0], o3[1]), i4 = t5.getElevation(o3[2], o3[1]), l3 = t5.getElevation(o3[2], o3[3]), u3 = t5.getElevation(o3[0], o3[3]), c3 = t5.isLeaf(o3[0], o3[1]), h2 = t5.isLeaf(o3[2], o3[1]), p3 = t5.isLeaf(o3[2], o3[3]), f2 = t5.isLeaf(o3[0], o3[3]), d2 = Math.min(r6.min, i4.min, l3.min, u3.min), m2 = Math.max(r6.max, i4.max, l3.max, u3.max), y3 = c3 && h2 && p3 && f2;
                  a3.maximums.push(m2), a3.minimums.push(d2), a3.leaves.push(m2 - d2 <= 5 && y3 ? 1 : 0);
                }
                r5.push(a3);
              }
              return r5;
            }(this.dem), r4 = e4.length - 1, n3 = e4[r4];
            this._addNode(n3.minimums[0], n3.maximums[0], n3.leaves[0]), this._construct(e4, 0, 0, r4, 0);
          }
          raycastRoot(t3, e4, r4, n3, i3, s4, a3 = 1) {
            return Mf([t3, e4, -100], [r4, n3, this.maximums[0] * a3], i3, s4);
          }
          raycast(e4, r4, n3, i3, s4, a3, o3 = 1) {
            if (!this.nodeCount)
              return null;
            const l3 = this.raycastRoot(e4, r4, n3, i3, s4, a3, o3);
            if (null == l3)
              return null;
            const u3 = [], c3 = [], h2 = [], p3 = [], f2 = [{ idx: 0, t: l3, nodex: 0, nodey: 0, depth: 0 }];
            for (; f2.length > 0; ) {
              const { idx: l4, t: d2, nodex: m2, nodey: y3, depth: g3 } = f2.pop();
              if (this.leaves[l4]) {
                If(m2, y3, g3, e4, r4, n3, i3, h2, p3);
                const l5 = 1 << g3, u4 = (m2 + 0) / l5, c4 = (m2 + 1) / l5, f3 = (y3 + 0) / l5, x4 = (y3 + 1) / l5, b2 = Ef(u4, f3, this.dem) * o3, v3 = Ef(c4, f3, this.dem) * o3, _3 = Ef(c4, x4, this.dem) * o3, w2 = Ef(u4, x4, this.dem) * o3, M3 = Af(h2[0], h2[1], b2, p3[0], h2[1], v3, p3[0], p3[1], _3, s4, a3), A2 = Af(p3[0], p3[1], _3, h2[0], p3[1], w2, h2[0], h2[1], b2, s4, a3), S2 = Math.min(null !== M3 ? M3 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                if (S2 !== Number.MAX_VALUE)
                  return S2;
                {
                  const e5 = t2.Q.scaleAndAdd([], s4, a3, d2);
                  if (Pf(b2, v3, w2, _3, Sf(e5[0], h2[0], p3[0]), Sf(e5[1], h2[1], p3[1])) >= e5[2])
                    return d2;
                }
                continue;
              }
              let x3 = 0;
              for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
                If((m2 << 1) + this._siblingOffset[t3][0], (y3 << 1) + this._siblingOffset[t3][1], g3 + 1, e4, r4, n3, i3, h2, p3), h2[2] = -100, p3[2] = this.maximums[this.childOffsets[l4] + t3] * o3;
                const f3 = Mf(h2, p3, s4, a3);
                if (null != f3) {
                  const e5 = f3;
                  u3[t3] = e5;
                  let r5 = false;
                  for (let n4 = 0; n4 < x3 && !r5; n4++)
                    e5 >= u3[c3[n4]] && (c3.splice(n4, 0, t3), r5 = true);
                  r5 || (c3[x3] = t3), x3++;
                }
              }
              for (let t3 = 0; t3 < x3; t3++) {
                const e5 = c3[t3];
                f2.push({ idx: this.childOffsets[l4] + e5, t: u3[e5], nodex: (m2 << 1) + this._siblingOffset[e5][0], nodey: (y3 << 1) + this._siblingOffset[e5][1], depth: g3 + 1 });
              }
            }
            return null;
          }
          _addNode(t3, e4, r4) {
            return this.minimums.push(t3), this.maximums.push(e4), this.leaves.push(r4), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(t3, e4, r4, n3, i3) {
            if (1 === t3[n3].isLeaf(e4, r4))
              return;
            this.childOffsets[i3] || (this.childOffsets[i3] = this.nodeCount);
            const s4 = n3 - 1, a3 = t3[s4];
            let o3 = 0, l3 = 0;
            for (let t4 = 0; t4 < this._siblingOffset.length; t4++) {
              const n4 = 2 * e4 + this._siblingOffset[t4][0], i4 = 2 * r4 + this._siblingOffset[t4][1], s5 = a3.getElevation(n4, i4), u3 = a3.isLeaf(n4, i4), c3 = this._addNode(s5.min, s5.max, u3);
              u3 && (o3 |= 1 << t4), l3 || (l3 = c3);
            }
            for (let n4 = 0; n4 < this._siblingOffset.length; n4++)
              o3 & 1 << n4 || this._construct(t3, 2 * e4 + this._siblingOffset[n4][0], 2 * r4 + this._siblingOffset[n4][1], s4, l3 + n4);
          }
        }
        function Pf(t3, e4, r4, n3, i3, s4) {
          return qn(qn(t3, r4, s4), qn(e4, n3, s4), i3);
        }
        function Ef(t3, e4, r4) {
          const n3 = r4.dim, i3 = Ze(t3 * n3 - 0.5, 0, n3 - 1), s4 = Ze(e4 * n3 - 0.5, 0, n3 - 1), a3 = Math.floor(i3), o3 = Math.floor(s4), l3 = Math.min(a3 + 1, n3 - 1), u3 = Math.min(o3 + 1, n3 - 1);
          return Pf(r4.get(a3, o3), r4.get(l3, o3), r4.get(a3, u3), r4.get(l3, u3), i3 - a3, s4 - o3);
        }
        const zf = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function Tf(t3, e4, r4) {
          return (256 * t3 * 256 + 256 * e4 + r4) / 10 - 1e4;
        }
        function Bf(t3, e4, r4) {
          return 256 * t3 + e4 + r4 / 256 - 32768;
        }
        class Cf {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(t3, e4, r4, n3 = false) {
            if (this.uid = t3, e4.height !== e4.width)
              throw new RangeError("DEM tiles must be square");
            if (r4 && "mapbox" !== r4 && "terrarium" !== r4)
              return hr(`"${r4}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e4.height;
            const i3 = this.dim = e4.height - 2, s4 = new Uint32Array(e4.data.buffer);
            if (this.pixels = new Uint8Array(e4.data.buffer), this.floatView = new Float32Array(e4.data.buffer), this.borderReady = n3, this._modifiedForSources = {}, !n3) {
              for (let t4 = 0; t4 < i3; t4++)
                s4[this._idx(-1, t4)] = s4[this._idx(0, t4)], s4[this._idx(i3, t4)] = s4[this._idx(i3 - 1, t4)], s4[this._idx(t4, -1)] = s4[this._idx(t4, 0)], s4[this._idx(t4, i3)] = s4[this._idx(t4, i3 - 1)];
              s4[this._idx(-1, -1)] = s4[this._idx(0, 0)], s4[this._idx(i3, -1)] = s4[this._idx(i3 - 1, 0)], s4[this._idx(-1, i3)] = s4[this._idx(0, i3 - 1)], s4[this._idx(i3, i3)] = s4[this._idx(i3 - 1, i3 - 1)];
            }
            const a3 = "terrarium" === r4 ? Bf : Tf;
            for (let t4 = 0; t4 < s4.length; ++t4) {
              const e5 = 4 * t4;
              this.floatView[t4] = a3(this.pixels[e5], this.pixels[e5 + 1], this.pixels[e5 + 2]);
            }
            this._timestamp = Tr.now();
          }
          _buildQuadTree() {
            this._tree = new kf(this);
          }
          get(t3, e4, r4 = false) {
            r4 && (t3 = Ze(t3, -1, this.dim), e4 = Ze(e4, -1, this.dim));
            const n3 = this._idx(t3, e4);
            return this.floatView[n3];
          }
          set(t3, e4, r4) {
            const n3 = this._idx(t3, e4), i3 = this.floatView[n3];
            return this.floatView[n3] = r4, r4 - i3;
          }
          static getUnpackVector(t3) {
            return zf[t3];
          }
          _idx(t3, e4) {
            if (t3 < -1 || t3 >= this.dim + 1 || e4 < -1 || e4 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e4 + 1) * this.stride + (t3 + 1);
          }
          static pack(t3, e4) {
            const r4 = [0, 0, 0, 0], n3 = Cf.getUnpackVector(e4);
            let i3 = Math.floor((t3 + n3[3]) / n3[2]);
            return r4[2] = i3 % 256, i3 = Math.floor(i3 / 256), r4[1] = i3 % 256, i3 = Math.floor(i3 / 256), r4[0] = i3, r4;
          }
          getPixels() {
            return new ip({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(t3, e4, r4) {
            if (this.dim !== t3.dim)
              throw new Error("dem dimension mismatch");
            let n3 = e4 * this.dim, i3 = e4 * this.dim + this.dim, s4 = r4 * this.dim, a3 = r4 * this.dim + this.dim;
            switch (e4) {
              case -1:
                n3 = i3 - 1;
                break;
              case 1:
                i3 = n3 + 1;
            }
            switch (r4) {
              case -1:
                s4 = a3 - 1;
                break;
              case 1:
                a3 = s4 + 1;
            }
            const o3 = -e4 * this.dim, l3 = -r4 * this.dim;
            for (let e5 = s4; e5 < a3; e5++)
              for (let r5 = n3; r5 < i3; r5++) {
                const n4 = 4 * this._idx(r5, e5), i4 = 4 * this._idx(r5 + o3, e5 + l3);
                this.pixels[n4 + 0] = t3.pixels[i4 + 0], this.pixels[n4 + 1] = t3.pixels[i4 + 1], this.pixels[n4 + 2] = t3.pixels[i4 + 2], this.pixels[n4 + 3] = t3.pixels[i4 + 3];
              }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        fo(Cf, "DEMData"), fo(kf, "DemMinMaxQuadTree", { omit: ["dem"] });
        class Rf {
          constructor(t3, e4, r4) {
            this._demTile = t3, this._dem = this._demTile.dem, this._scale = e4, this._offset = r4;
          }
          static create(t3, e4, r4) {
            const n3 = r4 || t3.findDEMTileFor(e4);
            if (!n3 || !n3.dem)
              return;
            const i3 = n3.dem, s4 = n3.tileID, a3 = 1 << e4.canonical.z - s4.canonical.z;
            return new Rf(n3, i3.dim / is / a3, [(e4.canonical.x / a3 - s4.canonical.x) * i3.dim, (e4.canonical.y / a3 - s4.canonical.y) * i3.dim]);
          }
          tileCoordToPixel(t3, e4) {
            const r4 = e4 * this._scale + this._offset[1], n3 = Math.floor(t3 * this._scale + this._offset[0]), i3 = Math.floor(r4);
            return new Ue(n3, i3);
          }
          getElevationAt(t3, e4, r4, n3) {
            const i3 = t3 * this._scale + this._offset[0], s4 = e4 * this._scale + this._offset[1], a3 = Math.floor(i3), o3 = Math.floor(s4), l3 = this._dem;
            return n3 = !!n3, r4 ? qn(qn(l3.get(a3, o3, n3), l3.get(a3, o3 + 1, n3), s4 - o3), qn(l3.get(a3 + 1, o3, n3), l3.get(a3 + 1, o3 + 1, n3), s4 - o3), i3 - a3) : l3.get(a3, o3, n3);
          }
          getElevationAtPixel(t3, e4, r4) {
            return this._dem.get(t3, e4, !!r4);
          }
          getMeterToDEM(t3) {
            return (1 << this._demTile.tileID.canonical.z) * vc(1, t3) * this._dem.stride;
          }
        }
        const Vf = ff.types, Df = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius"], Lf = ["fill-extrusion-flood-light-ground-radius"], Ff = Math.pow(2, 13), Of = Math.pow(2, 15) - 1, Uf = new Ue(0, 1), Nf = 2147483648;
        function jf(t3, e4, r4, n3, i3, s4, a3, o3) {
          t3.emplaceBack((e4 << 1) + a3, (r4 << 1) + s4, (Math.floor(n3 * Ff) << 1) + i3, Math.round(o3));
        }
        function qf(t3, e4, r4, n3, i3, s4) {
          t3.emplaceBack(e4.x, e4.y, (r4.x << 1) + n3, (r4.y << 1) + i3, s4);
        }
        function $f(t3, e4, r4) {
          const n3 = 16384;
          t3.emplaceBack(e4.x, e4.y, e4.z, r4[0] * n3, r4[1] * n3, r4[2] * n3);
        }
        class Gf {
          constructor() {
            this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
          }
        }
        class Qf {
          constructor() {
            this.centroidXY = new Ue(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Ue(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Ue(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
          }
          span() {
            return new Ue(this.max.x - this.min.x, this.max.y - this.min.y);
          }
        }
        class Yf {
          constructor() {
            this.acc = new Ue(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
          }
          startRing(t3, e4) {
            t3.min.x === Number.MAX_VALUE && (t3.min.x = t3.max.x = e4.x, t3.min.y = t3.max.y = e4.y);
          }
          appendEdge(t3, e4, r4) {
            this.accCount++, this.acc._add(e4);
            let n3 = !!this.borders;
            e4.x < t3.min.x ? (t3.min.x = e4.x, n3 = true) : e4.x > t3.max.x && (t3.max.x = e4.x, n3 = true), e4.y < t3.min.y ? (t3.min.y = e4.y, n3 = true) : e4.y > t3.max.y && (t3.max.y = e4.y, n3 = true), ((0 === e4.x || e4.x === is) && e4.x === r4.x) != ((0 === e4.y || e4.y === is) && e4.y === r4.y) && this.processBorderOverlap(e4, r4), n3 && this.checkBorderIntersection(e4, r4);
          }
          checkBorderIntersection(t3, e4) {
            e4.x < 0 != t3.x < 0 && this.addBorderIntersection(0, qn(e4.y, t3.y, (0 - e4.x) / (t3.x - e4.x))), e4.x > is != t3.x > is && this.addBorderIntersection(1, qn(e4.y, t3.y, (is - e4.x) / (t3.x - e4.x))), e4.y < 0 != t3.y < 0 && this.addBorderIntersection(2, qn(e4.x, t3.x, (0 - e4.y) / (t3.y - e4.y))), e4.y > is != t3.y > is && this.addBorderIntersection(3, qn(e4.x, t3.x, (is - e4.y) / (t3.y - e4.y)));
          }
          addBorderIntersection(t3, e4) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const r4 = this.borders[t3];
            e4 < r4[0] && (r4[0] = e4), e4 > r4[1] && (r4[1] = e4);
          }
          processBorderOverlap(t3, e4) {
            if (t3.x === e4.x) {
              if (t3.y === e4.y)
                return;
              const r4 = 0 === t3.x ? 0 : 1;
              this.addBorderIntersection(r4, e4.y), this.addBorderIntersection(r4, t3.y);
            } else {
              const r4 = 0 === t3.y ? 2 : 3;
              this.addBorderIntersection(r4, e4.x), this.addBorderIntersection(r4, t3.x);
            }
          }
          centroid() {
            return 0 === this.accCount ? new Ue(0, 0) : new Ue(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
          }
          intersectsCount() {
            return this.borders ? this.borders.reduce((t3, e4) => t3 + +(e4[0] !== Number.MAX_VALUE), 0) : 0;
          }
        }
        function Xf(t3, e4) {
          const r4 = t3.add(e4)._unit(), n3 = Ze(t3.x * r4.x + t3.y * r4.y, -1, 1);
          var i3, s4, a3;
          return i3 = Math.acos(n3), Math.min(4, Math.max(-4, Math.tan(i3))) / 4 * Of * ((s4 = t3).x * (a3 = e4).y - s4.y * a3.x < 0 ? -1 : 1);
        }
        const Zf = [(t3) => t3.x < 0, (t3) => t3.x > is, (t3) => t3.y < 0, (t3) => t3.y > is];
        function Kf(t3, e4, r4, n3) {
          const i3 = [4];
          if (0 === n3)
            return i3;
          r4._mult(n3);
          const s4 = t3.sub(r4), a3 = e4.sub(r4), o3 = [t3, e4, s4, a3];
          for (let t4 = 0; t4 < 4; t4++)
            for (const e5 of o3)
              if (Zf[t4](e5)) {
                i3.push(t4);
                break;
              }
          return i3;
        }
        class Wf {
          constructor(t3) {
            this.vertexArray = new Pl(), this.indexArray = new ql(), this.programConfigurations = new ju(t3.layers, t3.zoom, (t4) => Lf.includes(t4)), this._segments = new mu(), this.hiddenByLandmarkVertexArray = new eu(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new mu();
          }
          getDefaultSegment() {
            return this.regionSegments[4];
          }
          hasData() {
            return 0 !== this.vertexArray.length;
          }
          addData(t3, e4, r4, n3 = false) {
            const i3 = t3.length;
            if (i3 > 2) {
              let s4 = Math.max(0, this._segments.get().length - 1);
              const a3 = this._segments._prepareSegment(4 * i3, this.vertexArray.length, 2 * this._segmentToGroundQuads[s4].length);
              let o3;
              s4 !== this._segments.get().length - 1 && (s4++, this._segmentToGroundQuads[s4] = [], this._segmentToRegionTriCounts[s4] = [0, 0, 0, 0, 0]);
              {
                const e5 = t3[0], r5 = t3[1];
                o3 = Xf(e5.sub(t3[i3 - 1])._perp()._unit(), r5.sub(e5)._perp()._unit());
              }
              for (let l3 = 0; l3 < i3; l3++) {
                const u3 = l3 === i3 - 1 ? 0 : l3 + 1, c3 = t3[l3], h2 = t3[u3], p3 = t3[u3 === i3 - 1 ? 0 : u3 + 1], f2 = h2.sub(c3)._perp()._unit(), d2 = Xf(f2, p3.sub(h2)._perp()._unit()), m2 = o3, y3 = d2;
                if (rd(c3, h2, e4) || n3 && nd(c3, e4) && nd(h2, e4)) {
                  o3 = d2;
                  continue;
                }
                const g3 = a3.vertexLength;
                qf(this.vertexArray, c3, h2, 1, 1, m2), qf(this.vertexArray, c3, h2, 1, 0, m2), qf(this.vertexArray, c3, h2, 0, 1, y3), qf(this.vertexArray, c3, h2, 0, 0, y3), a3.vertexLength += 4;
                const x3 = Kf(c3, h2, f2, r4);
                for (const t4 of x3)
                  this._segmentToGroundQuads[s4].push({ id: g3, region: t4 }), this._segmentToRegionTriCounts[s4][t4] += 2, a3.primitiveLength += 2;
                o3 = d2;
              }
            }
          }
          prepareBorderSegments() {
            if (!this.hasData())
              return;
            const t3 = this._segments.get(), e4 = t3.length;
            for (let t4 = 0; t4 < e4; t4++)
              this._segmentToGroundQuads[t4].sort((t5, e5) => t5.region - e5.region);
            for (let r4 = 0; r4 < e4; r4++) {
              const e5 = this._segmentToGroundQuads[r4], n3 = t3[r4], i3 = this._segmentToRegionTriCounts[r4];
              i3.reduce((t4, e6) => t4 + e6, 0);
              let s4 = 0;
              for (let t4 = 0; t4 <= 4; t4++) {
                const e6 = i3[t4];
                if (0 !== e6) {
                  let r5 = this.regionSegments[t4];
                  r5 || (r5 = this.regionSegments[t4] = new mu());
                  const i4 = { vertexOffset: n3.vertexOffset, primitiveOffset: n3.primitiveOffset + s4, vertexLength: n3.vertexLength, primitiveLength: e6 };
                  r5.get().push(i4);
                }
                s4 += e6;
              }
              for (let t4 = 0; t4 < e5.length; t4++) {
                const r5 = e5[t4].id;
                this.indexArray.emplaceBack(r5, r5 + 1, r5 + 3), this.indexArray.emplaceBack(r5, r5 + 3, r5 + 2);
              }
            }
            this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
          }
          addPaintPropertiesData(t3, e4, r4, n3, i3, s4) {
            this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t3, e4, r4, n3, i3, s4);
          }
          upload(t3) {
            this.hasData() && (this.vertexBuffer = t3.createVertexBuffer(this.vertexArray, Xp.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray));
          }
          uploadPaintProperties(t3) {
            this.hasData() && this.programConfigurations.upload(t3);
          }
          update(t3, e4, r4, n3, i3, s4) {
            this.hasData() && this.programConfigurations.updatePaintArrays(t3, e4, r4, n3, i3, s4);
          }
          updateHiddenByLandmark(t3) {
            if (!this.hasData())
              return;
            const e4 = t3.groundVertexCount + t3.groundVertexArrayOffset;
            if (0 === t3.groundVertexCount)
              return;
            const r4 = t3.flags & Nf ? 1 : 0;
            for (let n3 = t3.groundVertexArrayOffset; n3 < e4; ++n3)
              this.hiddenByLandmarkVertexArray.emplace(n3, r4);
            this._needsHiddenByLandmarkUpdate = true;
          }
          uploadHiddenByLandmark(t3) {
            this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t3.createVertexBuffer(this.hiddenByLandmarkVertexArray, Kp.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
          }
          destroy() {
            if (this.vertexBuffer) {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
              for (let t3 = 0; t3 <= 4; t3++) {
                const e4 = this.regionSegments[t3];
                e4 && e4.destroy();
              }
            }
          }
        }
        class Hf {
          constructor(t3) {
            this.zoom = t3.zoom, this.canonical = t3.canonical, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.fqid), this.index = t3.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t3.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new ql(), this.footprintVertices = new Sl(), this.footprintSegments = [], this.layoutVertexArray = new kl(), this.centroidVertexArray = new pu(), this.indexArray = new ql(), this.programConfigurations = new ju(t3.layers, t3.zoom, (t4) => Df.includes(t4)), this.segments = new mu(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.groundEffect = new Wf(t3), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
          }
          populate(t3, e4, r4, n3) {
            this.features = [], this.hasPattern = jp("fill-extrusion", this.layers, e4), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = Pc(r4), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
            for (const { feature: i3, id: s4, index: a3, sourceLayerIndex: o3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, l3 = Fc(i3, t4);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), l3, r4))
                continue;
              const u3 = { id: s4, sourceLayerIndex: o3, index: a3, geometry: t4 ? l3.geometry : Lc(i3, r4, n3), properties: i3.properties, type: i3.type, patterns: {} }, c3 = this.layoutVertexArray.length;
              this.hasPattern ? this.features.push(qp("fill-extrusion", this.layers, u3, this.zoom, e4)) : this.addFeature(u3, u3.geometry, a3, r4, {}, e4.availableImages, n3, e4.brightness), e4.featureIndex.insert(i3, u3.geometry, a3, o3, this.index, c3);
            }
            this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
          }
          addFeatures(t3, e4, r4, n3, i3, s4) {
            for (const t4 of this.features) {
              const { geometry: a3 } = t4;
              this.addFeature(t4, a3, t4.index, e4, r4, n3, i3, s4);
            }
            this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
          }
          update(t3, e4, r4, n3, i3) {
            const s4 = 0 !== Object.keys(t3).length;
            if (s4 && !this.stateDependentLayers.length)
              return;
            const a3 = s4 ? this.stateDependentLayers : this.layers;
            this.programConfigurations.updatePaintArrays(t3, e4, a3, r4, n3, i3), this.groundEffect.update(t3, e4, a3, r4, n3, i3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Hp), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t3.createVertexBuffer(this.layoutVertexExtArray, Wp.members, true)), this.groundEffect.upload(t3)), this.groundEffect.uploadPaintProperties(t3), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          uploadCentroid(t3) {
            this.groundEffect.uploadHiddenByLandmark(t3), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, Zp.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t3, {}) / this.tileToMeter, u3 = [new Ue(0, 0), new Ue(is, is)], c3 = a3.projection, h2 = "globe" === c3.name, p3 = "Polygon" === Vf[t3.type], f2 = new Yf();
            f2.centroidDataIndex = this.centroidData.length;
            const d2 = new Qf(), m2 = this.layers[0].paint.get("fill-extrusion-base").evaluate(t3, {}, n3) <= 0, y3 = this.layers[0].paint.get("fill-extrusion-height").evaluate(t3, {}, n3);
            d2.height = y3, d2.vertexArrayOffset = this.layoutVertexArray.length, d2.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Rl());
            const g3 = Up(e4, 500);
            for (let t4 = g3.length - 1; t4 >= 0; t4--) {
              const e5 = g3[t4];
              (0 === e5.length || (x3 = e5[0]).every((t5) => t5.x <= 0) || x3.every((t5) => t5.x >= is) || x3.every((t5) => t5.y <= 0) || x3.every((t5) => t5.y >= is)) && g3.splice(t4, 1);
            }
            var x3;
            let b2;
            if (h2)
              b2 = od(g3, u3, n3);
            else {
              b2 = [];
              for (const t4 of g3)
                b2.push({ polygon: t4, bounds: u3 });
            }
            const v3 = p3 ? this.edgeRadius : 0, _3 = v3 > 0 && this.zoom < 17, w2 = (t4, e5) => {
              if (0 === t4.length)
                return false;
              const r5 = t4[t4.length - 1];
              return e5.x === r5.x && e5.y === r5.y;
            };
            for (const { polygon: t4, bounds: e5 } of b2) {
              let r5 = 0, i4 = 0;
              for (const e6 of t4)
                p3 && !e6[0].equals(e6[e6.length - 1]) && e6.push(e6[0]), i4 += p3 ? e6.length - 1 : e6.length;
              const s5 = this.segments.prepareSegment((p3 ? 5 : 4) * i4, this.layoutVertexArray, this.indexArray);
              d2.footprintSegIdx < 0 && (d2.footprintSegIdx = this.footprintSegments.length), d2.polygonSegIdx < 0 && (d2.polygonSegIdx = this.polygonSegments.length);
              const a4 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, o4 = new Gf();
              if (o4.vertexOffset = this.footprintVertices.length, o4.indexOffset = 3 * this.footprintIndices.length, o4.ringIndices = [], p3) {
                const i5 = [], a5 = [];
                r5 = s5.vertexLength;
                for (let r6 = 0; r6 < t4.length; r6++) {
                  const u5 = t4[r6];
                  u5.length && 0 !== r6 && a5.push(i5.length / 2);
                  const p4 = [];
                  let f3, d3;
                  f3 = u5[1].sub(u5[0])._perp()._unit(), o4.ringIndices.push(u5.length - 1);
                  for (let t5 = 1; t5 < u5.length; t5++) {
                    const e6 = u5[t5], r7 = u5[t5 === u5.length - 1 ? 1 : t5 + 1], a6 = e6.clone();
                    if (v3) {
                      d3 = r7.sub(e6)._perp()._unit();
                      const t6 = f3.add(d3)._unit(), n4 = v3 * Math.min(4, 1 / (f3.x * t6.x + f3.y * t6.y));
                      a6.x += n4 * t6.x, a6.y += n4 * t6.y, a6.x = Math.round(a6.x), a6.y = Math.round(a6.y), f3 = d3;
                    }
                    !m2 || 0 !== v3 && !_3 || w2(p4, a6) || p4.push(a6), jf(this.layoutVertexArray, a6.x, a6.y, 0, 0, 1, 1, 0), s5.vertexLength++, this.footprintVertices.emplaceBack(e6.x, e6.y), i5.push(e6.x, e6.y), h2 && $f(this.layoutVertexExtArray, c3.projectTilePoint(a6.x, a6.y, n3), c3.upVector(n3, a6.x, a6.y));
                  }
                  m2 && (0 === v3 || _3) && (0 !== p4.length && w2(p4, p4[0]) && p4.pop(), this.groundEffect.addData(p4, e5, l3));
                }
                const u4 = Op(i5, a5);
                for (let t5 = 0; t5 < u4.length; t5 += 3)
                  this.footprintIndices.emplaceBack(o4.vertexOffset + u4[t5 + 0], o4.vertexOffset + u4[t5 + 1], o4.vertexOffset + u4[t5 + 2]), this.indexArray.emplaceBack(r5 + u4[t5], r5 + u4[t5 + 2], r5 + u4[t5 + 1]), s5.primitiveLength++;
                o4.indexCount += u4.length, o4.vertexCount += this.footprintVertices.length - o4.vertexOffset;
              }
              for (let i5 = 0; i5 < t4.length; i5++) {
                const a5 = t4[i5];
                f2.startRing(d2, a5[0]);
                let o5 = a5.length > 4 && id(a5[a5.length - 2], a5[0], a5[1]), u4 = v3 ? td(a5[a5.length - 2], a5[0], a5[1], v3) : 0;
                const y4 = [];
                let g4, x4, b3;
                x4 = a5[1].sub(a5[0])._perp()._unit();
                let _4 = true;
                for (let t5 = 1, i6 = 0; t5 < a5.length; t5++) {
                  let l4 = a5[t5 - 1], p4 = a5[t5];
                  const M3 = a5[t5 === a5.length - 1 ? 1 : t5 + 1];
                  if (f2.appendEdge(d2, p4, l4), rd(p4, l4, e5)) {
                    v3 && (x4 = M3.sub(p4)._perp()._unit(), _4 = !_4);
                    continue;
                  }
                  const A2 = p4.sub(l4)._perp(), S2 = A2.x / (Math.abs(A2.x) + Math.abs(A2.y)), I2 = A2.y > 0 ? 1 : 0, k2 = l4.dist(p4);
                  if (i6 + k2 > 32768 && (i6 = 0), v3) {
                    b3 = M3.sub(p4)._perp()._unit();
                    let t6 = ed(l4, p4, M3, Jf(x4, b3), v3);
                    isNaN(t6) && (t6 = 0);
                    const e6 = p4.sub(l4)._unit();
                    l4 = l4.add(e6.mult(u4))._round(), p4 = p4.add(e6.mult(-t6))._round(), u4 = t6, x4 = b3, m2 && this.zoom >= 17 && (w2(y4, l4) || y4.push(l4), w2(y4, p4) || y4.push(p4));
                  }
                  const P2 = s5.vertexLength, E2 = a5.length > 4 && id(l4, p4, M3);
                  let z3 = sd(i6, o5, _4);
                  if (jf(this.layoutVertexArray, l4.x, l4.y, S2, I2, 0, 0, z3), jf(this.layoutVertexArray, l4.x, l4.y, S2, I2, 0, 1, z3), i6 += k2, z3 = sd(i6, E2, !_4), o5 = E2, jf(this.layoutVertexArray, p4.x, p4.y, S2, I2, 0, 0, z3), jf(this.layoutVertexArray, p4.x, p4.y, S2, I2, 0, 1, z3), s5.vertexLength += 4, this.indexArray.emplaceBack(P2 + 0, P2 + 1, P2 + 2), this.indexArray.emplaceBack(P2 + 1, P2 + 3, P2 + 2), s5.primitiveLength += 2, v3) {
                    const n4 = r5 + (1 === t5 ? a5.length - 2 : t5 - 2), i7 = 1 === t5 ? r5 : n4 + 1;
                    if (this.indexArray.emplaceBack(P2 + 1, n4, P2 + 3), this.indexArray.emplaceBack(n4, i7, P2 + 3), s5.primitiveLength += 2, void 0 === g4 && (g4 = P2), !rd(M3, a5[t5], e5)) {
                      const e6 = t5 === a5.length - 1 ? g4 : s5.vertexLength;
                      this.indexArray.emplaceBack(P2 + 2, P2 + 3, e6), this.indexArray.emplaceBack(P2 + 3, e6 + 1, e6), this.indexArray.emplaceBack(P2 + 3, i7, e6 + 1), s5.primitiveLength += 3;
                    }
                    _4 = !_4;
                  }
                  if (h2) {
                    const t6 = this.layoutVertexExtArray, e6 = c3.projectTilePoint(l4.x, l4.y, n3), r6 = c3.projectTilePoint(p4.x, p4.y, n3), i7 = c3.upVector(n3, l4.x, l4.y), s6 = c3.upVector(n3, p4.x, p4.y);
                    $f(t6, e6, i7), $f(t6, e6, i7), $f(t6, r6, s6), $f(t6, r6, s6);
                  }
                }
                p3 && (r5 += a5.length - 1), m2 && v3 && this.zoom >= 17 && (0 !== y4.length && w2(y4, y4[0]) && y4.pop(), this.groundEffect.addData(y4, e5, l3, v3 > 0));
              }
              this.footprintSegments.push(o4), a4.triangleCount = this.indexArray.length - a4.triangleArrayOffset, this.polygonSegments.push(a4), ++d2.footprintSegLen, ++d2.polygonSegLen;
            }
            if (d2.vertexCount = this.layoutVertexArray.length - d2.vertexArrayOffset, d2.groundVertexCount = this.groundEffect.vertexArray.length - d2.groundVertexArrayOffset, 0 !== d2.vertexCount) {
              if (d2.centroidXY = f2.borders ? Uf : this.encodeCentroid(f2, d2), this.centroidData.push(d2), f2.borders) {
                this.featuresOnBorder.push(f2);
                const t4 = this.featuresOnBorder.length - 1;
                for (let e5 = 0; e5 < f2.borders.length; e5++)
                  f2.borders[e5][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e5].push(t4);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r4, i3, s4, n3, o3), this.groundEffect.addPaintPropertiesData(t3, r4, i3, s4, n3, o3), this.maxHeight = Math.max(this.maxHeight, y3);
            }
          }
          sortBorders() {
            for (let t3 = 0; t3 < this.borderFeatureIndices.length; t3++)
              this.borderFeatureIndices[t3].sort((e4, r4) => this.featuresOnBorder[e4].borders[t3][0] - this.featuresOnBorder[r4].borders[t3][0]);
          }
          splitToSubtiles() {
            const t3 = [];
            for (let e5 = 0; e5 < this.centroidData.length; e5++) {
              const r5 = this.centroidData[e5], n4 = +(r5.min.y + r5.max.y > is), i4 = 2 * n4 + (+(r5.min.x + r5.max.x > is) ^ n4);
              for (let n5 = 0; n5 < r5.polygonSegLen; n5++) {
                const s5 = r5.polygonSegIdx + n5;
                t3.push({ centroidIdx: e5, subtile: i4, polygonSegmentIdx: s5, triangleSegmentIdx: this.polygonSegments[s5].triangleSegIdx });
              }
            }
            const e4 = new ql();
            t3.sort((t4, e5) => t4.triangleSegmentIdx === e5.triangleSegmentIdx ? t4.subtile - e5.subtile : t4.triangleSegmentIdx - e5.triangleSegmentIdx);
            let r4 = 0, n3 = 0, i3 = 0;
            for (const e5 of t3) {
              if (e5.triangleSegmentIdx !== r4)
                break;
              i3++;
            }
            const s4 = t3.length;
            for (; n3 !== t3.length; ) {
              r4 = t3[n3].triangleSegmentIdx;
              let a3 = 0, o3 = n3, l3 = n3;
              for (let e5 = o3; e5 < i3 && t3[e5].subtile === a3; e5++)
                l3++;
              for (; o3 !== i3; ) {
                const n4 = t3[o3];
                a3 = n4.subtile;
                const s5 = this.centroidData[n4.centroidIdx].min.clone(), u3 = this.centroidData[n4.centroidIdx].max.clone(), c3 = { vertexOffset: this.segments.segments[r4].vertexOffset, primitiveOffset: e4.length, vertexLength: this.segments.segments[r4].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                for (let r5 = o3; r5 < l3; r5++) {
                  const n5 = t3[r5], i4 = this.polygonSegments[n5.polygonSegmentIdx], a4 = this.centroidData[n5.centroidIdx].min, o4 = this.centroidData[n5.centroidIdx].max, l4 = this.indexArray.uint16;
                  for (let t4 = i4.triangleArrayOffset; t4 < i4.triangleArrayOffset + i4.triangleCount; t4++)
                    e4.emplaceBack(l4[3 * t4], l4[3 * t4 + 1], l4[3 * t4 + 2]);
                  c3.primitiveLength += i4.triangleCount, s5.x = Math.min(s5.x, a4.x), s5.y = Math.min(s5.y, a4.y), u3.x = Math.max(u3.x, o4.x), u3.y = Math.max(u3.y, o4.y);
                }
                c3.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c3, min: s5, max: u3 }), o3 = l3;
                for (let e5 = o3; e5 < i3 && t3[e5].subtile === t3[o3].subtile; e5++)
                  l3++;
              }
              n3 = i3;
              for (let e5 = n3; e5 < s4 && t3[e5].triangleSegmentIdx === t3[n3].triangleSegmentIdx; e5++)
                i3++;
            }
            e4._trim(), this.indexArray = e4;
          }
          getVisibleSegments(t3, e4, r4) {
            let n3 = 0, i3 = 0;
            const s4 = 1 << t3.canonical.z;
            if (e4) {
              const r5 = e4.getMinMaxForTile(t3);
              r5 && (n3 = r5.min, i3 = r5.max);
            }
            i3 += this.maxHeight;
            const a3 = t3.toUnwrapped();
            let o3;
            const l3 = [a3.canonical.x / s4 + a3.wrap, a3.canonical.y / s4], u3 = [(a3.canonical.x + 1) / s4 + a3.wrap, (a3.canonical.y + 1) / s4], c3 = new mu(), h2 = (t4, e5, r5) => [t4[0] * (1 - r5[0]) + e5[0] * r5[0], t4[1] * (1 - r5[1]) + e5[1] * r5[1]], p3 = [], f2 = [];
            for (const t4 of this.triangleSubSegments) {
              p3[0] = t4.min.x / is, p3[1] = t4.min.y / is, f2[0] = t4.max.x / is, f2[1] = t4.max.y / is;
              const e5 = h2(l3, u3, p3), s5 = h2(l3, u3, f2);
              if (0 === new mh([e5[0], e5[1], n3], [s5[0], s5[1], i3]).intersectsPrecise(r4)) {
                o3 && (c3.segments.push(o3), o3 = void 0);
                continue;
              }
              const a4 = t4.segment;
              o3 && o3.vertexOffset !== a4.vertexOffset && (c3.segments.push(o3), o3 = void 0), o3 ? (o3.vertexLength += a4.vertexLength, o3.primitiveLength += a4.primitiveLength) : o3 = { vertexOffset: a4.vertexOffset, primitiveLength: a4.primitiveLength, vertexLength: a4.vertexLength, primitiveOffset: a4.primitiveOffset, sortKey: void 0, vaos: {} };
            }
            return o3 && c3.segments.push(o3), c3;
          }
          encodeCentroid(t3, e4) {
            const r4 = t3.centroid(), n3 = e4.span(), i3 = Math.min(7, Math.round(n3.x * this.tileToMeter / 10)), s4 = Math.min(7, Math.round(n3.y * this.tileToMeter / 10));
            return new Ue(Ze(r4.x, 1, is - 1) << 3 | i3, Ze(r4.y, 1, is - 1) << 3 | s4);
          }
          encodeBorderCentroid(t3) {
            if (!t3.borders)
              return new Ue(0, 0);
            const e4 = t3.borders, r4 = Number.MAX_VALUE;
            if (e4[0][0] !== r4 || e4[1][0] !== r4) {
              const t4 = e4[0][0] !== r4 ? 0 : 1;
              return new Ue(6 | (e4[0][0] !== r4 ? 0 : 65528), (e4[t4][0] + e4[t4][1]) / 2 << 3 | 6);
            }
            {
              const t4 = e4[2][0] !== r4 ? 2 : 3;
              return new Ue((e4[t4][0] + e4[t4][1]) / 2 << 3 | 6, 6 | (e4[2][0] !== r4 ? 0 : 65528));
            }
          }
          showCentroid(t3) {
            const e4 = this.centroidData[t3.centroidDataIndex];
            e4.flags &= Nf, e4.centroidXY.x = 0, e4.centroidXY.y = 0, this.writeCentroidToBuffer(e4);
          }
          writeCentroidToBuffer(t3) {
            this.groundEffect.updateHiddenByLandmark(t3);
            const e4 = t3.vertexArrayOffset, r4 = t3.vertexCount + t3.vertexArrayOffset, n3 = t3.flags & Nf ? Uf : t3.centroidXY, i3 = this.centroidVertexArray.geta_centroid_pos0(e4);
            if (this.centroidVertexArray.geta_centroid_pos1(e4) !== n3.y || i3 !== n3.x) {
              for (let t4 = e4; t4 < r4; ++t4)
                this.centroidVertexArray.emplace(t4, n3.x, n3.y);
              this.needsCentroidUpdate = true;
            }
          }
          createCentroidsBuffer() {
            this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
            for (const t3 of this.centroidData)
              this.writeCentroidToBuffer(t3);
          }
          updateReplacement(t3, e4) {
            if (e4.updateTime === this.replacementUpdateTime)
              return;
            this.replacementUpdateTime = e4.updateTime;
            const r4 = e4.getReplacementRegionsForTile(t3.toUnwrapped());
            if (function(t4, e5) {
              if (t4.length !== e5.length)
                return false;
              for (let r5 = 0; r5 < t4.length; r5++)
                if (t4[r5].sourceId !== e5[r5].sourceId || !yf(t4[r5], e5[r5]))
                  return false;
              return true;
            }(this.activeReplacements, r4))
              return;
            if (this.activeReplacements = r4, 0 === this.centroidVertexArray.length)
              this.createCentroidsBuffer();
            else
              for (const t4 of this.centroidData)
                t4.flags &= 2147483647;
            const n3 = [];
            for (const e5 of this.activeReplacements) {
              const r5 = Math.pow(2, e5.footprintTileId.canonical.z - t3.canonical.z);
              for (const i3 of this.centroidData)
                if (!(i3.flags & Nf || e5.min.x > i3.max.x || i3.min.x > e5.max.x || e5.min.y > i3.max.y || i3.min.y > e5.max.y))
                  for (let s4 = 0; s4 < i3.footprintSegLen; s4++) {
                    const a3 = this.footprintSegments[i3.footprintSegIdx + s4];
                    if (n3.length = 0, ld(this.footprintVertices, a3.vertexOffset, a3.vertexCount, e5.footprintTileId.canonical, t3.canonical, n3), vf(e5.footprint, n3, this.footprintIndices.uint16, a3.indexOffset, a3.indexCount, -a3.vertexOffset, -r5)) {
                      i3.flags |= Nf;
                      break;
                    }
                  }
            }
            for (const t4 of this.centroidData)
              this.writeCentroidToBuffer(t4);
            this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
          }
          footprintContainsPoint(t3, e4, r4) {
            let n3 = false;
            for (let i3 = 0; i3 < r4.footprintSegLen; i3++) {
              const s4 = this.footprintSegments[r4.footprintSegIdx + i3];
              let a3 = 0;
              for (const r5 of s4.ringIndices) {
                for (let i4 = a3, o3 = r5 + a3 - 1; i4 < r5 + a3; o3 = i4++) {
                  const r6 = this.footprintVertices.int16[2 * (i4 + s4.vertexOffset) + 0], a4 = this.footprintVertices.int16[2 * (i4 + s4.vertexOffset) + 1], l3 = this.footprintVertices.int16[2 * (o3 + s4.vertexOffset) + 1];
                  a4 > e4 != l3 > e4 && t3 < (this.footprintVertices.int16[2 * (o3 + s4.vertexOffset) + 0] - r6) * (e4 - a4) / (l3 - a4) + r6 && (n3 = !n3);
                }
                a3 = r5;
              }
            }
            return n3;
          }
          getHeightAtTileCoord(t3, e4) {
            let r4 = Number.NEGATIVE_INFINITY, n3 = true;
            const i3 = 4 * (t3 + is) * is + (e4 + is);
            if (this.partLookup.hasOwnProperty(i3)) {
              const t4 = this.partLookup[i3];
              return t4 ? { height: t4.height, hidden: !!(t4.flags & Nf) } : void 0;
            }
            for (const s4 of this.centroidData)
              t3 > s4.max.x || s4.min.x > t3 || e4 > s4.max.y || s4.min.y > e4 || this.footprintContainsPoint(t3, e4, s4) && s4 && s4.height > r4 && (r4 = s4.height, this.partLookup[i3] = s4, n3 = !!(s4.flags & Nf));
            if (r4 !== Number.NEGATIVE_INFINITY)
              return { height: r4, hidden: n3 };
            this.partLookup[i3] = void 0;
          }
        }
        function Jf(t3, e4) {
          const r4 = t3.add(e4)._unit();
          return t3.x * r4.x + t3.y * r4.y;
        }
        function td(t3, e4, r4, n3) {
          const i3 = e4.sub(t3)._perp()._unit(), s4 = r4.sub(e4)._perp()._unit();
          return ed(t3, e4, r4, Jf(i3, s4), n3);
        }
        function ed(t3, e4, r4, n3, i3) {
          const s4 = Math.sqrt(1 - n3 * n3);
          return Math.min(t3.dist(e4) / 3, e4.dist(r4) / 3, i3 * s4 / n3);
        }
        function rd(t3, e4, r4) {
          return t3.x < r4[0].x && e4.x < r4[0].x || t3.x > r4[1].x && e4.x > r4[1].x || t3.y < r4[0].y && e4.y < r4[0].y || t3.y > r4[1].y && e4.y > r4[1].y;
        }
        function nd(t3, e4) {
          return t3.x < e4[0].x || t3.x > e4[1].x || t3.y < e4[0].y || t3.y > e4[1].y;
        }
        function id(t3, e4, r4) {
          if (t3.x < 0 || t3.x >= is || e4.x < 0 || e4.x >= is || r4.x < 0 || r4.x >= is)
            return false;
          const n3 = r4.sub(e4), i3 = n3.perp(), s4 = t3.sub(e4);
          return (n3.x * s4.x + n3.y * s4.y) / Math.sqrt((n3.x * n3.x + n3.y * n3.y) * (s4.x * s4.x + s4.y * s4.y)) > -0.866 && i3.x * s4.x + i3.y * s4.y < 0;
        }
        function sd(t3, e4, r4) {
          const n3 = e4 ? 2 | t3 : -3 & t3;
          return r4 ? 1 | n3 : -2 & n3;
        }
        function ad() {
          const t3 = Math.PI / 32, e4 = Math.tan(t3), r4 = ic;
          return r4 * Math.sqrt(1 + 2 * e4 * e4) - r4;
        }
        function od(t3, e4, r4) {
          const n3 = 1 << r4.z, i3 = _c(r4.x / n3), s4 = _c((r4.x + 1) / n3), a3 = wc(r4.y / n3), o3 = wc((r4.y + 1) / n3);
          return function(t4, e5, r5, n4, i4 = 0, s5) {
            const a4 = [];
            if (!t4.length || !r5 || !n4)
              return a4;
            const o4 = (t5, e6) => {
              for (const r6 of t5)
                a4.push({ polygon: r6, bounds: e6 });
            }, l3 = Math.ceil(Math.log2(r5)), u3 = Math.ceil(Math.log2(n4)), c3 = l3 - u3, h2 = [];
            for (let t5 = 0; t5 < Math.abs(c3); t5++)
              h2.push(c3 > 0 ? 0 : 1);
            for (let t5 = 0; t5 < Math.min(l3, u3); t5++)
              h2.push(0), h2.push(1);
            let p3 = t4;
            if (p3 = df(p3, e5[0].y - i4, e5[1].y + i4, 1), p3 = df(p3, e5[0].x - i4, e5[1].x + i4, 0), !p3.length)
              return a4;
            const f2 = [];
            for (h2.length ? f2.push({ polygons: p3, bounds: e5, depth: 0 }) : o4(p3, e5); f2.length; ) {
              const t5 = f2.pop(), e6 = t5.depth, r6 = h2[e6], n5 = t5.bounds[0], a5 = t5.bounds[1], l4 = 0 === r6 ? n5.x : n5.y, u4 = 0 === r6 ? a5.x : a5.y, c4 = s5 ? s5(r6, l4, u4) : 0.5 * (l4 + u4), p4 = df(t5.polygons, l4 - i4, c4 + i4, r6), d2 = df(t5.polygons, c4 - i4, u4 + i4, r6);
              if (p4.length) {
                const t6 = [n5, new Ue(0 === r6 ? c4 : a5.x, 1 === r6 ? c4 : a5.y)];
                h2.length > e6 + 1 ? f2.push({ polygons: p4, bounds: t6, depth: e6 + 1 }) : o4(p4, t6);
              }
              if (d2.length) {
                const t6 = [new Ue(0 === r6 ? c4 : n5.x, 1 === r6 ? c4 : n5.y), a5];
                h2.length > e6 + 1 ? f2.push({ polygons: d2, bounds: t6, depth: e6 + 1 }) : o4(d2, t6);
              }
            }
            return a4;
          }(t3, e4, Math.ceil((s4 - i3) / 11.25), Math.ceil((a3 - o3) / 11.25), 1, (t4, e5, i4) => {
            if (0 === t4)
              return 0.5 * (e5 + i4);
            {
              const t5 = wc((r4.y + e5 / is) / n3);
              return (bc(0.5 * (wc((r4.y + i4 / is) / n3) + t5)) * n3 - r4.y) * is;
            }
          });
        }
        function ld(t3, e4, r4, n3, i3, s4) {
          const a3 = Math.pow(2, n3.z - i3.z);
          for (let o3 = 0; o3 < r4; o3++) {
            let r5 = t3.int16[2 * (o3 + e4) + 0], l3 = t3.int16[2 * (o3 + e4) + 1];
            r5 = (r5 + i3.x * is) * a3 - n3.x * is, l3 = (l3 + i3.y * is) * a3 - n3.y * is, s4.push(new Ue(r5, l3));
          }
        }
        fo(Hf, "FillExtrusionBucket", { omit: ["layers", "features"] }), fo(Qf, "PartData"), fo(Gf, "FootprintSegment"), fo(Yf, "BorderCentroidData"), fo(Wf, "GroundEffect");
        const ud = new Ho({ visibility: new Zo(el["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Zo(el["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
        var cd = { paint: new Ho({ "fill-extrusion-opacity": new Zo(el["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ko(el["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Zo(el["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Zo(el["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Ko(el["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ko(el["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ko(el["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Zo(el["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Zo(el["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Zo(el["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new Ko(el["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new Ko(el["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Zo(el["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Zo(el["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Zo(el["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Zo(el["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new Zo(el["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]) }), layout: ud };
        class hd extends Ue {
          constructor(t3, e4, r4) {
            super(t3, e4), this.z = r4;
          }
        }
        function pd(t3, e4) {
          return t3.x * e4.x + t3.y * e4.y;
        }
        function fd(t3, e4) {
          if (1 === t3.length) {
            let r4 = 0;
            const n3 = e4[r4++];
            let i3;
            for (; !i3 || n3.equals(i3); )
              if (i3 = e4[r4++], !i3)
                return 1 / 0;
            for (; r4 < e4.length; r4++) {
              const s4 = e4[r4], a3 = t3[0], o3 = i3.sub(n3), l3 = s4.sub(n3), u3 = a3.sub(n3), c3 = pd(o3, o3), h2 = pd(o3, l3), p3 = pd(l3, l3), f2 = pd(u3, o3), d2 = pd(u3, l3), m2 = c3 * p3 - h2 * h2, y3 = (p3 * f2 - h2 * d2) / m2, g3 = (c3 * d2 - h2 * f2) / m2, x3 = n3.z * (1 - y3 - g3) + i3.z * y3 + s4.z * g3;
              if (isFinite(x3))
                return x3;
            }
            return 1 / 0;
          }
          {
            let t4 = 1 / 0;
            for (const r4 of e4)
              t4 = Math.min(t4, r4.z);
            return t4;
          }
        }
        function dd(t3, e4, r4, n3, i3, s4, a3, o3) {
          const l3 = a3 * i3.getElevationAt(t3, e4, true, true), u3 = 0 !== s4[0], c3 = u3 ? 0 === s4[1] ? a3 * (s4[0] / 7 - 450) : a3 * function(t4, e5, r5) {
            const n4 = Math.floor(e5[0] / 8), i4 = Math.floor(e5[1] / 8), s5 = 10 * (e5[0] - 8 * n4), a4 = 10 * (e5[1] - 8 * i4), o4 = t4.getElevationAt(n4, i4, true, true), l4 = t4.getMeterToDEM(r5), u4 = Math.floor(0.5 * (s5 * l4 - 1)), c4 = Math.floor(0.5 * (a4 * l4 - 1)), h2 = t4.tileCoordToPixel(n4, i4), p3 = 2 * u4 + 1, f2 = 2 * c4 + 1, d2 = function(t5, e6, r6, n5, i5) {
              return [t5.getElevationAtPixel(e6, r6, true), t5.getElevationAtPixel(e6 + i5, r6, true), t5.getElevationAtPixel(e6, r6 + i5, true), t5.getElevationAtPixel(e6 + n5, r6 + i5, true)];
            }(t4, h2.x - u4, h2.y - c4, p3, f2), m2 = Math.abs(d2[0] - d2[1]), y3 = Math.abs(d2[2] - d2[3]), g3 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x3 = Math.min(0.25, 0.5 * l4 * (m2 + y3) / p3), b2 = Math.min(0.25, 0.5 * l4 * g3 / f2);
            return o4 + Math.max(x3 * s5, b2 * a4);
          }(i3, s4, o3) : l3;
          return { base: l3 + (0 === r4) ? -1 : r4, top: u3 ? Math.max(c3 + n3, l3 + r4 + 2) : l3 + n3 };
        }
        const md = Ml([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: yd } = md, gd = Ml([{ name: "a_packed", components: 4, type: "Float32" }]), { members: xd } = gd, bd = Ml([{ name: "a_pattern_data", components: 2, type: "Float32" }]), { members: vd } = bd;
        class _d {
          constructor(t3, e4) {
            this.width = t3, this.height = e4, this.nextRow = 0, this.image = new rp({ width: t3, height: e4 }), this.positions = {}, this.uploaded = false;
          }
          getDash(t3, e4) {
            const r4 = this.getKey(t3, e4);
            return this.positions[r4];
          }
          trim() {
            const t3 = this.width, e4 = this.height = nr(this.nextRow);
            this.image.resize({ width: t3, height: e4 });
          }
          getKey(t3, e4) {
            return t3.join(",") + e4;
          }
          getDashRanges(t3, e4, r4) {
            const n3 = [];
            let i3 = t3.length % 2 == 1 ? -t3[t3.length - 1] * r4 : 0, s4 = t3[0] * r4, a3 = true;
            n3.push({ left: i3, right: s4, isDash: a3, zeroLength: 0 === t3[0] });
            let o3 = t3[0];
            for (let e5 = 1; e5 < t3.length; e5++) {
              a3 = !a3;
              const l3 = t3[e5];
              i3 = o3 * r4, o3 += l3, s4 = o3 * r4, n3.push({ left: i3, right: s4, isDash: a3, zeroLength: 0 === l3 });
            }
            return n3;
          }
          addRoundDash(t3, e4, r4) {
            const n3 = e4 / 2;
            for (let e5 = -r4; e5 <= r4; e5++) {
              const i3 = this.width * (this.nextRow + r4 + e5);
              let s4 = 0, a3 = t3[s4];
              for (let o3 = 0; o3 < this.width; o3++) {
                o3 / a3.right > 1 && (a3 = t3[++s4]);
                const l3 = Math.abs(o3 - a3.left), u3 = Math.abs(o3 - a3.right), c3 = Math.min(l3, u3);
                let h2;
                const p3 = e5 / r4 * (n3 + 1);
                if (a3.isDash) {
                  const t4 = n3 - Math.abs(p3);
                  h2 = Math.sqrt(c3 * c3 + t4 * t4);
                } else
                  h2 = n3 - Math.sqrt(c3 * c3 + p3 * p3);
                this.image.data[i3 + o3] = Math.max(0, Math.min(255, h2 + 128));
              }
            }
          }
          addRegularDash(t3, e4) {
            for (let e5 = t3.length - 1; e5 >= 0; --e5) {
              const r5 = t3[e5], n4 = t3[e5 + 1];
              r5.zeroLength ? t3.splice(e5, 1) : n4 && n4.isDash === r5.isDash && (n4.left = r5.left, t3.splice(e5, 1));
            }
            const r4 = t3[0], n3 = t3[t3.length - 1];
            r4.isDash === n3.isDash && (r4.left = n3.left - this.width, n3.right = r4.right + this.width);
            const i3 = this.width * this.nextRow;
            let s4 = 0, a3 = t3[s4];
            for (let r5 = 0; r5 < this.width; r5++) {
              r5 / a3.right > 1 && (a3 = t3[++s4]);
              const n4 = Math.abs(r5 - a3.left), o3 = Math.abs(r5 - a3.right), l3 = Math.min(n4, o3);
              this.image.data[i3 + r5] = Math.max(0, Math.min(255, (a3.isDash ? l3 : -l3) + e4 + 128));
            }
          }
          addDash(t3, e4) {
            const r4 = this.getKey(t3, e4);
            if (this.positions[r4])
              return this.positions[r4];
            const n3 = "round" === e4, i3 = n3 ? 7 : 0, s4 = 2 * i3 + 1;
            if (this.nextRow + s4 > this.height)
              return hr("LineAtlas out of space"), null;
            0 === t3.length && t3.push(1);
            let a3 = 0;
            for (let e5 = 0; e5 < t3.length; e5++)
              t3[e5] < 0 && (hr("Negative value is found in line dasharray, replacing values with 0"), t3[e5] = 0), a3 += t3[e5];
            if (0 !== a3) {
              const r5 = this.width / a3, s5 = this.getDashRanges(t3, this.width, r5);
              n3 ? this.addRoundDash(s5, r5, i3) : this.addRegularDash(s5, "square" === e4 ? 0.5 * r5 : 0);
            }
            const o3 = this.nextRow + i3;
            this.nextRow += s4;
            const l3 = { tl: [o3, i3], br: [a3, 0] };
            return this.positions[r4] = l3, l3;
          }
        }
        fo(_d, "LineAtlas");
        const wd = ff.types, Md = Math.cos(Math.PI / 180 * 37.5), Ad = Math.cos(Math.PI / 180 * 5);
        class Sd {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.fqid), this.index = t3.index, this.projection = t3.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
              this.gradients[t4.id] = {};
            }), this.layoutVertexArray = new El(), this.layoutVertexArray2 = new zl(), this.patternVertexArray = new Tl(), this.indexArray = new ql(), this.programConfigurations = new ju(t3.layers, t3.zoom), this.segments = new mu(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e4, r4, n3) {
            this.hasPattern = jp("line", this.layers, e4);
            const i3 = this.layers[0].layout.get("line-sort-key"), s4 = [];
            for (const { feature: e5, id: a4, index: o4, sourceLayerIndex: l4 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = Fc(e5, t4);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), u3, r4))
                continue;
              const c3 = i3 ? i3.evaluate(u3, {}, r4) : void 0, h2 = { id: a4, properties: e5.properties, type: e5.type, sourceLayerIndex: l4, index: o4, geometry: t4 ? u3.geometry : Lc(e5, r4, n3), patterns: {}, sortKey: c3 };
              s4.push(h2);
            }
            i3 && s4.sort((t4, e5) => t4.sortKey - e5.sortKey);
            const { lineAtlas: a3, featureIndex: o3 } = e4, l3 = this.addConstantDashes(a3);
            for (const n4 of s4) {
              const { geometry: i4, index: s5, sourceLayerIndex: u3 } = n4;
              if (l3 && this.addFeatureDashes(n4, a3), this.hasPattern) {
                const t4 = qp("line", this.layers, n4, this.zoom, e4);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n4, i4, s5, r4, a3.positions, e4.availableImages, e4.brightness);
              o3.insert(t3[s5].feature, i4, s5, u3, this.index);
            }
          }
          addConstantDashes(t3) {
            let e4 = false;
            for (const r4 of this.layers) {
              const n3 = r4.paint.get("line-dasharray").value, i3 = r4.layout.get("line-cap").value;
              if ("constant" !== n3.kind || "constant" !== i3.kind)
                e4 = true;
              else {
                const e5 = i3.value, r5 = n3.value;
                if (!r5)
                  continue;
                t3.addDash(r5, e5);
              }
            }
            return e4;
          }
          addFeatureDashes(t3, e4) {
            const r4 = this.zoom;
            for (const n3 of this.layers) {
              const i3 = n3.paint.get("line-dasharray").value, s4 = n3.layout.get("line-cap").value;
              if ("constant" === i3.kind && "constant" === s4.kind)
                continue;
              let a3, o3;
              if ("constant" === i3.kind) {
                if (a3 = i3.value, !a3)
                  continue;
              } else
                a3 = i3.evaluate({ zoom: r4 }, t3);
              o3 = "constant" === s4.kind ? s4.value : s4.evaluate({ zoom: r4 }, t3), e4.addDash(a3, o3), t3.patterns[n3.id] = e4.getKey(a3, o3);
            }
          }
          update(t3, e4, r4, n3, i3) {
            const s4 = 0 !== Object.keys(t3).length;
            s4 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t3, e4, s4 ? this.stateDependentLayers : this.layers, r4, n3, i3);
          }
          addFeatures(t3, e4, r4, n3, i3, s4) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e4, r4, n3, s4);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, xd)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t3.createVertexBuffer(this.patternVertexArray, vd)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, yd), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t3) {
            if (t3.properties && t3.properties.hasOwnProperty("mapbox_clip_start") && t3.properties.hasOwnProperty("mapbox_clip_end"))
              return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
          }
          addFeature(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = this.layers[0].layout, l3 = o3.get("line-join").evaluate(t3, {}), u3 = o3.get("line-cap").evaluate(t3, {}), c3 = o3.get("line-miter-limit"), h2 = o3.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t3);
            for (const r5 of e4)
              this.addLine(r5, t3, l3, u3, c3, h2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r4, i3, s4, n3, a3);
          }
          addLine(t3, e4, r4, n3, i3, s4) {
            this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0;
            const a3 = "none" === r4;
            if (this.patternJoinNone = this.hasPattern && a3, this.segmentStart = 0, this.segmentPoints = [], this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e5 = 0; e5 < t3.length - 1; e5++)
                this.totalDistance += t3[e5].dist(t3[e5 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const o3 = "Polygon" === wd[e4.type];
            let l3 = t3.length;
            for (; l3 >= 2 && t3[l3 - 1].equals(t3[l3 - 2]); )
              l3--;
            let u3 = 0;
            for (; u3 < l3 - 1 && t3[u3].equals(t3[u3 + 1]); )
              u3++;
            if (l3 < (o3 ? 3 : 2))
              return;
            "bevel" === r4 && (i3 = 1.05);
            const c3 = this.overscaling <= 16 ? 15 * is / (512 * this.overscaling) : 0, h2 = this.segments.prepareSegment(10 * l3, this.layoutVertexArray, this.indexArray);
            let p3, f2, d2, m2, y3;
            this.e1 = this.e2 = -1, o3 && (p3 = t3[l3 - 2], y3 = t3[u3].sub(p3)._unit()._perp());
            for (let e5 = u3; e5 < l3; e5++) {
              if (d2 = e5 === l3 - 1 ? o3 ? t3[u3 + 1] : void 0 : t3[e5 + 1], d2 && t3[e5].equals(d2))
                continue;
              y3 && (m2 = y3), p3 && (f2 = p3), p3 = t3[e5], y3 = d2 ? d2.sub(p3)._unit()._perp() : m2, m2 = m2 || y3;
              const g3 = f2 && d2;
              let x3 = g3 ? r4 : o3 || a3 ? "butt" : n3;
              const b2 = m2.x * y3.x + m2.y * y3.y;
              if (a3) {
                const t4 = function(t5) {
                  if (t5.patternJoinNone) {
                    const e6 = t5.segmentPoints.length / 2, r5 = t5.lineSoFar - t5.segmentStart;
                    for (let n4 = 0; n4 < e6; ++n4) {
                      const e7 = t5.segmentPoints[2 * n4 + 1], i4 = Math.round(t5.segmentPoints[2 * n4]) + 0.5 + 0.25 * e7;
                      t5.patternVertexArray.emplaceBack(i4, r5), t5.patternVertexArray.emplaceBack(i4, r5);
                    }
                    t5.segmentPoints = [], t5.segmentStart = t5.lineSoFar;
                  }
                  t5.e1 = t5.e2 = -1;
                };
                if (g3 && b2 < Ad) {
                  this.updateDistance(f2, p3), this.addCurrentVertex(p3, m2, 1, 1, h2), t4(this), this.addCurrentVertex(p3, y3, -1, -1, h2);
                  continue;
                }
                if (f2) {
                  if (!d2) {
                    this.updateDistance(f2, p3), this.addCurrentVertex(p3, m2, 1, 1, h2), t4(this);
                    continue;
                  }
                  x3 = "miter";
                }
              }
              let v3 = m2.add(y3);
              0 === v3.x && 0 === v3.y || v3._unit();
              const _3 = v3.x * y3.x + v3.y * y3.y, w2 = 0 !== _3 ? 1 / _3 : 1 / 0, M3 = 2 * Math.sqrt(2 - 2 * _3), A2 = _3 < Md && f2 && d2, S2 = m2.x * y3.y - m2.y * y3.x > 0;
              if (A2 && e5 > u3) {
                const t4 = p3.dist(f2);
                if (t4 > 2 * c3) {
                  const e6 = p3.sub(p3.sub(f2)._mult(c3 / t4)._round());
                  this.updateDistance(f2, e6), this.addCurrentVertex(e6, m2, 0, 0, h2), f2 = e6;
                }
              }
              if (g3 && "round" === x3 && (w2 < s4 ? x3 = "miter" : w2 <= 2 && (x3 = "fakeround")), "miter" === x3 && w2 > i3 && (x3 = "bevel"), "bevel" === x3 && (w2 > 2 && (x3 = "flipbevel"), w2 < i3 && (x3 = "miter")), f2 && this.updateDistance(f2, p3), "miter" === x3)
                v3._mult(w2), this.addCurrentVertex(p3, v3, 0, 0, h2);
              else if ("flipbevel" === x3) {
                if (w2 > 100)
                  v3 = y3.mult(-1);
                else {
                  const t4 = w2 * m2.add(y3).mag() / m2.sub(y3).mag();
                  v3._perp()._mult(t4 * (S2 ? -1 : 1));
                }
                this.addCurrentVertex(p3, v3, 0, 0, h2), this.addCurrentVertex(p3, v3.mult(-1), 0, 0, h2);
              } else if ("bevel" === x3 || "fakeround" === x3) {
                const t4 = -Math.sqrt(w2 * w2 - 1), e6 = S2 ? t4 : 0, r5 = S2 ? 0 : t4;
                if (f2 && this.addCurrentVertex(p3, m2, e6, r5, h2), "fakeround" === x3) {
                  const t5 = Math.round(180 * M3 / Math.PI / 20);
                  for (let e7 = 1; e7 < t5; e7++) {
                    let r6 = e7 / t5;
                    if (0.5 !== r6) {
                      const t6 = r6 - 0.5;
                      r6 += r6 * t6 * (r6 - 1) * ((1.0904 + b2 * (b2 * (3.55645 - 1.43519 * b2) - 3.2452)) * t6 * t6 + (0.848013 + b2 * (0.215638 * b2 - 1.06021)));
                    }
                    const n4 = y3.sub(m2)._mult(r6)._add(m2)._unit()._mult(S2 ? -1 : 1);
                    this.addHalfVertex(p3, n4.x, n4.y, false, S2, 0, h2);
                  }
                }
                d2 && this.addCurrentVertex(p3, y3, -e6, -r5, h2);
              } else
                "butt" === x3 ? this.addCurrentVertex(p3, v3, 0, 0, h2) : "square" === x3 ? (f2 || this.addCurrentVertex(p3, v3, -1, -1, h2), this.addCurrentVertex(p3, v3, 0, 0, h2), f2 && this.addCurrentVertex(p3, v3, 1, 1, h2)) : "round" === x3 && (f2 && (this.addCurrentVertex(p3, m2, 0, 0, h2), this.addCurrentVertex(p3, m2, 1, 1, h2, true)), d2 && (this.addCurrentVertex(p3, y3, -1, -1, h2, true), this.addCurrentVertex(p3, y3, 0, 0, h2)));
              if (A2 && e5 < l3 - 1) {
                const t4 = p3.dist(d2);
                if (t4 > 2 * c3) {
                  const e6 = p3.add(d2.sub(p3)._mult(c3 / t4)._round());
                  this.updateDistance(p3, e6), this.addCurrentVertex(e6, y3, 0, 0, h2), p3 = e6;
                }
              }
            }
          }
          addCurrentVertex(t3, e4, r4, n3, i3, s4 = false) {
            const a3 = e4.y * n3 - e4.x, o3 = -e4.y - e4.x * n3;
            this.addHalfVertex(t3, e4.x + e4.y * r4, e4.y - e4.x * r4, s4, false, r4, i3), this.addHalfVertex(t3, a3, o3, s4, true, -n3, i3), this.patternJoinNone && this.segmentPoints.push(this.lineSoFar - this.segmentStart, r4);
          }
          addHalfVertex({ x: t3, y: e4 }, r4, n3, i3, s4, a3, o3) {
            this.layoutVertexArray.emplaceBack((t3 << 1) + (i3 ? 1 : 0), (e4 << 1) + (s4 ? 1 : 0), Math.round(63 * r4) + 128, Math.round(63 * n3) + 128, 1 + (0 === a3 ? 0 : a3 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
            const l3 = o3.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l3), o3.primitiveLength++), s4 ? this.e2 = l3 : this.e1 = l3;
          }
          updateScaledDistance() {
            if (this.lineClips) {
              const t3 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
              this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t3 * this.lineClips.start + this.distance;
            } else
              this.lineSoFar = this.distance;
          }
          updateDistance(t3, e4) {
            this.distance += t3.dist(e4), this.updateScaledDistance();
          }
        }
        fo(Sd, "LineBucket", { omit: ["layers", "patternFeatures"] });
        const Id = new Ho({ "line-cap": new Ko(el.layout_line["line-cap"]), "line-join": new Ko(el.layout_line["line-join"]), "line-miter-limit": new Zo(el.layout_line["line-miter-limit"]), "line-round-limit": new Zo(el.layout_line["line-round-limit"]), "line-sort-key": new Ko(el.layout_line["line-sort-key"]), visibility: new Zo(el.layout_line.visibility) });
        var kd = { paint: new Ho({ "line-opacity": new Ko(el.paint_line["line-opacity"]), "line-color": new Ko(el.paint_line["line-color"]), "line-translate": new Zo(el.paint_line["line-translate"]), "line-translate-anchor": new Zo(el.paint_line["line-translate-anchor"]), "line-width": new Ko(el.paint_line["line-width"]), "line-gap-width": new Ko(el.paint_line["line-gap-width"]), "line-offset": new Ko(el.paint_line["line-offset"]), "line-blur": new Ko(el.paint_line["line-blur"]), "line-dasharray": new Ko(el.paint_line["line-dasharray"]), "line-pattern": new Ko(el.paint_line["line-pattern"]), "line-gradient": new Wo(el.paint_line["line-gradient"]), "line-trim-offset": new Zo(el.paint_line["line-trim-offset"]), "line-emissive-strength": new Zo(el.paint_line["line-emissive-strength"]), "line-border-width": new Ko(el.paint_line["line-border-width"]), "line-border-color": new Ko(el.paint_line["line-border-color"]) }), layout: Id };
        function Pd(t3, e4, r4) {
          return e4 * (is / (t3.tileSize * Math.pow(2, r4 - t3.tileID.overscaledZ)));
        }
        function Ed(t3, e4) {
          return 1 / Pd(t3, 1, e4.tileZoom);
        }
        function zd(t3, e4, r4, n3) {
          return t3.translatePosMatrix(n3 || e4.tileID.projMatrix, e4, r4.paint.get("line-translate"), r4.paint.get("line-translate-anchor"));
        }
        const Td = (t3) => {
          const e4 = [];
          Bd(t3) && e4.push("RENDER_LINE_DASH"), t3.paint.get("line-gradient") && e4.push("RENDER_LINE_GRADIENT");
          const r4 = t3.paint.get("line-trim-offset");
          0 === r4[0] && 0 === r4[1] || e4.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t3.paint.get("line-border-width").constantOr(1) && e4.push("RENDER_LINE_BORDER");
          const n3 = "none" === t3.layout.get("line-join").constantOr("miter"), i3 = !!t3.paint.get("line-pattern").constantOr(1);
          return n3 && i3 && e4.push("LINE_JOIN_NONE"), e4;
        };
        function Bd(t3) {
          const e4 = t3.paint.get("line-dasharray").value;
          return e4.value || "constant" !== e4.kind;
        }
        const Cd = new class extends Ko {
          possiblyEvaluate(t3, e4) {
            return e4 = new Uo(Math.floor(e4.zoom), { now: e4.now, fadeDuration: e4.fadeDuration, transition: e4.transition }), super.possiblyEvaluate(t3, e4);
          }
          evaluate(t3, e4, r4, n3) {
            return e4 = Je({}, e4, { zoom: Math.floor(e4.zoom) }), super.evaluate(t3, e4, r4, n3);
          }
        }(kd.paint.properties["line-width"].specification);
        function Rd(t3, e4) {
          return e4 > 0 ? e4 + 2 * t3 : t3;
        }
        Cd.useIntegerZoom = true;
        const Vd = Ml([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Dd = Ml([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Ld = Ml([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        Ml([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Fd = Ml([{ name: "a_z_offset", components: 1, type: "Float32" }], 4), Od = Ml([{ name: "a_texb", components: 2, type: "Uint16" }]), Ud = Ml([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Nd = Ml([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_z_offset", components: 1, type: "Float32" }]);
        Ml([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const jd = Ml([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), qd = Ml([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        Ml([{ name: "triangle", components: 3, type: "Uint16" }]), Ml([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Ml([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), Ml([{ type: "Float32", name: "offsetX" }]), Ml([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var $d = 24;
        const Gd = 128;
        function Qd(t3, e4) {
          const { expression: r4 } = e4;
          if ("constant" === r4.kind)
            return { kind: "constant", layoutSize: r4.evaluate(new Uo(t3 + 1)) };
          if ("source" === r4.kind)
            return { kind: "source" };
          {
            const { zoomStops: e5, interpolationType: n3 } = r4;
            let i3 = 0;
            for (; i3 < e5.length && e5[i3] <= t3; )
              i3++;
            i3 = Math.max(0, i3 - 1);
            let s4 = i3;
            for (; s4 < e5.length && e5[s4] < t3 + 1; )
              s4++;
            s4 = Math.min(e5.length - 1, s4);
            const a3 = e5[i3], o3 = e5[s4];
            return "composite" === r4.kind ? { kind: "composite", minZoom: a3, maxZoom: o3, interpolationType: n3 } : { kind: "camera", minZoom: a3, maxZoom: o3, minSize: r4.evaluate(new Uo(a3)), maxSize: r4.evaluate(new Uo(o3)), interpolationType: n3 };
          }
        }
        function Yd(t3, { uSize: e4, uSizeT: r4 }, { lowerSize: n3, upperSize: i3 }) {
          return "source" === t3.kind ? n3 / Gd : "composite" === t3.kind ? qn(n3 / Gd, i3 / Gd, r4) : e4;
        }
        function Xd(t3, e4) {
          let r4 = 0, n3 = 0;
          if ("constant" === t3.kind)
            n3 = t3.layoutSize;
          else if ("source" !== t3.kind) {
            const { interpolationType: i3, minZoom: s4, maxZoom: a3 } = t3, o3 = i3 ? Ze(ha.interpolationFactor(i3, e4, s4, a3), 0, 1) : 0;
            "camera" === t3.kind ? n3 = qn(t3.minSize, t3.maxSize, o3) : r4 = o3;
          }
          return { uSizeT: r4, uSize: n3 };
        }
        var Zd = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Gd, evaluateSizeForFeature: Yd, evaluateSizeForZoom: Xd, getSizeData: Qd });
        function Kd(t3, e4, r4) {
          return t3.sections.forEach((t4) => {
            t4.text = function(t5, e5, r5) {
              const n3 = e5.layout.get("text-transform").evaluate(r5, {});
              return "uppercase" === n3 ? t5 = t5.toLocaleUpperCase() : "lowercase" === n3 && (t5 = t5.toLocaleLowerCase()), Oo.applyArabicShaping && (t5 = Oo.applyArabicShaping(t5)), t5;
            }(t4.text, e4, r4);
          }), t3;
        }
        const Wd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42", "\u2190": "\u2191", "\u2192": "\u2193" };
        function Hd(t3) {
          return "\uFE36" === t3 || "\uFE48" === t3 || "\uFE38" === t3 || "\uFE44" === t3 || "\uFE42" === t3 || "\uFE3E" === t3 || "\uFE3C" === t3 || "\uFE3A" === t3 || "\uFE18" === t3 || "\uFE40" === t3 || "\uFE10" === t3 || "\uFE13" === t3 || "\uFE14" === t3 || "\uFF40" === t3 || "\uFFE3" === t3 || "\uFE11" === t3 || "\uFE12" === t3;
        }
        function Jd(t3) {
          return "\uFE35" === t3 || "\uFE47" === t3 || "\uFE37" === t3 || "\uFE43" === t3 || "\uFE41" === t3 || "\uFE3D" === t3 || "\uFE3B" === t3 || "\uFE39" === t3 || "\uFE17" === t3 || "\uFE3F" === t3;
        }
        var tm = {
          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
          read: function(t3, e4, r4, n3, i3) {
            var s4, a3, o3 = 8 * i3 - n3 - 1, l3 = (1 << o3) - 1, u3 = l3 >> 1, c3 = -7, h2 = r4 ? i3 - 1 : 0, p3 = r4 ? -1 : 1, f2 = t3[e4 + h2];
            for (h2 += p3, s4 = f2 & (1 << -c3) - 1, f2 >>= -c3, c3 += o3; c3 > 0; s4 = 256 * s4 + t3[e4 + h2], h2 += p3, c3 -= 8)
              ;
            for (a3 = s4 & (1 << -c3) - 1, s4 >>= -c3, c3 += n3; c3 > 0; a3 = 256 * a3 + t3[e4 + h2], h2 += p3, c3 -= 8)
              ;
            if (0 === s4)
              s4 = 1 - u3;
            else {
              if (s4 === l3)
                return a3 ? NaN : 1 / 0 * (f2 ? -1 : 1);
              a3 += Math.pow(2, n3), s4 -= u3;
            }
            return (f2 ? -1 : 1) * a3 * Math.pow(2, s4 - n3);
          },
          write: function(t3, e4, r4, n3, i3, s4) {
            var a3, o3, l3, u3 = 8 * s4 - i3 - 1, c3 = (1 << u3) - 1, h2 = c3 >> 1, p3 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n3 ? 0 : s4 - 1, d2 = n3 ? 1 : -1, m2 = e4 < 0 || 0 === e4 && 1 / e4 < 0 ? 1 : 0;
            for (e4 = Math.abs(e4), isNaN(e4) || e4 === 1 / 0 ? (o3 = isNaN(e4) ? 1 : 0, a3 = c3) : (a3 = Math.floor(Math.log(e4) / Math.LN2), e4 * (l3 = Math.pow(2, -a3)) < 1 && (a3--, l3 *= 2), (e4 += a3 + h2 >= 1 ? p3 / l3 : p3 * Math.pow(2, 1 - h2)) * l3 >= 2 && (a3++, l3 /= 2), a3 + h2 >= c3 ? (o3 = 0, a3 = c3) : a3 + h2 >= 1 ? (o3 = (e4 * l3 - 1) * Math.pow(2, i3), a3 += h2) : (o3 = e4 * Math.pow(2, h2 - 1) * Math.pow(2, i3), a3 = 0)); i3 >= 8; t3[r4 + f2] = 255 & o3, f2 += d2, o3 /= 256, i3 -= 8)
              ;
            for (a3 = a3 << i3 | o3, u3 += i3; u3 > 0; t3[r4 + f2] = 255 & a3, f2 += d2, a3 /= 256, u3 -= 8)
              ;
            t3[r4 + f2 - d2] |= 128 * m2;
          }
        }, em = nm, rm = tm;
        function nm(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        nm.Varint = 0, nm.Fixed64 = 1, nm.Bytes = 2, nm.Fixed32 = 5;
        var im = 4294967296, sm = 1 / im, am = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function om(t3) {
          return t3.type === nm.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function lm(t3, e4, r4) {
          return r4 ? 4294967296 * e4 + (t3 >>> 0) : 4294967296 * (e4 >>> 0) + (t3 >>> 0);
        }
        function um(t3, e4, r4) {
          var n3 = e4 <= 16383 ? 1 : e4 <= 2097151 ? 2 : e4 <= 268435455 ? 3 : Math.floor(Math.log(e4) / (7 * Math.LN2));
          r4.realloc(n3);
          for (var i3 = r4.pos - 1; i3 >= t3; i3--)
            r4.buf[i3 + n3] = r4.buf[i3];
        }
        function cm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeVarint(t3[r4]);
        }
        function hm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeSVarint(t3[r4]);
        }
        function pm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeFloat(t3[r4]);
        }
        function fm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeDouble(t3[r4]);
        }
        function dm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeBoolean(t3[r4]);
        }
        function mm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeFixed32(t3[r4]);
        }
        function ym(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeSFixed32(t3[r4]);
        }
        function gm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeFixed64(t3[r4]);
        }
        function xm(t3, e4) {
          for (var r4 = 0; r4 < t3.length; r4++)
            e4.writeSFixed64(t3[r4]);
        }
        function bm(t3, e4) {
          return (t3[e4] | t3[e4 + 1] << 8 | t3[e4 + 2] << 16) + 16777216 * t3[e4 + 3];
        }
        function vm(t3, e4, r4) {
          t3[r4] = e4, t3[r4 + 1] = e4 >>> 8, t3[r4 + 2] = e4 >>> 16, t3[r4 + 3] = e4 >>> 24;
        }
        function _m(t3, e4) {
          return (t3[e4] | t3[e4 + 1] << 8 | t3[e4 + 2] << 16) + (t3[e4 + 3] << 24);
        }
        nm.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e4, r4) {
          for (r4 = r4 || this.length; this.pos < r4; ) {
            var n3 = this.readVarint(), i3 = n3 >> 3, s4 = this.pos;
            this.type = 7 & n3, t3(i3, e4, this), this.pos === s4 && this.skip(n3);
          }
          return e4;
        }, readMessage: function(t3, e4) {
          return this.readFields(t3, e4, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = bm(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = _m(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = bm(this.buf, this.pos) + bm(this.buf, this.pos + 4) * im;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = bm(this.buf, this.pos) + _m(this.buf, this.pos + 4) * im;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var t3 = rm.read(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t3;
        }, readDouble: function() {
          var t3 = rm.read(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t3;
        }, readVarint: function(t3) {
          var e4, r4, n3 = this.buf;
          return e4 = 127 & (r4 = n3[this.pos++]), r4 < 128 ? e4 : (e4 |= (127 & (r4 = n3[this.pos++])) << 7, r4 < 128 ? e4 : (e4 |= (127 & (r4 = n3[this.pos++])) << 14, r4 < 128 ? e4 : (e4 |= (127 & (r4 = n3[this.pos++])) << 21, r4 < 128 ? e4 : function(t4, e5, r5) {
            var n4, i3, s4 = r5.buf;
            if (n4 = (112 & (i3 = s4[r5.pos++])) >> 4, i3 < 128)
              return lm(t4, n4, e5);
            if (n4 |= (127 & (i3 = s4[r5.pos++])) << 3, i3 < 128)
              return lm(t4, n4, e5);
            if (n4 |= (127 & (i3 = s4[r5.pos++])) << 10, i3 < 128)
              return lm(t4, n4, e5);
            if (n4 |= (127 & (i3 = s4[r5.pos++])) << 17, i3 < 128)
              return lm(t4, n4, e5);
            if (n4 |= (127 & (i3 = s4[r5.pos++])) << 24, i3 < 128)
              return lm(t4, n4, e5);
            if (n4 |= (1 & (i3 = s4[r5.pos++])) << 31, i3 < 128)
              return lm(t4, n4, e5);
            throw new Error("Expected varint not more than 10 bytes");
          }(e4 |= (15 & (r4 = n3[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e4 = this.pos;
          return this.pos = t3, t3 - e4 >= 12 && am ? function(t4, e5, r4) {
            return am.decode(t4.subarray(e5, r4));
          }(this.buf, e4, t3) : function(t4, e5, r4) {
            for (var n3 = "", i3 = e5; i3 < r4; ) {
              var s4, a3, o3, l3 = t4[i3], u3 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
              if (i3 + c3 > r4)
                break;
              1 === c3 ? l3 < 128 && (u3 = l3) : 2 === c3 ? 128 == (192 & (s4 = t4[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & s4) <= 127 && (u3 = null) : 3 === c3 ? (a3 = t4[i3 + 2], 128 == (192 & (s4 = t4[i3 + 1])) && 128 == (192 & a3) && ((u3 = (15 & l3) << 12 | (63 & s4) << 6 | 63 & a3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (a3 = t4[i3 + 2], o3 = t4[i3 + 3], 128 == (192 & (s4 = t4[i3 + 1])) && 128 == (192 & a3) && 128 == (192 & o3) && ((u3 = (15 & l3) << 18 | (63 & s4) << 12 | (63 & a3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
            }
            return n3;
          }(this.buf, e4, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e4 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e4;
        }, readPackedVarint: function(t3, e4) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readVarint(e4));
          var r4 = om(this);
          for (t3 = t3 || []; this.pos < r4; )
            t3.push(this.readVarint(e4));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readSVarint());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readBoolean());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readFloat());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readDouble());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readFixed32());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readSFixed32());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readFixed64());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== nm.Bytes)
            return t3.push(this.readSFixed64());
          var e4 = om(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var e4 = 7 & t3;
          if (e4 === nm.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e4 === nm.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e4 === nm.Fixed32)
            this.pos += 4;
          else {
            if (e4 !== nm.Fixed64)
              throw new Error("Unimplemented type: " + e4);
            this.pos += 8;
          }
        }, writeTag: function(t3, e4) {
          this.writeVarint(t3 << 3 | e4);
        }, realloc: function(t3) {
          for (var e4 = this.length || 16; e4 < this.pos + t3; )
            e4 *= 2;
          if (e4 !== this.length) {
            var r4 = new Uint8Array(e4);
            r4.set(this.buf), this.buf = r4, this.length = e4;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), vm(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), vm(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), vm(this.buf, -1 & t3, this.pos), vm(this.buf, Math.floor(t3 * sm), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), vm(this.buf, -1 & t3, this.pos), vm(this.buf, Math.floor(t3 * sm), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e4) {
            var r4, n3;
            if (t4 >= 0 ? (r4 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r4 = ~(-t4 % 4294967296)) ? r4 = r4 + 1 | 0 : (r4 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e4.realloc(10), function(t5, e5, r5) {
              r5.buf[r5.pos++] = 127 & t5 | 128, t5 >>>= 7, r5.buf[r5.pos++] = 127 & t5 | 128, t5 >>>= 7, r5.buf[r5.pos++] = 127 & t5 | 128, t5 >>>= 7, r5.buf[r5.pos++] = 127 & t5 | 128, r5.buf[r5.pos] = 127 & (t5 >>>= 7);
            }(r4, 0, e4), function(t5, e5) {
              var r5 = (7 & t5) << 4;
              e5.buf[e5.pos++] |= r5 | ((t5 >>>= 3) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5)))));
            }(n3, e4);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e4 = this.pos;
          this.pos = function(t4, e5, r5) {
            for (var n3, i3, s4 = 0; s4 < e5.length; s4++) {
              if ((n3 = e5.charCodeAt(s4)) > 55295 && n3 < 57344) {
                if (!i3) {
                  n3 > 56319 || s4 + 1 === e5.length ? (t4[r5++] = 239, t4[r5++] = 191, t4[r5++] = 189) : i3 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t4[r5++] = 239, t4[r5++] = 191, t4[r5++] = 189, i3 = n3;
                  continue;
                }
                n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
              } else
                i3 && (t4[r5++] = 239, t4[r5++] = 191, t4[r5++] = 189, i3 = null);
              n3 < 128 ? t4[r5++] = n3 : (n3 < 2048 ? t4[r5++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r5++] = n3 >> 12 | 224 : (t4[r5++] = n3 >> 18 | 240, t4[r5++] = n3 >> 12 & 63 | 128), t4[r5++] = n3 >> 6 & 63 | 128), t4[r5++] = 63 & n3 | 128);
            }
            return r5;
          }(this.buf, t3, this.pos);
          var r4 = this.pos - e4;
          r4 >= 128 && um(e4, r4, this), this.pos = e4 - 1, this.writeVarint(r4), this.pos += r4;
        }, writeFloat: function(t3) {
          this.realloc(4), rm.write(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t3) {
          this.realloc(8), rm.write(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e4 = t3.length;
          this.writeVarint(e4), this.realloc(e4);
          for (var r4 = 0; r4 < e4; r4++)
            this.buf[this.pos++] = t3[r4];
        }, writeRawMessage: function(t3, e4) {
          this.pos++;
          var r4 = this.pos;
          t3(e4, this);
          var n3 = this.pos - r4;
          n3 >= 128 && um(r4, n3, this), this.pos = r4 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t3, e4, r4) {
          this.writeTag(t3, nm.Bytes), this.writeRawMessage(e4, r4);
        }, writePackedVarint: function(t3, e4) {
          e4.length && this.writeMessage(t3, cm, e4);
        }, writePackedSVarint: function(t3, e4) {
          e4.length && this.writeMessage(t3, hm, e4);
        }, writePackedBoolean: function(t3, e4) {
          e4.length && this.writeMessage(t3, dm, e4);
        }, writePackedFloat: function(t3, e4) {
          e4.length && this.writeMessage(t3, pm, e4);
        }, writePackedDouble: function(t3, e4) {
          e4.length && this.writeMessage(t3, fm, e4);
        }, writePackedFixed32: function(t3, e4) {
          e4.length && this.writeMessage(t3, mm, e4);
        }, writePackedSFixed32: function(t3, e4) {
          e4.length && this.writeMessage(t3, ym, e4);
        }, writePackedFixed64: function(t3, e4) {
          e4.length && this.writeMessage(t3, gm, e4);
        }, writePackedSFixed64: function(t3, e4) {
          e4.length && this.writeMessage(t3, xm, e4);
        }, writeBytesField: function(t3, e4) {
          this.writeTag(t3, nm.Bytes), this.writeBytes(e4);
        }, writeFixed32Field: function(t3, e4) {
          this.writeTag(t3, nm.Fixed32), this.writeFixed32(e4);
        }, writeSFixed32Field: function(t3, e4) {
          this.writeTag(t3, nm.Fixed32), this.writeSFixed32(e4);
        }, writeFixed64Field: function(t3, e4) {
          this.writeTag(t3, nm.Fixed64), this.writeFixed64(e4);
        }, writeSFixed64Field: function(t3, e4) {
          this.writeTag(t3, nm.Fixed64), this.writeSFixed64(e4);
        }, writeVarintField: function(t3, e4) {
          this.writeTag(t3, nm.Varint), this.writeVarint(e4);
        }, writeSVarintField: function(t3, e4) {
          this.writeTag(t3, nm.Varint), this.writeSVarint(e4);
        }, writeStringField: function(t3, e4) {
          this.writeTag(t3, nm.Bytes), this.writeString(e4);
        }, writeFloatField: function(t3, e4) {
          this.writeTag(t3, nm.Fixed32), this.writeFloat(e4);
        }, writeDoubleField: function(t3, e4) {
          this.writeTag(t3, nm.Fixed64), this.writeDouble(e4);
        }, writeBooleanField: function(t3, e4) {
          this.writeVarintField(t3, Boolean(e4));
        } };
        var wm = h(em);
        const Mm = 3;
        function Am(t3, e4, r4) {
          e4.glyphs = [], 1 === t3 && r4.readMessage(Sm, e4);
        }
        function Sm(t3, e4, r4) {
          if (3 === t3) {
            const { id: t4, bitmap: n3, width: i3, height: s4, left: a3, top: o3, advance: l3 } = r4.readMessage(Im, {});
            e4.glyphs.push({ id: t4, bitmap: new rp({ width: i3 + 2 * Mm, height: s4 + 2 * Mm }, n3), metrics: { width: i3, height: s4, left: a3, top: o3, advance: l3 } });
          } else
            4 === t3 ? e4.ascender = r4.readSVarint() : 5 === t3 && (e4.descender = r4.readSVarint());
        }
        function Im(t3, e4, r4) {
          1 === t3 ? e4.id = r4.readVarint() : 2 === t3 ? e4.bitmap = r4.readBytes() : 3 === t3 ? e4.width = r4.readVarint() : 4 === t3 ? e4.height = r4.readVarint() : 5 === t3 ? e4.left = r4.readSVarint() : 6 === t3 ? e4.top = r4.readSVarint() : 7 === t3 && (e4.advance = r4.readVarint());
        }
        const km = Mm, Pm = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        class Em {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t3, e4) {
            const r4 = new Em();
            return r4.scale = t3 || 1, r4.fontStack = e4, r4;
          }
          static forImage(t3) {
            const e4 = new Em();
            return e4.imageName = t3, e4;
          }
        }
        class zm {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t3, e4) {
            const r4 = new zm();
            for (let n3 = 0; n3 < t3.sections.length; n3++) {
              const i3 = t3.sections[n3];
              i3.image ? r4.addImageSection(i3) : r4.addTextSection(i3, e4);
            }
            return r4;
          }
          length() {
            return this.text.length;
          }
          getSection(t3) {
            return this.sections[this.sectionIndex[t3]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(t3) {
            return this.sectionIndex[t3];
          }
          getCodePoint(t3) {
            return this.text.codePointAt(t3);
          }
          verticalizePunctuation(t3) {
            this.text = function(t4, e4) {
              let r4 = "";
              for (let n3 = 0; n3 < t4.length; n3++) {
                const i3 = t4.charCodeAt(n3 + 1) || null, s4 = t4.charCodeAt(n3 - 1) || null;
                r4 += !e4 && (i3 && Ao(i3) && !Wd[t4[n3 + 1]] || s4 && Ao(s4) && !Wd[t4[n3 - 1]]) || !Wd[t4[n3]] ? t4[n3] : Wd[t4[n3]];
              }
              return r4;
            }(this.text, t3);
          }
          trim() {
            let t3 = 0;
            for (let e5 = 0; e5 < this.text.length && Bm[this.text.charCodeAt(e5)]; e5++)
              t3++;
            let e4 = this.text.length;
            for (let r4 = this.text.length - 1; r4 >= 0 && r4 >= t3 && Bm[this.text.charCodeAt(r4)]; r4--)
              e4--;
            this.text = this.text.substring(t3, e4), this.sectionIndex = this.sectionIndex.slice(t3, e4);
          }
          substring(t3, e4) {
            const r4 = new zm();
            return r4.text = this.text.substring(t3, e4), r4.sectionIndex = this.sectionIndex.slice(t3, e4), r4.sections = this.sections, r4;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t3, e4) => Math.max(t3, this.sections[e4].scale), 0);
          }
          addTextSection(t3, e4) {
            this.text += t3.text, this.sections.push(Em.forText(t3.scale, t3.fontStack || e4));
            const r4 = this.sections.length - 1;
            for (let e5 = 0; e5 < t3.text.length; ++e5)
              this.sectionIndex.push(r4);
          }
          addImageSection(t3) {
            const e4 = t3.image ? t3.image.namePrimary : "";
            if (0 === e4.length)
              return void hr("Can't add FormattedSection with an empty image.");
            const r4 = this.getNextImageSectionCharCode();
            r4 ? (this.text += String.fromCodePoint(r4), this.sections.push(Em.forImage(e4)), this.sectionIndex.push(this.sections.length - 1)) : hr("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Tm(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2) {
          const m2 = zm.fromFeature(t3, i3);
          h2 === Pm.vertical && m2.verticalizePunctuation(p3);
          let y3 = [];
          const g3 = function(t4, e5, r5, n4, i4, s5) {
            if (!t4)
              return [];
            const a4 = [], o4 = function(t5, e6, r6, n5, i5, s6) {
              let a5 = 0;
              for (let r7 = 0; r7 < t5.length(); r7++) {
                const o5 = t5.getSection(r7);
                a5 += Rm(t5.getCodePoint(r7), o5, n5, i5, e6, s6);
              }
              return a5 / Math.max(1, Math.ceil(a5 / r6));
            }(t4, e5, r5, n4, i4, s5), l4 = t4.text.indexOf("\u200B") >= 0;
            let u4 = 0;
            for (let r6 = 0; r6 < t4.length(); r6++) {
              const h3 = t4.getSection(r6), p4 = t4.getCodePoint(r6);
              if (Bm[p4] || (u4 += Rm(p4, h3, n4, i4, e5, s5)), r6 < t4.length() - 1) {
                const e6 = !((c4 = p4) < 11904 || !(bo["Bopomofo Extended"](c4) || bo.Bopomofo(c4) || bo["CJK Compatibility Forms"](c4) || bo["CJK Compatibility Ideographs"](c4) || bo["CJK Compatibility"](c4) || bo["CJK Radicals Supplement"](c4) || bo["CJK Strokes"](c4) || bo["CJK Symbols and Punctuation"](c4) || bo["CJK Unified Ideographs Extension A"](c4) || bo["CJK Unified Ideographs"](c4) || bo["Enclosed CJK Letters and Months"](c4) || bo["Halfwidth and Fullwidth Forms"](c4) || bo.Hiragana(c4) || bo["Ideographic Description Characters"](c4) || bo["Kangxi Radicals"](c4) || bo["Katakana Phonetic Extensions"](c4) || bo.Katakana(c4) || bo["Vertical Forms"](c4) || bo["Yi Radicals"](c4) || bo["Yi Syllables"](c4)));
                (Cm[p4] || e6 || h3.imageName) && a4.push(Lm(r6 + 1, u4, o4, a4, Dm(p4, t4.getCodePoint(r6 + 1), e6 && l4), false));
              }
            }
            var c4;
            return Fm(Lm(t4.length(), u4, o4, a4, 0, true));
          }(m2, u3, s4, e4, n3, f2), { processBidirectionalText: x3, processStyledBidirectionalText: b2 } = Oo;
          if (x3 && 1 === m2.sections.length) {
            const t4 = x3(m2.toString(), g3);
            for (const e5 of t4) {
              const t5 = new zm();
              t5.text = e5, t5.sections = m2.sections;
              for (let r5 = 0; r5 < e5.length; r5++)
                t5.sectionIndex.push(0);
              y3.push(t5);
            }
          } else if (b2) {
            const t4 = b2(m2.text, m2.sectionIndex, g3);
            for (const e5 of t4) {
              const t5 = new zm();
              t5.text = e5[0], t5.sectionIndex = e5[1], t5.sections = m2.sections, y3.push(t5);
            }
          } else
            y3 = function(t4, e5) {
              const r5 = [], n4 = t4.text;
              let i4 = 0;
              for (const n5 of e5)
                r5.push(t4.substring(i4, n5)), i4 = n5;
              return i4 < n4.length && r5.push(t4.substring(i4, n4.length)), r5;
            }(m2, g3);
          const v3 = [], _3 = { positionedLines: v3, text: m2.toString(), top: c3[1], bottom: c3[1], left: c3[0], right: c3[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
          return function(t4, e5, r5, n4, i4, s5, a4, o4, l4, u4, c4, h3) {
            let p4 = 0, f3 = 0, d3 = 0;
            const m3 = "right" === o4 ? 1 : "left" === o4 ? 0 : 0.5;
            let y4 = false;
            for (const t5 of i4) {
              const r6 = t5.getSections();
              for (const t6 of r6) {
                if (t6.imageName)
                  continue;
                const r7 = e5[t6.fontStack];
                if (r7 && (y4 = void 0 !== r7.ascender && void 0 !== r7.descender, !y4))
                  break;
              }
              if (!y4)
                break;
            }
            let g4 = 0;
            for (const a5 of i4) {
              a5.trim();
              const i5 = a5.getMaxScale(), o5 = (i5 - 1) * $d, b4 = { positionedGlyphs: [], lineOffset: 0 };
              t4.positionedLines[g4] = b4;
              const v5 = b4.positionedGlyphs;
              let _5 = 0;
              if (!a5.length()) {
                f3 += s5, ++g4;
                continue;
              }
              let w2 = 0, M3 = 0;
              for (let s6 = 0; s6 < a5.length(); s6++) {
                const o6 = a5.getSection(s6), d4 = a5.getSectionIndex(s6), m4 = a5.getCodePoint(s6);
                let g5 = o6.scale, b5 = null, A3 = null, S2 = null, I2 = $d, k2 = 0;
                const P2 = !(l4 === Pm.horizontal || !c4 && !Mo(m4) || c4 && (Bm[m4] || (x4 = m4, bo.Arabic(x4) || bo["Arabic Supplement"](x4) || bo["Arabic Extended-A"](x4) || bo["Arabic Presentation Forms-A"](x4) || bo["Arabic Presentation Forms-B"](x4))));
                if (o6.imageName) {
                  const e6 = n4[o6.imageName];
                  if (!e6)
                    continue;
                  S2 = o6.imageName, t4.iconsInText = t4.iconsInText || true, A3 = e6.paddedRect;
                  const r6 = e6.displaySize;
                  g5 = g5 * $d / h3, b5 = { width: r6[0], height: r6[1], left: 0, top: -km, advance: P2 ? r6[1] : r6[0], localGlyph: false }, k2 = y4 ? -b5.height * g5 : i5 * $d - 17 - r6[1] * g5, I2 = b5.advance;
                  const s7 = (P2 ? r6[0] : r6[1]) * g5 - $d * i5;
                  s7 > 0 && s7 > _5 && (_5 = s7);
                } else {
                  const t5 = r5[o6.fontStack];
                  if (!t5)
                    continue;
                  t5[m4] && (A3 = t5[m4]);
                  const n5 = e5[o6.fontStack];
                  if (!n5)
                    continue;
                  const s7 = n5.glyphs[m4];
                  if (!s7)
                    continue;
                  if (b5 = s7.metrics, I2 = 8203 !== m4 ? $d : 0, y4) {
                    const t6 = void 0 !== n5.ascender ? Math.abs(n5.ascender) : 0, e6 = void 0 !== n5.descender ? Math.abs(n5.descender) : 0, r6 = (t6 + e6) * g5;
                    w2 < r6 && (w2 = r6, M3 = (t6 - e6) / 2 * g5), k2 = -t6 * g5;
                  } else
                    k2 = (i5 - g5) * $d - 17;
                }
                P2 ? (t4.verticalizable = true, v5.push({ glyph: m4, imageName: S2, x: p4, y: f3 + k2, vertical: P2, scale: g5, localGlyph: b5.localGlyph, fontStack: o6.fontStack, sectionIndex: d4, metrics: b5, rect: A3 }), p4 += I2 * g5 + u4) : (v5.push({ glyph: m4, imageName: S2, x: p4, y: f3 + k2, vertical: P2, scale: g5, localGlyph: b5.localGlyph, fontStack: o6.fontStack, sectionIndex: d4, metrics: b5, rect: A3 }), p4 += b5.advance * g5 + u4);
              }
              0 !== v5.length && (d3 = Math.max(p4 - u4, d3), y4 ? Um(v5, m3, _5, M3, s5 * i5 / 2) : Um(v5, m3, _5, 0, s5 / 2)), p4 = 0;
              const A2 = s5 * i5 + _5;
              b4.lineOffset = Math.max(_5, o5), f3 += A2, ++g4;
            }
            var x4;
            const b3 = f3, { horizontalAlign: v4, verticalAlign: _4 } = Om(a4);
            (function(t5, e6, r6, n5, i5, s6) {
              const a5 = (e6 - r6) * i5, o5 = -s6 * n5;
              for (const e7 of t5)
                for (const t6 of e7.positionedGlyphs)
                  t6.x += a5, t6.y += o5;
            })(t4.positionedLines, m3, v4, _4, d3, b3), t4.top += -_4 * b3, t4.bottom = t4.top + b3, t4.left += -v4 * d3, t4.right = t4.left + d3, t4.hasBaseline = y4;
          }(_3, e4, r4, n3, y3, a3, o3, l3, h2, u3, p3, d2), !function(t4) {
            for (const e5 of t4)
              if (0 !== e5.positionedGlyphs.length)
                return false;
            return true;
          }(v3) && _3;
        }
        const Bm = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Cm = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Rm(t3, e4, r4, n3, i3, s4) {
          if (e4.imageName) {
            const t4 = n3[e4.imageName];
            return t4 ? t4.displaySize[0] * e4.scale * $d / s4 + i3 : 0;
          }
          {
            const n4 = r4[e4.fontStack], s5 = n4 && n4.glyphs[t3];
            return s5 ? s5.metrics.advance * e4.scale + i3 : 0;
          }
        }
        function Vm(t3, e4, r4, n3) {
          const i3 = Math.pow(t3 - e4, 2);
          return n3 ? t3 < e4 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r4) * r4;
        }
        function Dm(t3, e4, r4) {
          let n3 = 0;
          return 10 === t3 && (n3 -= 1e4), r4 && (n3 += 150), 40 !== t3 && 65288 !== t3 || (n3 += 50), 41 !== e4 && 65289 !== e4 || (n3 += 50), n3;
        }
        function Lm(t3, e4, r4, n3, i3, s4) {
          let a3 = null, o3 = Vm(e4, r4, i3, s4);
          for (const t4 of n3) {
            const n4 = Vm(e4 - t4.x, r4, i3, s4) + t4.badness;
            n4 <= o3 && (a3 = t4, o3 = n4);
          }
          return { index: t3, x: e4, priorBreak: a3, badness: o3 };
        }
        function Fm(t3) {
          return t3 ? Fm(t3.priorBreak).concat(t3.index) : [];
        }
        function Om(t3) {
          let e4 = 0.5, r4 = 0.5;
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              e4 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e4 = 0;
          }
          switch (t3) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r4 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r4 = 0;
          }
          return { horizontalAlign: e4, verticalAlign: r4 };
        }
        function Um(t3, e4, r4, n3, i3) {
          if (!(e4 || r4 || n3 || i3))
            return;
          const s4 = t3.length - 1, a3 = t3[s4], o3 = (a3.x + a3.metrics.advance * a3.scale) * e4;
          for (let e5 = 0; e5 <= s4; e5++)
            t3[e5].x -= o3, t3[e5].y += r4 + n3 + i3;
        }
        function Nm(t3, e4, r4, n3) {
          const { horizontalAlign: i3, verticalAlign: s4 } = Om(n3), a3 = r4[0] - t3.displaySize[0] * i3, o3 = r4[1] - t3.displaySize[1] * s4;
          return { imagePrimary: t3, imageSecondary: e4, top: o3, bottom: o3 + t3.displaySize[1], left: a3, right: a3 + t3.displaySize[0] };
        }
        function jm(t3, e4, r4, n3, i3, s4) {
          const a3 = t3.imagePrimary;
          let o3;
          if (a3.content) {
            const t4 = a3.content, e5 = a3.pixelRatio || 1;
            o3 = [t4[0] / e5, t4[1] / e5, a3.displaySize[0] - t4[2] / e5, a3.displaySize[1] - t4[3] / e5];
          }
          const l3 = e4.left * s4, u3 = e4.right * s4;
          let c3, h2, p3, f2;
          "width" === r4 || "both" === r4 ? (f2 = i3[0] + l3 - n3[3], h2 = i3[0] + u3 + n3[1]) : (f2 = i3[0] + (l3 + u3 - a3.displaySize[0]) / 2, h2 = f2 + a3.displaySize[0]);
          const d2 = e4.top * s4, m2 = e4.bottom * s4;
          return "height" === r4 || "both" === r4 ? (c3 = i3[1] + d2 - n3[0], p3 = i3[1] + m2 + n3[2]) : (c3 = i3[1] + (d2 + m2 - a3.displaySize[1]) / 2, p3 = c3 + a3.displaySize[1]), { imagePrimary: a3, imageSecondary: void 0, top: c3, right: h2, bottom: p3, left: f2, collisionPadding: o3 };
        }
        class qm extends Ue {
          constructor(t3, e4, r4, n3, i3) {
            super(t3, e4), this.angle = n3, this.z = r4, void 0 !== i3 && (this.segment = i3);
          }
          clone() {
            return new qm(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function $m(t3, e4, r4, n3, i3) {
          if (void 0 === e4.segment)
            return true;
          let s4 = e4, a3 = e4.segment + 1, o3 = 0;
          for (; o3 > -r4 / 2; ) {
            if (a3--, a3 < 0)
              return false;
            o3 -= t3[a3].dist(s4), s4 = t3[a3];
          }
          o3 += t3[a3].dist(t3[a3 + 1]), a3++;
          const l3 = [];
          let u3 = 0;
          for (; o3 < r4 / 2; ) {
            const e5 = t3[a3], r5 = t3[a3 + 1];
            if (!r5)
              return false;
            let s5 = t3[a3 - 1].angleTo(e5) - e5.angleTo(r5);
            for (s5 = Math.abs((s5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: o3, angleDelta: s5 }), u3 += s5; o3 - l3[0].distance > n3; )
              u3 -= l3.shift().angleDelta;
            if (u3 > i3)
              return false;
            a3++, o3 += e5.dist(r5);
          }
          return true;
        }
        function Gm(t3) {
          let e4 = 0;
          for (let r4 = 0; r4 < t3.length - 1; r4++)
            e4 += t3[r4].dist(t3[r4 + 1]);
          return e4;
        }
        function Qm(t3, e4, r4) {
          return t3 ? 0.6 * e4 * r4 : 0;
        }
        function Ym(t3, e4) {
          return Math.max(t3 ? t3.right - t3.left : 0, e4 ? e4.right - e4.left : 0);
        }
        function Xm(t3, e4, r4, n3, i3, s4) {
          const a3 = Qm(r4, i3, s4), o3 = Ym(r4, n3) * s4;
          let l3 = 0;
          const u3 = Gm(t3) / 2;
          for (let r5 = 0; r5 < t3.length - 1; r5++) {
            const n4 = t3[r5], i4 = t3[r5 + 1], s5 = n4.dist(i4);
            if (l3 + s5 > u3) {
              const c3 = (u3 - l3) / s5, h2 = qn(n4.x, i4.x, c3), p3 = qn(n4.y, i4.y, c3), f2 = new qm(h2, p3, 0, i4.angleTo(n4), r5);
              return !a3 || $m(t3, f2, o3, a3, e4) ? f2 : void 0;
            }
            l3 += s5;
          }
        }
        function Zm(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          const u3 = Qm(n3, s4, a3), c3 = Ym(n3, i3), h2 = c3 * a3, p3 = 0 === t3[0].x || t3[0].x === l3 || 0 === t3[0].y || t3[0].y === l3;
          return e4 - h2 < e4 / 4 && (e4 = h2 + e4 / 4), Km(t3, p3 ? e4 / 2 * o3 % e4 : (c3 / 2 + 2 * s4) * a3 * o3 % e4, e4, u3, r4, h2, p3, false, l3);
        }
        function Km(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          const u3 = s4 / 2, c3 = Gm(t3);
          let h2 = 0, p3 = e4 - r4, f2 = [];
          for (let e5 = 0; e5 < t3.length - 1; e5++) {
            const a4 = t3[e5], o4 = t3[e5 + 1], d2 = a4.dist(o4), m2 = o4.angleTo(a4);
            for (; p3 + r4 < h2 + d2; ) {
              p3 += r4;
              const y3 = (p3 - h2) / d2, g3 = qn(a4.x, o4.x, y3), x3 = qn(a4.y, o4.y, y3);
              if (g3 >= 0 && g3 < l3 && x3 >= 0 && x3 < l3 && p3 - u3 >= 0 && p3 + u3 <= c3) {
                const r5 = new qm(g3, x3, 0, m2, e5);
                n3 && !$m(t3, r5, s4, n3, i3) || f2.push(r5);
              }
            }
            h2 += d2;
          }
          return o3 || f2.length || a3 || (f2 = Km(t3, h2 / 2, r4, n3, i3, s4, a3, true, l3)), f2;
        }
        function Wm(t3, e4, r4, n3, i3) {
          const s4 = [];
          for (let a3 = 0; a3 < t3.length; a3++) {
            const o3 = t3[a3];
            let l3;
            for (let t4 = 0; t4 < o3.length - 1; t4++) {
              let a4 = o3[t4], u3 = o3[t4 + 1];
              a4.x < e4 && u3.x < e4 || (a4.x < e4 ? a4 = new Ue(e4, a4.y + (e4 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round() : u3.x < e4 && (u3 = new Ue(e4, a4.y + (e4 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round()), a4.y < r4 && u3.y < r4 || (a4.y < r4 ? a4 = new Ue(a4.x + (r4 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), r4)._round() : u3.y < r4 && (u3 = new Ue(a4.x + (r4 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), r4)._round()), a4.x >= n3 && u3.x >= n3 || (a4.x >= n3 ? a4 = new Ue(n3, a4.y + (n3 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round() : u3.x >= n3 && (u3 = new Ue(n3, a4.y + (n3 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round()), a4.y >= i3 && u3.y >= i3 || (a4.y >= i3 ? a4 = new Ue(a4.x + (i3 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), i3)._round() : u3.y >= i3 && (u3 = new Ue(a4.x + (i3 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), i3)._round()), l3 && a4.equals(l3[l3.length - 1]) || (l3 = [a4], s4.push(l3)), l3.push(u3)))));
            }
          }
          return s4;
        }
        function Hm(t3) {
          let e4 = 0, r4 = 0;
          for (const n4 of t3)
            e4 += n4.w * n4.h, r4 = Math.max(r4, n4.w);
          t3.sort((t4, e5) => e5.h - t4.h);
          const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e4 / 0.95)), r4), h: 1 / 0 }];
          let i3 = 0, s4 = 0;
          for (const e5 of t3)
            for (let t4 = n3.length - 1; t4 >= 0; t4--) {
              const r5 = n3[t4];
              if (!(e5.w > r5.w || e5.h > r5.h)) {
                if (e5.x = r5.x, e5.y = r5.y, s4 = Math.max(s4, e5.y + e5.h), i3 = Math.max(i3, e5.x + e5.w), e5.w === r5.w && e5.h === r5.h) {
                  const e6 = n3.pop();
                  t4 < n3.length && (n3[t4] = e6);
                } else
                  e5.h === r5.h ? (r5.x += e5.w, r5.w -= e5.w) : e5.w === r5.w ? (r5.y += e5.h, r5.h -= e5.h) : (n3.push({ x: r5.x + e5.w, y: r5.y, w: r5.w - e5.w, h: e5.h }), r5.y += e5.h, r5.h -= e5.h);
                break;
              }
            }
          return { w: i3, h: s4, fill: e4 / (i3 * s4) || 0 };
        }
        fo(qm, "Anchor");
        const Jm = 1;
        class ty {
          constructor(t3, { pixelRatio: e4, version: r4, stretchX: n3, stretchY: i3, content: s4 }) {
            this.paddedRect = t3, this.pixelRatio = e4, this.stretchX = n3, this.stretchY = i3, this.content = s4, this.version = r4;
          }
          get tl() {
            return [this.paddedRect.x + Jm, this.paddedRect.y + Jm];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - Jm, this.paddedRect.y + this.paddedRect.h - Jm];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * Jm) / this.pixelRatio, (this.paddedRect.h - 2 * Jm) / this.pixelRatio];
          }
        }
        class ey {
          constructor(t3, e4) {
            const r4 = {}, n3 = {};
            this.haveRenderCallbacks = [];
            const i3 = [];
            this.addImages(t3, r4, i3), this.addImages(e4, n3, i3);
            const { w: s4, h: a3 } = Hm(i3), o3 = new np({ width: s4 || 1, height: a3 || 1 });
            for (const e5 in t3) {
              const n4 = t3[e5], i4 = r4[e5].paddedRect;
              np.copy(n4.data, o3, { x: 0, y: 0 }, { x: i4.x + Jm, y: i4.y + Jm }, n4.data, n4.sdf);
            }
            for (const t4 in e4) {
              const r5 = e4[t4], i4 = n3[t4].paddedRect, s5 = i4.x + Jm, a4 = i4.y + Jm, l3 = r5.data.width, u3 = r5.data.height;
              np.copy(r5.data, o3, { x: 0, y: 0 }, { x: s5, y: a4 }, r5.data), np.copy(r5.data, o3, { x: 0, y: u3 - 1 }, { x: s5, y: a4 - 1 }, { width: l3, height: 1 }), np.copy(r5.data, o3, { x: 0, y: 0 }, { x: s5, y: a4 + u3 }, { width: l3, height: 1 }), np.copy(r5.data, o3, { x: l3 - 1, y: 0 }, { x: s5 - 1, y: a4 }, { width: 1, height: u3 }), np.copy(r5.data, o3, { x: 0, y: 0 }, { x: s5 + l3, y: a4 }, { width: 1, height: u3 });
            }
            this.image = o3, this.iconPositions = r4, this.patternPositions = n3;
          }
          addImages(t3, e4, r4) {
            for (const n3 in t3) {
              const i3 = t3[n3], s4 = { x: 0, y: 0, w: i3.data.width + 2 * Jm, h: i3.data.height + 2 * Jm };
              r4.push(s4), e4[n3] = new ty(s4, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n3);
            }
          }
          patchUpdatedImages(t3, e4, r4) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e5) => t3.hasImage(e5, r4)), t3.dispatchRenderCallbacks(this.haveRenderCallbacks, r4);
            for (const n3 in t3.getUpdatedImages(r4))
              this.patchUpdatedImage(this.iconPositions[n3], t3.getImage(n3, r4), e4), this.patchUpdatedImage(this.patternPositions[n3], t3.getImage(n3, r4), e4);
          }
          patchUpdatedImage(t3, e4, r4) {
            if (!t3 || !e4)
              return;
            if (t3.version === e4.version)
              return;
            t3.version = e4.version;
            const [n3, i3] = t3.tl, s4 = !!Object.keys(this.patternPositions).length;
            r4.update(e4.data, { useMipmap: s4 }, { x: n3, y: i3 });
          }
        }
        fo(ty, "ImagePosition"), fo(ey, "ImageAtlas");
        const ry = 1e20;
        function ny(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          for (let u3 = e4; u3 < e4 + n3; u3++)
            iy(t3, r4 * s4 + u3, s4, i3, a3, o3, l3);
          for (let u3 = r4; u3 < r4 + i3; u3++)
            iy(t3, u3 * s4 + e4, 1, n3, a3, o3, l3);
        }
        function iy(t3, e4, r4, n3, i3, s4, a3) {
          s4[0] = 0, a3[0] = -ry, a3[1] = ry, i3[0] = t3[e4];
          for (let o3 = 1, l3 = 0, u3 = 0; o3 < n3; o3++) {
            i3[o3] = t3[e4 + o3 * r4];
            const n4 = o3 * o3;
            do {
              const t4 = s4[l3];
              u3 = (i3[o3] - i3[t4] + n4 - t4 * t4) / (o3 - t4) / 2;
            } while (u3 <= a3[l3] && --l3 > -1);
            l3++, s4[l3] = o3, a3[l3] = u3, a3[l3 + 1] = ry;
          }
          for (let o3 = 0, l3 = 0; o3 < n3; o3++) {
            for (; a3[l3 + 1] < o3; )
              l3++;
            const n4 = s4[l3], u3 = o3 - n4;
            t3[e4 + o3 * r4] = i3[n4] + u3 * u3;
          }
        }
        const sy = 2, ay = { none: 0, ideographs: 1, all: 2 };
        class oy {
          constructor(t3, e4, r4) {
            this.requestManager = t3, this.localGlyphMode = e4, this.localFontFamily = r4, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(t3, e4) {
            this.urls[e4] = t3;
          }
          getGlyphs(t3, e4, r4) {
            const i3 = [], s4 = this.urls[e4] || n2.GLYPHS_URL;
            for (const e5 in t3)
              for (const r5 of t3[e5])
                i3.push({ stack: e5, id: r5 });
            He(i3, ({ stack: t4, id: e5 }, r5) => {
              let n3 = this.entries[t4];
              n3 || (n3 = this.entries[t4] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let i4 = n3.glyphs[e5];
              if (void 0 !== i4)
                return void r5(null, { stack: t4, id: e5, glyph: i4 });
              if (i4 = this._tinySDF(n3, t4, e5), i4)
                return n3.glyphs[e5] = i4, void r5(null, { stack: t4, id: e5, glyph: i4 });
              const a3 = Math.floor(e5 / 256);
              if (256 * a3 > 65535)
                return void r5(new Error("glyphs > 65535 not supported"));
              if (n3.ranges[a3])
                return void r5(null, { stack: t4, id: e5, glyph: i4 });
              let o3 = n3.requests[a3];
              o3 || (o3 = n3.requests[a3] = [], oy.loadGlyphRange(t4, a3, s4, this.requestManager, (t5, e6) => {
                if (e6) {
                  n3.ascender = e6.ascender, n3.descender = e6.descender;
                  for (const t6 in e6.glyphs)
                    this._doesCharSupportLocalGlyph(+t6) || (n3.glyphs[+t6] = e6.glyphs[+t6]);
                  n3.ranges[a3] = true;
                }
                for (const r6 of o3)
                  r6(t5, e6);
                delete n3.requests[a3];
              })), o3.push((n4, i5) => {
                n4 ? r5(n4) : i5 && r5(null, { stack: t4, id: e5, glyph: i5.glyphs[e5] || null });
              });
            }, (t4, e5) => {
              if (t4)
                r4(t4);
              else if (e5) {
                const t5 = {};
                for (const { stack: r5, id: n3, glyph: i4 } of e5)
                  void 0 === t5[r5] && (t5[r5] = {}), void 0 === t5[r5].glyphs && (t5[r5].glyphs = {}), t5[r5].glyphs[n3] = i4 && { id: i4.id, bitmap: i4.bitmap.clone(), metrics: i4.metrics }, t5[r5].ascender = this.entries[r5].ascender, t5[r5].descender = this.entries[r5].descender;
                r4(null, t5);
              }
            });
          }
          _doesCharSupportLocalGlyph(t3) {
            return this.localGlyphMode !== ay.none && (this.localGlyphMode === ay.all ? !!this.localFontFamily : !!this.localFontFamily && (bo["CJK Unified Ideographs"](t3) || bo["Hangul Syllables"](t3) || bo.Hiragana(t3) || bo.Katakana(t3) || bo["CJK Symbols and Punctuation"](t3) || bo["CJK Unified Ideographs Extension A"](t3) || bo["CJK Unified Ideographs Extension B"](t3)));
          }
          _tinySDF(t3, e4, r4) {
            const n3 = this.localFontFamily;
            if (!n3 || !this._doesCharSupportLocalGlyph(r4))
              return;
            let i3 = t3.tinySDF;
            if (!i3) {
              let r5 = "400";
              /bold/i.test(e4) ? r5 = "900" : /medium/i.test(e4) ? r5 = "500" : /light/i.test(e4) && (r5 = "200"), i3 = t3.tinySDF = new oy.TinySDF({ fontFamily: n3, fontWeight: r5, fontSize: 24 * sy, buffer: 3 * sy, radius: 8 * sy }), i3.fontWeight = r5;
            }
            if (this.localGlyphs[i3.fontWeight][r4])
              return this.localGlyphs[i3.fontWeight][r4];
            const s4 = String.fromCodePoint(r4), { data: a3, width: o3, height: l3, glyphWidth: u3, glyphHeight: c3, glyphLeft: h2, glyphTop: p3, glyphAdvance: f2 } = i3.draw(s4);
            return this.localGlyphs[i3.fontWeight][r4] = { id: r4, bitmap: new rp({ width: o3, height: l3 }, a3), metrics: { width: u3 / sy, height: c3 / sy, left: h2 / sy, top: p3 / sy - 27, advance: f2 / sy, localGlyph: true } };
          }
        }
        oy.loadGlyphRange = function(t3, e4, r4, n3, i3) {
          const s4 = 256 * e4, a3 = s4 + 255, o3 = n3.transformRequest(n3.normalizeGlyphsURL(r4).replace("{fontstack}", t3).replace("{range}", `${s4}-${a3}`), Zr.Glyphs);
          Jr(o3, (t4, e5) => {
            if (t4)
              i3(t4);
            else if (e5) {
              const t5 = {}, r5 = function(t6) {
                return new wm(t6).readFields(Am, {});
              }(e5);
              for (const e6 of r5.glyphs)
                t5[e6.id] = e6;
              i3(null, { glyphs: t5, ascender: r5.ascender, descender: r5.descender });
            }
          });
        }, oy.TinySDF = class {
          constructor({ fontSize: t3 = 24, buffer: e4 = 3, radius: r4 = 8, cutoff: n3 = 0.25, fontFamily: i3 = "sans-serif", fontWeight: s4 = "normal", fontStyle: a3 = "normal" } = {}) {
            this.buffer = e4, this.cutoff = n3, this.radius = r4;
            const o3 = this.size = t3 + 4 * e4, l3 = this._createCanvas(o3), u3 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
            u3.font = `${a3} ${s4} ${t3}px ${i3}`, u3.textBaseline = "alphabetic", u3.textAlign = "left", u3.fillStyle = "black", this.gridOuter = new Float64Array(o3 * o3), this.gridInner = new Float64Array(o3 * o3), this.f = new Float64Array(o3), this.z = new Float64Array(o3 + 1), this.v = new Uint16Array(o3);
          }
          _createCanvas(t3) {
            const e4 = document.createElement("canvas");
            return e4.width = e4.height = t3, e4;
          }
          draw(t3) {
            const { width: e4, actualBoundingBoxAscent: r4, actualBoundingBoxDescent: n3, actualBoundingBoxLeft: i3, actualBoundingBoxRight: s4 } = this.ctx.measureText(t3), a3 = Math.ceil(r4), o3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s4 - i3))), l3 = Math.min(this.size - this.buffer, a3 + Math.ceil(n3)), u3 = o3 + 2 * this.buffer, c3 = l3 + 2 * this.buffer, h2 = Math.max(u3 * c3, 0), p3 = new Uint8ClampedArray(h2), f2 = { data: p3, width: u3, height: c3, glyphWidth: o3, glyphHeight: l3, glyphTop: a3, glyphLeft: 0, glyphAdvance: e4 };
            if (0 === o3 || 0 === l3)
              return f2;
            const { ctx: d2, buffer: m2, gridInner: y3, gridOuter: g3 } = this;
            d2.clearRect(m2, m2, o3, l3), d2.fillText(t3, m2, m2 + a3);
            const x3 = d2.getImageData(m2, m2, o3, l3);
            g3.fill(ry, 0, h2), y3.fill(0, 0, h2);
            for (let t4 = 0; t4 < l3; t4++)
              for (let e5 = 0; e5 < o3; e5++) {
                const r5 = x3.data[4 * (t4 * o3 + e5) + 3] / 255;
                if (0 === r5)
                  continue;
                const n4 = (t4 + m2) * u3 + e5 + m2;
                if (1 === r5)
                  g3[n4] = 0, y3[n4] = ry;
                else {
                  const t5 = 0.5 - r5;
                  g3[n4] = t5 > 0 ? t5 * t5 : 0, y3[n4] = t5 < 0 ? t5 * t5 : 0;
                }
              }
            ny(g3, 0, 0, u3, c3, u3, this.f, this.v, this.z), ny(y3, m2, m2, o3, l3, u3, this.f, this.v, this.z);
            for (let t4 = 0; t4 < h2; t4++) {
              const e5 = Math.sqrt(g3[t4]) - Math.sqrt(y3[t4]);
              p3[t4] = Math.round(255 - 255 * (e5 / this.radius + this.cutoff));
            }
            return f2;
          }
        };
        const ly = Jm;
        function uy(t3, e4, r4, n3) {
          const i3 = [], s4 = t3.imagePrimary, a3 = s4.pixelRatio, o3 = s4.paddedRect.w - 2 * ly, l3 = s4.paddedRect.h - 2 * ly, u3 = t3.right - t3.left, c3 = t3.bottom - t3.top, h2 = s4.stretchX || [[0, o3]], p3 = s4.stretchY || [[0, l3]], f2 = (t4, e5) => t4 + e5[1] - e5[0], d2 = h2.reduce(f2, 0), m2 = p3.reduce(f2, 0), y3 = o3 - d2, g3 = l3 - m2;
          let x3 = 0, b2 = d2, v3 = 0, _3 = m2, w2 = 0, M3 = y3, A2 = 0, S2 = g3;
          if (s4.content && n3) {
            const t4 = s4.content;
            x3 = cy(h2, 0, t4[0]), v3 = cy(p3, 0, t4[1]), b2 = cy(h2, t4[0], t4[2]), _3 = cy(p3, t4[1], t4[3]), w2 = t4[0] - x3, A2 = t4[1] - v3, M3 = t4[2] - t4[0] - b2, S2 = t4[3] - t4[1] - _3;
          }
          const I2 = (n4, i4, o4, l4) => {
            const h3 = py(n4.stretch - x3, b2, u3, t3.left), p4 = fy(n4.fixed - w2, M3, n4.stretch, d2), f3 = py(i4.stretch - v3, _3, c3, t3.top), y4 = fy(i4.fixed - A2, S2, i4.stretch, m2), g4 = py(o4.stretch - x3, b2, u3, t3.left), I3 = fy(o4.fixed - w2, M3, o4.stretch, d2), k2 = py(l4.stretch - v3, _3, c3, t3.top), P2 = fy(l4.fixed - A2, S2, l4.stretch, m2), E2 = new Ue(h3, f3), z3 = new Ue(g4, f3), T2 = new Ue(g4, k2), B2 = new Ue(h3, k2), C2 = new Ue(p4 / a3, y4 / a3), R3 = new Ue(I3 / a3, P2 / a3), V2 = e4 * Math.PI / 180;
            if (V2) {
              const t4 = Math.sin(V2), e5 = Math.cos(V2), r5 = [e5, -t4, t4, e5];
              E2._matMult(r5), z3._matMult(r5), B2._matMult(r5), T2._matMult(r5);
            }
            const D2 = n4.stretch + n4.fixed, L2 = o4.stretch + o4.fixed, F2 = i4.stretch + i4.fixed, O2 = l4.stretch + l4.fixed, U2 = t3.imageSecondary;
            return { tl: E2, tr: z3, bl: B2, br: T2, texPrimary: { x: s4.paddedRect.x + ly + D2, y: s4.paddedRect.y + ly + F2, w: L2 - D2, h: O2 - F2 }, texSecondary: U2 ? { x: U2.paddedRect.x + ly + D2, y: U2.paddedRect.y + ly + F2, w: L2 - D2, h: O2 - F2 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: C2, pixelOffsetBR: R3, minFontScaleX: M3 / a3 / u3, minFontScaleY: S2 / a3 / c3, isSDF: r4 };
          };
          if (n3 && (s4.stretchX || s4.stretchY)) {
            const t4 = hy(h2, y3, d2), e5 = hy(p3, g3, m2);
            for (let r5 = 0; r5 < t4.length - 1; r5++) {
              const n4 = t4[r5], s5 = t4[r5 + 1];
              for (let t5 = 0; t5 < e5.length - 1; t5++)
                i3.push(I2(n4, e5[t5], s5, e5[t5 + 1]));
            }
          } else
            i3.push(I2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o3 + 1 }, { fixed: 0, stretch: l3 + 1 }));
          return i3;
        }
        function cy(t3, e4, r4) {
          let n3 = 0;
          for (const i3 of t3)
            n3 += Math.max(e4, Math.min(r4, i3[1])) - Math.max(e4, Math.min(r4, i3[0]));
          return n3;
        }
        function hy(t3, e4, r4) {
          const n3 = [{ fixed: -ly, stretch: 0 }];
          for (const [e5, r5] of t3) {
            const t4 = n3[n3.length - 1];
            n3.push({ fixed: e5 - t4.stretch, stretch: t4.stretch }), n3.push({ fixed: e5 - t4.stretch, stretch: t4.stretch + (r5 - e5) });
          }
          return n3.push({ fixed: e4 + ly, stretch: r4 }), n3;
        }
        function py(t3, e4, r4, n3) {
          return t3 / e4 * r4 + n3;
        }
        function fy(t3, e4, r4, n3) {
          return t3 - e4 * r4 / n3;
        }
        function dy(t3, e4, r4, n3) {
          const i3 = e4 + t3.positionedLines[n3].lineOffset;
          return 0 === n3 ? r4 + i3 / 2 : r4 + (i3 + (e4 + t3.positionedLines[n3 - 1].lineOffset)) / 2;
        }
        function my(t3, e4 = 1, r4 = false) {
          let n3 = 1 / 0, i3 = 1 / 0, s4 = -1 / 0, a3 = -1 / 0;
          const o3 = t3[0];
          for (let t4 = 0; t4 < o3.length; t4++) {
            const e5 = o3[t4];
            (!t4 || e5.x < n3) && (n3 = e5.x), (!t4 || e5.y < i3) && (i3 = e5.y), (!t4 || e5.x > s4) && (s4 = e5.x), (!t4 || e5.y > a3) && (a3 = e5.y);
          }
          const l3 = Math.min(s4 - n3, a3 - i3);
          let u3 = l3 / 2;
          const c3 = new ns([], yy);
          if (0 === l3)
            return new Ue(n3, i3);
          for (let e5 = n3; e5 < s4; e5 += l3)
            for (let r5 = i3; r5 < a3; r5 += l3)
              c3.push(new gy(e5 + u3, r5 + u3, u3, t3));
          let h2 = function(t4) {
            let e5 = 0, r5 = 0, n4 = 0;
            const i4 = t4[0];
            for (let t5 = 0, s5 = i4.length, a4 = s5 - 1; t5 < s5; a4 = t5++) {
              const s6 = i4[t5], o4 = i4[a4], l4 = s6.x * o4.y - o4.x * s6.y;
              r5 += (s6.x + o4.x) * l4, n4 += (s6.y + o4.y) * l4, e5 += 3 * l4;
            }
            return new gy(r5 / e5, n4 / e5, 0, t4);
          }(t3), p3 = c3.length;
          for (; c3.length; ) {
            const n4 = c3.pop();
            (n4.d > h2.d || !h2.d) && (h2 = n4, r4 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, p3)), n4.max - h2.d <= e4 || (u3 = n4.h / 2, c3.push(new gy(n4.p.x - u3, n4.p.y - u3, u3, t3)), c3.push(new gy(n4.p.x + u3, n4.p.y - u3, u3, t3)), c3.push(new gy(n4.p.x - u3, n4.p.y + u3, u3, t3)), c3.push(new gy(n4.p.x + u3, n4.p.y + u3, u3, t3)), p3 += 4);
          }
          return r4 && (console.log(`num probes: ${p3}`), console.log(`best distance: ${h2.d}`)), h2.p;
        }
        function yy(t3, e4) {
          return e4.max - t3.max;
        }
        class gy {
          constructor(t3, e4, r4, n3) {
            this.p = new Ue(t3, e4), this.h = r4, this.d = function(t4, e5) {
              let r5 = false, n4 = 1 / 0;
              for (let i3 = 0; i3 < e5.length; i3++) {
                const s4 = e5[i3];
                for (let e6 = 0, i4 = s4.length, a3 = i4 - 1; e6 < i4; a3 = e6++) {
                  const i5 = s4[e6], o3 = s4[a3];
                  i5.y > t4.y != o3.y > t4.y && t4.x < (o3.x - i5.x) * (t4.y - i5.y) / (o3.y - i5.y) + i5.x && (r5 = !r5), n4 = Math.min(n4, Zc(t4, i5, o3));
                }
              }
              return (r5 ? 1 : -1) * Math.sqrt(n4);
            }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const xy = Number.POSITIVE_INFINITY, by = Math.sqrt(2);
        function vy(t3, [e4, r4]) {
          let n3 = 0, i3 = 0;
          if (r4 === xy) {
            e4 < 0 && (e4 = 0);
            const r5 = e4 / by;
            switch (t3) {
              case "top-right":
              case "top-left":
                i3 = r5 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                i3 = 7 - r5;
                break;
              case "bottom":
                i3 = 7 - e4;
                break;
              case "top":
                i3 = e4 - 7;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                n3 = -r5;
                break;
              case "top-left":
              case "bottom-left":
                n3 = r5;
                break;
              case "left":
                n3 = e4;
                break;
              case "right":
                n3 = -e4;
            }
          } else {
            switch (e4 = Math.abs(e4), r4 = Math.abs(r4), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i3 = r4 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i3 = 7 - r4;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n3 = -e4;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n3 = e4;
            }
          }
          return [n3, i3];
        }
        function _y(t3) {
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function wy(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2) {
          let m2 = s4.textMaxSize.evaluate(e4, {}, h2);
          void 0 === m2 && (m2 = a3);
          const y3 = t3.layers[0].layout, g3 = y3.get("icon-offset").evaluate(e4, {}, h2), x3 = Iy(r4.horizontal) || r4.vertical, b2 = "globe" === p3.name, v3 = $d, _3 = a3 / v3, w2 = t3.tilePixelRatio * m2 / v3, M3 = (T2 = t3.overscaling, t3.zoom > 18 && T2 > 2 && (T2 >>= 1), Math.max(is / (512 * T2), 1) * y3.get("symbol-spacing")), A2 = y3.get("text-padding") * t3.tilePixelRatio, S2 = y3.get("icon-padding") * t3.tilePixelRatio, I2 = qe(y3.get("text-max-angle")), k2 = "map" === y3.get("text-rotation-alignment") && "point" !== y3.get("symbol-placement"), P2 = "map" === y3.get("icon-rotation-alignment") && "point" !== y3.get("symbol-placement"), E2 = y3.get("symbol-placement"), z3 = M3 / 2;
          var T2;
          const B2 = y3.get("icon-text-fit").evaluate(e4, {}, h2), C2 = y3.get("icon-text-fit-padding").evaluate(e4, {}, h2), R3 = "none" !== B2;
          let V2;
          false === t3.hasAnyIconTextFit && R3 && (t3.hasAnyIconTextFit = true), n3 && R3 && (t3.allowVerticalPlacement && r4.vertical && (V2 = jm(n3, r4.vertical, B2, C2, g3, _3)), x3 && (n3 = jm(n3, x3, B2, C2, g3, _3)));
          const D2 = (a4, o4, m3) => {
            if (o4.x < 0 || o4.x >= is || o4.y < 0 || o4.y >= is)
              return;
            let y4 = null;
            if (b2) {
              const { x: t4, y: e5, z: r5 } = p3.projectTilePoint(o4.x, o4.y, m3);
              y4 = { anchor: new qm(t4, e5, r5, 0, void 0), up: p3.upVector(m3, o4.x, o4.y) };
            }
            !function(t4, e5, r5, n4, i4, s5, a5, o5, l4, u4, c4, h3, p4, f3, d3, m4, y5, g4, x4, b3, v4, _4, w3, M4, A3, S3, I3) {
              const k3 = t4.addToLineVertexArray(e5, n4);
              let P3, E3, z4, T3, B3, C3, R4, V3 = 0, D3 = 0, L2 = 0, F2 = 0, O2 = -1, U2 = -1;
              const N2 = {};
              let j3 = Tn("");
              const q3 = r5 ? r5.anchor : e5, $2 = "none" !== l4.layout.get("icon-text-fit").evaluate(v4, {}, A3);
              let G2 = 0, Q2 = 0;
              if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset") ? [G2, Q2] = l4.layout.get("text-offset").evaluate(v4, {}, A3).map((t5) => t5 * $d) : (G2 = l4.layout.get("text-radial-offset").evaluate(v4, {}, A3) * $d, Q2 = xy), t4.allowVerticalPlacement && i4.vertical) {
                const t5 = i4.vertical;
                if (d3)
                  C3 = Py(t5), o5 && (R4 = Py(o5));
                else {
                  const r6 = l4.layout.get("text-rotate").evaluate(v4, {}, A3) + 90;
                  z4 = ky(u4, q3, e5, c4, h3, p4, t5, f3, r6, m4), o5 && (T3 = ky(u4, q3, e5, c4, h3, p4, o5, g4, r6));
                }
              }
              if (s5) {
                const n5 = l4.layout.get("icon-rotate").evaluate(v4, {}, A3), i5 = uy(s5, n5, w3, $2), a6 = o5 ? uy(o5, n5, w3, $2) : void 0;
                E3 = ky(u4, q3, e5, c4, h3, p4, s5, g4, n5), V3 = 4 * i5.length;
                const f4 = t4.iconSizeData;
                let d4 = null;
                "source" === f4.kind ? (d4 = [Gd * l4.layout.get("icon-size").evaluate(v4, {}, A3)], d4[0] > Ay && hr(`${t4.layerIds[0]}: Value for "icon-size" is >= ${My}. Reduce your "icon-size".`)) : "composite" === f4.kind && (d4 = [Gd * _4.compositeIconSizes[0].evaluate(v4, {}, A3), Gd * _4.compositeIconSizes[1].evaluate(v4, {}, A3)], (d4[0] > Ay || d4[1] > Ay) && hr(`${t4.layerIds[0]}: Value for "icon-size" is >= ${My}. Reduce your "icon-size".`)), t4.addSymbols(t4.icon, i5, d4, b3, x4, v4, false, r5, e5, k3.lineStartIndex, k3.lineLength, -1, M4, A3, S3, I3), O2 = t4.icon.placedSymbolArray.length - 1, a6 && (D3 = 4 * a6.length, t4.addSymbols(t4.icon, a6, d4, b3, x4, v4, Pm.vertical, r5, e5, k3.lineStartIndex, k3.lineLength, -1, M4, A3, S3, I3), U2 = t4.icon.placedSymbolArray.length - 1);
              }
              for (const n5 in i4.horizontal) {
                const s6 = i4.horizontal[n5];
                P3 || (j3 = Tn(s6.text), d3 ? B3 = Py(s6) : P3 = ky(u4, q3, e5, c4, h3, p4, s6, f3, l4.layout.get("text-rotate").evaluate(v4, {}, A3), m4));
                const o6 = 1 === s6.positionedLines.length;
                if (L2 += Sy(t4, r5, e5, s6, a5, l4, d3, v4, m4, k3, i4.vertical ? Pm.horizontal : Pm.horizontalOnly, o6 ? Object.keys(i4.horizontal) : [n5], N2, O2, _4, M4, A3, S3), o6)
                  break;
              }
              i4.vertical && (F2 += Sy(t4, r5, e5, i4.vertical, a5, l4, d3, v4, m4, k3, Pm.vertical, ["vertical"], N2, U2, _4, M4, A3, S3));
              let Y2 = -1;
              const X3 = (t5, e6) => t5 ? Math.max(t5, e6) : e6;
              Y2 = X3(B3, Y2), Y2 = X3(C3, Y2), Y2 = X3(R4, Y2);
              const Z3 = Y2 > -1 ? 1 : 0;
              t4.glyphOffsetArray.length >= 65535 && hr("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== v4.sortKey && t4.addToSortKeyRanges(t4.symbolInstances.length, v4.sortKey), t4.symbolInstances.emplaceBack(e5.x, e5.y, q3.x, q3.y, q3.z, N2.right >= 0 ? N2.right : -1, N2.center >= 0 ? N2.center : -1, N2.left >= 0 ? N2.left : -1, N2.vertical >= 0 ? N2.vertical : -1, O2, U2, j3, void 0 !== P3 ? P3 : t4.collisionBoxArray.length, void 0 !== P3 ? P3 + 1 : t4.collisionBoxArray.length, void 0 !== z4 ? z4 : t4.collisionBoxArray.length, void 0 !== z4 ? z4 + 1 : t4.collisionBoxArray.length, void 0 !== E3 ? E3 : t4.collisionBoxArray.length, void 0 !== E3 ? E3 + 1 : t4.collisionBoxArray.length, T3 || t4.collisionBoxArray.length, T3 ? T3 + 1 : t4.collisionBoxArray.length, c4, L2, F2, V3, D3, Z3, 0, G2, Q2, Y2, 0, $2 ? 1 : 0);
            }(t3, o4, y4, a4, r4, n3, i3, V2, t3.layers[0], t3.collisionBoxArray, e4.index, e4.sourceLayerIndex, t3.index, A2, k2, l3, 0, S2, P2, g3, e4, s4, u3, c3, h2, f2, d2);
          };
          if ("line" === E2)
            for (const i4 of Wm(e4.geometry, 0, 0, is, is)) {
              const e5 = Zm(i4, M3, I2, r4.vertical || x3, n3, v3, w2, t3.overscaling, is);
              for (const r5 of e5)
                x3 && Ey(t3, x3.text, z3, r5) || D2(i4, r5, h2);
            }
          else if ("line-center" === E2) {
            for (const t4 of e4.geometry)
              if (t4.length > 1) {
                const e5 = Xm(t4, I2, r4.vertical || x3, n3, v3, w2);
                e5 && D2(t4, e5, h2);
              }
          } else if ("Polygon" === e4.type)
            for (const t4 of Up(e4.geometry, 0)) {
              const e5 = my(t4, 16);
              D2(t4[0], new qm(e5.x, e5.y, 0, 0, void 0), h2);
            }
          else if ("LineString" === e4.type)
            for (const t4 of e4.geometry)
              D2(t4, new qm(t4[0].x, t4[0].y, 0, 0, void 0), h2);
          else if ("Point" === e4.type)
            for (const t4 of e4.geometry)
              for (const e5 of t4)
                D2([e5], new qm(e5.x, e5.y, 0, 0, void 0), h2);
        }
        const My = 255, Ay = My * Gd;
        function Sy(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2, y3, g3) {
          const x3 = function(t4, e5, r5, n4, i4, s5, a4, o4) {
            const l4 = [];
            if (0 === e5.positionedLines.length)
              return l4;
            const u4 = n4.layout.get("text-rotate").evaluate(s5, {}) * Math.PI / 180, c4 = function(t5) {
              const e6 = t5[0], r6 = t5[1], n5 = e6 * r6;
              return n5 > 0 ? [e6, -r6] : n5 < 0 ? [-e6, r6] : 0 === e6 ? [r6, e6] : [r6, -e6];
            }(r5);
            let h3 = Math.abs(e5.top - e5.bottom);
            for (const t5 of e5.positionedLines)
              h3 -= t5.lineOffset;
            const p4 = e5.positionedLines.length, f3 = h3 / p4;
            let d3 = e5.top - r5[1];
            for (let t5 = 0; t5 < p4; ++t5) {
              const n5 = e5.positionedLines[t5];
              d3 = dy(e5, f3, d3, t5);
              for (const t6 of n5.positionedGlyphs) {
                if (!t6.rect)
                  continue;
                const n6 = t6.rect || {};
                let s6 = km + 1, h4 = true, p5 = 1, f4 = 0;
                if (t6.imageName) {
                  const e6 = a4[t6.imageName];
                  if (!e6)
                    continue;
                  if (e6.sdf) {
                    hr("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  h4 = false, p5 = e6.pixelRatio, s6 = Jm / p5;
                }
                const m3 = (i4 || o4) && t6.vertical, y4 = t6.metrics.advance * t6.scale / 2, g4 = t6.metrics, x4 = t6.rect;
                if (null === x4)
                  continue;
                o4 && e5.verticalizable && (f4 = t6.imageName ? y4 - t6.metrics.width * t6.scale / 2 : 0);
                const b3 = i4 ? [t6.x + y4, t6.y] : [0, 0];
                let v4 = [0, 0], _3 = [0, 0], w2 = false;
                i4 || (m3 ? (_3 = [t6.x + y4 + c4[0], t6.y + c4[1] - f4], w2 = true) : v4 = [t6.x + y4 + r5[0], t6.y + r5[1] - f4]);
                const M3 = x4.w * t6.scale / (p5 * (t6.localGlyph ? sy : 1)), A2 = x4.h * t6.scale / (p5 * (t6.localGlyph ? sy : 1));
                let S2, I2, k2, P2;
                if (m3) {
                  const e6 = t6.y - d3, r6 = new Ue(-y4, y4 - e6), n7 = -Math.PI / 2, i5 = new Ue(..._3);
                  S2 = new Ue(-y4 + v4[0], v4[1]), S2._rotateAround(n7, r6)._add(i5), S2.x += -e6 + y4, S2.y -= (g4.left - s6) * t6.scale;
                  const a5 = t6.imageName ? g4.advance * t6.scale : $d * t6.scale, o5 = String.fromCodePoint(t6.glyph);
                  Hd(o5) ? S2.x += (1 - s6) * t6.scale : Jd(o5) ? S2.x += a5 - g4.height * t6.scale + (-s6 - 1) * t6.scale : S2.x += t6.imageName || g4.width + 2 * s6 === x4.w && g4.height + 2 * s6 === x4.h ? (a5 - A2) / 2 : (a5 - (g4.height + 2 * s6) * t6.scale) / 2, I2 = new Ue(S2.x, S2.y - M3), k2 = new Ue(S2.x + A2, S2.y), P2 = new Ue(S2.x + A2, S2.y - M3);
                } else {
                  const e6 = (g4.left - s6) * t6.scale - y4 + v4[0], r6 = (-g4.top - s6) * t6.scale + v4[1], n7 = e6 + M3, i5 = r6 + A2;
                  S2 = new Ue(e6, r6), I2 = new Ue(n7, r6), k2 = new Ue(e6, i5), P2 = new Ue(n7, i5);
                }
                if (u4) {
                  let t7;
                  t7 = i4 ? new Ue(0, 0) : w2 ? new Ue(c4[0], c4[1]) : new Ue(r5[0], r5[1]), S2._rotateAround(u4, t7), I2._rotateAround(u4, t7), k2._rotateAround(u4, t7), P2._rotateAround(u4, t7);
                }
                const E2 = new Ue(0, 0), z3 = new Ue(0, 0);
                l4.push({ tl: S2, tr: I2, bl: k2, br: P2, texPrimary: n6, texSecondary: void 0, writingMode: e5.writingMode, glyphOffset: b3, sectionIndex: t6.sectionIndex, isSDF: h4, pixelOffsetTL: E2, pixelOffsetBR: z3, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return l4;
          }(0, n3, l3, s4, a3, o3, i3, t3.allowVerticalPlacement), b2 = t3.textSizeData;
          let v3 = null;
          "source" === b2.kind ? (v3 = [Gd * s4.layout.get("text-size").evaluate(o3, {}, y3)], v3[0] > Ay && hr(`${t3.layerIds[0]}: Value for "text-size" is >= ${My}. Reduce your "text-size".`)) : "composite" === b2.kind && (v3 = [Gd * d2.compositeTextSizes[0].evaluate(o3, {}, y3), Gd * d2.compositeTextSizes[1].evaluate(o3, {}, y3)], (v3[0] > Ay || v3[1] > Ay) && hr(`${t3.layerIds[0]}: Value for "text-size" is >= ${My}. Reduce your "text-size".`)), t3.addSymbols(t3.text, x3, v3, l3, a3, o3, c3, e4, r4, u3.lineStartIndex, u3.lineLength, f2, m2, y3, g3, false);
          for (const e5 of h2)
            p3[e5] = t3.text.placedSymbolArray.length - 1;
          return 4 * x3.length;
        }
        function Iy(t3) {
          for (const e4 in t3)
            return t3[e4];
          return null;
        }
        function ky(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3) {
          let c3 = a3.top, h2 = a3.bottom, p3 = a3.left, f2 = a3.right;
          const d2 = a3.collisionPadding;
          if (d2 && (p3 -= d2[0], c3 -= d2[1], f2 += d2[2], h2 += d2[3]), l3) {
            const t4 = new Ue(p3, c3), e5 = new Ue(f2, c3), r5 = new Ue(p3, h2), n4 = new Ue(f2, h2), i4 = qe(l3);
            let s5 = new Ue(0, 0);
            u3 && (s5 = new Ue(u3[0], u3[1])), t4._rotateAround(i4, s5), e5._rotateAround(i4, s5), r5._rotateAround(i4, s5), n4._rotateAround(i4, s5), p3 = Math.min(t4.x, e5.x, r5.x, n4.x), f2 = Math.max(t4.x, e5.x, r5.x, n4.x), c3 = Math.min(t4.y, e5.y, r5.y, n4.y), h2 = Math.max(t4.y, e5.y, r5.y, n4.y);
          }
          return t3.emplaceBack(e4.x, e4.y, e4.z, r4.x, r4.y, p3, c3, f2, h2, o3, n3, i3, s4), t3.length - 1;
        }
        function Py(t3) {
          t3.collisionPadding && (t3.top -= t3.collisionPadding[1], t3.bottom += t3.collisionPadding[3]);
          const e4 = t3.bottom - t3.top;
          return e4 > 0 ? Math.max(10, e4) : null;
        }
        function Ey(t3, e4, r4, n3) {
          const i3 = t3.compareText;
          if (e4 in i3) {
            const t4 = i3[e4];
            for (let e5 = t4.length - 1; e5 >= 0; e5--)
              if (n3.dist(t4[e5]) < r4)
                return true;
          } else
            i3[e4] = [];
          return i3[e4].push(n3), false;
        }
        function zy(t3, e4) {
          const r4 = t3.fovAboveCenter, n3 = t3.elevation ? t3.elevation.getMinElevationBelowMSL() * e4 : 0, i3 = (t3._camera.position[2] * t3.worldSize - n3) / Math.cos(t3._pitch), s4 = Math.sin(r4) * i3 / Math.sin(Math.max(Math.PI / 2 - t3._pitch - r4, 0.01)), a3 = Math.sin(t3._pitch) * s4 + i3;
          return Math.min(1.01 * a3, i3 * (1 / t3._horizonShift));
        }
        function Ty(t3, e4) {
          if (!e4.isReprojectedInTileSpace)
            return { scale: 1 << t3.z, x: t3.x, y: t3.y, x2: t3.x + 1, y2: t3.y + 1, projection: e4 };
          const r4 = Math.pow(2, -t3.z), n3 = t3.x * r4, i3 = (t3.x + 1) * r4, s4 = t3.y * r4, a3 = (t3.y + 1) * r4, o3 = _c(n3), l3 = _c(i3), u3 = wc(s4), c3 = wc(a3), h2 = e4.project(o3, u3), p3 = e4.project(l3, u3), f2 = e4.project(l3, c3), d2 = e4.project(o3, c3);
          let m2 = Math.min(h2.x, p3.x, f2.x, d2.x), y3 = Math.min(h2.y, p3.y, f2.y, d2.y), g3 = Math.max(h2.x, p3.x, f2.x, d2.x), x3 = Math.max(h2.y, p3.y, f2.y, d2.y);
          const b2 = r4 / 16;
          function v3(t4, r5, n4, i4, s5, a4) {
            const o4 = (n4 + s5) / 2, l4 = (i4 + a4) / 2, u4 = e4.project(_c(o4), wc(l4)), c4 = Math.max(0, m2 - u4.x, y3 - u4.y, u4.x - g3, u4.y - x3);
            m2 = Math.min(m2, u4.x), g3 = Math.max(g3, u4.x), y3 = Math.min(y3, u4.y), x3 = Math.max(x3, u4.y), c4 > b2 && (v3(t4, u4, n4, i4, o4, l4), v3(u4, r5, o4, l4, s5, a4));
          }
          v3(h2, p3, n3, s4, i3, s4), v3(p3, f2, i3, s4, i3, a3), v3(f2, d2, i3, a3, n3, a3), v3(d2, h2, n3, a3, n3, s4), m2 -= b2, y3 -= b2, g3 += b2, x3 += b2;
          const _3 = 1 / Math.max(g3 - m2, x3 - y3);
          return { scale: _3, x: m2 * _3, y: y3 * _3, x2: g3 * _3, y2: x3 * _3, projection: e4 };
        }
        function By(t3, { x: e4, y: r4 }, n3 = 0) {
          return new Ue(((e4 - n3) * t3.scale - t3.x) * is, (r4 * t3.scale - t3.y) * is);
        }
        const Cy = t2.a9.identity(new Float32Array(16));
        class Ry {
          constructor(t3) {
            this.spec = t3, this.name = t3.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(t3, e4) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(t3, e4) {
            return new ac(0, 0);
          }
          projectTilePoint(t3, e4, r4) {
            return { x: t3, y: e4, z: 0 };
          }
          locationPoint(t3, e4, r4 = true) {
            return t3._coordinatePoint(t3.locationCoordinate(e4), r4);
          }
          pixelsPerMeter(t3, e4) {
            return vc(1, t3) * e4;
          }
          pixelSpaceConversion(t3, e4, r4) {
            return 1;
          }
          farthestPixelDistance(t3) {
            return zy(t3, t3.pixelsPerMeter);
          }
          pointCoordinate(t3, e4, r4, n3) {
            const i3 = t3.horizonLineFromTop(false), s4 = new Ue(e4, Math.max(i3, r4));
            return t3.rayIntersectionCoordinate(t3.pointRayIntersection(s4, n3));
          }
          pointCoordinate3D(t3, e4, r4) {
            const n3 = new Ue(e4, r4);
            if (t3.elevation)
              return t3.elevation.pointCoordinate(n3);
            {
              const e5 = this.pointCoordinate(t3, n3.x, n3.y, 0);
              return [e5.x, e5.y, e5.z];
            }
          }
          isPointAboveHorizon(t3, e4) {
            if (t3.elevation)
              return !this.pointCoordinate3D(t3, e4.x, e4.y);
            const r4 = t3.horizonLineFromTop();
            return e4.y < r4;
          }
          createInversionMatrix(t3, e4) {
            return Cy;
          }
          createTileMatrix(e4, r4, n3) {
            let i3, s4, a3;
            const o3 = n3.canonical, l3 = t2.a9.identity(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const u3 = Ty(o3, this);
              i3 = 1, s4 = u3.x + n3.wrap * u3.scale, a3 = u3.y, t2.a9.scale(l3, l3, [i3 / u3.scale, i3 / u3.scale, e4.pixelsPerMeter / r4]);
            } else
              i3 = r4 / e4.zoomScale(o3.z), s4 = (o3.x + Math.pow(2, o3.z) * n3.wrap) * i3, a3 = o3.y * i3;
            return t2.a9.translate(l3, l3, [s4, a3, 0]), t2.a9.scale(l3, l3, [i3 / is, i3 / is, 1]), l3;
          }
          upVector(t3, e4, r4) {
            return [0, 0, 1];
          }
          upVectorScale(t3, e4, r4) {
            return { metersToTile: 1 };
          }
        }
        class Vy extends Ry {
          constructor(t3) {
            super(t3), this.range = [4, 7], this.center = t3.center || [-96, 37.5];
            const [e4, r4] = this.parallels = t3.parallels || [29.5, 45.5], n3 = Math.sin(qe(e4));
            this.n = (n3 + Math.sin(qe(r4))) / 2, this.c = 1 + n3 * (2 * this.n - n3), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(t3, e4) {
            const { n: r4, c: n3, r0: i3 } = this, s4 = qe(t3 - this.center[0]), a3 = qe(e4), o3 = Math.sqrt(n3 - 2 * r4 * Math.sin(a3)) / r4;
            return { x: o3 * Math.sin(s4 * r4), y: o3 * Math.cos(s4 * r4) - i3, z: 0 };
          }
          unproject(t3, e4) {
            const { n: r4, c: n3, r0: i3 } = this, s4 = i3 + e4;
            let a3 = Math.atan2(t3, Math.abs(s4)) * Math.sign(s4);
            s4 * r4 < 0 && (a3 -= Math.PI * Math.sign(t3) * Math.sign(s4));
            const o3 = qe(this.center[0]) * r4;
            a3 = We(a3, -Math.PI - o3, Math.PI - o3);
            const l3 = Ze($e(a3 / r4) + this.center[0], -180, 180), u3 = Math.asin(Ze((n3 - (t3 * t3 + s4 * s4) * r4 * r4) / (2 * r4), -1, 1)), c3 = Ze($e(u3), -Ac, Ac);
            return new ac(l3, c3);
          }
        }
        const Dy = 1.340264, Ly = -0.081106, Fy = 893e-6, Oy = 3796e-6, Uy = Math.sqrt(3) / 2;
        class Ny extends Ry {
          project(t3, e4) {
            e4 = e4 / 180 * Math.PI, t3 = t3 / 180 * Math.PI;
            const r4 = Math.asin(Uy * Math.sin(e4)), n3 = r4 * r4, i3 = n3 * n3 * n3;
            return { x: 0.5 * (t3 * Math.cos(r4) / (Uy * (Dy + 3 * Ly * n3 + i3 * (7 * Fy + 9 * Oy * n3))) / Math.PI + 0.5), y: 1 - 0.5 * (r4 * (Dy + Ly * n3 + i3 * (Fy + Oy * n3)) / Math.PI + 1), z: 0 };
          }
          unproject(t3, e4) {
            t3 = (2 * t3 - 0.5) * Math.PI;
            let r4 = e4 = (2 * (1 - e4) - 1) * Math.PI, n3 = r4 * r4, i3 = n3 * n3 * n3;
            for (let t4, s5, a4, o4 = 0; o4 < 12 && (s5 = r4 * (Dy + Ly * n3 + i3 * (Fy + Oy * n3)) - e4, a4 = Dy + 3 * Ly * n3 + i3 * (7 * Fy + 9 * Oy * n3), t4 = s5 / a4, r4 = Ze(r4 - t4, -Math.PI / 3, Math.PI / 3), n3 = r4 * r4, i3 = n3 * n3 * n3, !(Math.abs(t4) < 1e-12)); ++o4)
              ;
            const s4 = Uy * t3 * (Dy + 3 * Ly * n3 + i3 * (7 * Fy + 9 * Oy * n3)) / Math.cos(r4), a3 = Math.asin(Math.sin(r4) / Uy), o3 = Ze(180 * s4 / Math.PI, -180, 180), l3 = Ze(180 * a3 / Math.PI, -Ac, Ac);
            return new ac(o3, l3);
          }
        }
        class jy extends Ry {
          constructor(t3) {
            super(t3), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t3, e4) {
            return { x: 0.5 + t3 / 360, y: 0.5 - e4 / 360, z: 0 };
          }
          unproject(t3, e4) {
            const r4 = 360 * (t3 - 0.5), n3 = Ze(360 * (0.5 - e4), -Ac, Ac);
            return new ac(r4, n3);
          }
        }
        const qy = Math.PI / 2;
        function $y(t3) {
          return Math.tan((qy + t3) / 2);
        }
        class Gy extends Ry {
          constructor(t3) {
            super(t3), this.center = t3.center || [0, 30];
            const [e4, r4] = this.parallels = t3.parallels || [30, 30];
            let n3 = qe(e4), i3 = qe(r4);
            this.southernCenter = n3 + i3 < 0, this.southernCenter && (n3 = -n3, i3 = -i3);
            const s4 = Math.cos(n3), a3 = $y(n3);
            this.n = n3 === i3 ? Math.sin(n3) : Math.log(s4 / Math.cos(i3)) / Math.log($y(i3) / a3), this.f = s4 * Math.pow($y(n3), this.n) / this.n;
          }
          project(t3, e4) {
            e4 = qe(e4), this.southernCenter && (e4 = -e4), t3 = qe(t3 - this.center[0]);
            const r4 = 1e-6, { n: n3, f: i3 } = this;
            i3 > 0 ? e4 < -qy + r4 && (e4 = -qy + r4) : e4 > qy - r4 && (e4 = qy - r4);
            const s4 = i3 / Math.pow($y(e4), n3);
            let a3 = s4 * Math.sin(n3 * t3), o3 = i3 - s4 * Math.cos(n3 * t3);
            return a3 = 0.5 * (a3 / Math.PI + 0.5), o3 = 0.5 * (o3 / Math.PI + 0.5), { x: a3, y: this.southernCenter ? o3 : 1 - o3, z: 0 };
          }
          unproject(t3, e4) {
            t3 = (2 * t3 - 0.5) * Math.PI, this.southernCenter && (e4 = 1 - e4), e4 = (2 * (1 - e4) - 0.5) * Math.PI;
            const { n: r4, f: n3 } = this, i3 = n3 - e4, s4 = Math.sign(i3), a3 = Math.sign(r4) * Math.sqrt(t3 * t3 + i3 * i3);
            let o3 = Math.atan2(t3, Math.abs(i3)) * s4;
            i3 * r4 < 0 && (o3 -= Math.PI * Math.sign(t3) * s4);
            const l3 = Ze($e(o3 / r4) + this.center[0], -180, 180), u3 = Ze($e(2 * Math.atan(Math.pow(n3 / a3, 1 / r4)) - qy), -Ac, Ac);
            return new ac(l3, this.southernCenter ? -u3 : u3);
          }
        }
        class Qy extends Ry {
          constructor(t3) {
            super(t3), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
          }
          project(t3, e4) {
            return { x: xc(t3), y: bc(e4), z: 0 };
          }
          unproject(t3, e4) {
            const r4 = _c(t3), n3 = wc(e4);
            return new ac(r4, n3);
          }
        }
        const Yy = qe(Ac);
        class Xy extends Ry {
          project(t3, e4) {
            const r4 = (e4 = qe(e4)) * e4, n3 = r4 * r4;
            return { x: 0.5 * ((t3 = qe(t3)) * (0.8707 - 0.131979 * r4 + n3 * (n3 * (3971e-6 * r4 - 1529e-6 * n3) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e4 * (1.007226 + r4 * (0.015085 + n3 * (0.028874 * r4 - 0.044475 - 5916e-6 * n3))) / Math.PI + 1), z: 0 };
          }
          unproject(t3, e4) {
            t3 = (2 * t3 - 0.5) * Math.PI;
            let r4 = e4 = (2 * (1 - e4) - 1) * Math.PI, n3 = 25, i3 = 0, s4 = r4 * r4;
            do {
              s4 = r4 * r4;
              const t4 = s4 * s4;
              i3 = (r4 * (1.007226 + s4 * (0.015085 + t4 * (0.028874 * s4 - 0.044475 - 5916e-6 * t4))) - e4) / (1.007226 + s4 * (0.045255 + t4 * (0.259866 * s4 - 0.311325 - 5916e-6 * 11 * t4))), r4 = Ze(r4 - i3, -Yy, Yy);
            } while (Math.abs(i3) > 1e-6 && --n3 > 0);
            s4 = r4 * r4;
            const a3 = Ze($e(t3 / (0.8707 + s4 * (s4 * (s4 * s4 * s4 * (3971e-6 - 1529e-6 * s4) - 0.013791) - 0.131979))), -180, 180), o3 = $e(r4);
            return new ac(a3, o3);
          }
        }
        const Zy = qe(Ac);
        class Ky extends Ry {
          project(t3, e4) {
            e4 = qe(e4), t3 = qe(t3);
            const r4 = Math.cos(e4), n3 = 2 / Math.PI, i3 = Math.acos(r4 * Math.cos(t3 / 2)), s4 = Math.sin(i3) / i3, a3 = 0.5 * (t3 * n3 + 2 * r4 * Math.sin(t3 / 2) / s4) || 0, o3 = 0.5 * (e4 + Math.sin(e4) / s4) || 0;
            return { x: 0.5 * (a3 / Math.PI + 0.5), y: 1 - 0.5 * (o3 / Math.PI + 1), z: 0 };
          }
          unproject(t3, e4) {
            let r4 = t3 = (2 * t3 - 0.5) * Math.PI, n3 = e4 = (2 * (1 - e4) - 1) * Math.PI, i3 = 25;
            const s4 = 1e-6;
            let a3 = 0, o3 = 0;
            do {
              const i4 = Math.cos(n3), s5 = Math.sin(n3), l3 = 2 * s5 * i4, u3 = s5 * s5, c3 = i4 * i4, h2 = Math.cos(r4 / 2), p3 = Math.sin(r4 / 2), f2 = 2 * h2 * p3, d2 = p3 * p3, m2 = 1 - c3 * h2 * h2, y3 = m2 ? 1 / m2 : 0, g3 = m2 ? Math.acos(i4 * h2) * Math.sqrt(1 / m2) : 0, x3 = 0.5 * (2 * g3 * i4 * p3 + 2 * r4 / Math.PI) - t3, b2 = 0.5 * (g3 * s5 + n3) - e4, v3 = 0.5 * y3 * (c3 * d2 + g3 * i4 * h2 * u3) + 1 / Math.PI, _3 = y3 * (f2 * l3 / 4 - g3 * s5 * p3), w2 = 0.125 * y3 * (l3 * p3 - g3 * s5 * c3 * f2), M3 = 0.5 * y3 * (u3 * h2 + g3 * d2 * i4) + 0.5, A2 = _3 * w2 - M3 * v3;
              a3 = (b2 * _3 - x3 * M3) / A2, o3 = (x3 * w2 - b2 * v3) / A2, r4 = Ze(r4 - a3, -Math.PI, Math.PI), n3 = Ze(n3 - o3, -Zy, Zy);
            } while ((Math.abs(a3) > s4 || Math.abs(o3) > s4) && --i3 > 0);
            return new ac($e(r4), $e(n3));
          }
        }
        class Wy extends Ry {
          constructor(t3) {
            super(t3), this.center = t3.center || [0, 0], this.parallels = t3.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(qe(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t3, e4) {
            const { scale: r4, cosPhi: n3 } = this;
            return { x: qe(t3) * n3 * r4 + 0.5, y: -Math.sin(qe(e4)) / n3 * r4 + 0.5, z: 0 };
          }
          unproject(t3, e4) {
            const { scale: r4, cosPhi: n3 } = this, i3 = -(e4 - 0.5) / r4, s4 = Ze($e((t3 - 0.5) / r4) / n3, -180, 180), a3 = Math.asin(Ze(i3 * n3, -1, 1)), o3 = Ze($e(a3), -Ac, Ac);
            return new ac(s4, o3);
          }
        }
        class Hy extends Qy {
          constructor(t3) {
            super(t3), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(e4, r4, n3) {
            const i3 = Th(e4, r4, n3), s4 = Rh(Sh(n3));
            return t2.Q.transformMat4(i3, i3, s4), { x: i3[0], y: i3[1], z: i3[2] };
          }
          locationPoint(e4, r4) {
            const n3 = nc(r4.lat, r4.lng), i3 = t2.Q.normalize([], n3), s4 = e4.elevation ? e4.elevation.getAtPointOrZero(e4.locationCoordinate(r4), e4._centerAltitude) : e4._centerAltitude, a3 = vc(1, 0) * is * s4;
            t2.Q.scaleAndAdd(n3, n3, i3, a3);
            const o3 = t2.a9.identity(new Float64Array(16));
            return t2.a9.multiply(o3, e4.pixelMatrix, e4.globeMatrix), t2.Q.transformMat4(n3, n3, o3), new Ue(n3[0], n3[1]);
          }
          pixelsPerMeter(t3, e4) {
            return vc(1, 0) * e4;
          }
          pixelSpaceConversion(t3, e4, r4) {
            const n3 = vc(1, t3) * e4, i3 = qn(vc(1, 45) * e4, n3, r4);
            return this.pixelsPerMeter(t3, e4) / i3;
          }
          createTileMatrix(e4, r4, n3) {
            const i3 = Vh(Sh(n3.canonical));
            return t2.a9.multiply(new Float64Array(16), e4.globeMatrix, i3);
          }
          createInversionMatrix(e4, r4) {
            const { center: n3 } = e4, i3 = Rh(Sh(r4));
            return t2.a9.rotateY(i3, i3, qe(n3.lng)), t2.a9.rotateX(i3, i3, qe(n3.lat)), t2.a9.scale(i3, i3, [e4._pixelsPerMercatorPixel, e4._pixelsPerMercatorPixel, 1]), Float32Array.from(i3);
          }
          pointCoordinate(t3, e4, r4, n3) {
            return wh(t3, e4, r4, true) || new Ec(0, 0);
          }
          pointCoordinate3D(t3, e4, r4) {
            const n3 = this.pointCoordinate(t3, e4, r4, 0);
            return [n3.x, n3.y, n3.z];
          }
          isPointAboveHorizon(t3, e4) {
            return !wh(t3, e4.x, e4.y, false);
          }
          farthestPixelDistance(e4) {
            const r4 = function(e5, r5) {
              const n4 = e5.cameraToCenterDistance, i3 = e5._centerAltitude * r5, s4 = e5._camera, a3 = e5._camera.forward(), o3 = t2.Q.add([], t2.Q.scale([], a3, -n4), [0, 0, i3]), l3 = e5.worldSize / (2 * Math.PI), u3 = [0, 0, -l3], c3 = e5.width / e5.height, h2 = Math.tan(e5.fovAboveCenter), p3 = t2.Q.scale([], s4.up(), h2), f2 = t2.Q.scale([], s4.right(), h2 * c3), d2 = t2.Q.normalize([], t2.Q.add([], t2.Q.add([], a3, p3), f2)), m2 = [];
              let y3;
              if (new lh(o3, d2).closestPointOnSphere(u3, l3, m2)) {
                const r6 = t2.Q.add([], m2, u3), n5 = t2.Q.sub([], r6, o3);
                y3 = Math.cos(e5.fovAboveCenter) * t2.Q.length(n5);
              } else {
                const e6 = t2.Q.sub([], o3, u3), r6 = t2.Q.sub([], u3, o3);
                t2.Q.normalize(r6, r6);
                const n5 = t2.Q.length(e6) - l3;
                y3 = Math.sqrt(n5 * (n5 + 2 * l3));
                const i4 = Math.acos(y3 / (l3 + n5)) - Math.acos(t2.Q.dot(a3, r6));
                y3 *= Math.cos(i4);
              }
              return 1.01 * y3;
            }(e4, this.pixelsPerMeter(e4.center.lat, e4.worldSize)), n3 = Oh(e4.zoom);
            if (n3 > 0) {
              const t3 = zy(e4, vc(1, e4.center.lat) * e4.worldSize), i3 = e4.worldSize / (2 * Math.PI), s4 = Math.max(e4.width, e4.height) / e4.worldSize * Math.PI;
              return qn(r4, t3 + i3 * (1 - Math.cos(s4)), Math.pow(n3, 10));
            }
            return r4;
          }
          upVector(t3, e4, r4) {
            return Th(e4, r4, t3, 1);
          }
          upVectorScale(t3) {
            return { metersToTile: vh(Bh(Sh(t3))) };
          }
        }
        function Jy(t3) {
          const e4 = t3.parallels, r4 = !!e4 && Math.abs(e4[0] + e4[1]) < 0.01;
          switch (t3.name) {
            case "mercator":
              return new Qy(t3);
            case "equirectangular":
              return new jy(t3);
            case "naturalEarth":
              return new Xy(t3);
            case "equalEarth":
              return new Ny(t3);
            case "winkelTripel":
              return new Ky(t3);
            case "albers":
              return r4 ? new Wy(t3) : new Vy(t3);
            case "lambertConformalConic":
              return r4 ? new Wy(t3) : new Gy(t3);
            case "globe":
              return new Hy(t3);
          }
          throw new Error(`Invalid projection name: ${t3.name}`);
        }
        const tg = ff.types, eg = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function rg(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3) {
          const f2 = o3 ? Math.min(Ay, Math.round(o3[0])) : 0, d2 = o3 ? Math.min(Ay, Math.round(o3[1])) : 0;
          t3.emplaceBack(e4, r4, Math.round(32 * n3), Math.round(32 * i3), s4, a3, (f2 << 1) + (l3 ? 1 : 0), d2, 16 * u3, 16 * c3, 256 * h2, 256 * p3);
        }
        function ng(t3, e4, r4) {
          t3.emplaceBack(e4, r4);
        }
        function ig(t3, e4, r4, n3, i3, s4, a3) {
          t3.emplaceBack(e4, r4, n3, i3, s4, a3);
        }
        function sg(t3, e4, r4, n3, i3) {
          t3.emplaceBack(e4, r4, n3, i3), t3.emplaceBack(e4, r4, n3, i3), t3.emplaceBack(e4, r4, n3, i3), t3.emplaceBack(e4, r4, n3, i3);
        }
        function ag(t3) {
          for (const e4 of t3.sections)
            if (ko(e4.text))
              return true;
          return false;
        }
        class og {
          constructor(t3) {
            this.layoutVertexArray = new Vl(), this.indexArray = new ql(), this.programConfigurations = t3, this.segments = new mu(), this.dynamicLayoutVertexArray = new zl(), this.opacityVertexArray = new Ll(), this.placedSymbolArray = new su(), this.iconTransitioningVertexArray = new Fl(), this.globeExtVertexArray = new Dl(), this.zOffsetVertexArray = new Ql();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
          }
          upload(t3, e4, r4, n3, i3) {
            this.isEmpty() || (r4 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Vd.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e4), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, Ld.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, eg, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t3.createVertexBuffer(this.iconTransitioningVertexArray, Od.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t3.createVertexBuffer(this.globeExtVertexArray, Dd.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i3) && (this.zOffsetVertexBuffer = t3.createVertexBuffer(this.zOffsetVertexArray, Fd.members, true)), this.opacityVertexBuffer.itemSize = 1), (r4 || n3) && this.programConfigurations.upload(t3));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
          }
        }
        fo(og, "SymbolBuffers");
        class lg {
          constructor(t3, e4, r4) {
            this.layoutVertexArray = new t3(), this.layoutAttributes = e4, this.indexArray = new r4(), this.segments = new mu(), this.collisionVertexArray = new jl(), this.collisionVertexArrayExt = new zl();
          }
          upload(t3) {
            this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, Ud.members, true), this.collisionVertexBufferExt = t3.createVertexBuffer(this.collisionVertexArrayExt, Nd.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        fo(lg, "CollisionBuffers");
        class ug {
          constructor(e4) {
            this.collisionBoxArray = e4.collisionBoxArray, this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = e4.index, this.pixelRatio = e4.pixelRatio, this.sourceLayerIndex = e4.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = t2.a9.identity([]), this.placementViewportMatrix = t2.a9.identity([]);
            const r4 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Qd(this.zoom, r4["text-size"]), this.iconSizeData = Qd(this.zoom, r4["icon-size"]);
            const n3 = this.layers[0].layout, i3 = n3.get("symbol-sort-key"), s4 = n3.get("symbol-z-order");
            this.canOverlap = n3.get("text-allow-overlap") || n3.get("icon-allow-overlap") || n3.get("text-ignore-placement") || n3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s4 && void 0 !== i3.constantOr(1), this.sortFeaturesByY = ("viewport-y" === s4 || "auto" === s4 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = n3.get("text-writing-mode").map((t3) => Pm[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = e4.sourceID, this.projection = e4.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = n3.get("symbol-z-elevate");
          }
          createArrays() {
            this.text = new og(new ju(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new og(new ju(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new lu(), this.lineVertexArray = new uu(), this.symbolInstances = new ou();
          }
          calculateGlyphDependencies(t3, e4, r4, n3, i3) {
            for (let r5 = 0; r5 < t3.length; r5++) {
              const s4 = t3.codePointAt(r5);
              if (void 0 === s4)
                break;
              if (e4[s4] = true, n3 && i3 && s4 <= 65535) {
                const n4 = Wd[t3.charAt(r5)];
                n4 && (e4[n4.charCodeAt(0)] = true);
              }
            }
          }
          populate(e4, r4, n3, i3) {
            const s4 = this.layers[0], a3 = s4.layout, o3 = "globe" === this.projection.name, l3 = a3.get("text-font"), u3 = a3.get("text-field"), c3 = a3.get("icon-image"), h2 = ("constant" !== u3.value.kind || u3.value.value instanceof fi && !u3.value.value.isEmpty() || u3.value.value.toString().length > 0) && ("constant" !== l3.value.kind || l3.value.value.length > 0), p3 = "constant" !== c3.value.kind || !!c3.value.value || Object.keys(c3.parameters).length > 0, f2 = a3.get("symbol-sort-key");
            if (this.features = [], !h2 && !p3)
              return;
            const d2 = r4.iconDependencies, m2 = r4.glyphDependencies, y3 = r4.availableImages, g3 = new Uo(this.zoom);
            for (const { feature: r5, id: u4, index: c4, sourceLayerIndex: x3 } of e4) {
              const e5 = s4._featureFilter.needGeometry, b2 = Fc(r5, e5);
              if (!s4._featureFilter.filter(g3, b2, n3))
                continue;
              if (e5 || (b2.geometry = Lc(r5, n3, i3)), o3 && 1 !== r5.type && n3.z <= 5) {
                const e6 = b2.geometry, r6 = 0.98078528056, i4 = (e7, i5) => {
                  const s5 = Th(e7.x, e7.y, n3, 1), a4 = Th(i5.x, i5.y, n3, 1);
                  return t2.Q.dot(s5, a4) < r6;
                };
                for (let t3 = 0; t3 < e6.length; t3++)
                  e6[t3] = Cc(e6[t3], i4);
              }
              let v3, _3;
              if (h2) {
                const t3 = s4.getValueAndResolveTokens("text-field", b2, n3, y3), e6 = fi.factory(t3);
                ag(e6) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Lo() || this.hasRTLText && Oo.isParsed()) && (v3 = Kd(e6, s4, b2));
              }
              if (p3) {
                const t3 = s4.getValueAndResolveTokens("icon-image", b2, n3, y3);
                _3 = t3 instanceof di ? t3 : di.fromString(t3);
              }
              if (!v3 && !_3)
                continue;
              const w2 = this.sortFeaturesByKey ? f2.evaluate(b2, {}, n3) : void 0;
              if (this.features.push({ id: u4, text: v3, icon: _3, index: c4, sourceLayerIndex: x3, geometry: b2.geometry, properties: r5.properties, type: tg[r5.type], sortKey: w2 }), _3 && (d2[_3.namePrimary] = true, _3.nameSecondary && (d2[_3.nameSecondary] = true)), v3) {
                const t3 = l3.evaluate(b2, {}, n3).join(","), e6 = "map" === a3.get("text-rotation-alignment") && "point" !== a3.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Pm.vertical) >= 0;
                for (const r6 of v3.sections)
                  if (r6.image)
                    d2[r6.image.namePrimary] = true;
                  else {
                    const n4 = vo(v3.toString()), i4 = r6.fontStack || t3, s5 = m2[i4] = m2[i4] || {};
                    this.calculateGlyphDependencies(r6.text, s5, e6, this.allowVerticalPlacement, n4);
                  }
              }
            }
            "line" === a3.get("symbol-placement") && (this.features = function(t3) {
              const e5 = {}, r5 = {}, n4 = [];
              let i4 = 0;
              function s5(e6) {
                n4.push(t3[e6]), i4++;
              }
              function a4(t4, e6, i5) {
                const s6 = r5[t4];
                return delete r5[t4], r5[e6] = s6, n4[s6].geometry[0].pop(), n4[s6].geometry[0] = n4[s6].geometry[0].concat(i5[0]), s6;
              }
              function o4(t4, r6, i5) {
                const s6 = e5[r6];
                return delete e5[r6], e5[t4] = s6, n4[s6].geometry[0].shift(), n4[s6].geometry[0] = i5[0].concat(n4[s6].geometry[0]), s6;
              }
              function l4(t4, e6, r6) {
                const n5 = r6 ? e6[0][e6[0].length - 1] : e6[0][0];
                return `${t4}:${n5.x}:${n5.y}`;
              }
              for (let u4 = 0; u4 < t3.length; u4++) {
                const c4 = t3[u4], h3 = c4.geometry, p4 = c4.text ? c4.text.toString() : null;
                if (!p4) {
                  s5(u4);
                  continue;
                }
                const f3 = l4(p4, h3), d3 = l4(p4, h3, true);
                if (f3 in r5 && d3 in e5 && r5[f3] !== e5[d3]) {
                  const t4 = o4(f3, d3, h3), i5 = a4(f3, d3, n4[t4].geometry);
                  delete e5[f3], delete r5[d3], r5[l4(p4, n4[i5].geometry, true)] = i5, n4[t4].geometry = null;
                } else
                  f3 in r5 ? a4(f3, d3, h3) : d3 in e5 ? o4(f3, d3, h3) : (s5(u4), e5[f3] = i4 - 1, r5[d3] = i4 - 1);
              }
              return n4.filter((t4) => t4.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e5) => t3.sortKey - e5.sortKey);
          }
          update(t3, e4, r4, n3, i3) {
            const s4 = 0 !== Object.keys(t3).length;
            if (s4 && !this.stateDependentLayers.length)
              return;
            const a3 = s4 ? this.stateDependentLayers : this.layers;
            this.text.programConfigurations.updatePaintArrays(t3, e4, a3, r4, n3, i3), this.icon.programConfigurations.updatePaintArrays(t3, e4, a3, r4, n3, i3);
          }
          updateZOffset() {
            const t3 = (t4, e5, n4) => {
              r4 += e5, r4 > t4.length && t4.resize(r4);
              for (let i3 = -e5; i3 < 0; i3++)
                t4.emplace(i3 + r4, n4);
            }, e4 = (t4, e5, r5) => {
              n3 += e5, n3 > t4.length && t4.resize(n3);
              for (let i3 = -e5; i3 < 0; i3++)
                t4.emplace(i3 + n3, r5);
            };
            if (!this.zOffsetBuffersNeedUpload)
              return;
            this.zOffsetBuffersNeedUpload = false;
            let r4 = 0, n3 = 0;
            for (let r5 = 0; r5 < this.symbolInstances.length; r5++) {
              const n4 = this.symbolInstances.get(r5), { numHorizontalGlyphVertices: i3, numVerticalGlyphVertices: s4, numIconVertices: a3 } = n4, o3 = n4.zOffset, l3 = a3 > 0;
              if ((i3 > 0 || s4 > 0) && (t3(this.text.zOffsetVertexArray, i3, o3), t3(this.text.zOffsetVertexArray, s4, o3)), l3) {
                const { placedIconSymbolIndex: t4, verticalPlacedIconSymbolIndex: r6 } = n4;
                t4 >= 0 && e4(this.icon.zOffsetVertexArray, a3, o3), r6 >= 0 && e4(this.icon.zOffsetVertexArray, n4.numVerticalIconVertices, o3);
              }
            }
            this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t3) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = Jy(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t3, e4) {
            const r4 = this.lineVertexArray.length;
            if (void 0 !== t3.segment)
              for (const { x: t4, y: r5 } of e4)
                this.lineVertexArray.emplaceBack(t4, r5);
            return { lineStartIndex: r4, lineLength: this.lineVertexArray.length - r4 };
          }
          addSymbols(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3, h2, p3, f2, d2, m2) {
            const y3 = t3.indexArray, g3 = t3.layoutVertexArray, x3 = t3.globeExtVertexArray, b2 = t3.segments.prepareSegment(4 * e4.length, g3, y3, this.canOverlap ? s4.sortKey : void 0), v3 = this.glyphOffsetArray.length, _3 = b2.vertexLength, w2 = this.allowVerticalPlacement && a3 === Pm.vertical ? Math.PI / 2 : 0, M3 = s4.text && s4.text.sections;
            for (let n4 = 0; n4 < e4.length; n4++) {
              const { tl: i4, tr: a4, bl: u4, br: c4, texPrimary: h3, texSecondary: v4, pixelOffsetTL: _4, pixelOffsetBR: A3, minFontScaleX: S2, minFontScaleY: I2, glyphOffset: k2, isSDF: P2, sectionIndex: E2 } = e4[n4], z3 = b2.vertexLength, T2 = k2[1];
              if (rg(g3, l3.x, l3.y, i4.x, T2 + i4.y, h3.x, h3.y, r4, P2, _4.x, _4.y, S2, I2), rg(g3, l3.x, l3.y, a4.x, T2 + a4.y, h3.x + h3.w, h3.y, r4, P2, A3.x, _4.y, S2, I2), rg(g3, l3.x, l3.y, u4.x, T2 + u4.y, h3.x, h3.y + h3.h, r4, P2, _4.x, A3.y, S2, I2), rg(g3, l3.x, l3.y, c4.x, T2 + c4.y, h3.x + h3.w, h3.y + h3.h, r4, P2, A3.x, A3.y, S2, I2), o3) {
                const { x: e5, y: r5, z: n5 } = o3.anchor, [i5, s5, a5] = o3.up;
                ig(x3, e5, r5, n5, i5, s5, a5), ig(x3, e5, r5, n5, i5, s5, a5), ig(x3, e5, r5, n5, i5, s5, a5), ig(x3, e5, r5, n5, i5, s5, a5), sg(t3.dynamicLayoutVertexArray, e5, r5, n5, w2);
              } else
                sg(t3.dynamicLayoutVertexArray, l3.x, l3.y, l3.z, w2);
              if (m2) {
                const e5 = v4 || h3;
                ng(t3.iconTransitioningVertexArray, e5.x, e5.y), ng(t3.iconTransitioningVertexArray, e5.x + e5.w, e5.y), ng(t3.iconTransitioningVertexArray, e5.x, e5.y + e5.h), ng(t3.iconTransitioningVertexArray, e5.x + e5.w, e5.y + e5.h);
              }
              y3.emplaceBack(z3, z3 + 1, z3 + 2), y3.emplaceBack(z3 + 1, z3 + 2, z3 + 3), b2.vertexLength += 4, b2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(k2[0]), n4 !== e4.length - 1 && E2 === e4[n4 + 1].sectionIndex || t3.programConfigurations.populatePaintArrays(g3.length, s4, s4.index, {}, p3, f2, d2, M3 && M3[E2]);
            }
            const A2 = o3 ? o3.anchor : l3;
            t3.placedSymbolArray.emplaceBack(A2.x, A2.y, A2.z, l3.x, l3.y, v3, this.glyphOffsetArray.length - v3, _3, u3, c3, l3.segment, r4 ? r4[0] : 0, r4 ? r4[1] : 0, n3[0], n3[1], a3, 0, false, 0, h2, 0);
          }
          _commitLayoutVertex(t3, e4, r4, n3, i3, s4, a3) {
            t3.emplaceBack(e4, r4, n3, i3, s4, Math.round(a3.x), Math.round(a3.y));
          }
          _addCollisionDebugVertices(t3, e4, r4, n3, i3, s4, a3) {
            const o3 = r4.segments.prepareSegment(4, r4.layoutVertexArray, r4.indexArray), l3 = o3.vertexLength, u3 = a3.tileAnchorX, c3 = a3.tileAnchorY;
            for (let t4 = 0; t4 < 4; t4++)
              r4.collisionVertexArray.emplaceBack(0, 0, 0, 0);
            this._commitDebugCollisionVertexUpdate(r4.collisionVertexArrayExt, e4, t3.padding, a3.zOffset), this._commitLayoutVertex(r4.layoutVertexArray, n3, i3, s4, u3, c3, new Ue(t3.x1, t3.y1)), this._commitLayoutVertex(r4.layoutVertexArray, n3, i3, s4, u3, c3, new Ue(t3.x2, t3.y1)), this._commitLayoutVertex(r4.layoutVertexArray, n3, i3, s4, u3, c3, new Ue(t3.x2, t3.y2)), this._commitLayoutVertex(r4.layoutVertexArray, n3, i3, s4, u3, c3, new Ue(t3.x1, t3.y2)), o3.vertexLength += 4;
            const h2 = r4.indexArray;
            h2.emplaceBack(l3, l3 + 1), h2.emplaceBack(l3 + 1, l3 + 2), h2.emplaceBack(l3 + 2, l3 + 3), h2.emplaceBack(l3 + 3, l3), o3.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(t3, e4, r4, n3, i3, s4) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r4.get(a3), i4 = this.getSymbolInstanceTextSize(t3, s4, e4, a3);
              this._addCollisionDebugVertices(n4, i4, this.textCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s4);
            }
          }
          _addIconDebugCollisionBoxes(t3, e4, r4, n3, i3, s4) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r4.get(a3), i4 = this.getSymbolInstanceIconSize(t3, e4, s4.placedIconSymbolIndex);
              this._addCollisionDebugVertices(n4, i4, this.iconCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s4);
            }
          }
          generateCollisionDebugBuffers(t3, e4) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new lg(Ul, jd.members, Fl), this.iconCollisionBox = new lg(Ul, jd.members, Fl);
            const r4 = Xd(this.iconSizeData, t3), n3 = Xd(this.textSizeData, t3);
            for (let i3 = 0; i3 < this.symbolInstances.length; i3++) {
              const s4 = this.symbolInstances.get(i3);
              this._addTextDebugCollisionBoxes(n3, t3, e4, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._addTextDebugCollisionBoxes(n3, t3, e4, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r4, t3, e4, s4.iconBoxStartIndex, s4.iconBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r4, t3, e4, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex, s4);
            }
          }
          getSymbolInstanceTextSize(t3, e4, r4, n3) {
            const i3 = this.text.placedSymbolArray.get(e4.rightJustifiedTextSymbolIndex >= 0 ? e4.rightJustifiedTextSymbolIndex : e4.centerJustifiedTextSymbolIndex >= 0 ? e4.centerJustifiedTextSymbolIndex : e4.leftJustifiedTextSymbolIndex >= 0 ? e4.leftJustifiedTextSymbolIndex : e4.verticalPlacedTextSymbolIndex >= 0 ? e4.verticalPlacedTextSymbolIndex : n3), s4 = Yd(this.textSizeData, t3, i3) / $d;
            return this.tilePixelRatio * s4;
          }
          getSymbolInstanceIconSize(t3, e4, r4) {
            const n3 = this.icon.placedSymbolArray.get(r4), i3 = Yd(this.iconSizeData, t3, n3);
            return this.tilePixelRatio * i3;
          }
          _commitDebugCollisionVertexUpdate(t3, e4, r4, n3) {
            t3.emplaceBack(e4, -r4, -r4, n3), t3.emplaceBack(e4, r4, -r4, n3), t3.emplaceBack(e4, r4, r4, n3), t3.emplaceBack(e4, -r4, r4, n3);
          }
          _updateTextDebugCollisionBoxes(t3, e4, r4, n3, i3, s4) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r4.get(a3), i4 = this.getSymbolInstanceTextSize(t3, s4, e4, a3);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i4, n4.padding, s4.zOffset);
            }
          }
          _updateIconDebugCollisionBoxes(t3, e4, r4, n3, i3, s4) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r4.get(a3), i4 = this.getSymbolInstanceIconSize(t3, e4, s4.placedIconSymbolIndex);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i4, n4.padding, s4.zOffset);
            }
          }
          updateCollisionDebugBuffers(t3, e4) {
            if (!this.hasDebugData())
              return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const r4 = Xd(this.iconSizeData, t3), n3 = Xd(this.textSizeData, t3);
            for (let i3 = 0; i3 < this.symbolInstances.length; i3++) {
              const s4 = this.symbolInstances.get(i3);
              this._updateTextDebugCollisionBoxes(n3, t3, e4, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._updateTextDebugCollisionBoxes(n3, t3, e4, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._updateIconDebugCollisionBoxes(r4, t3, e4, s4.iconBoxStartIndex, s4.iconBoxEndIndex, s4), this._updateIconDebugCollisionBoxes(r4, t3, e4, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex, s4);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
            const u3 = {};
            if (e4 < r4) {
              const { x1: r5, y1: n4, x2: i4, y2: s5, padding: a4, projectedAnchorX: o4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3, featureIndex: f2 } = t3.get(e4);
              u3.textBox = { x1: r5, y1: n4, x2: i4, y2: s5, padding: a4, projectedAnchorX: o4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3 }, u3.textFeatureIndex = f2;
            }
            if (n3 < i3) {
              const { x1: e5, y1: r5, x2: i4, y2: s5, padding: a4, projectedAnchorX: o4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3, featureIndex: f2 } = t3.get(n3);
              u3.verticalTextBox = { x1: e5, y1: r5, x2: i4, y2: s5, padding: a4, projectedAnchorX: o4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3 }, u3.verticalTextFeatureIndex = f2;
            }
            if (s4 < a3) {
              const { x1: e5, y1: r5, x2: n4, y2: i4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3, featureIndex: f2 } = t3.get(s4);
              u3.iconBox = { x1: e5, y1: r5, x2: n4, y2: i4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3 }, u3.iconFeatureIndex = f2;
            }
            if (o3 < l3) {
              const { x1: e5, y1: r5, x2: n4, y2: i4, padding: s5, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3, featureIndex: f2 } = t3.get(o3);
              u3.verticalIconBox = { x1: e5, y1: r5, x2: n4, y2: i4, padding: s5, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: c3, tileAnchorX: h2, tileAnchorY: p3 }, u3.verticalIconFeatureIndex = f2;
            }
            return u3;
          }
          deserializeCollisionBoxes(t3) {
            this.collisionArrays = [];
            for (let e4 = 0; e4 < this.symbolInstances.length; e4++) {
              const r4 = this.symbolInstances.get(e4);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r4.textBoxStartIndex, r4.textBoxEndIndex, r4.verticalTextBoxStartIndex, r4.verticalTextBoxEndIndex, r4.iconBoxStartIndex, r4.iconBoxEndIndex, r4.verticalIconBoxStartIndex, r4.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          hasIconTextFit() {
            return this.hasAnyIconTextFit;
          }
          addIndicesForPlacedSymbol(t3, e4) {
            const r4 = t3.placedSymbolArray.get(e4), n3 = r4.vertexStartIndex + 4 * r4.numGlyphs;
            for (let e5 = r4.vertexStartIndex; e5 < n3; e5 += 4)
              t3.indexArray.emplaceBack(e5, e5 + 1, e5 + 2), t3.indexArray.emplaceBack(e5 + 1, e5 + 2, e5 + 3);
          }
          getSortedSymbolIndexes(t3) {
            if (this.sortedAngle === t3 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            const e4 = Math.sin(t3), r4 = Math.cos(t3), n3 = [], i3 = [], s4 = [];
            for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
              s4.push(t4);
              const a3 = this.symbolInstances.get(t4);
              n3.push(0 | Math.round(e4 * a3.tileAnchorX + r4 * a3.tileAnchorY)), i3.push(a3.featureIndex);
            }
            return s4.sort((t4, e5) => n3[t4] - n3[e5] || i3[e5] - i3[t4]), s4;
          }
          getSortedIndexesByZOffset() {
            if (!this.zOffsetSortDirty)
              return this.symbolInstanceIndexesSortedZOffset;
            if (!this.symbolInstanceIndexesSortedZOffset) {
              this.symbolInstanceIndexesSortedZOffset = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3)
                this.symbolInstanceIndexesSortedZOffset.push(t3);
            }
            return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t3, e4) => this.symbolInstances.get(e4).zOffset - this.symbolInstances.get(t3).zOffset);
          }
          addToSortKeyRanges(t3, e4) {
            const r4 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r4 && r4.sortKey === e4 ? r4.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e4, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
          }
          sortFeatures(t3) {
            if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t4 of this.symbolInstanceIndexes) {
                const e4 = this.symbolInstances.get(t4);
                this.featureSortOrder.push(e4.featureIndex);
                const { rightJustifiedTextSymbolIndex: r4, centerJustifiedTextSymbolIndex: n3, leftJustifiedTextSymbolIndex: i3, verticalPlacedTextSymbolIndex: s4, placedIconSymbolIndex: a3, verticalPlacedIconSymbolIndex: o3 } = e4;
                r4 >= 0 && this.addIndicesForPlacedSymbol(this.text, r4), n3 >= 0 && n3 !== r4 && this.addIndicesForPlacedSymbol(this.text, n3), i3 >= 0 && i3 !== n3 && i3 !== r4 && this.addIndicesForPlacedSymbol(this.text, i3), s4 >= 0 && this.addIndicesForPlacedSymbol(this.text, s4), a3 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a3), o3 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o3);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        fo(ug, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ug.addDynamicAttributes = sg;
        const cg = new Ho({ "symbol-placement": new Zo(el.layout_symbol["symbol-placement"]), "symbol-spacing": new Zo(el.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Zo(el.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ko(el.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Zo(el.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Zo(el.layout_symbol["symbol-z-elevate"]), "icon-allow-overlap": new Zo(el.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Zo(el.layout_symbol["icon-ignore-placement"]), "icon-optional": new Zo(el.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Zo(el.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ko(el.layout_symbol["icon-size"]), "icon-text-fit": new Ko(el.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ko(el.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ko(el.layout_symbol["icon-image"]), "icon-rotate": new Ko(el.layout_symbol["icon-rotate"]), "icon-padding": new Zo(el.layout_symbol["icon-padding"]), "icon-keep-upright": new Zo(el.layout_symbol["icon-keep-upright"]), "icon-offset": new Ko(el.layout_symbol["icon-offset"]), "icon-anchor": new Ko(el.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Zo(el.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Zo(el.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Zo(el.layout_symbol["text-rotation-alignment"]), "text-field": new Ko(el.layout_symbol["text-field"]), "text-font": new Ko(el.layout_symbol["text-font"]), "text-size": new Ko(el.layout_symbol["text-size"]), "text-max-width": new Ko(el.layout_symbol["text-max-width"]), "text-line-height": new Ko(el.layout_symbol["text-line-height"]), "text-letter-spacing": new Ko(el.layout_symbol["text-letter-spacing"]), "text-justify": new Ko(el.layout_symbol["text-justify"]), "text-radial-offset": new Ko(el.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Zo(el.layout_symbol["text-variable-anchor"]), "text-anchor": new Ko(el.layout_symbol["text-anchor"]), "text-max-angle": new Zo(el.layout_symbol["text-max-angle"]), "text-writing-mode": new Zo(el.layout_symbol["text-writing-mode"]), "text-rotate": new Ko(el.layout_symbol["text-rotate"]), "text-padding": new Zo(el.layout_symbol["text-padding"]), "text-keep-upright": new Zo(el.layout_symbol["text-keep-upright"]), "text-transform": new Ko(el.layout_symbol["text-transform"]), "text-offset": new Ko(el.layout_symbol["text-offset"]), "text-allow-overlap": new Zo(el.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Zo(el.layout_symbol["text-ignore-placement"]), "text-optional": new Zo(el.layout_symbol["text-optional"]), visibility: new Zo(el.layout_symbol.visibility) });
        var hg = { paint: new Ho({ "icon-opacity": new Ko(el.paint_symbol["icon-opacity"]), "icon-emissive-strength": new Ko(el.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new Ko(el.paint_symbol["text-emissive-strength"]), "icon-color": new Ko(el.paint_symbol["icon-color"]), "icon-halo-color": new Ko(el.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ko(el.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ko(el.paint_symbol["icon-halo-blur"]), "icon-translate": new Zo(el.paint_symbol["icon-translate"]), "icon-translate-anchor": new Zo(el.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Ko(el.paint_symbol["icon-image-cross-fade"]), "text-opacity": new Ko(el.paint_symbol["text-opacity"]), "text-color": new Ko(el.paint_symbol["text-color"], { runtimeType: Jn, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new Ko(el.paint_symbol["text-halo-color"]), "text-halo-width": new Ko(el.paint_symbol["text-halo-width"]), "text-halo-blur": new Ko(el.paint_symbol["text-halo-blur"]), "text-translate": new Zo(el.paint_symbol["text-translate"]), "text-translate-anchor": new Zo(el.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Zo(el.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Zo(el.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Zo(el.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Zo(el.paint_symbol["icon-color-brightness-max"]) }), layout: cg };
        class pg {
          constructor(t3) {
            this.type = t3.property.overrides ? t3.property.overrides.runtimeType : Zn, this.defaultValue = t3;
          }
          evaluate(t3) {
            if (t3.formattedSection) {
              const e4 = this.defaultValue.property.overrides;
              if (e4 && e4.hasOverride(t3.formattedSection))
                return e4.getOverride(t3.formattedSection);
            }
            return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t3) {
            this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        fo(pg, "FormatSectionOverride", { omit: ["defaultValue"] });
        class fg extends bl {
          constructor(e4, r4, n3) {
            super(e4, hg, r4, n3), this._colorAdjustmentMatrix = t2.a9.identity([]);
          }
          recalculate(t3, e4) {
            super.recalculate(t3, e4), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const r4 = this.layout.get("text-writing-mode");
            if (r4) {
              const t4 = [];
              for (const e5 of r4)
                t4.indexOf(e5) < 0 && t4.push(e5);
              this.layout._values["text-writing-mode"] = t4;
            } else
              this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getColorAdjustmentMatrix(e4, r4, n3, i3) {
            return this._saturation === e4 && this._contrast === r4 && this._brightnessMin === n3 && this._brightnessMax === i3 || (this._colorAdjustmentMatrix = function(e5, r5, n4, i4) {
              e5 = Er(e5), r5 = Pr(r5);
              const s4 = t2.a9.create(), a3 = e5 / 3, o3 = 1 - 2 * a3, l3 = [o3, a3, a3, 0, a3, o3, a3, 0, a3, a3, o3, 0, 0, 0, 0, 1], u3 = 0.5 - 0.5 * r5, c3 = i4 - n4;
              return t2.a9.multiply(s4, [c3, 0, 0, 0, 0, c3, 0, 0, 0, 0, c3, 0, n4, n4, n4, 1], [r5, 0, 0, 0, 0, r5, 0, 0, 0, 0, r5, 0, u3, u3, u3, 1]), t2.a9.multiply(s4, s4, l3), s4;
            }(e4, r4, n3, i3), this._saturation = e4, this._contrast = r4, this._brightnessMin = n3, this._brightnessMax = i3), this._colorAdjustmentMatrix;
          }
          getValueAndResolveTokens(t3, e4, r4, n3) {
            const i3 = this.layout.get(t3).evaluate(e4, {}, r4, n3), s4 = this._unevaluatedLayout._values[t3];
            return s4.isDataDriven() || eo(s4.value) || !i3 ? i3 : function(t4, e5) {
              return e5.replace(/{([^{}]+)}/g, (e6, r5) => r5 in t4 ? String(t4[r5]) : "");
            }(e4.properties, i3);
          }
          createBucket(t3) {
            return new ug(t3);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t3 of hg.paint.overridableProperties) {
              if (!fg.hasPaintOverride(this.layout, t3))
                continue;
              const e4 = this.paint.get(t3), r4 = new pg(e4), n3 = new to(r4, e4.property.specification, this.scope, this.options);
              let i3 = null;
              i3 = "constant" === e4.value.kind || "source" === e4.value.kind ? new no("source", n3) : new io("composite", n3, e4.value.zoomStops, e4.value._interpolationType), this.paint._values[t3] = new Yo(e4.property, i3, e4.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t3, e4, r4) {
            return !(!this.layout || e4.isDataDriven() || r4.isDataDriven()) && fg.hasPaintOverride(this.layout, t3);
          }
          static hasPaintOverride(t3, e4) {
            const r4 = t3.get("text-field"), n3 = hg.paint.properties[e4];
            let i3 = false;
            const s4 = (t4) => {
              for (const e5 of t4)
                if (n3.overrides && n3.overrides.hasOverride(e5))
                  return void (i3 = true);
            };
            if ("constant" === r4.value.kind && r4.value.value instanceof fi)
              s4(r4.value.value.sections);
            else if ("source" === r4.value.kind) {
              const t4 = (e6) => {
                i3 || (e6 instanceof bi && gi(e6.value) === ni ? s4(e6.value.sections) : e6 instanceof Mi ? s4(e6.sections) : e6.eachChild(t4));
              }, e5 = r4.value;
              e5._styleExpression && t4(e5._styleExpression.expression);
            }
            return i3;
          }
          getProgramIds() {
            const t3 = 0 !== this.paint.get("icon-opacity").constantOr(1), e4 = 0 !== this.paint.get("text-opacity").constantOr(1), r4 = [];
            return t3 && r4.push("symbolIcon"), e4 && r4.push("symbolSDF"), r4;
          }
          getDefaultProgramParams(t3, e4) {
            return { config: new Nu(this, e4), overrideFog: false };
          }
        }
        const dg = new Ho({ visibility: new Zo(el.layout_background.visibility) });
        var mg = { paint: new Ho({ "background-color": new Zo(el.paint_background["background-color"]), "background-pattern": new Zo(el.paint_background["background-pattern"]), "background-opacity": new Zo(el.paint_background["background-opacity"]), "background-emissive-strength": new Zo(el.paint_background["background-emissive-strength"]) }), layout: dg };
        const yg = new Ho({ visibility: new Zo(el.layout_raster.visibility) });
        var gg = { paint: new Ho({ "raster-opacity": new Zo(el.paint_raster["raster-opacity"]), "raster-color": new Wo(el.paint_raster["raster-color"]), "raster-color-mix": new Zo(el.paint_raster["raster-color-mix"]), "raster-color-range": new Zo(el.paint_raster["raster-color-range"]), "raster-hue-rotate": new Zo(el.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Zo(el.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Zo(el.paint_raster["raster-brightness-max"]), "raster-saturation": new Zo(el.paint_raster["raster-saturation"]), "raster-contrast": new Zo(el.paint_raster["raster-contrast"]), "raster-resampling": new Zo(el.paint_raster["raster-resampling"]), "raster-fade-duration": new Zo(el.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Zo(el.paint_raster["raster-emissive-strength"]), "raster-array-band": new Zo(el.paint_raster["raster-array-band"]), "raster-elevation": new Zo(el.paint_raster["raster-elevation"]) }), layout: yg }, xg = Ml([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class bg {
          constructor(t3, e4, r4, n3) {
            this.context = t3, this.format = r4, this.texture = t3.gl.createTexture(), this.update(e4, n3);
          }
          update(t3, e4, r4) {
            const { width: n3, height: i3 } = t3, { context: s4 } = this, { gl: a3 } = s4;
            if (a3.bindTexture(a3.TEXTURE_2D, this.texture), s4.pixelStoreUnpackFlipY.set(false), s4.pixelStoreUnpack.set(1), s4.pixelStoreUnpackPremultiplyAlpha.set(this.format === a3.RGBA && (!e4 || false !== e4.premultiply)), r4 || this.size && this.size[0] === n3 && this.size[1] === i3) {
              const { x: e5, y: s5 } = r4 || { x: 0, y: 0 };
              if (t3 instanceof HTMLImageElement || t3 instanceof HTMLCanvasElement || t3 instanceof HTMLVideoElement || t3 instanceof ImageData || ImageBitmap && t3 instanceof ImageBitmap)
                a3.texSubImage2D(a3.TEXTURE_2D, 0, e5, s5, a3.RGBA, a3.UNSIGNED_BYTE, t3);
              else {
                let r5 = this.format, o3 = a3.UNSIGNED_BYTE;
                this.format === a3.R32F && (r5 = a3.RED, o3 = a3.FLOAT), a3.texSubImage2D(a3.TEXTURE_2D, 0, e5, s5, n3, i3, r5, o3, t3.data);
              }
            } else if (this.size = [n3, i3], t3 instanceof HTMLImageElement || t3 instanceof HTMLCanvasElement || t3 instanceof HTMLVideoElement || t3 instanceof ImageData || ImageBitmap && t3 instanceof ImageBitmap) {
              let e5 = this.format;
              this.format === a3.R8 && (e5 = a3.RED), a3.texImage2D(a3.TEXTURE_2D, 0, this.format, e5, a3.UNSIGNED_BYTE, t3);
            } else {
              let e5 = this.format, r5 = this.format, s5 = a3.UNSIGNED_BYTE;
              this.format === a3.DEPTH_COMPONENT && (e5 = a3.DEPTH_COMPONENT16, s5 = a3.UNSIGNED_SHORT), this.format === a3.R8 && (r5 = a3.RED), this.format === a3.R32F && (s5 = a3.FLOAT, r5 = a3.RED), a3.texImage2D(a3.TEXTURE_2D, 0, e5, n3, i3, 0, r5, s5, t3.data);
            }
            this.useMipmap = Boolean(e4 && e4.useMipmap), this.useMipmap && a3.generateMipmap(a3.TEXTURE_2D);
          }
          bind(t3, e4, r4 = false) {
            const { context: n3 } = this, { gl: i3 } = n3;
            i3.bindTexture(i3.TEXTURE_2D, this.texture), t3 !== this.minFilter && (i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_MAG_FILTER, t3), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_MIN_FILTER, this.useMipmap && !r4 ? t3 === i3.NEAREST ? i3.NEAREST_MIPMAP_NEAREST : i3.LINEAR_MIPMAP_LINEAR : t3), this.minFilter = t3), e4 !== this.wrapS && (i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_WRAP_S, e4), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_WRAP_T, e4), this.wrapS = e4);
          }
          bindExtraParam(t3, e4, r4, n3) {
            const { context: i3 } = this, { gl: s4 } = i3;
            s4.bindTexture(s4.TEXTURE_2D, this.texture), e4 !== this.magFilter && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MAG_FILTER, e4), this.magFilter = e4), t3 !== this.minFilter && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MIN_FILTER, this.useMipmap ? t3 === s4.NEAREST ? s4.NEAREST_MIPMAP_NEAREST : s4.LINEAR_MIPMAP_LINEAR : t3), this.minFilter = t3), r4 !== this.wrapS && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_S, r4), this.wrapS = r4), n3 !== this.wrapT && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_T, n3), this.wrapT = n3);
          }
          destroy() {
            const { gl: t3 } = this.context;
            t3.deleteTexture(this.texture), this.texture = null;
          }
        }
        class vg {
          constructor(t3, e4) {
            this.context = t3, this.texture = e4;
          }
          bind(t3, e4) {
            const { context: r4 } = this, { gl: n3 } = r4;
            n3.bindTexture(n3.TEXTURE_2D, this.texture), t3 !== this.minFilter && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MAG_FILTER, t3), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MIN_FILTER, t3), this.minFilter = t3), e4 !== this.wrapS && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_S, e4), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_T, e4), this.wrapS = e4);
          }
        }
        function _g(e4, r4, n3, i3, s4, a3, o3, l3) {
          const u3 = [e4, r4, 1, n3, i3, 1, s4, a3, 1], c3 = [o3, l3, 1], h2 = t2.ct.adjoint([], u3), [p3, f2, d2] = t2.Q.transformMat3(c3, c3, h2);
          return t2.ct.multiply(u3, u3, [p3, 0, 0, 0, f2, 0, 0, 0, d2]);
        }
        function wg(e4, r4, n3, i3, s4, a3, o3, l3) {
          const u3 = function(e5, r5, n4, i4, s5, a4, o4, l4) {
            const u4 = _g(0, 0, 1, 0, 1, 1, 0, 1), c3 = _g(e5, r5, n4, i4, s5, a4, o4, l4), h2 = t2.ct.adjoint([], u4);
            return t2.ct.multiply(c3, c3, h2);
          }(e4, r4, n3, i3, s4, a3, o3, l3);
          return [u3[2] / u3[8] / is, u3[5] / u3[8] / is];
        }
        function Mg(t3) {
          return [t3[0], Math.min(Math.max(t3[1], -Ac), Ac)];
        }
        class Ag extends Dn {
          constructor(t3, e4, r4, n3) {
            super(), this.id = t3, this.dispatcher = r4, this.coordinates = e4.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n3), this.options = e4, this._dirty = false;
          }
          load(t3, e4) {
            if (this._loaded = e4 || false, this.fire(new Rn("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
              return t3 && (this.coordinates = t3), this._loaded = true, void this._finishLoading();
            this._imageRequest = sn(this.map._requestManager.transformRequest(this.url, Zr.Image), (e5, r4) => {
              this._imageRequest = null, this._loaded = true, e5 ? this.fire(new Vn(e5)) : r4 && (this.image = r4 instanceof HTMLImageElement ? Tr.getImageData(r4) : r4, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t3 && (this.coordinates = t3), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t3) {
            return t3.url ? (this._imageRequest && t3.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t3.url, this.load(t3.coordinates, this._loaded), this) : this;
          }
          setTexture(t3) {
            if (!(t3.handle instanceof WebGLTexture))
              throw new Error("The provided handle is not a WebGLTexture instance");
            return this.texture = new vg(this.map.painter.context, t3.handle), this.width = t3.dimensions[0], this.height = t3.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new Rn("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          onRemove() {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof vg || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
          }
          setCoordinates(t3) {
            if (this.coordinates = t3, this._boundsArray = void 0, this._unsupportedCoords = false, !t3.length)
              return this;
            this.onNorthPole = false, this.onSouthPole = false;
            let e4 = t3[0][1], r4 = t3[0][1];
            for (const n4 of t3)
              n4[1] > r4 && (r4 = n4[1]), n4[1] < e4 && (e4 = n4[1]);
            const n3 = (r4 + e4) / 2;
            if (n3 > Ac ? this.onNorthPole = true : n3 < -Ac && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
              const e5 = t3.map(Ec.fromLngLat);
              this.tileID = function(t4) {
                let e6 = 1 / 0, r5 = 1 / 0, n4 = -1 / 0, i3 = -1 / 0;
                for (const s5 of t4)
                  e6 = Math.min(e6, s5.x), r5 = Math.min(r5, s5.y), n4 = Math.max(n4, s5.x), i3 = Math.max(i3, s5.y);
                const s4 = Math.max(n4 - e6, i3 - r5), a3 = Math.max(0, Math.floor(-Math.log(s4) / Math.LN2)), o3 = Math.pow(2, a3);
                let l3 = Math.floor((e6 + n4) / 2 * o3);
                return l3 > 1 && (l3 -= 1), new cc(a3, l3, Math.floor((r5 + i3) / 2 * o3));
              }(e5), this.minzoom = this.maxzoom = this.tileID.z;
            }
            return this.fire(new Rn("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            this._boundsArray = void 0, this._unsupportedCoords = false;
          }
          _prepareData(e4) {
            for (const t3 in this.tiles) {
              const e5 = this.tiles[t3];
              "loaded" !== e5.state && (e5.state = "loaded", e5.texture = this.texture);
            }
            if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
              return;
            const r4 = Ty(new cc(0, 0, 0), this.map.transform.projection), n3 = [r4.projection.project(this.coordinates[0][0], this.coordinates[0][1]), r4.projection.project(this.coordinates[1][0], this.coordinates[1][1]), r4.projection.project(this.coordinates[2][0], this.coordinates[2][1]), r4.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
            if (!function(t3) {
              const e5 = t3[1].x - t3[0].x, r5 = t3[1].y - t3[0].y, n4 = t3[2].x - t3[1].x, i4 = t3[2].y - t3[1].y, s5 = t3[3].x - t3[2].x, a4 = t3[3].y - t3[2].y, o4 = t3[0].x - t3[3].x, l4 = t3[0].y - t3[3].y, u4 = e5 * i4 - n4 * r5, c4 = n4 * a4 - s5 * i4, h3 = s5 * l4 - o4 * a4, p4 = o4 * r5 - e5 * l4;
              return u4 > 0 && c4 > 0 && h3 > 0 && p4 > 0 || u4 < 0 && c4 < 0 && h3 < 0 && p4 < 0;
            }(n3))
              return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
            const i3 = Ty(this.tileID, this.map.transform.projection), [s4, a3, o3, l3] = this.coordinates.map((t3) => {
              const e5 = i3.projection.project(t3[0], t3[1]);
              return By(i3, e5)._round();
            });
            this.perspectiveTransform = wg(s4.x, s4.y, a3.x, a3.y, o3.x, o3.y, l3.x, l3.y);
            const u3 = this._boundsArray = new kl();
            u3.emplaceBack(s4.x, s4.y, 0, 0), u3.emplaceBack(a3.x, a3.y, is, 0), u3.emplaceBack(l3.x, l3.y, 0, is), u3.emplaceBack(o3.x, o3.y, is, is), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e4.createVertexBuffer(u3, xg.members), this.boundsSegments = mu.simpleSegment(0, 0, 4, 2);
            const c3 = [], h2 = [Mg((p3 = this.coordinates)[0]), Mg(p3[1]), Mg(p3[2]), Mg(p3[3])];
            var p3;
            const [f2, d2, m2, y3] = function(t3) {
              let e5 = t3[0][0], r5 = e5, n4 = t3[0][1], i4 = n4;
              for (let s5 = 1; s5 < t3.length; s5++)
                t3[s5][0] < e5 ? e5 = t3[s5][0] : t3[s5][0] > r5 && (r5 = t3[s5][0]), t3[s5][1] < n4 ? n4 = t3[s5][1] : t3[s5][1] > i4 && (i4 = t3[s5][1]);
              return [e5, n4, r5 - e5, i4 - n4];
            }(h2);
            {
              const i4 = new kl(), [s5, a4, o4, l4] = function(t3) {
                let e5 = t3[0].x, r5 = e5, n4 = t3[0].y, i5 = n4;
                for (let s6 = 1; s6 < t3.length; s6++)
                  t3[s6].x < e5 ? e5 = t3[s6].x : t3[s6].x > r5 && (r5 = t3[s6].x), t3[s6].y < n4 ? n4 = t3[s6].y : t3[s6].y > i5 && (i5 = t3[s6].y);
                return [e5, n4, r5 - e5, i5 - n4];
              }(n3), u4 = (t3) => [(t3.x - s5) / o4, (t3.y - a4) / l4], [h3, p4, g3, x3] = n3.map(u4), b2 = function(e5, r5, n4, i5, s6, a5, o5, l5) {
                const u5 = _g(0, 0, 1, 0, 1, 1, 0, 1), c4 = _g(e5, r5, n4, i5, s6, a5, o5, l5), h4 = t2.ct.adjoint([], c4);
                return t2.ct.multiply(u5, u5, h4);
              }(h3[0], h3[1], p4[0], p4[1], g3[0], g3[1], x3[0], x3[1]);
              this.elevatedGlobePerspectiveTransform = wg(h3[0], h3[1], p4[0], p4[1], g3[0], g3[1], x3[0], x3[1]);
              const v3 = (e5, r5) => {
                c3.push(e5.lng);
                const n4 = Math.round((e5.lng - f2) / m2 * is), s6 = Math.round((e5.lat - d2) / y3 * is), a5 = u4(r5), o5 = t2.Q.transformMat3([], [a5[0], a5[1], 1], b2), l5 = Math.round(o5[0] / o5[2] * is), h4 = Math.round(o5[1] / o5[2] * is);
                i4.emplaceBack(n4, s6, l5, h4);
              }, _3 = n3[3].x - n3[0].x, w2 = n3[3].y - n3[0].y, M3 = n3[2].x - n3[1].x, A2 = n3[2].y - n3[1].y;
              for (let t3 = 0; t3 < 65; t3++) {
                const e5 = t3 / 64, i5 = [n3[0].x + e5 * _3, n3[0].y + e5 * w2], s6 = [n3[1].x + e5 * M3, n3[1].y + e5 * A2], a5 = s6[0] - i5[0], o5 = s6[1] - i5[1];
                for (let t4 = 0; t4 < 65; t4++) {
                  const e6 = t4 / 64, n4 = { x: i5[0] + a5 * e6, y: i5[1] + o5 * e6, z: 0 };
                  v3(r4.projection.unproject(n4.x, n4.y), n4);
                }
              }
              this.elevatedGlobeVertexBuffer = e4.createVertexBuffer(i4, xg.members);
            }
            {
              this.maxLongitudeTriangleSize = 0;
              let t3 = [], r5 = new ql();
              const n4 = (e5, n5, i4) => {
                r5.emplaceBack(e5, n5, i4);
                const s5 = c3[e5], a4 = c3[n5], o4 = c3[i4], l4 = Math.min(Math.min(s5, a4), o4), u4 = Math.max(Math.max(s5, a4), o4) - l4;
                u4 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u4), t3.push(l4 + u4 / 2);
              };
              for (let t4 = 0; t4 < 64; t4++)
                for (let e5 = 0; e5 < 64; e5++) {
                  const r6 = 65 * t4 + e5, i4 = r6 + 1, s5 = r6 + 65, a4 = s5 + 1;
                  n4(r6, s5, i4), n4(i4, s5, a4);
                }
              [t3, r5] = function(t4, e5) {
                const r6 = Array.from({ length: t4.length }, (t5, e6) => e6);
                r6.sort((e6, r7) => t4[e6] - t4[r7]);
                const n5 = [], i4 = new ql();
                for (let s5 = 0; s5 < r6.length; s5++) {
                  const a4 = r6[s5];
                  n5.push(t4[a4]);
                  const o4 = 3 * a4, l4 = o4 + 1;
                  i4.emplaceBack(e5.uint16[o4], e5.uint16[l4], e5.uint16[l4 + 1]);
                }
                return [n5, i4];
              }(t3, r5), this.elevatedGlobeTrianglesCenterLongitudes = t3, this.elevatedGlobeIndexBuffer = e4.createIndexBuffer(r5);
            }
            this.elevatedGlobeSegments = mu.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, m2 / is, 0, y3 / is, 0, 0, d2, f2, 0]);
          }
          prepare() {
            const t3 = 0 !== Object.keys(this.tiles).length;
            if (this.tileID && !t3)
              return;
            const e4 = this.map.painter.context, r4 = e4.gl;
            !this._dirty || this.texture instanceof vg || (this.texture ? this.texture.update(this.image) : (this.texture = new bg(e4, this.image, r4.RGBA), this.texture.bind(r4.LINEAR, r4.CLAMP_TO_EDGE)), this._dirty = false), t3 && this._prepareData(e4);
          }
          loadTile(t3, e4) {
            this.tileID && this.tileID.equals(t3.tileID.canonical) ? (this.tiles[String(t3.tileID.wrap)] = t3, t3.buckets = {}, e4(null)) : (t3.state = "errored", e4(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          getSegmentsForLongitude(t3) {
            const e4 = this.elevatedGlobeSegments;
            if (!this.elevatedGlobeTrianglesCenterLongitudes || !e4)
              return null;
            const r4 = this.elevatedGlobeTrianglesCenterLongitudes;
            let n3 = ((t4, e5) => t4 + 360 * Math.round((e5 - t4) / 360))(t3 + 180, r4[0]);
            const i3 = new mu(), s4 = (t4, r5) => {
              i3.segments.push({ vertexOffset: 0, primitiveOffset: t4, vertexLength: e4.segments[0].vertexLength, primitiveLength: r5, sortKey: void 0, vaos: {} });
            }, a3 = 0.51 * this.maxLongitudeTriangleSize;
            if (Math.abs(r4[0] - n3) <= a3) {
              const t4 = kr(r4, 0, r4.length, n3 + a3);
              return t4 === r4.length || s4(t4, Ir(r4, t4 + 1, r4.length, n3 + 360 - a3) - t4), i3;
            }
            n3 < r4[0] && (n3 += 360);
            const o3 = Ir(r4, 0, r4.length, n3 - a3);
            if (o3 === r4.length)
              return s4(0, r4.length), i3;
            s4(0, o3 - 0);
            const l3 = kr(r4, o3 + 1, r4.length, n3 + a3);
            return l3 !== r4.length && s4(l3, r4.length - l3), i3;
          }
        }
        const Sg = (Math.pow(256, 2) - 1) / 16907520;
        class Ig extends bl {
          constructor(t3, e4, r4) {
            super(t3, gg, e4, r4), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
          }
          getProgramIds() {
            return ["raster"];
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-color"].value.value;
          }
          tileCoverLift() {
            return this.paint.get("raster-elevation");
          }
          isDraped(t3) {
            return !(t3 && t3._source instanceof Ag && (t3._source.onNorthPole || t3._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "raster-color" !== t3 && "raster-color-range" !== t3 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
          }
          updateColorRamp(t3) {
            if (!this.hasColorMap())
              return;
            if (!this._curRampRange)
              return;
            const e4 = this._transitionablePaint._values["raster-color"].value.expression, [r4, n3] = t3 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
            isNaN(r4) && isNaN(n3) || r4 === this._curRampRange[0] && n3 === this._curRampRange[1] || (this.colorRamp = op({ expression: e4, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: r4, end: n3 }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [r4, n3]);
          }
        }
        const kg = new Ho({ visibility: new Zo(el["layout_raster-particle"].visibility) });
        var Pg = { paint: new Ho({ "raster-particle-array-band": new Zo(el["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Zo(el["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new Wo(el["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Zo(el["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Zo(el["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Zo(el["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Zo(el["paint_raster-particle"]["raster-particle-reset-rate-factor"]) }), layout: kg };
        class Eg extends bl {
          constructor(t3, e4, r4) {
            super(t3, Pg, e4, r4), this._updateColorRamp(), this.lastInvalidatedAt = Tr.now();
          }
          onRemove(t3) {
            this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-particle-color"].value.value;
          }
          getProgramIds() {
            return ["rasterParticle"];
          }
          hasOffscreenPass() {
            return "none" !== this.visibility;
          }
          isDraped(t3) {
            return false;
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "raster-particle-color" !== t3 && "raster-particle-max-speed" !== t3 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t3 && this._invalidateAnimationState();
          }
          _updateColorRamp() {
            if (!this.hasColorMap())
              return;
            const t3 = this._transitionablePaint._values["raster-particle-color"].value.expression, e4 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
            this.colorRamp = op({ expression: t3, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: e4 }], resolution: 256 }), this.colorRampTexture = null;
          }
          _invalidateAnimationState() {
            this.lastInvalidatedAt = Tr.now();
          }
        }
        class zg extends bl {
          constructor(t3, e4) {
            super(t3, {}, e4), this.implementation = t3, t3.slot && (this.slot = t3.slot);
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          isDraped(t3) {
            return void 0 !== this.implementation.renderToTile;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
          }
          onAdd(t3) {
            this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
          }
          onRemove(t3) {
            this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
          }
        }
        const Tg = new Ho({ visibility: new Zo(el.layout_sky.visibility) });
        var Bg = { paint: new Ho({ "sky-type": new Zo(el.paint_sky["sky-type"]), "sky-atmosphere-sun": new Zo(el.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Zo(el.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Zo(el.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Zo(el.paint_sky["sky-gradient-radius"]), "sky-gradient": new Wo(el.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Zo(el.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Zo(el.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Zo(el.paint_sky["sky-opacity"]) }), layout: Tg };
        function Cg(e4, r4, n3) {
          const i3 = [0, 0, 1], s4 = t2.bl.identity([]);
          return t2.bl.rotateY(s4, s4, n3 ? -qe(e4) + Math.PI : qe(e4)), t2.bl.rotateX(s4, s4, -qe(r4)), t2.Q.transformQuat(i3, i3, s4), t2.Q.normalize(i3, i3);
        }
        var Rg = { paint: new Ho({}) };
        function Vg(e4, r4) {
          const n3 = Lg(e4.projection, e4.zoom, e4.width, e4.height), i3 = function(e5, r5, n4, i4, s5) {
            const a3 = new ac(n4.lng - 180 * Fg, n4.lat), o3 = new ac(n4.lng + 180 * Fg, n4.lat), l3 = e5.project(a3.lng, a3.lat), u3 = e5.project(o3.lng, o3.lat), c3 = -Math.atan2(u3.y - l3.y, u3.x - l3.x), h2 = Ec.fromLngLat(n4);
            h2.y = Ze(h2.y, -1 + Fg, 1 - Fg);
            const p3 = h2.toLngLat(), f2 = e5.project(p3.lng, p3.lat), d2 = Ec.fromLngLat(p3);
            d2.x += Fg;
            const m2 = d2.toLngLat(), y3 = e5.project(m2.lng, m2.lat), g3 = Ug(y3.x - f2.x, y3.y - f2.y, c3), x3 = Ec.fromLngLat(p3);
            x3.y += Fg;
            const b2 = x3.toLngLat(), v3 = e5.project(b2.lng, b2.lat), _3 = Ug(v3.x - f2.x, v3.y - f2.y, c3), w2 = Math.abs(g3.x) / Math.abs(_3.y), M3 = t2.a9.identity([]);
            t2.a9.rotateZ(M3, M3, -c3 * (1 - (s5 ? 0 : i4)));
            const A2 = t2.a9.identity([]);
            return t2.a9.scale(A2, A2, [1, 1 - (1 - w2) * i4, 1]), A2[4] = -_3.x / _3.y * i4, t2.a9.rotateZ(A2, A2, c3), t2.a9.multiply(A2, M3, A2), A2;
          }(e4.projection, 0, e4.center, n3, r4), s4 = Dg(e4);
          return t2.a9.scale(i3, i3, [s4, s4, 1]), i3;
        }
        function Dg(t3) {
          const e4 = t3.projection, r4 = Lg(t3.projection, t3.zoom, t3.width, t3.height), n3 = Og(e4, t3.center), i3 = Og(e4, ac.convert(e4.center));
          return Math.pow(2, n3 * r4 + (1 - r4) * i3);
        }
        function Lg(t3, e4, r4, n3, i3 = 1 / 0) {
          const s4 = t3.range;
          if (!s4)
            return 0;
          const a3 = Math.min(i3, Math.max(r4, n3)), o3 = Math.log(a3 / 1024) / Math.LN2;
          return Ke(s4[0] + o3, s4[1] + o3, e4);
        }
        const Fg = 1 / 4e4;
        function Og(t3, e4) {
          const r4 = Ze(e4.lat, -Ac, Ac), n3 = new ac(e4.lng - 180 * Fg, r4), i3 = new ac(e4.lng + 180 * Fg, r4), s4 = t3.project(n3.lng, r4), a3 = t3.project(i3.lng, r4), o3 = Ec.fromLngLat(n3), l3 = Ec.fromLngLat(i3), u3 = a3.x - s4.x, c3 = a3.y - s4.y, h2 = l3.x - o3.x, p3 = l3.y - o3.y, f2 = Math.sqrt((h2 * h2 + p3 * p3) / (u3 * u3 + c3 * c3));
          return Math.log(f2) / Math.LN2;
        }
        function Ug(t3, e4, r4) {
          const n3 = Math.cos(r4), i3 = Math.sin(r4);
          return { x: t3 * n3 - e4 * i3, y: t3 * i3 + e4 * n3 };
        }
        function Ng(e4, r4, n3) {
          t2.a9.identity(e4), t2.a9.rotateZ(e4, e4, qe(r4[2])), t2.a9.rotateX(e4, e4, qe(r4[0])), t2.a9.rotateY(e4, e4, qe(r4[1])), t2.a9.scale(e4, e4, n3), t2.a9.multiply(e4, e4, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        function jg(e4, r4, n3, i3, s4, a3, o3, l3) {
          const u3 = [n3[0] - r4[0], n3[1] - r4[1], 0], c3 = [i3[0] - r4[0], i3[1] - r4[1], 0];
          if (t2.Q.length(u3) < 1e-12 || t2.Q.length(c3) < 1e-12)
            return t2.bl.identity(e4);
          const h2 = t2.Q.cross([], u3, c3);
          t2.Q.normalize(h2, h2), t2.Q.subtract(c3, i3, r4), u3[2] = (a3 - s4) * l3, c3[2] = (o3 - s4) * l3;
          const p3 = u3;
          return t2.Q.cross(p3, u3, c3), t2.Q.normalize(p3, p3), t2.bl.rotationTo(e4, h2, p3);
        }
        function qg(e4, r4, n3 = false) {
          const i3 = Oh(r4.zoom), s4 = function(e5, r5, n4) {
            const i4 = r5.worldSize, s5 = [e5[12], e5[13], e5[14]], a3 = wc(s5[1] / i4), o3 = _c(s5[0] / i4), l3 = t2.a9.identity([]), u3 = vc(1, a3) * i4, c3 = vc(1, 0) * i4 * Ic(a3, r5.zoom), h2 = 1 / Dh(i4);
            let p3 = c3 * h2;
            if (n4) {
              const t3 = Lg(r5.projection, r5.zoom, r5.width, r5.height, 1024);
              p3 = h2 * r5.projection.pixelSpaceConversion(r5.center.lat, i4, t3);
            }
            const f2 = nc(a3, o3);
            t2.Q.add(f2, f2, t2.Q.scale([], t2.Q.normalize([], f2), u3 * p3 * s5[2]));
            const d2 = function(e6) {
              const r6 = [e6[0], e6[1], e6[2]];
              let n5 = [0, 1, 0];
              const i5 = t2.Q.cross([], n5, r6);
              return t2.Q.cross(n5, r6, i5), 0 === t2.Q.squaredLength(n5) && (n5 = [0, 1, 0], t2.Q.cross(i5, r6, n5)), t2.Q.normalize(i5, i5), t2.Q.normalize(n5, n5), t2.Q.normalize(r6, r6), [i5[0], i5[1], i5[2], 0, n5[0], n5[1], n5[2], 0, r6[0], r6[1], r6[2], 0, e6[0], e6[1], e6[2], 1];
            }(f2);
            t2.a9.scale(l3, l3, [p3, p3, p3 * u3]), t2.a9.translate(l3, l3, [-s5[0], -s5[1], -s5[2]]);
            const m2 = t2.a9.multiply([], r5.globeMatrix, d2);
            return t2.a9.multiply(m2, m2, l3), t2.a9.multiply(m2, m2, e5), m2;
          }(e4, r4, n3);
          if (i3 > 0) {
            const n4 = function(e5, r5) {
              const n5 = r5.worldSize, i4 = vc(1, 0) * n5 * Ic(r5.center.lat, r5.zoom) / Dh(n5), s5 = vc(1, r5.center.lat) * n5, a3 = t2.a9.identity([]);
              return t2.a9.rotateY(a3, a3, qe(r5.center.lng)), t2.a9.rotateX(a3, a3, qe(r5.center.lat)), t2.a9.translate(a3, a3, [0, 0, Xu]), t2.a9.scale(a3, a3, [i4, i4, i4 * s5]), t2.a9.translate(a3, a3, [r5.point.x - 0.5 * n5, r5.point.y - 0.5 * n5, 0]), t2.a9.multiply(a3, a3, e5), t2.a9.multiply(a3, r5.globeMatrix, a3);
            }(e4, r4);
            return function(e5, r5, n5) {
              const i4 = (e6, r6, n6) => {
                const i5 = t2.Q.length(e6), s6 = t2.Q.length(r6), a4 = Ih(e6, r6, n6);
                return t2.Q.scale(a4, a4, 1 / t2.Q.length(a4) * qn(i5, s6, n6));
              }, s5 = i4([e5[0], e5[1], e5[2]], [r5[0], r5[1], r5[2]], n5), a3 = i4([e5[4], e5[5], e5[6]], [r5[4], r5[5], r5[6]], n5), o3 = i4([e5[8], e5[9], e5[10]], [r5[8], r5[9], r5[10]], n5), l3 = Ih([e5[12], e5[13], e5[14]], [r5[12], r5[13], r5[14]], n5);
              return [s5[0], s5[1], s5[2], 0, a3[0], a3[1], a3[2], 0, o3[0], o3[1], o3[2], 0, l3[0], l3[1], l3[2], 1];
            }(s4, n4, i3);
          }
          return s4;
        }
        function $g(t3, e4, r4, n3) {
          const i3 = mh.projectAabbCorners(n3, r4);
          let s4 = Number.MAX_VALUE, a3 = -1;
          for (let t4 = 0; t4 < i3.length; ++t4) {
            const r5 = i3[t4];
            r5[0] = (0.5 * r5[0] + 0.5) * e4.width, r5[1] = (0.5 - 0.5 * r5[1]) * e4.height, r5[2] < s4 && (a3 = t4, s4 = r5[2]);
          }
          const o3 = (t4) => new Ue(i3[t4][0], i3[t4][1]);
          let l3;
          switch (a3) {
            case 0:
            case 6:
              l3 = [o3(1), o3(5), o3(4), o3(7), o3(3), o3(2), o3(1)];
              break;
            case 1:
            case 7:
              l3 = [o3(0), o3(4), o3(5), o3(6), o3(2), o3(3), o3(0)];
              break;
            case 3:
            case 5:
              l3 = [o3(1), o3(0), o3(4), o3(7), o3(6), o3(2), o3(1)];
              break;
            default:
              l3 = [o3(1), o3(5), o3(6), o3(7), o3(3), o3(0), o3(1)];
          }
          if (jc(t3, l3))
            return s4;
        }
        const Gg = Ml([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Qg = Ml([{ name: "a_color_3f", components: 3, type: "Float32" }]), Yg = Ml([{ name: "a_color_4f", components: 4, type: "Float32" }]), Xg = Ml([{ name: "a_uv_2f", components: 2, type: "Float32" }]), Zg = Ml([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Kg = Ml([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), Wg = Ml([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]);
        class Hg {
          constructor(t3, e4, r4, n3) {
            this.message = (t3 ? `${t3}: ` : "") + r4, n3 && (this.identifier = n3), null != e4 && e4.__line__ && (this.line = e4.__line__);
          }
        }
        function Jg(t3, e4) {
          const r4 = -1 === t3.indexOf("://");
          try {
            return new URL(t3, r4 && e4 ? "http://example.com" : void 0), true;
          } catch (t4) {
            return false;
          }
        }
        class tx {
          constructor(t3, e4) {
            this.feature = t3, this.instancedDataOffset = e4, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
          }
        }
        class ex {
          constructor() {
            this.instancedDataArray = new Hl(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
          }
        }
        class rx {
          constructor(t3) {
            this.zoom = t3.zoom, this.canonical = t3.canonical, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.fqid), this.projection = t3.projection, this.index = t3.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = false;
          }
          populate(t3, e4, r4, n3) {
            this.tileToMeter = Pc(r4);
            const i3 = this.layers[0]._featureFilter.needGeometry;
            this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
            for (const { feature: s4, id: a3, index: o3, sourceLayerIndex: l3 } of t3) {
              const t4 = null != a3 ? a3 : s4.properties && s4.properties.hasOwnProperty("id") ? s4.properties.id : void 0, u3 = Fc(s4, i3);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), u3, r4))
                continue;
              const c3 = { id: t4, sourceLayerIndex: l3, index: o3, geometry: i3 ? u3.geometry : Lc(s4, r4, n3), properties: s4.properties, type: s4.type, patterns: {} }, h2 = this.addFeature(c3, c3.geometry, u3);
              h2 && e4.featureIndex.insert(s4, c3.geometry, o3, l3, this.index, this.instancesPerModel[h2].instancedDataArray.length, is / 32);
            }
            this.lookup = null;
          }
          update(t3, e4, r4, n3) {
            for (const e5 in this.instancesPerModel) {
              const r5 = this.instancesPerModel[e5];
              for (const e6 in t3)
                r5.idToFeaturesIndex.hasOwnProperty(e6) && (this.evaluate(r5.features[r5.idToFeaturesIndex[e6]], t3[e6], r5, true), this.uploaded = false);
            }
            this.maxHeight = 0;
          }
          updateZoomBasedPaintProperties() {
            if (!this.hasZoomDependentProperties)
              return false;
            let e4 = false;
            for (const r4 in this.instancesPerModel) {
              const n3 = this.instancesPerModel[r4];
              for (const r5 of n3.features) {
                const i3 = this.layers[0], s4 = r5.feature, a3 = this.canonical, o3 = i3.paint.get("model-rotation").evaluate(s4, {}, a3), l3 = i3.paint.get("model-scale").evaluate(s4, {}, a3), u3 = i3.paint.get("model-translation").evaluate(s4, {}, a3);
                t2.Q.exactEquals(r5.rotation, o3) && t2.Q.exactEquals(r5.scale, l3) && t2.Q.exactEquals(r5.translation, u3) || (this.evaluate(r5, r5.featureStates, n3, true), e4 = true);
              }
            }
            return e4;
          }
          isEmpty() {
            for (const t3 in this.instancesPerModel)
              if (0 !== this.instancesPerModel[t3].instancedDataArray.length)
                return false;
            return true;
          }
          uploadPending() {
            return !this.uploaded;
          }
          upload(t3) {
            if (!this.uploaded)
              for (const e4 in this.instancesPerModel) {
                const r4 = this.instancesPerModel[e4];
                r4.instancedDataArray.length < 0 || 0 === r4.instancedDataArray.length || (r4.instancedDataBuffer ? r4.instancedDataBuffer.updateData(r4.instancedDataArray) : r4.instancedDataBuffer = t3.createVertexBuffer(r4.instancedDataArray, Kg.members, true, void 0, this.instanceCount));
              }
            this.uploaded = true;
          }
          destroy() {
            for (const t4 in this.instancesPerModel) {
              const e4 = this.instancesPerModel[t4];
              0 !== e4.instancedDataArray.length && e4.instancedDataBuffer && e4.instancedDataBuffer.destroy();
            }
            const t3 = this.layers[0].modelManager;
            if (t3 && this.modelUris)
              for (const e4 of this.modelUris)
                t3.removeModel(e4, "");
          }
          addFeature(t3, e4, r4) {
            const n3 = this.layers[0], i3 = n3.layout.get("model-id").evaluate(r4, {}, this.canonical);
            if (!i3)
              return hr(`modelId is not evaluated for layer ${n3.id} and it is not going to get rendered.`), i3;
            Jg(i3, false) && (this.modelUris.includes(i3) || this.modelUris.push(i3)), this.instancesPerModel[i3] || (this.instancesPerModel[i3] = new ex());
            const s4 = this.instancesPerModel[i3], a3 = s4.instancedDataArray, o3 = new tx(r4, a3.length);
            for (const t4 of e4)
              for (const e5 of t4) {
                if (e5.x < 0 || e5.x >= is || e5.y < 0 || e5.y >= is)
                  continue;
                const t5 = (this.lookupDim - 1) / is, r5 = this.lookupDim * (e5.y * t5 | 0) + e5.x * t5 | 0;
                if (this.lookup) {
                  if (0 !== this.lookup[r5])
                    continue;
                  this.lookup[r5] = 1;
                }
                this.instanceCount++;
                const n4 = a3.length;
                a3.resize(n4 + 1), s4.instancesEvaluatedElevation.push(0), a3.float32[16 * n4] = e5.x, a3.float32[16 * n4 + 1] = e5.y;
              }
            return o3.instancedDataCount = s4.instancedDataArray.length - o3.instancedDataOffset, o3.instancedDataCount > 0 && (t3.id && (s4.idToFeaturesIndex[t3.id] = s4.features.length), s4.features.push(o3), this.evaluate(o3, {}, s4, false)), i3;
          }
          getModelUris() {
            return this.modelUris;
          }
          evaluate(t3, e4, r4, n3) {
            const i3 = this.layers[0], s4 = t3.feature, a3 = this.canonical, o3 = t3.rotation = i3.paint.get("model-rotation").evaluate(s4, e4, a3), l3 = t3.scale = i3.paint.get("model-scale").evaluate(s4, e4, a3), u3 = t3.translation = i3.paint.get("model-translation").evaluate(s4, e4, a3), c3 = i3.paint.get("model-color").evaluate(s4, e4, a3);
            c3.a = i3.paint.get("model-color-mix-intensity").evaluate(s4, e4, a3);
            const h2 = [];
            this.maxVerticalOffset < u3[2] && (this.maxVerticalOffset = u3[2]), this.maxScale = Math.max(Math.max(this.maxScale, l3[0]), Math.max(l3[1], l3[2])), Ng(h2, o3, l3);
            const p3 = Math.round(100 * c3.a) + c3.b / 1.05;
            for (let e5 = 0; e5 < t3.instancedDataCount; ++e5) {
              const i4 = t3.instancedDataOffset + e5, s5 = 16 * i4, o4 = r4.instancedDataArray.float32;
              let l4 = 0;
              n3 && (l4 = o4[s5 + 6] - r4.instancesEvaluatedElevation[i4]);
              const f2 = 0 | o4[s5 + 1];
              o4[s5] = (0 | o4[s5]) + c3.r / 1.05, o4[s5 + 1] = f2 + c3.g / 1.05, o4[s5 + 2] = p3, o4[s5 + 3] = 1 / (a3.z > 10 ? this.tileToMeter : Pc(a3, f2)), o4[s5 + 4] = u3[0], o4[s5 + 5] = u3[1], o4[s5 + 6] = u3[2] + l4, o4[s5 + 7] = h2[0], o4[s5 + 8] = h2[1], o4[s5 + 9] = h2[2], o4[s5 + 10] = h2[4], o4[s5 + 11] = h2[5], o4[s5 + 12] = h2[6], o4[s5 + 13] = h2[8], o4[s5 + 14] = h2[9], o4[s5 + 15] = h2[10], r4.instancesEvaluatedElevation[i4] = u3[2];
            }
          }
        }
        fo(rx, "ModelBucket", { omit: ["layers"] }), fo(ex, "PerModelAttributes"), fo(tx, "ModelFeature");
        const nx = new Ho({ visibility: new Zo(el.layout_model.visibility), "model-id": new Ko(el.layout_model["model-id"]) });
        var ix = { paint: new Ho({ "model-opacity": new Zo(el.paint_model["model-opacity"]), "model-rotation": new Ko(el.paint_model["model-rotation"]), "model-scale": new Ko(el.paint_model["model-scale"]), "model-translation": new Ko(el.paint_model["model-translation"]), "model-color": new Ko(el.paint_model["model-color"]), "model-color-mix-intensity": new Ko(el.paint_model["model-color-mix-intensity"]), "model-type": new Zo(el.paint_model["model-type"]), "model-cast-shadows": new Zo(el.paint_model["model-cast-shadows"]), "model-receive-shadows": new Zo(el.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Zo(el.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new Ko(el.paint_model["model-emissive-strength"]), "model-roughness": new Ko(el.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new Ko(el.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Zo(el.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Zo(el.paint_model["model-front-cutoff"]) }), layout: nx };
        const sx = 64, ax = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
        function ox(e4, r4, n3, i3, s4, a3, o3, l3, u3, c3 = false) {
          const h2 = n3.zoom, p3 = n3.project(i3), f2 = Ic(i3.lat, h2), d2 = 1 / f2;
          t2.a9.identity(e4), t2.a9.translate(e4, e4, [p3.x + o3[0] * d2, p3.y + o3[1] * d2, o3[2]]);
          let m2 = 1, y3 = 1;
          const g3 = n3.worldSize;
          if (c3) {
            if ("mercator" === n3.projection.name) {
              let e5 = 0;
              n3.elevation && (e5 = n3.elevation.getAtPointOrZero(new Ec(p3.x / g3, p3.y / g3), 0));
              const r5 = t2.aa.transformMat4([], [p3.x, p3.y, e5, 1], n3.projMatrix)[3] / n3.cameraToCenterDistance;
              m2 = r5, y3 = r5 * Ic(n3.center.lat, h2);
            } else if ("globe" === n3.projection.name) {
              const r5 = qg(e4, n3), s5 = t2.a9.multiply([], n3.projMatrix, r5), a4 = [0, 0, 0, 1];
              t2.aa.transformMat4(a4, a4, s5);
              const o4 = a4[3] / n3.cameraToCenterDistance, l4 = Oh(h2), u4 = n3.projection.pixelsPerMeter(i3.lat, g3) * Ic(i3.lat, h2), c4 = n3.projection.pixelsPerMeter(n3.center.lat, g3) * Ic(n3.center.lat, h2);
              m2 = o4 / qn(u4, Sc(n3.center.lat), l4), y3 = o4 * f2 / u4, m2 *= c4, y3 *= c4;
            }
          } else
            m2 = d2;
          t2.a9.scale(e4, e4, [m2, m2, y3]);
          const x3 = [...e4], b2 = r4.orientation, v3 = [];
          if (Ng(v3, [b2[0] + s4[0], b2[1] + s4[1], b2[2] + s4[2]], a3), t2.a9.multiply(e4, x3, v3), l3 && n3.elevation) {
            let s5 = 0;
            const a4 = [];
            if (u3 && n3.elevation) {
              s5 = function(e5, r5, n4, i4, s6) {
                const a5 = r5.elevation;
                if (!a5)
                  return 0;
                const o5 = mh.projectAabbCorners(n4, i4), l5 = vc(1, s6.lat) * r5.worldSize, u4 = function(e6, r6) {
                  const n5 = [0, 0, 1], i5 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                  for (const s7 of i5) {
                    const i6 = e6[s7.corners[0]], a6 = e6[s7.corners[1]], o6 = e6[s7.corners[2]], l6 = [a6[0] - i6[0], a6[1] - i6[1], r6 * (a6[2] - i6[2])], u5 = t2.Q.cross(l6, l6, [o6[0] - i6[0], o6[1] - i6[1], r6 * (o6[2] - i6[2])]);
                    t2.Q.normalize(u5, u5), s7.dotProductWithUp = t2.Q.dot(u5, n5);
                  }
                  return i5.sort((t3, e7) => t3.dotProductWithUp - e7.dotProductWithUp), i5[0].corners;
                }(o5, l5), c4 = o5[u4[0]], h3 = o5[u4[1]], p4 = o5[u4[2]], f3 = o5[u4[3]], d3 = a5.getAtPointOrZero(new Ec(c4[0] / r5.worldSize, c4[1] / r5.worldSize), 0), m3 = a5.getAtPointOrZero(new Ec(h3[0] / r5.worldSize, h3[1] / r5.worldSize), 0), y4 = a5.getAtPointOrZero(new Ec(p4[0] / r5.worldSize, p4[1] / r5.worldSize), 0), g4 = a5.getAtPointOrZero(new Ec(f3[0] / r5.worldSize, f3[1] / r5.worldSize), 0), x4 = (d3 + g4) / 2, b3 = (m3 + y4) / 2;
                return x4 > b3 ? m3 < y4 ? jg(e5, h3, f3, c4, m3, g4, d3, l5) : jg(e5, p4, c4, f3, y4, d3, g4, l5) : d3 < g4 ? jg(e5, c4, h3, p4, d3, m3, y4, l5) : jg(e5, f3, p4, h3, g4, y4, m3, l5), Math.max(x4, b3);
              }(a4, n3, r4.aabb, e4, i3);
              const o4 = t2.a9.fromQuat([], a4), l4 = t2.a9.multiply([], o4, v3);
              t2.a9.multiply(e4, x3, l4);
            } else
              s5 = n3.elevation.getAtPointOrZero(new Ec(p3.x / g3, p3.y / g3), 0);
            0 !== s5 && (e4[14] += s5);
          }
        }
        function lx(t3, e4, r4 = false) {
          t3.uploaded || (t3.gfxTexture = new bg(e4, t3.image, r4 ? e4.gl.R8 : e4.gl.RGBA, { useMipmap: t3.sampler.minFilter >= e4.gl.NEAREST_MIPMAP_NEAREST }), t3.uploaded = true, t3.image = null);
        }
        function ux(t3, e4, r4) {
          t3.indexBuffer = e4.createIndexBuffer(t3.indexArray, false, true), t3.vertexBuffer = e4.createVertexBuffer(t3.vertexArray, Gg.members, false, true), t3.normalArray && (t3.normalBuffer = e4.createVertexBuffer(t3.normalArray, Zg.members, false, true)), t3.texcoordArray && (t3.texcoordBuffer = e4.createVertexBuffer(t3.texcoordArray, Xg.members, false, true)), t3.colorArray && (t3.colorBuffer = e4.createVertexBuffer(t3.colorArray, (12 === t3.colorArray.bytesPerElement ? Qg : Yg).members, false, true)), t3.featureArray && (t3.pbrBuffer = e4.createVertexBuffer(t3.featureArray, Wg.members, true)), t3.segments = mu.simpleSegment(0, 0, t3.vertexArray.length, t3.indexArray.length);
          const n3 = t3.material;
          n3.pbrMetallicRoughness.baseColorTexture && lx(n3.pbrMetallicRoughness.baseColorTexture, e4), n3.pbrMetallicRoughness.metallicRoughnessTexture && lx(n3.pbrMetallicRoughness.metallicRoughnessTexture, e4), n3.normalTexture && lx(n3.normalTexture, e4), n3.occlusionTexture && lx(n3.occlusionTexture, e4, r4), n3.emissionTexture && lx(n3.emissionTexture, e4);
        }
        function cx(t3, e4, r4) {
          if (t3.meshes)
            for (const n3 of t3.meshes)
              ux(n3, e4, r4);
          if (t3.children)
            for (const n3 of t3.children)
              cx(n3, e4, r4);
        }
        function hx(t3) {
          if (t3.meshes)
            for (const e4 of t3.meshes)
              e4.indexArray.destroy(), e4.vertexArray.destroy(), e4.colorArray && e4.colorArray.destroy(), e4.normalArray && e4.normalArray.destroy(), e4.texcoordArray && e4.texcoordArray.destroy(), e4.featureArray && e4.featureArray.destroy();
          if (t3.children)
            for (const e4 of t3.children)
              hx(e4);
        }
        function px(t3) {
          if (t3.meshes)
            for (const r4 of t3.meshes)
              r4.vertexBuffer && (r4.vertexBuffer.destroy(), r4.indexBuffer.destroy(), r4.normalBuffer && r4.normalBuffer.destroy(), r4.texcoordBuffer && r4.texcoordBuffer.destroy(), r4.colorBuffer && r4.colorBuffer.destroy(), r4.pbrBuffer && r4.pbrBuffer.destroy(), r4.segments.destroy(), r4.material && ((e4 = r4.material).pbrMetallicRoughness.baseColorTexture && e4.pbrMetallicRoughness.baseColorTexture.gfxTexture && e4.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e4.pbrMetallicRoughness.metallicRoughnessTexture && e4.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e4.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e4.normalTexture && e4.normalTexture.gfxTexture && e4.normalTexture.gfxTexture.destroy(), e4.emissionTexture && e4.emissionTexture.gfxTexture && e4.emissionTexture.gfxTexture.destroy(), e4.occlusionTexture && e4.occlusionTexture.gfxTexture && e4.occlusionTexture.gfxTexture.destroy()));
          var e4;
          if (t3.children)
            for (const e5 of t3.children)
              px(e5);
        }
        class fx {
          constructor(t3) {
            this._callback = t3, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class dx {
          constructor() {
            this.tasks = {}, this.taskQueue = [], sr(["process"], this), this.invoker = new fx(this.process), this.nextId = 0;
          }
          add(t3, e4) {
            const r4 = this.nextId++, n3 = function({ type: t4, isSymbolTile: e5, zoom: r5 }) {
              return r5 = r5 || 0, "message" === t4 ? 0 : "maybePrepare" !== t4 || e5 ? "parseTile" !== t4 || e5 ? "parseTile" === t4 && e5 ? 300 - r5 : "maybePrepare" === t4 && e5 ? 400 - r5 : 500 : 200 - r5 : 100 - r5;
            }(e4);
            if (0 === n3) {
              mr();
              try {
                t3();
              } finally {
              }
              return null;
            }
            return this.tasks[r4] = { fn: t3, metadata: e4, priority: n3, id: r4 }, this.taskQueue.push(r4), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[r4];
            } };
          }
          process() {
            mr();
            try {
              if (this.taskQueue = this.taskQueue.filter((t4) => !!this.tasks[t4]), !this.taskQueue.length)
                return;
              const t3 = this.pick();
              if (null === t3)
                return;
              const e4 = this.tasks[t3];
              if (delete this.tasks[t3], this.taskQueue.length && this.invoker.trigger(), !e4)
                return;
              e4.fn();
            } finally {
            }
          }
          pick() {
            let t3 = null, e4 = 1 / 0;
            for (let r5 = 0; r5 < this.taskQueue.length; r5++) {
              const n3 = this.tasks[this.taskQueue[r5]];
              n3.priority < e4 && (e4 = n3.priority, t3 = r5);
            }
            if (null === t3)
              return null;
            const r4 = this.taskQueue[t3];
            return this.taskQueue.splice(t3, 1), r4;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class mx {
          constructor(t3, e4, r4) {
            this.target = t3, this.parent = e4, this.mapId = r4, this.callbacks = {}, this.cancelCallbacks = {}, sr(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new dx();
          }
          send(t3, e4, r4, n3, i3 = false, s4) {
            const a3 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r4 && (r4.metadata = s4, this.callbacks[a3] = r4);
            const o3 = /* @__PURE__ */ new Set();
            return this.target.postMessage({ id: a3, type: t3, hasCallback: !!r4, targetMapId: n3, mustQueue: i3, sourceMapId: this.mapId, data: go(e4, o3) }, o3), { cancel: () => {
              r4 && delete this.callbacks[a3], this.target.postMessage({ id: a3, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
            } };
          }
          receive(t3) {
            const e4 = t3.data, r4 = e4.id;
            if (r4 && (!e4.targetMapId || this.mapId === e4.targetMapId))
              if ("<cancel>" === e4.type) {
                const t4 = this.cancelCallbacks[r4];
                delete this.cancelCallbacks[r4], t4 && t4.cancel();
              } else if (e4.mustQueue || mr()) {
                const t4 = this.callbacks[r4], n3 = this.scheduler.add(() => this.processTask(r4, e4), t4 && t4.metadata || { type: "message" });
                n3 && (this.cancelCallbacks[r4] = n3);
              } else
                this.processTask(r4, e4);
          }
          processTask(t3, e4) {
            if (delete this.cancelCallbacks[t3], "<response>" === e4.type) {
              const r4 = this.callbacks[t3];
              delete this.callbacks[t3], r4 && (e4.error ? r4(xo(e4.error)) : r4(null, xo(e4.data)));
            } else {
              const r4 = /* @__PURE__ */ new Set(), n3 = e4.hasCallback ? (e5, n4) => {
                this.target.postMessage({ id: t3, type: "<response>", sourceMapId: this.mapId, error: e5 ? go(e5) : null, data: go(n4, r4) }, r4);
              } : (t4) => {
              }, i3 = xo(e4.data);
              if (this.parent[e4.type])
                this.parent[e4.type](e4.sourceMapId, i3, n3);
              else if (this.parent.getWorkerSource) {
                const t4 = e4.type.split(".");
                this.parent.getWorkerSource(e4.sourceMapId, t4[0], i3.source, i3.scope)[t4[1]](i3, n3);
              } else
                n3(new Error(`Could not find function ${e4.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }
        class yx {
          constructor(t3, e4) {
            this.workerPool = t3, this.actors = [], this.currentActor = 0, this.id = er();
            const r4 = this.workerPool.acquire(this.id);
            for (let t4 = 0; t4 < r4.length; t4++) {
              const n3 = new yx.Actor(r4[t4], e4, this.id);
              n3.name = `Worker ${t4}`, this.actors.push(n3);
            }
            this.ready = false, this.broadcast("checkIfReady", null, () => {
              this.ready = true;
            });
          }
          broadcast(t3, e4, r4) {
            He(this.actors, (r5, n3) => {
              r5.send(t3, e4, n3);
            }, r4 = r4 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((t3) => {
              t3.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        yx.Actor = mx;
        var gx = { workerUrl: "", workerClass: null, workerParams: void 0 };
        function xx() {
          return null != gx.workerClass ? new gx.workerClass() : new self.Worker(gx.workerUrl, gx.workerParams);
        }
        const bx = "mapboxgl_preloaded_worker_pool";
        class vx {
          constructor() {
            this.active = {};
          }
          acquire(t3) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < vx.workerCount; )
                this.workers.push(new xx());
            return this.active[t3] = true, this.workers.slice();
          }
          release(t3) {
            delete this.active[t3], this.workers && 0 === this.numActive() && (this.workers.forEach((t4) => {
              t4.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[bx];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        let _x;
        function wx() {
          return _x || (_x = new vx()), _x;
        }
        vx.workerCount = 2;
        let Mx, Ax, Sx, Ix, kx, Px = null;
        function Ex() {
          return mr() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : Ax || n2.DRACO_URL;
        }
        function zx() {
          if (mr() && self.worker && self.worker.meshoptUrl)
            return self.worker.meshoptUrl;
          if (Ix)
            return Ix;
          const t3 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
          if ("object" != typeof WebAssembly)
            throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
          return Ix = WebAssembly.validate(t3) ? n2.MESHOPT_SIMD_URL : n2.MESHOPT_URL, Ix;
        }
        const Tx = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Bx = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, Cx = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
        function Rx(t3, e4, r4) {
          const n3 = r4.json.bufferViews.length, i3 = r4.buffers.length;
          e4.bufferView = n3, r4.json.bufferViews[n3] = { buffer: i3, byteLength: t3.byteLength }, r4.buffers[i3] = t3;
        }
        const Vx = "KHR_draco_mesh_compression";
        function Dx(t3, e4) {
          const r4 = t3.extensions && t3.extensions[Vx];
          if (!r4)
            return;
          const n3 = new Sx.Decoder(), i3 = qx(e4, r4.bufferView), s4 = new Sx.Mesh();
          if (!n3.DecodeArrayToMesh(i3, i3.byteLength, s4))
            throw new Error("Failed to decode Draco mesh");
          const a3 = e4.json.accessors[t3.indices], o3 = Tx[a3.componentType], l3 = a3.count * o3.BYTES_PER_ELEMENT, u3 = Sx._malloc(l3);
          o3 === Uint16Array ? n3.GetTrianglesUInt16Array(s4, l3, u3) : n3.GetTrianglesUInt32Array(s4, l3, u3), Rx(Sx.memory.buffer.slice(u3, u3 + l3), a3, e4), Sx._free(u3);
          for (const i4 of Object.keys(r4.attributes)) {
            const a4 = n3.GetAttributeByUniqueId(s4, r4.attributes[i4]), o4 = e4.json.accessors[t3.attributes[i4]], l4 = Bx[o4.componentType], u4 = o4.count * Cx[o4.type] * Tx[o4.componentType].BYTES_PER_ELEMENT, c3 = Sx._malloc(u4);
            n3.GetAttributeDataArrayForAllPoints(s4, a4, Sx[l4], u4, c3), Rx(Sx.memory.buffer.slice(c3, c3 + u4), o4, e4), Sx._free(c3);
          }
          n3.destroy(), s4.destroy(), delete t3.extensions[Vx];
        }
        const Lx = "EXT_meshopt_compression";
        function Fx(t3, e4) {
          if (!t3.extensions || !t3.extensions[Lx])
            return;
          const r4 = t3.extensions[Lx], n3 = new Uint8Array(e4.buffers[r4.buffer], r4.byteOffset || 0, r4.byteLength || 0), i3 = new Uint8Array(r4.count * r4.byteStride);
          kx.decodeGltfBuffer(i3, r4.count, r4.byteStride, n3, r4.mode, r4.filter), t3.buffer = e4.buffers.length, t3.byteOffset = 0, e4.buffers[t3.buffer] = i3.buffer, delete t3.extensions[Lx];
        }
        const Ox = 1179937895, Ux = new TextDecoder("utf8");
        function Nx(t3, e4) {
          return new URL(t3, e4).href;
        }
        function jx(t3, e4, r4, n3) {
          return fetch(Nx(t3.uri, n3)).then((t4) => t4.arrayBuffer()).then((t4) => {
            e4.buffers[r4] = t4;
          });
        }
        function qx(t3, e4) {
          const r4 = t3.json.bufferViews[e4];
          return new Uint8Array(t3.buffers[r4.buffer], r4.byteOffset || 0, r4.byteLength);
        }
        function $x(t3, e4, r4, n3) {
          if (t3.uri) {
            const i3 = Nx(t3.uri, n3);
            return fetch(i3).then((t4) => t4.blob()).then((t4) => createImageBitmap(t4)).then((t4) => {
              e4.images[r4] = t4;
            });
          }
          if (void 0 !== t3.bufferView) {
            const n4 = qx(e4, t3.bufferView), i3 = new Blob([n4], { type: t3.mimeType });
            return createImageBitmap(i3).then((t4) => {
              e4.images[r4] = t4;
            });
          }
        }
        function Gx(t3, e4 = 0, r4) {
          const n3 = { json: null, images: [], buffers: [] };
          if (new Uint32Array(t3, e4, 1)[0] === Ox) {
            const r5 = new Uint32Array(t3, e4);
            let i4 = 2;
            const s5 = (r5[i4++] >> 2) - 3, a4 = r5[i4++] >> 2;
            if (i4++, n3.json = JSON.parse(Ux.decode(r5.subarray(i4, i4 + a4))), i4 += a4, i4 < s5) {
              const s6 = r5[i4++];
              i4++;
              const a5 = e4 + (i4 << 2);
              n3.buffers[0] = t3.slice(a5, a5 + s6);
            }
          } else
            n3.json = JSON.parse(Ux.decode(new Uint8Array(t3, e4)));
          const { buffers: i3, images: s4, meshes: a3, extensionsUsed: o3, bufferViews: l3 } = n3.json;
          let u3 = Promise.resolve();
          if (i3) {
            const t4 = [];
            for (let e5 = 0; e5 < i3.length; e5++) {
              const s5 = i3[e5];
              s5.uri ? t4.push(jx(s5, n3, e5, r4)) : n3.buffers[e5] || (n3.buffers[e5] = null);
            }
            u3 = Promise.all(t4);
          }
          return u3.then(() => {
            const t4 = [], e5 = o3 && o3.includes(Vx), i4 = o3 && o3.includes(Lx);
            if (e5 && t4.push(function() {
              if (!Sx)
                return Mx || (Mx = function(t5) {
                  let e6, r5 = null;
                  function n4() {
                    e6 = new Uint8Array(r5.buffer);
                  }
                  function i5() {
                    throw new Error("Unexpected Draco error.");
                  }
                  const s5 = { a: { a: i5, d: function(t6, r6, n5) {
                    return e6.copyWithin(t6, r6, r6 + n5);
                  }, c: function(t6) {
                    const i6 = e6.length, s6 = Math.max(t6 >>> 0, Math.ceil(1.2 * i6)), a4 = Math.ceil((s6 - i6) / 65536);
                    try {
                      return r5.grow(a4), n4(), true;
                    } catch (t7) {
                      return false;
                    }
                  }, b: i5 } };
                  return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t5, s5) : t5.then((t6) => t6.arrayBuffer()).then((t6) => WebAssembly.instantiate(t6, s5))).then((t6) => {
                    const { Rb: i6, Qb: s6, P: a4, T: o4, X: l4, Ja: u4, La: c3, Qa: h2, Va: p3, Wa: f2, eb: d2, jb: m2, f: y3, e: g3, yb: x3, zb: b2, Ab: v3, Bb: _3, Db: w2, Gb: M3 } = t6.instance.exports;
                    r5 = g3;
                    const A2 = /* @__PURE__ */ (() => {
                      let t7 = 0, r6 = 0, n5 = 0, a5 = 0;
                      return (o5) => {
                        n5 && (i6(a5), i6(t7), r6 += n5, n5 = t7 = 0), t7 || (r6 += 128, t7 = s6(r6));
                        const l5 = o5.length + 7 & -8;
                        let u5 = t7;
                        l5 >= r6 && (n5 = l5, u5 = a5 = s6(l5));
                        for (let t8 = 0; t8 < o5.length; t8++)
                          e6[u5 + t8] = o5[t8];
                        return u5;
                      };
                    })();
                    return n4(), y3(), { memory: g3, _free: i6, _malloc: s6, Mesh: class {
                      constructor() {
                        this.ptr = a4();
                      }
                      destroy() {
                        o4(this.ptr);
                      }
                    }, Decoder: class {
                      constructor() {
                        this.ptr = u4();
                      }
                      destroy() {
                        m2(this.ptr);
                      }
                      DecodeArrayToMesh(t7, e7, r6) {
                        const n5 = A2(t7), i7 = c3(this.ptr, n5, e7, r6.ptr);
                        return !!l4(i7);
                      }
                      GetAttributeByUniqueId(t7, e7) {
                        return { ptr: h2(this.ptr, t7.ptr, e7) };
                      }
                      GetTrianglesUInt16Array(t7, e7, r6) {
                        p3(this.ptr, t7.ptr, e7, r6);
                      }
                      GetTrianglesUInt32Array(t7, e7, r6) {
                        f2(this.ptr, t7.ptr, e7, r6);
                      }
                      GetAttributeDataArrayForAllPoints(t7, e7, r6, n5, i7) {
                        d2(this.ptr, t7.ptr, e7.ptr, r6, n5, i7);
                      }
                    }, DT_INT8: x3(), DT_UINT8: b2(), DT_INT16: v3(), DT_UINT16: _3(), DT_UINT32: w2(), DT_FLOAT32: M3() };
                  });
                }(fetch(Ex())), Mx.then((t5) => {
                  Sx = t5, Mx = void 0;
                }));
            }()), i4 && t4.push(function() {
              if (kx)
                return;
              const t5 = function(t6) {
                let e6;
                const r5 = WebAssembly.instantiateStreaming(t6, {}).then((t7) => {
                  e6 = t7.instance, e6.exports.__wasm_call_ctors();
                }), n4 = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, i5 = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
                return { ready: r5, supported: true, decodeGltfBuffer(t7, r6, s5, a4, o4, l4) {
                  !function(t8, e7, r7, n5, i6, s6, a5) {
                    const o5 = t8.exports.sbrk, l5 = n5 + 3 & -4, u4 = o5(l5 * i6), c3 = o5(s6.length), h2 = new Uint8Array(t8.exports.memory.buffer);
                    h2.set(s6, c3);
                    const p3 = e7(u4, n5, i6, c3, s6.length);
                    if (0 === p3 && a5 && a5(u4, l5, i6), r7.set(h2.subarray(u4, u4 + n5 * i6)), o5(u4 - o5(0)), 0 !== p3)
                      throw new Error(`Malformed buffer data: ${p3}`);
                  }(e6, e6.exports[i5[o4]], t7, r6, s5, a4, e6.exports[n4[l4]]);
                } };
              }(fetch(zx()));
              return t5.ready.then(() => {
                kx = t5;
              });
            }()), s4)
              for (let e6 = 0; e6 < s4.length; e6++)
                t4.push($x(s4[e6], n3, e6, r4));
            return (t4.length ? Promise.all(t4) : Promise.resolve()).then(() => {
              if (e5 && a3)
                for (const { primitives: t5 } of a3)
                  for (const e6 of t5)
                    Dx(e6, n3);
              if (i4 && a3 && l3)
                for (const t5 of l3)
                  Fx(t5, n3);
              return n3;
            });
          });
        }
        class Qx {
          constructor(t3, e4, r4, n3) {
            if (this.triangleCount = e4.length / 3, this.min = new Ue(0, 0), this.max = new Ue(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t3.length)
              return;
            const [i3, s4] = [t3[0].clone(), t3[0].clone()];
            for (let e5 = 1; e5 < t3.length; ++e5) {
              const r5 = t3[e5];
              i3.x = Math.min(i3.x, r5.x), i3.y = Math.min(i3.y, r5.y), s4.x = Math.max(s4.x, r5.x), s4.y = Math.max(s4.y, r5.y);
            }
            if (n3) {
              const t4 = Math.ceil(Math.max(s4.x - i3.x, s4.y - i3.y) / n3);
              r4 = Math.max(r4, t4);
            }
            if (0 === r4)
              return;
            this.min = i3, this.max = s4;
            const a3 = this.max.sub(this.min);
            a3.x = Math.max(a3.x, 1), a3.y = Math.max(a3.y, 1);
            const o3 = Math.max(a3.x, a3.y) / r4;
            this.cellsX = Math.max(1, Math.ceil(a3.x / o3)), this.cellsY = Math.max(1, Math.ceil(a3.y / o3)), this.xScale = 1 / o3, this.yScale = 1 / o3;
            const l3 = [];
            for (let r5 = 0; r5 < this.triangleCount; r5++) {
              const n4 = t3[e4[3 * r5 + 0]].sub(this.min), i4 = t3[e4[3 * r5 + 1]].sub(this.min), s5 = t3[e4[3 * r5 + 2]].sub(this.min), a4 = Yx(Math.floor(Math.min(n4.x, i4.x, s5.x)), this.xScale, this.cellsX), u4 = Yx(Math.floor(Math.max(n4.x, i4.x, s5.x)), this.xScale, this.cellsX), c3 = Yx(Math.floor(Math.min(n4.y, i4.y, s5.y)), this.yScale, this.cellsY), h2 = Yx(Math.floor(Math.max(n4.y, i4.y, s5.y)), this.yScale, this.cellsY), p3 = new Ue(0, 0), f2 = new Ue(0, 0), d2 = new Ue(0, 0), m2 = new Ue(0, 0);
              for (let t4 = c3; t4 <= h2; ++t4) {
                p3.y = f2.y = t4 * o3, d2.y = m2.y = (t4 + 1) * o3;
                for (let e5 = a4; e5 <= u4; ++e5)
                  p3.x = d2.x = e5 * o3, f2.x = m2.x = (e5 + 1) * o3, (eh(n4, i4, s5, p3, f2, m2) || eh(n4, i4, s5, p3, m2, d2)) && l3.push({ cellIdx: t4 * this.cellsX + e5, triIdx: r5 });
              }
            }
            if (0 === l3.length)
              return;
            l3.sort((t4, e5) => t4.cellIdx - e5.cellIdx || t4.triIdx - e5.triIdx);
            let u3 = 0;
            for (; u3 < l3.length; ) {
              const t4 = l3[u3].cellIdx, e5 = { start: this.payload.length, len: 0 };
              for (; u3 < l3.length && l3[u3].cellIdx === t4; )
                ++e5.len, this.payload.push(l3[u3++].triIdx);
              this.cells[t4] = e5;
            }
          }
          query(t3, e4, r4) {
            if (0 === this.triangleCount || 0 === this.cells.length)
              return;
            if (t3.x > this.max.x || this.min.x > e4.x)
              return;
            if (t3.y > this.max.y || this.min.y > e4.y)
              return;
            this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8)));
            for (let t4 = 0; t4 < this.lookup.length; t4++)
              this.lookup[t4] = 0;
            const n3 = Yx(t3.x - this.min.x, this.xScale, this.cellsX), i3 = Yx(e4.x - this.min.x, this.xScale, this.cellsX), s4 = Yx(t3.y - this.min.y, this.yScale, this.cellsY), a3 = Yx(e4.y - this.min.y, this.yScale, this.cellsY);
            for (let t4 = s4; t4 <= a3; t4++)
              for (let e5 = n3; e5 <= i3; e5++) {
                const n4 = this.cells[t4 * this.cellsX + e5];
                if (n4)
                  for (let t5 = 0; t5 < n4.len; t5++) {
                    const e6 = this.payload[n4.start + t5], i4 = Math.floor(e6 / 8), s5 = 1 << e6 % 8;
                    if (!(this.lookup[i4] & s5) && (this.lookup[i4] |= s5, r4.push(e6), r4.length === this.triangleCount))
                      return;
                  }
              }
          }
        }
        function Yx(t3, e4, r4) {
          return Math.max(0, Math.min(r4 - 1, Math.floor(t3 * e4)));
        }
        function Xx(t3, e4) {
          const r4 = t3.json.bufferViews[e4.bufferView], n3 = Tx[e4.componentType];
          return new n3(t3.buffers[r4.buffer], (e4.byteOffset || 0) + (r4.byteOffset || 0), e4.count * (r4.byteStride && r4.byteStride !== Cx[e4.type] * n3.BYTES_PER_ELEMENT ? r4.byteStride / n3.BYTES_PER_ELEMENT : Cx[e4.type]));
        }
        function Zx(t3, e4, r4, n3) {
          const i3 = Tx[e4.componentType], s4 = function(t4) {
            switch (t4) {
              case Int8Array:
                return 1 / 127;
              case Uint8Array:
                return 1 / 255;
              case Int16Array:
                return 1 / 32767;
              case Uint16Array:
                return 1 / 65535;
              default:
                return 1;
            }
          }(i3), a3 = t3.json.bufferViews[e4.bufferView], o3 = a3.byteStride ? a3.byteStride / i3.BYTES_PER_ELEMENT : Cx[e4.type], l3 = r4.float32, u3 = l3.length / r4.capacity;
          for (let t4 = 0, r5 = 0; t4 < e4.count * o3; t4 += o3, r5 += u3)
            for (let e5 = 0; e5 < u3; e5++)
              l3[r5 + e5] = n3[t4 + e5] * s4;
          r4._trim();
        }
        function Kx(t3, e4, r4) {
          const n3 = t3.indices, i3 = t3.attributes, s4 = {};
          s4.indexArray = new ql();
          const a3 = e4.json.accessors[n3], o3 = a3.count / 3;
          s4.indexArray.reserve(o3);
          const l3 = Xx(e4, a3);
          for (let t4 = 0; t4 < o3; t4++)
            s4.indexArray.emplaceBack(l3[3 * t4], l3[3 * t4 + 1], l3[3 * t4 + 2]);
          s4.indexArray._trim(), s4.vertexArray = new Wl();
          const u3 = e4.json.accessors[i3.POSITION];
          s4.vertexArray.reserve(u3.count);
          const c3 = Xx(e4, u3);
          for (let t4 = 0; t4 < u3.count; t4++)
            s4.vertexArray.emplaceBack(c3[3 * t4], c3[3 * t4 + 1], c3[3 * t4 + 2]);
          if (s4.vertexArray._trim(), s4.aabb = new mh(u3.min, u3.max), s4.centroid = function(t4, e5) {
            const r5 = [0, 0, 0], n4 = t4.length;
            if (n4 > 0) {
              for (let i4 = 0; i4 < n4; i4++) {
                const n5 = 3 * t4[i4];
                r5[0] += e5[n5], r5[1] += e5[n5 + 1], r5[2] += e5[n5 + 2];
              }
              r5[0] /= n4, r5[1] /= n4, r5[2] /= n4;
            }
            return r5;
          }(l3, c3), void 0 !== i3.COLOR_0) {
            const t4 = e4.json.accessors[i3.COLOR_0], r5 = Cx[t4.type], n4 = Xx(e4, t4);
            s4.colorArray = 3 === r5 ? new Wl() : new zl(), s4.colorArray.resize(t4.count), Zx(e4, t4, s4.colorArray, n4);
          }
          if (void 0 !== i3.NORMAL) {
            s4.normalArray = new Wl();
            const t4 = e4.json.accessors[i3.NORMAL];
            s4.normalArray.resize(t4.count);
            const r5 = Xx(e4, t4);
            Zx(e4, t4, s4.normalArray, r5);
          }
          if (void 0 !== i3.TEXCOORD_0 && r4.length > 0) {
            s4.texcoordArray = new Tl();
            const t4 = e4.json.accessors[i3.TEXCOORD_0];
            s4.texcoordArray.resize(t4.count);
            const r5 = Xx(e4, t4);
            Zx(e4, t4, s4.texcoordArray, r5);
          }
          if (void 0 !== i3._FEATURE_ID_RGBA4444) {
            const t4 = e4.json.accessors[i3._FEATURE_ID_RGBA4444];
            e4.json.extensionsUsed && e4.json.extensionsUsed.includes("EXT_meshopt_compression") && (s4.featureData = Xx(e4, t4));
          }
          void 0 !== i3._FEATURE_RGBA4444 && (s4.featureData = new Uint32Array(Xx(e4, e4.json.accessors[i3._FEATURE_RGBA4444]).buffer));
          const h2 = t3.material;
          return s4.material = function(t4, e5) {
            const { emissiveFactor: r5 = [0, 0, 0], alphaMode: n4 = "OPAQUE", alphaCutoff: i4 = 0.5, normalTexture: s5, occlusionTexture: a4, emissiveTexture: o4, doubleSided: l4 } = t4, { baseColorFactor: u4 = [1, 1, 1, 1], metallicFactor: c4 = 1, roughnessFactor: h3 = 1, baseColorTexture: p3, metallicRoughnessTexture: f2 } = t4.pbrMetallicRoughness || {}, d2 = a4 ? e5[a4.index] : void 0;
            if (a4 && a4.extensions && a4.extensions.KHR_texture_transform && d2) {
              const t5 = a4.extensions.KHR_texture_transform;
              d2.offsetScale = [t5.offset[0], t5.offset[1], t5.scale[0], t5.scale[1]];
            }
            return { pbrMetallicRoughness: { baseColorFactor: new jn(...u4), metallicFactor: c4, roughnessFactor: h3, baseColorTexture: p3 ? e5[p3.index] : void 0, metallicRoughnessTexture: f2 ? e5[f2.index] : void 0 }, doubleSided: l4, emissiveFactor: r5, alphaMode: n4, alphaCutoff: i4, normalTexture: s5 ? e5[s5.index] : void 0, occlusionTexture: d2, emissionTexture: o4 ? e5[o4.index] : void 0, defined: void 0 === t4.defined };
          }(void 0 !== h2 ? e4.json.materials[h2] : { defined: false }, r4), s4;
        }
        function Wx(e4, r4, n3) {
          const { matrix: i3, rotation: s4, translation: a3, scale: o3, mesh: l3, extras: u3, children: c3 } = e4, h2 = {};
          if (h2.matrix = i3 || t2.a9.fromRotationTranslationScale([], s4 || [0, 0, 0, 1], a3 || [0, 0, 0], o3 || [1, 1, 1]), void 0 !== l3) {
            h2.meshes = n3[l3];
            const t3 = h2.anchor = [0, 0];
            for (const e5 of h2.meshes) {
              const { min: r5, max: n4 } = e5.aabb;
              t3[0] += r5[0] + n4[0], t3[1] += r5[1] + n4[1];
            }
            t3[0] = Math.floor(t3[0] / h2.meshes.length / 2), t3[1] = Math.floor(t3[1] / h2.meshes.length / 2);
          }
          if (u3 && (u3.id && (h2.id = u3.id), u3.lights && (h2.lights = function(t3) {
            if (!t3.length)
              return [];
            const e5 = function(t4) {
              const e6 = atob(t4), r6 = new Uint8Array(e6.length);
              for (let t5 = 0; t5 < e6.length; t5++)
                r6[t5] = e6.codePointAt(t5);
              return r6;
            }(t3), r5 = [], n4 = e5.length / 24, i4 = new Uint16Array(e5.buffer), s5 = new Float32Array(e5.buffer);
            for (let t4 = 0; t4 < n4; t4++) {
              const e6 = i4[2 * t4 * 6] / 30, n5 = i4[2 * t4 * 6 + 1] / 30, a4 = i4[2 * t4 * 6 + 10] / 100, o4 = s5[6 * t4 + 1], l4 = s5[6 * t4 + 2], u4 = s5[6 * t4 + 3], c4 = s5[6 * t4 + 4], h3 = u4 - o4, p3 = c4 - l4, f2 = Math.hypot(h3, p3);
              r5.push({ pos: [o4 + 0.5 * h3, l4 + 0.5 * p3, n5], normal: [p3 / f2, -h3 / f2, 0], width: f2, height: e6, depth: a4, points: [o4, l4, u4, c4] });
            }
            return r5;
          }(u3.lights))), c3) {
            const t3 = [];
            for (const e5 of c3)
              t3.push(Wx(r4.json.nodes[e5], r4, n3));
            h2.children = t3;
          }
          return h2;
        }
        function Hx(t3) {
          if (0 === t3.vertices.length || 0 === t3.indices.length)
            return null;
          const e4 = new Qx(t3.vertices, t3.indices, 8, 256), [r4, n3] = [e4.min.clone(), e4.max.clone()];
          return { vertices: t3.vertices, indices: t3.indices, grid: e4, min: r4, max: n3 };
        }
        function Jx(t3) {
          if (!t3.extras || !t3.extras.ground)
            return null;
          const e4 = t3.extras.ground;
          if (!e4 || !Array.isArray(e4) || 0 === e4.length)
            return null;
          const r4 = e4[0];
          if (!r4 || !Array.isArray(r4) || 0 === r4.length)
            return null;
          const n3 = [];
          for (const t4 of r4) {
            if (!Array.isArray(t4) || 2 !== t4.length)
              continue;
            const e5 = t4[0], r5 = t4[1];
            "number" == typeof e5 && "number" == typeof r5 && n3.push(new Ue(e5, r5));
          }
          if (n3.length < 3)
            return null;
          n3.length > 1 && n3[n3.length - 1].equals(n3[0]) && n3.pop();
          let i3 = 0;
          for (let t4 = 0; t4 < n3.length; t4++) {
            const e5 = n3[t4], r5 = n3[(t4 + 1) % n3.length], s5 = n3[(t4 + 2) % n3.length];
            i3 += (e5.x - r5.x) * (s5.y - r5.y) - (s5.x - r5.x) * (e5.y - r5.y);
          }
          i3 > 0 && n3.reverse();
          const s4 = Op(n3.flatMap((t4) => [t4.x, t4.y]), []);
          return 0 === s4.length ? null : { vertices: n3, indices: s4 };
        }
        function tb(e4, r4) {
          const n3 = [], i3 = [];
          let s4 = 0;
          const a3 = [];
          for (const o3 of e4) {
            s4 = n3.length;
            const e5 = o3.vertexArray.float32, l3 = o3.indexArray.uint16;
            for (let i4 = 0; i4 < o3.vertexArray.length; i4++)
              a3[0] = e5[3 * i4 + 0], a3[1] = e5[3 * i4 + 1], a3[2] = e5[3 * i4 + 2], t2.Q.transformMat4(a3, a3, r4), n3.push(new Ue(a3[0], a3[1]));
            for (let t3 = 0; t3 < 3 * o3.indexArray.length; t3++)
              i3.push(l3[t3] + s4);
          }
          if (i3.length % 3 != 0)
            return null;
          for (let t3 = 0; t3 < i3.length; t3 += 3) {
            const e5 = n3[i3[t3 + 0]], r5 = n3[i3[t3 + 1]], s5 = n3[i3[t3 + 2]];
            (e5.x - r5.x) * (s5.y - r5.y) - (s5.x - r5.x) * (e5.y - r5.y) > 0 && ([i3[t3 + 1], i3[t3 + 2]] = [i3[t3 + 2], i3[t3 + 1]]);
          }
          return { vertices: n3, indices: i3 };
        }
        function eb(t3) {
          const e4 = function(t4, e5) {
            const r5 = [], n4 = WebGL2RenderingContext;
            if (t4.json.textures)
              for (const i4 of t4.json.textures) {
                const s5 = { magFilter: n4.LINEAR, minFilter: n4.NEAREST, wrapS: n4.REPEAT, wrapT: n4.REPEAT };
                void 0 !== i4.sampler && Object.assign(s5, t4.json.samplers[i4.sampler]), r5.push({ image: e5[i4.source], sampler: s5, uploaded: false });
              }
            return r5;
          }(t3, t3.images), r4 = function(t4, e5) {
            const r5 = [];
            for (const n4 of t4.json.meshes) {
              const i4 = [];
              for (const r6 of n4.primitives)
                i4.push(Kx(r6, t4, e5));
              r5.push(i4);
            }
            return r5;
          }(t3, e4), { scenes: n3, scene: i3, nodes: s4 } = t3.json, a3 = n3 ? n3[i3 || 0].nodes : s4, o3 = [];
          for (const e5 of a3)
            o3.push(Wx(s4[e5], t3, r4));
          return function(t4, e5, r5) {
            const n4 = {}, i4 = /* @__PURE__ */ new Set();
            for (let s5 = 0; s5 < t4.length; s5++) {
              const t5 = r5[e5[s5]];
              if (!t5.extras)
                continue;
              const a4 = t5.extras["mapbox:footprint:version"], o4 = t5.extras["mapbox:footprint:id"];
              (a4 || o4) && i4.add(s5), "1.0.0" === a4 && o4 && (n4[o4] = s5);
            }
            for (let s5 = 0; s5 < t4.length; s5++) {
              if (i4.has(s5))
                continue;
              const a4 = t4[s5], o4 = r5[e5[s5]];
              if (!o4.extras)
                continue;
              let l3 = null;
              a4.id in n4 && (l3 = tb(t4[n4[a4.id]].meshes, a4.matrix)), l3 || (l3 = Jx(o4)), l3 && (a4.footprint = Hx(l3));
            }
            if (i4.size > 0) {
              const e6 = Array.from(i4.values()).sort((t5, e7) => t5 - e7);
              for (let r6 = e6.length - 1; r6 >= 0; r6--)
                t4.splice(e6[r6], 1);
            }
          }(o3, a3, t3.json.nodes), o3;
        }
        function rb(t3) {
          t3.heightmap = new Float32Array(4096), t3.heightmap.fill(-1);
          const e4 = t3.vertexArray.float32, r4 = t3.aabb.min[0] - 1, n3 = t3.aabb.min[1] - 1, i3 = sx / (t3.aabb.max[0] - r4 + 2), s4 = sx / (t3.aabb.max[1] - n3 + 2);
          for (let a3 = 0; a3 < e4.length; a3 += 3) {
            const o3 = e4[a3 + 2], l3 = (e4[a3 + 0] - r4) * i3 | 0, u3 = (e4[a3 + 1] - n3) * s4 | 0;
            o3 > t3.heightmap[u3 * sx + l3] && (t3.heightmap[u3 * sx + l3] = o3);
          }
        }
        function nb(e4, r4) {
          const n3 = {};
          n3.indexArray = new ql(), n3.indexArray.reserve(4 * e4.length), n3.vertexArray = new Wl(), n3.vertexArray.reserve(10 * e4.length), n3.colorArray = new zl(), n3.vertexArray.reserve(10 * e4.length);
          let i3 = 0;
          for (const s5 of e4) {
            const e5 = Math.min(10, Math.max(4, 1.3 * s5.height)) * r4, a4 = [-s5.normal[1], s5.normal[0], 0], o3 = Math.min(0.29, 0.1 * s5.width / s5.depth), l3 = s5.width - 2 * s5.depth * r4 * (o3 + 0.01), u3 = t2.Q.scaleAndAdd([], s5.pos, a4, l3 / 2), c3 = t2.Q.scaleAndAdd([], s5.pos, a4, -l3 / 2), h2 = [u3[0], u3[1], u3[2] + s5.height], p3 = [c3[0], c3[1], c3[2] + s5.height], f2 = t2.Q.scaleAndAdd([], s5.normal, a4, o3);
            t2.Q.scale(f2, f2, e5);
            const d2 = t2.Q.scaleAndAdd([], s5.normal, a4, -o3);
            t2.Q.scale(d2, d2, e5), t2.Q.add(f2, u3, f2), t2.Q.add(d2, c3, d2), u3[2] += 0.1, c3[2] += 0.1, n3.vertexArray.emplaceBack(f2[0], f2[1], f2[2]), n3.vertexArray.emplaceBack(d2[0], d2[1], d2[2]), n3.vertexArray.emplaceBack(u3[0], u3[1], u3[2]), n3.vertexArray.emplaceBack(c3[0], c3[1], c3[2]), n3.vertexArray.emplaceBack(h2[0], h2[1], h2[2]), n3.vertexArray.emplaceBack(p3[0], p3[1], p3[2]), n3.vertexArray.emplaceBack(u3[0], u3[1], u3[2]), n3.vertexArray.emplaceBack(c3[0], c3[1], c3[2]), n3.vertexArray.emplaceBack(f2[0], f2[1], f2[2]), n3.vertexArray.emplaceBack(d2[0], d2[1], d2[2]);
            const m2 = l3 / e5 / 2;
            n3.colorArray.emplaceBack(-m2 - o3, -1, m2, 0.8), n3.colorArray.emplaceBack(m2 + o3, -1, m2, 0.8), n3.colorArray.emplaceBack(-m2, 0, m2, 1.3), n3.colorArray.emplaceBack(m2, 0, m2, 1.3), n3.colorArray.emplaceBack(m2 + o3, -0.8, m2, 0.7), n3.colorArray.emplaceBack(m2 + o3, -0.8, m2, 0.7), n3.colorArray.emplaceBack(0, 0, m2, 1.3), n3.colorArray.emplaceBack(0, 0, m2, 1.3), n3.colorArray.emplaceBack(m2 + o3, -1.2, m2, 0.8), n3.colorArray.emplaceBack(m2 + o3, -1.2, m2, 0.8), n3.indexArray.emplaceBack(6 + i3, 4 + i3, 8 + i3), n3.indexArray.emplaceBack(7 + i3, 9 + i3, 5 + i3), n3.indexArray.emplaceBack(0 + i3, 1 + i3, 2 + i3), n3.indexArray.emplaceBack(1 + i3, 3 + i3, 2 + i3), i3 += 10;
          }
          const s4 = { defined: true, emissiveFactor: [0, 0, 0] }, a3 = {};
          return a3.baseColorFactor = jn.white, s4.pbrMetallicRoughness = a3, n3.material = s4, n3.aabb = new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), n3;
        }
        fo(Qx, "TriangleGridIndex");
        class ib {
          constructor(t3) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e4 = 0; e4 < t3.length; e4++) {
              const r4 = t3[e4];
              this._stringToNumber[r4] = e4, this._numberToString[e4] = r4;
            }
          }
          encode(t3) {
            return this._stringToNumber[t3];
          }
          decode(t3) {
            return this._numberToString[t3];
          }
        }
        const sb = ["tile", "layer", "source", "sourceLayer", "state"];
        class ab {
          constructor(t3, e4, r4, n3, i3) {
            this.type = "Feature", this._vectorTileFeature = t3, this._z = e4, this._x = r4, this._y = n3, this.properties = t3.properties, this.id = i3;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(t3) {
            this._geometry = t3;
          }
          toJSON() {
            const t3 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            void 0 !== this.id && (t3.id = this.id);
            for (const e4 of sb)
              void 0 !== this[e4] && (t3[e4] = this[e4]);
            return t3;
          }
        }
        class ob {
          constructor(t3, e4) {
            this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new ho(is, 16, 0), this.featureIndexArray = new hu(), this.promoteId = e4, this.is3DTile = false;
          }
          insert(t3, e4, r4, n3, i3, s4 = 0, a3 = 0) {
            const o3 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r4, n3, i3, s4);
            const l3 = this.grid;
            for (let t4 = 0; t4 < e4.length; t4++) {
              const r5 = e4[t4], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t5 = 0; t5 < r5.length; t5++) {
                const e5 = r5[t5];
                n4[0] = Math.min(n4[0], e5.x), n4[1] = Math.min(n4[1], e5.y), n4[2] = Math.max(n4[2], e5.x), n4[3] = Math.max(n4[3], e5.y);
              }
              0 !== a3 && (n4[0] -= a3, n4[1] -= a3, n4[2] += a3, n4[3] += a3), n4[0] < is && n4[1] < is && n4[2] >= 0 && n4[3] >= 0 && l3.insert(o3, n4[0], n4[1], n4[2], n4[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new pf(new wm(this.rawTileData)).layers, this.sourceLayerCoder = new ib(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const t3 in this.vtLayers)
                this.vtFeatures[t3] = [];
            }
            return this.vtLayers;
          }
          query(t3, e4, r4, n3) {
            this.loadVTLayers();
            const i3 = t3.params || {}, s4 = nl(i3.filter), a3 = t3.tileResult, o3 = t3.transform, l3 = a3.bufferedTilespaceBounds, u3 = this.grid.query(l3.min.x, l3.min.y, l3.max.x, l3.max.y, (t4, e5, r5, n4) => Hc(a3.bufferedTilespaceGeometry, t4, e5, r5, n4));
            u3.sort(ub);
            let c3 = null;
            o3.elevation && u3.length > 0 && (c3 = Rf.create(o3.elevation, this.tileID));
            const h2 = {};
            let p3;
            for (let l4 = 0; l4 < u3.length; l4++) {
              const f2 = u3[l4];
              if (f2 === p3)
                continue;
              p3 = f2;
              const d2 = this.featureIndexArray.get(f2);
              let m2 = null;
              if (this.is3DTile) {
                const t4 = this.bucketLayerIDs[0][0], r5 = e4[t4];
                if ("model" !== r5.type)
                  continue;
                const { queryFeature: n4, intersectionZ: i4 } = r5.queryIntersectsMatchingFeature(a3, d2.featureIndex, s4, o3);
                n4 && this.appendToResult(h2, t4, d2.featureIndex, n4, i4);
              } else
                this.loadMatchingFeature(h2, d2, s4, i3.layers, i3.availableImages, e4, r4, n3, (e5, r5, n4, i4 = 0) => (m2 || (m2 = Lc(e5, this.tileID.canonical, t3.tileTransform)), r5.queryIntersectsFeature(a3, e5, n4, m2, this.z, t3.transform, t3.pixelPosMatrix, c3, i4)));
            }
            return h2;
          }
          loadMatchingFeature(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
            const { featureIndex: u3, bucketIndex: c3, sourceLayerIndex: h2, layoutVertexArrayOffset: p3 } = e4, f2 = this.bucketLayerIDs[c3];
            if (n3 && !function(t4, e5) {
              for (let r5 = 0; r5 < t4.length; r5++)
                if (e5.indexOf(t4[r5]) >= 0)
                  return true;
              return false;
            }(n3, f2))
              return;
            const d2 = this.sourceLayerCoder.decode(h2), m2 = this.vtLayers[d2].feature(u3);
            if (r4.needGeometry) {
              const t4 = Fc(m2, true);
              if (!r4.filter(new Uo(this.tileID.overscaledZ), t4, this.tileID.canonical))
                return;
            } else if (!r4.filter(new Uo(this.tileID.overscaledZ), m2))
              return;
            const y3 = this.getId(m2, d2);
            for (let e5 = 0; e5 < f2.length; e5++) {
              const r5 = f2[e5];
              if (n3 && n3.indexOf(r5) < 0)
                continue;
              const c4 = s4[r5];
              if (!c4)
                continue;
              let h3 = {};
              void 0 !== y3 && o3 && (h3 = o3.getState(c4.sourceLayer || "_geojsonTileLayer", y3));
              const d3 = !l3 || l3(m2, c4, h3, p3);
              if (!d3)
                continue;
              const g3 = new ab(m2, this.z, this.x, this.y, y3), x3 = Je({}, a3[r5]);
              x3.paint = lb(x3.paint, c4.paint, m2, h3, i3), x3.layout = lb(x3.layout, c4.layout, m2, h3, i3), g3.layer = x3, this.appendToResult(t3, r5, u3, g3, d3);
            }
          }
          appendToResult(t3, e4, r4, n3, i3) {
            let s4 = t3[e4];
            void 0 === s4 && (s4 = t3[e4] = []), s4.push({ featureIndex: r4, feature: n3, intersectionZ: i3 });
          }
          lookupSymbolFeatures(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = {};
            this.loadVTLayers();
            const u3 = nl(i3);
            for (const i4 of t3)
              this.loadMatchingFeature(l3, { bucketIndex: r4, sourceLayerIndex: n3, featureIndex: i4, layoutVertexArrayOffset: 0 }, u3, s4, a3, o3, e4);
            return l3;
          }
          loadFeature(t3) {
            const { featureIndex: e4, sourceLayerIndex: r4 } = t3;
            this.loadVTLayers();
            const n3 = this.sourceLayerCoder.decode(r4), i3 = this.vtFeatures[n3];
            if (i3[e4])
              return i3[e4];
            const s4 = this.vtLayers[n3].feature(e4);
            return i3[e4] = s4, s4;
          }
          hasLayer(t3) {
            for (const e4 of this.bucketLayerIDs)
              for (const r4 of e4)
                if (t3 === r4)
                  return true;
            return false;
          }
          getId(t3, e4) {
            let r4 = t3.id;
            if (this.promoteId) {
              const n3 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e4];
              null != n3 && (r4 = t3.properties[n3]), "boolean" == typeof r4 && (r4 = Number(r4));
            }
            return r4;
          }
        }
        function lb(t3, e4, r4, n3, i3) {
          return or(t3, (t4, s4) => {
            const a3 = e4 instanceof Xo ? e4.get(s4) : null;
            return a3 && a3.evaluate ? a3.evaluate(r4, n3, i3) : a3;
          });
        }
        function ub(t3, e4) {
          return e4 - t3;
        }
        fo(ob, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        const cb = new Float32Array(262144), hb = new Uint8Array(262144);
        function pb(t3) {
          let e4 = 0;
          if (t3.meshes)
            for (const r4 of t3.meshes)
              e4 = Math.max(e4, r4.aabb.max[2]);
          if (t3.children)
            for (const r4 of t3.children)
              e4 = Math.max(e4, pb(r4));
          return e4;
        }
        function fb(t3, e4, r4) {
          if (t3.meshes)
            for (const n3 of t3.meshes)
              n3.aabb.min[0] !== 1 / 0 && r4.insert(e4, n3.aabb.min[0], n3.aabb.min[1], n3.aabb.max[0], n3.aabb.max[1]);
          if (t3.children)
            for (const n3 of t3.children)
              fb(n3, e4, r4);
        }
        const db = ["", "wall", "door", "roof", "window", "lamp", "logo"];
        class mb {
          constructor(t3) {
            this.node = t3, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.feature = { type: "Point", id: t3.id, geometry: [], properties: { height: pb(t3) } };
          }
          getLocalBounds() {
            if (!this.node.meshes)
              return new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            if (!this.aabb) {
              let t3 = 0;
              const e4 = new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
              for (const r4 of this.node.meshes)
                this.node.lightMeshIndex !== t3 && e4.encapsulate(r4.aabb), t3++;
              this.aabb = mh.applyTransform(e4, this.node.matrix);
            }
            return this.aabb;
          }
        }
        class yb {
          constructor(t3, e4, r4, n3, i3, s4) {
            this.id = e4, this.modelTraits |= ax.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, r4 && (this.modelTraits |= ax.HasMapboxMeshFeatures), n3 && (this.modelTraits |= ax.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = i3, this.dirty = true, this.needsUpload = false, this.nodesInfo = [];
            for (const e5 of t3)
              this.nodesInfo.push(new mb(e5)), fb(e5, s4.featureIndexArray.length, s4.grid), s4.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, s4.bucketLayerIDs.length - 1, 0);
          }
          update() {
            console.log("Update 3D model bucket");
          }
          populate() {
            console.log("populate 3D model bucket");
          }
          uploadPending() {
            return !this.uploaded || this.needsUpload;
          }
          upload(t3) {
            if (!this.needsUpload)
              return;
            const e4 = this.getNodesInfo();
            for (const r4 of e4) {
              const e5 = r4.node;
              this.uploaded ? this.updatePbrBuffer(e5) : cx(e5, t3, true);
            }
            for (const t4 of e4)
              hx(t4.node);
            this.uploaded = true, this.needsUpload = false;
          }
          updatePbrBuffer(t3) {
            let e4 = false;
            if (!t3.meshes)
              return e4;
            for (const r4 of t3.meshes)
              r4.pbrBuffer && (r4.pbrBuffer.updateData(r4.featureArray), e4 = true);
            return e4;
          }
          needsReEvaluation(t3, e4, r4) {
            const n3 = t3.transform.projectionOptions, i3 = t3.style.getBrightness(), s4 = this.brightness !== i3;
            return !!(!this.uploaded || this.dirty || n3.name !== this.projection.name || gb(r4.paint.get("model-color").value, s4) || gb(r4.paint.get("model-color-mix-intensity").value, s4) || gb(r4.paint.get("model-roughness").value, s4) || gb(r4.paint.get("model-emissive-strength").value, s4) || gb(r4.paint.get("model-height-based-emissive-strength-multiplier").value, s4)) && (this.projection = n3, this.brightness = i3, true);
          }
          evaluateScale(t3, e4) {
            if (t3.transform.zoom === this.zoom)
              return;
            this.zoom = t3.transform.zoom;
            const r4 = this.getNodesInfo(), n3 = this.id.canonical;
            for (const t4 of r4) {
              const r5 = t4.feature;
              t4.evaluatedScale = e4.paint.get("model-scale").evaluate(r5, {}, n3);
            }
          }
          evaluate(t3) {
            const e4 = this.getNodesInfo();
            for (const r4 of e4) {
              if (!r4.node.meshes)
                continue;
              const e5 = r4.feature, n3 = r4.node.meshes && r4.node.meshes[0].featureData, i3 = r4.evaluatedColor[2], s4 = r4.evaluatedRMEA[2], a3 = this.id.canonical;
              if (r4.hasTranslucentParts = false, n3) {
                for (let n4 = 0; n4 < db.length; n4++) {
                  const i4 = db[n4];
                  i4.length && (e5.properties.part = i4);
                  const s5 = t3.paint.get("model-color").evaluate(e5, {}, a3), o3 = t3.paint.get("model-color-mix-intensity").evaluate(e5, {}, a3);
                  r4.evaluatedColor[n4] = [s5.r, s5.g, s5.b, o3], r4.evaluatedRMEA[n4][0] = t3.paint.get("model-roughness").evaluate(e5, {}, a3), r4.evaluatedRMEA[n4][2] = t3.paint.get("model-emissive-strength").evaluate(e5, {}, a3), r4.evaluatedRMEA[n4][3] = s5.a, r4.emissionHeightBasedParams[n4] = t3.paint.get("model-height-based-emissive-strength-multiplier").evaluate(e5, {}, a3), !r4.hasTranslucentParts && s5.a < 1 && (r4.hasTranslucentParts = true);
                }
                delete e5.properties.part, bb(r4, i3 !== r4.evaluatedColor[2] || s4 !== r4.evaluatedRMEA[2], this.modelTraits);
              } else
                r4.evaluatedRMEA[0][2] = t3.paint.get("model-emissive-strength").evaluate(e5, {}, a3);
              r4.evaluatedScale = t3.paint.get("model-scale").evaluate(e5, {}, a3), this.updatePbrBuffer(r4.node) || (this.needsUpload = true);
            }
            this.dirty = false;
          }
          elevationUpdate(t3, e4, r4, n3) {
            const i3 = t3.findDEMTileFor(r4);
            if (i3 && (i3.tileID.canonical !== this.terrainTile || e4 !== this.terrainExaggeration)) {
              if (i3.dem && i3.tileID.overscaledZ !== this.elevationReadFromZ) {
                this.elevationReadFromZ = i3.tileID.overscaledZ;
                const e5 = Rf.create(t3, r4, i3);
                if (!e5)
                  return;
                this.modelTraits & ax.HasMapboxMeshFeatures && this.updateDEM(t3, e5, r4, n3);
                for (const t4 of this.getNodesInfo()) {
                  const r5 = t4.node;
                  if (!r5.footprint || !r5.footprint.vertices || !r5.footprint.vertices.length)
                    continue;
                  const n4 = r5.footprint.vertices;
                  let i4 = e5.getElevationAt(n4[0].x, n4[0].y, true, true);
                  for (let t5 = 1; t5 < n4.length; t5++)
                    i4 = Math.min(i4, e5.getElevationAt(n4[t5].x, n4[t5].y, true, true));
                  r5.elevation = i4;
                }
              }
              this.terrainTile = i3.tileID.canonical, this.terrainExaggeration = e4;
            }
          }
          updateDEM(t3, e4, r4, n3) {
            let i3 = e4._dem._modifiedForSources[n3];
            if (void 0 === i3 && (e4._dem._modifiedForSources[n3] = [], i3 = e4._dem._modifiedForSources[n3]), i3.includes(r4.canonical))
              return;
            const s4 = e4._dem.dim;
            i3.push(r4.canonical);
            let a3 = false;
            for (const t4 of this.getNodesInfo()) {
              const r5 = t4.node;
              if (!r5.footprint || !r5.footprint.grid)
                continue;
              const n4 = r5.footprint.grid, i4 = e4.tileCoordToPixel(n4.min.x, n4.min.y), o3 = e4.tileCoordToPixel(n4.max.x, n4.max.y), l3 = Math.min(Math.min(s4 - o3.y, i4.x), Math.min(i4.y, s4 - o3.x));
              if (l3 < 0)
                continue;
              const u3 = Ze(l3, 2, 5);
              let c3 = Math.max(0, i4.x - u3), h2 = Math.max(0, i4.y - u3), p3 = Math.min(o3.x + u3, s4 - 1), f2 = Math.min(o3.y + u3, s4 - 1);
              for (let t5 = h2; t5 <= f2; ++t5)
                for (let e5 = c3; e5 <= p3; ++e5)
                  hb[t5 * s4 + e5] = 255;
              let d2 = 0, m2 = 0;
              for (let t5 = 0; t5 < n4.cellsY; ++t5)
                for (let r6 = 0; r6 < n4.cellsX; ++r6) {
                  if (!n4.cells[t5 * n4.cellsX + r6])
                    continue;
                  const i5 = e4.tileCoordToPixel(n4.min.x + r6 / n4.xScale, n4.min.y + t5 / n4.yScale), a4 = e4.tileCoordToPixel(n4.min.x + (r6 + 1) / n4.xScale, n4.min.y + (t5 + 1) / n4.yScale);
                  for (let t6 = i5.y; t6 <= Math.min(a4.y + 1, s4 - 1); ++t6)
                    for (let r7 = i5.x; r7 <= Math.min(a4.x + 1, s4 - 1); ++r7)
                      255 === hb[t6 * s4 + r7] && (hb[t6 * s4 + r7] = 0, d2 += e4.getElevationAtPixel(r7, t6), m2++);
                }
              const y3 = d2 / m2;
              c3 = Math.max(1, i4.x - u3), h2 = Math.max(1, i4.y - u3), p3 = Math.min(o3.x + u3, s4 - 2), f2 = Math.min(o3.y + u3, s4 - 2), a3 = true;
              for (let t5 = h2; t5 <= f2; ++t5)
                for (let r6 = c3; r6 <= p3; ++r6)
                  0 === hb[t5 * s4 + r6] && (cb[t5 * s4 + r6] = e4._dem.set(r6, t5, y3));
              for (let t5 = 1; t5 < u3; ++t5) {
                c3 = Math.max(1, i4.x - t5), h2 = Math.max(1, i4.y - t5), p3 = Math.min(o3.x + t5, s4 - 2), f2 = Math.min(o3.y + t5, s4 - 2);
                for (let r6 = h2; r6 <= f2; ++r6)
                  for (let n5 = c3; n5 <= p3; ++n5) {
                    const i5 = r6 * s4 + n5;
                    if (255 === hb[i5]) {
                      let a4 = 0, o4 = 0, l4 = -1, c4 = -1;
                      for (let e5 = -1; e5 <= 1; ++e5)
                        for (let i6 = -1; i6 <= 1; ++i6) {
                          const u4 = (r6 + e5) * s4 + n5 + i6;
                          if (hb[u4] >= t5)
                            continue;
                          const h3 = cb[u4], p4 = Math.abs(h3);
                          p4 > o4 && (a4 = h3, o4 = p4, l4 = i6, c4 = e5);
                        }
                      if (o4 > 0.1) {
                        const s5 = 1 - (t5 + 0.5 * Math.abs(l4 * c4)) / u3;
                        let o5 = e4._dem.get(n5, r6) + a4 * s5;
                        const h3 = e4._dem.get(n5 + l4, r6 + c4), p4 = e4._dem.get(n5 - l4, r6 - c4, true);
                        (o5 - h3) * (o5 - p4) > 0 && (o5 = (h3 + p4) / 2), cb[i5] = e4._dem.set(n5, r6, o5), hb[i5] = t5;
                      }
                    }
                  }
              }
            }
            a3 && (e4._demTile.needsDEMTextureUpload = true, e4._dem._timestamp = Tr.now());
          }
          getNodesInfo() {
            return this.nodesInfo;
          }
          destroy() {
            const t3 = this.getNodesInfo();
            for (const e4 of t3)
              hx(e4.node), px(e4.node);
          }
          isEmpty() {
            return !this.nodesInfo.length;
          }
          updateReplacement(t3, e4) {
            if (e4.updateTime === this.replacementUpdateTime)
              return;
            this.replacementUpdateTime = e4.updateTime;
            const r4 = e4.getReplacementRegionsForTile(t3.toUnwrapped()), n3 = this.getNodesInfo();
            for (let t4 = 0; t4 < this.nodesInfo.length; t4++) {
              const e5 = n3[t4].node;
              n3[t4].hiddenByReplacement = !!e5.footprint && !r4.find((t5) => t5.footprint === e5.footprint);
            }
          }
          getHeightAtTileCoord(e4, r4) {
            const n3 = this.getNodesInfo(), i3 = [], s4 = [0, 0, 0];
            for (let a3 = 0; a3 < this.nodesInfo.length; a3++) {
              const o3 = n3[a3], l3 = o3.node.meshes[0], u3 = mh.applyTransform(l3.aabb, o3.node.matrix);
              if (e4 < u3.min[0] || r4 < u3.min[1] || e4 > u3.max[0] || r4 > u3.max[1])
                continue;
              const c3 = (e4 - l3.aabb.min[0]) / (l3.aabb.max[0] - l3.aabb.min[0]) * sx | 0, h2 = Math.min(63, (r4 - l3.aabb.min[1]) / (l3.aabb.max[1] - l3.aabb.min[1]) * sx | 0) * sx + Math.min(63, c3);
              if (s4[2] = l3.heightmap[h2], t2.Q.transformMat4(s4, s4, o3.node.matrix), !(l3.heightmap[h2] < 0 && o3.node.footprint)) {
                if (o3.hiddenByReplacement)
                  return;
                return { height: s4[2], maxHeight: o3.feature.properties.height, hidden: false, verticalScale: o3.evaluatedScale[2] };
              }
              if (o3.node.footprint.grid.query(new Ue(e4, r4), new Ue(e4, r4), i3), i3.length > 0)
                return { height: void 0, maxHeight: o3.feature.properties.height, hidden: o3.hiddenByReplacement, verticalScale: o3.evaluatedScale[2] };
            }
          }
        }
        function gb(t3, e4) {
          return !t3.isLightConstant && e4;
        }
        function xb(t3, e4, r4, n3, i3, s4, a3, o3) {
          let l3 = (61440 & e4 | (61440 & e4) >> 4) >> 8, u3 = (3840 & e4 | (3840 & e4) >> 4) >> 4, c3 = 240 & e4 | (240 & e4) >> 4;
          r4[3] > 0 && (l3 = qn(l3, 255 * r4[0], r4[3]), u3 = qn(u3, 255 * r4[1], r4[3]), c3 = qn(c3, 255 * r4[2], r4[3]));
          const h2 = l3 << 8 | u3, p3 = c3 << 8 | Math.floor(255 * n3[3]), f2 = function(t4) {
            const e5 = Ze(t4, 0, 2);
            return Math.min(Math.round(0.5 * e5 * 255), 255);
          }(n3[2]) << 8 | 15 * n3[0] << 4 | 15 * n3[1], d2 = Ze(i3[0], 0, 1), m2 = Ze(i3[1], 0, 1), y3 = Ze(i3[2], 0, 1), g3 = Ze(i3[3], 0, 1);
          let x3, b2, v3, _3;
          if (d2 !== m2 && a3 !== s4 && m2 !== d2) {
            const t4 = a3 - s4;
            b2 = 1 / (t4 * (m2 - d2)), v3 = -(s4 + t4 * d2) / (t4 * (m2 - d2));
            const e5 = Ze(i3[4], -1, 1);
            _3 = Math.pow(10, e5), x3 = 255 * y3 << 8 | 255 * g3;
          } else
            x3 = 65535, b2 = 0, v3 = 1, _3 = 1;
          if (t3.emplaceBack(h2, p3, f2, x3, b2, v3, _3), o3) {
            const t4 = o3.length;
            o3.clear();
            for (let e5 = 0; e5 < t4; e5++)
              o3.emplaceBack(h2, p3, f2, x3, b2, v3, _3);
          }
        }
        function bb(t3, e4, r4) {
          const n3 = t3.node;
          let i3 = 0;
          const s4 = r4 & ax.HasMeshoptCompression;
          for (const r5 of n3.meshes) {
            if (n3.lights && n3.lightMeshIndex === i3)
              continue;
            if (!r5.featureData)
              continue;
            r5.featureArray = new Jl(), r5.featureArray.reserve(r5.featureData.length);
            let a3 = e4;
            for (const e5 of r5.featureData) {
              const i4 = s4 ? 65535 & e5 : e5 >> 16 & 65535, o3 = s4 ? e5 >> 16 & 65535 : 65535 & e5, l3 = (15 & o3) < 8 ? 15 & o3 : 0, u3 = t3.evaluatedRMEA[l3], c3 = t3.evaluatedColor[l3], h2 = t3.emissionHeightBasedParams[l3];
              let p3;
              if (a3 && 2 === l3 && n3.lights && (p3 = new Jl(), p3.resize(10 * n3.lights.length)), xb(r5.featureArray, i4, c3, u3, h2, r5.aabb.min[2], r5.aabb.max[2], p3), p3 && a3) {
                a3 = false;
                const t4 = n3.meshes[n3.lightMeshIndex];
                t4.featureArray = p3, t4.featureArray._trim();
              }
            }
            r5.featureArray._trim(), i3++;
          }
        }
        function vb(t3, e4, r4, n3) {
          const i3 = 1 << t3.z;
          e4.lat = wc((n3 / is + t3.y) / i3), e4.lng = _c((r4 / is + t3.x) / i3);
        }
        fo(yb, "Tiled3dModelBucket", { omit: ["layers"] }), fo(mb, "Tiled3dModelFeature");
        const _b = { circle: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, oh, e4, r4);
          }
          createBucket(t3) {
            return new Nc(t3);
          }
          queryRadius(t3) {
            const e4 = t3;
            return rh("circle-radius", this, e4) + rh("circle-stroke-width", this, e4) + nh(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = sh(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s4.angle, t3.pixelToTileUnitsFactor), u3 = this.paint.get("circle-radius").evaluate(e4, r4) + this.paint.get("circle-stroke-width").evaluate(e4, r4);
            return Yh(t3, n3, s4, a3, o3, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l3, u3);
          }
          getProgramIds() {
            return ["circle"];
          }
          getDefaultProgramParams(t3, e4) {
            const r4 = Qh(this);
            return { config: new Nu(this, e4), defines: r4, overrideFog: false };
          }
        }, heatmap: class extends bl {
          createBucket(t3) {
            return new Hh(t3);
          }
          constructor(t3, e4, r4) {
            super(t3, ap, e4, r4), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "heatmap-color" === t3 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = op({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(t3) {
            return rh("heatmap-radius", this, t3);
          }
          queryIntersectsFeature(t3, e4, r4, n3, i3, s4, a3, o3) {
            const l3 = this.paint.get("heatmap-radius").evaluate(e4, r4);
            return Yh(t3, n3, s4, a3, o3, true, true, new Ue(0, 0), l3);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getDefaultProgramParams(t3, e4) {
            return "heatmap" === t3 ? { config: new Nu(this, e4), overrideFog: false } : {};
          }
        }, hillshade: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, up, e4, r4);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
          getDefaultProgramParams(t3, e4) {
            return { overrideFog: false };
          }
        }, fill: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, Qp, e4, r4);
          }
          getProgramIds() {
            const t3 = this.paint.get("fill-pattern"), e4 = t3 && t3.constantOr(1), r4 = [e4 ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r4.push(e4 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r4;
          }
          getDefaultProgramParams(t3, e4) {
            return { config: new Nu(this, e4), overrideFog: false };
          }
          recalculate(t3, e4) {
            super.recalculate(t3, e4);
            const r4 = this.paint._values["fill-outline-color"];
            "constant" === r4.value.kind && void 0 === r4.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t3) {
            return new $p(t3);
          }
          queryRadius() {
            return nh(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t3, e4, r4, n3, i3, s4) {
            return !t3.queryGeometry.isAboveHorizon && $c(ih(t3.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s4.angle, t3.pixelToTileUnitsFactor), n3);
          }
          isTileClipped() {
            return true;
          }
        }, "fill-extrusion": class extends bl {
          constructor(t3, e4, r4) {
            super(t3, cd, e4, r4), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(t3) {
            return new Hf(t3);
          }
          queryRadius() {
            return nh(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          hasShadowPass() {
            return true;
          }
          cutoffRange() {
            return this.paint.get("fill-extrusion-cutoff-fade-range");
          }
          canCastShadows() {
            return true;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          queryIntersectsFeature(e4, r4, n3, i3, s4, a3, o3, l3, u3) {
            const c3 = sh(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a3.angle, e4.pixelToTileUnitsFactor), h2 = this.paint.get("fill-extrusion-height").evaluate(r4, n3), p3 = this.paint.get("fill-extrusion-base").evaluate(r4, n3), f2 = [0, 0], d2 = l3 && a3.elevation, m2 = a3.elevation ? a3.elevation.exaggeration() : 1, y3 = e4.tile.getBucket(this);
            if (d2 && y3 instanceof Hf) {
              const t3 = y3.centroidVertexArray, e5 = u3 + 1;
              e5 < t3.length && (f2[0] = t3.geta_centroid_pos0(e5), f2[1] = t3.geta_centroid_pos1(e5));
            }
            if (0 === f2[0] && 1 === f2[1])
              return false;
            "globe" === a3.projection.name && (i3 = od([i3], [new Ue(0, 0), new Ue(is, is)], e4.tileID.canonical).map((t3) => t3.polygon).flat());
            const g3 = d2 ? l3 : null, [x3, b2] = function(e5, r5, n4, i4, s5, a4, o4, l4, u4, c4, h3) {
              return "globe" === e5.projection.name ? function(e6, r6, n5, i5, s6, a5, o5, l5, u5, c5, h4) {
                const p4 = [], f3 = [], d3 = e6.projection.upVectorScale(h4, e6.center.lat, e6.worldSize).metersToTile, m3 = [0, 0, 0, 1], y4 = [0, 0, 0, 1], g4 = (t3, e7, r7, n6) => {
                  t3[0] = e7, t3[1] = r7, t3[2] = n6, t3[3] = 1;
                }, x4 = ad();
                n5 > 0 && (n5 += x4), i5 += x4;
                for (const x5 of r6) {
                  const r7 = [], b3 = [];
                  for (const p5 of x5) {
                    const f4 = p5.x + s6.x, x6 = p5.y + s6.y, v4 = e6.projection.projectTilePoint(f4, x6, h4), _3 = e6.projection.upVector(h4, p5.x, p5.y);
                    let w2 = n5, M3 = i5;
                    if (o5) {
                      const t3 = dd(f4, x6, n5, i5, o5, l5, u5, c5);
                      w2 += t3.base, M3 += t3.top;
                    }
                    0 !== n5 ? g4(m3, v4.x + _3[0] * d3 * w2, v4.y + _3[1] * d3 * w2, v4.z + _3[2] * d3 * w2) : g4(m3, v4.x, v4.y, v4.z), g4(y4, v4.x + _3[0] * d3 * M3, v4.y + _3[1] * d3 * M3, v4.z + _3[2] * d3 * M3), t2.Q.transformMat4(m3, m3, a5), t2.Q.transformMat4(y4, y4, a5), r7.push(new hd(m3[0], m3[1], m3[2])), b3.push(new hd(y4[0], y4[1], y4[2]));
                  }
                  p4.push(r7), f3.push(b3);
                }
                return [p4, f3];
              }(e5, r5, n4, i4, s5, a4, o4, l4, u4, c4, h3) : o4 ? function(e6, r6, n5, i5, s6, a5, o5, l5, u5) {
                const c5 = [], h4 = [], p4 = [0, 0, 0, 1];
                for (const f3 of e6) {
                  const e7 = [], d3 = [];
                  for (const c6 of f3) {
                    const h5 = c6.x + i5.x, f4 = c6.y + i5.y, m3 = dd(h5, f4, r6, n5, a5, o5, l5, u5);
                    p4[0] = h5, p4[1] = f4, p4[2] = m3.base, p4[3] = 1, t2.aa.transformMat4(p4, p4, s6), p4[3] = Math.max(p4[3], 1e-5);
                    const y4 = new hd(p4[0] / p4[3], p4[1] / p4[3], p4[2] / p4[3]);
                    p4[0] = h5, p4[1] = f4, p4[2] = m3.top, p4[3] = 1, t2.aa.transformMat4(p4, p4, s6), p4[3] = Math.max(p4[3], 1e-5);
                    const g4 = new hd(p4[0] / p4[3], p4[1] / p4[3], p4[2] / p4[3]);
                    e7.push(y4), d3.push(g4);
                  }
                  c5.push(e7), h4.push(d3);
                }
                return [c5, h4];
              }(r5, n4, i4, s5, a4, o4, l4, u4, c4) : function(t3, e6, r6, n5, i5) {
                const s6 = [], a5 = [], o5 = i5[8] * e6, l5 = i5[9] * e6, u5 = i5[10] * e6, c5 = i5[11] * e6, h4 = i5[8] * r6, p4 = i5[9] * r6, f3 = i5[10] * r6, d3 = i5[11] * r6;
                for (const e7 of t3) {
                  const t4 = [], r7 = [];
                  for (const s7 of e7) {
                    const e8 = s7.x + n5.x, a6 = s7.y + n5.y, m3 = i5[0] * e8 + i5[4] * a6 + i5[12], y4 = i5[1] * e8 + i5[5] * a6 + i5[13], g4 = i5[2] * e8 + i5[6] * a6 + i5[14], x4 = i5[3] * e8 + i5[7] * a6 + i5[15], b3 = m3 + o5, v4 = y4 + l5, _3 = g4 + u5, w2 = Math.max(x4 + c5, 1e-5), M3 = m3 + h4, A2 = y4 + p4, S2 = g4 + f3, I2 = Math.max(x4 + d3, 1e-5);
                    t4.push(new hd(b3 / w2, v4 / w2, _3 / w2)), r7.push(new hd(M3 / I2, A2 / I2, S2 / I2));
                  }
                  s6.push(t4), a5.push(r7);
                }
                return [s6, a5];
              }(r5, n4, i4, s5, a4);
            }(a3, i3, p3, h2, c3, o3, g3, f2, m2, a3.center.lat, e4.tileID.canonical), v3 = e4.queryGeometry;
            return function(t3, e5, r5) {
              let n4 = 1 / 0;
              $c(r5, e5) && (n4 = fd(r5, e5[0]));
              for (let i4 = 0; i4 < e5.length; i4++) {
                const s5 = e5[i4], a4 = t3[i4];
                for (let t4 = 0; t4 < s5.length - 1; t4++) {
                  const e6 = s5[t4], i5 = [e6, s5[t4 + 1], a4[t4 + 1], a4[t4], e6];
                  jc(r5, i5) && (n4 = Math.min(n4, fd(r5, i5)));
                }
              }
              return n4 !== 1 / 0 && n4;
            }(x3, b2, v3.isPointQuery() ? v3.screenBounds : v3.screenGeometry);
          }
        }, line: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, kd, e4, r4), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            if ("line-gradient" === t3) {
              const t4 = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = t4._styleExpression && t4._styleExpression.expression instanceof Qs, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          recalculate(t3, e4) {
            super.recalculate(t3, e4), this.paint._values["line-floorwidth"] = Cd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
          }
          createBucket(t3) {
            return new Sd(t3);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getDefaultProgramParams(t3, e4) {
            const r4 = Td(this);
            return { config: new Nu(this, e4), defines: r4, overrideFog: false };
          }
          queryRadius(t3) {
            const e4 = t3, r4 = Rd(rh("line-width", this, e4), rh("line-gap-width", this, e4)), n3 = rh("line-offset", this, e4);
            return r4 / 2 + Math.abs(n3) + nh(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t3, e4, r4, n3, i3, s4) {
            if (t3.queryGeometry.isAboveHorizon)
              return false;
            const a3 = ih(t3.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s4.angle, t3.pixelToTileUnitsFactor), o3 = t3.pixelToTileUnitsFactor / 2 * Rd(this.paint.get("line-width").evaluate(e4, r4), this.paint.get("line-gap-width").evaluate(e4, r4)), l3 = this.paint.get("line-offset").evaluate(e4, r4);
            return l3 && (n3 = function(t4, e5) {
              const r5 = [], n4 = new Ue(0, 0);
              for (let i4 = 0; i4 < t4.length; i4++) {
                const s5 = t4[i4], a4 = [];
                for (let t5 = 0; t5 < s5.length; t5++) {
                  const r6 = s5[t5], i5 = s5[t5 + 1], o4 = 0 === t5 ? n4 : r6.sub(s5[t5 - 1])._unit()._perp(), l4 = t5 === s5.length - 1 ? n4 : i5.sub(r6)._unit()._perp(), u3 = o4._add(l4)._unit();
                  u3._mult(1 / (u3.x * l4.x + u3.y * l4.y)), a4.push(u3._mult(e5)._add(r6));
                }
                r5.push(a4);
              }
              return r5;
            }(n3, l3 * t3.pixelToTileUnitsFactor)), function(t4, e5, r5) {
              for (let n4 = 0; n4 < e5.length; n4++) {
                const i4 = e5[n4];
                if (t4.length >= 3) {
                  for (let e6 = 0; e6 < i4.length; e6++)
                    if (Wc(t4, i4[e6]))
                      return true;
                }
                if (Gc(t4, i4, r5))
                  return true;
              }
              return false;
            }(a3, n3, o3);
          }
          isTileClipped() {
            return true;
          }
        }, symbol: fg, background: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, mg, e4, r4);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
          getDefaultProgramParams(t3, e4) {
            return { overrideFog: false };
          }
        }, raster: Ig, "raster-particle": Eg, sky: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, Bg, e4, r4), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "sky-gradient" === t3 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t3 && "sky-atmosphere-halo-color" !== t3 && "sky-atmosphere-color" !== t3 && "sky-atmosphere-sun-intensity" !== t3 || (this._skyboxInvalidated = true);
          }
          _updateColorRamp() {
            this.colorRamp = op({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(t3) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
              return true;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e4 = t3.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e4.azimuthal || this._lightPosition.polar !== e4.polar;
            }
            return false;
          }
          getCenter(t3, e4) {
            if ("atmosphere" === this.paint.get("sky-type")) {
              const r5 = this.paint.get("sky-atmosphere-sun"), n3 = !r5, i3 = t3.style.light, s4 = i3.properties.get("position");
              return n3 && "viewport" === i3.properties.get("anchor") && hr("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n3 ? Cg(s4.azimuthal, 90 - s4.polar, e4) : Cg(r5[0], 90 - r5[1], e4);
            }
            const r4 = this.paint.get("sky-gradient-center");
            return Cg(r4[0], 90 - r4[1], e4);
          }
          isSky() {
            return true;
          }
          markSkyboxValid(t3) {
            this._skyboxInvalidated = false, this._lightPosition = t3.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return true;
          }
          getProgramIds() {
            const t3 = this.paint.get("sky-type");
            return "atmosphere" === t3 ? ["skyboxCapture", "skybox"] : "gradient" === t3 ? ["skyboxGradient"] : null;
          }
        }, slot: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, Rg, e4);
          }
        }, model: class extends bl {
          constructor(t3, e4, r4) {
            super(t3, ix, e4, r4), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(t3) {
            return new rx(t3);
          }
          getProgramIds() {
            return ["model"];
          }
          is3D() {
            return true;
          }
          hasShadowPass() {
            return true;
          }
          canCastShadows() {
            return true;
          }
          hasLightBeamPass() {
            return true;
          }
          cutoffRange() {
            return this.paint.get("model-cutoff-fade-range");
          }
          queryRadius(t3) {
            return t3 instanceof yb ? is - 1 : 0;
          }
          queryIntersectsFeature(e4, r4, n3, i3, s4, a3) {
            if (!this.modelManager)
              return false;
            const o3 = this.modelManager, l3 = e4.tile.getBucket(this);
            if (!(l3 && l3 instanceof rx))
              return false;
            const u3 = l3;
            for (const n4 in u3.instancesPerModel) {
              const i4 = u3.instancesPerModel[n4], s5 = void 0 !== r4.id ? r4.id : r4.properties && r4.properties.hasOwnProperty("id") ? r4.properties.id : void 0;
              if (i4.idToFeaturesIndex.hasOwnProperty(s5)) {
                const r5 = i4.features[i4.idToFeaturesIndex[s5]], l4 = o3.getModel(n4, this.scope);
                if (!l4)
                  return false;
                let c3 = t2.a9.create();
                const h2 = new ac(0, 0), p3 = u3.canonical;
                let f2 = Number.MAX_VALUE;
                for (let n5 = 0; n5 < r5.instancedDataCount; ++n5) {
                  const s6 = 16 * (r5.instancedDataOffset + n5), o4 = i4.instancedDataArray.float32, u4 = [o4[s6 + 4], o4[s6 + 5], o4[s6 + 6]];
                  vb(p3, h2, o4[s6], 0 | o4[s6 + 1]), ox(c3, l4, a3, h2, r5.rotation, r5.scale, u4, false, false, false), "globe" === a3.projection.name && (c3 = qg(c3, a3));
                  const d2 = t2.a9.multiply([], a3.projMatrix, c3), m2 = e4.queryGeometry, y3 = $g(m2.isPointQuery() ? m2.screenBounds : m2.screenGeometry, a3, d2, l4.aabb);
                  null != y3 && (f2 = Math.min(y3, f2));
                }
                return f2 !== Number.MAX_VALUE && f2;
              }
            }
            return false;
          }
          _handleOverridablePaintPropertyUpdate(t3, e4, r4) {
            return !(!this.layout || e4.isDataDriven() || r4.isDataDriven() || "model-color" !== t3 && "model-color-mix-intensity" !== t3 && "model-rotation" !== t3 && "model-scale" !== t3 && "model-translation" !== t3 && "model-emissive-strength" !== t3);
          }
          _isPropertyZoomDependent(t3) {
            const e4 = this._transitionablePaint._values[t3];
            return null != e4 && null != e4.value && null != e4.value.expression && e4.value.expression instanceof io;
          }
          isZoomDependent() {
            return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
          }
          queryIntersectsMatchingFeature(e4, r4, n3, i3) {
            const s4 = e4.tile, a3 = s4.getBucket(this);
            let o3 = null, l3 = Number.MAX_VALUE;
            if (!(a3 && a3 instanceof yb))
              return { queryFeature: o3, intersectionZ: l3 };
            const u3 = a3.getNodesInfo()[r4];
            if (u3.hiddenByReplacement || !u3.node.meshes || !n3.filter(new Uo(s4.tileID.overscaledZ), u3.feature, s4.tileID.canonical))
              return { queryFeature: o3, intersectionZ: l3 };
            const c3 = u3.node, h2 = i3.calculatePosMatrix(s4.tileID.toUnwrapped(), i3.worldSize), p3 = u3.evaluatedScale;
            let f2 = 0;
            i3.elevation && c3.elevation && (f2 = c3.elevation * i3.elevation.exaggeration()), t2.a9.translate(h2, h2, [(c3.anchor ? c3.anchor[0] : 0) * (p3[0] - 1), (c3.anchor ? c3.anchor[1] : 0) * (p3[1] - 1), f2]), t2.a9.scale(h2, h2, p3), t2.a9.multiply(h2, h2, c3.matrix);
            const d2 = e4.queryGeometry, m2 = d2.isPointQuery() ? d2.screenBounds : d2.screenGeometry, y3 = function(e5) {
              const r5 = t2.a9.multiply([], h2, e5.matrix), n4 = t2.a9.multiply(r5, i3.expandedFarZProjMatrix, r5);
              for (let t3 = 0; t3 < e5.meshes.length; ++t3) {
                const r6 = e5.meshes[t3];
                if (t3 === e5.lightMeshIndex)
                  continue;
                const s5 = $g(m2, i3, n4, r6.aabb);
                null != s5 && (l3 = Math.min(s5, l3));
              }
              if (e5.children)
                for (const t3 of e5.children)
                  y3(t3);
            };
            if (y3(c3), l3 === Number.MAX_VALUE)
              return { queryFeature: o3, intersectionZ: l3 };
            const g3 = new ac(0, 0);
            return vb(s4.tileID.canonical, g3, u3.node.anchor[0], u3.node.anchor[1]), o3 = { type: "Feature", geometry: { type: "Point", coordinates: [g3.lng, g3.lat] }, properties: u3.feature.properties, id: u3.feature.id, state: {}, layer: this.serialize() }, { queryFeature: o3, intersectionZ: l3 };
          }
        } }, wb = { read: function(t3, e4) {
          return t3.readFields(wb._readField, { header_length: 0, x: 0, y: 0, z: 0, layers: [] }, e4);
        }, _readField: function(t3, e4, r4) {
          1 === t3 ? e4.header_length = r4.readFixed32() : 2 === t3 ? e4.x = r4.readVarint() : 3 === t3 ? e4.y = r4.readVarint() : 4 === t3 ? e4.z = r4.readVarint() : 5 === t3 && e4.layers.push(wb.Layer.read(r4, r4.readVarint() + r4.pos));
        }, PixelFormat: { PIXEL_FORMAT_UNKNOWN: { value: 0, options: {} }, PIXEL_FORMAT_UINT32: { value: 1, options: {} }, PIXEL_FORMAT_UINT16: { value: 2, options: {} }, PIXEL_FORMAT_UINT8: { value: 3, options: {} } }, Filter: {} };
        wb.Filter.read = function(t3, e4) {
          return t3.readFields(wb.Filter._readField, { delta_filter: null, filter: null, zigzag_filter: null, bitshuffle_filter: null, byteshuffle_filter: null }, e4);
        }, wb.Filter._readField = function(t3, e4, r4) {
          1 === t3 ? (e4.delta_filter = wb.Filter.Delta.read(r4, r4.readVarint() + r4.pos), e4.filter = "delta_filter") : 2 === t3 ? (e4.zigzag_filter = wb.Filter.Zigzag.read(r4, r4.readVarint() + r4.pos), e4.filter = "zigzag_filter") : 3 === t3 ? (e4.bitshuffle_filter = wb.Filter.BitShuffle.read(r4, r4.readVarint() + r4.pos), e4.filter = "bitshuffle_filter") : 4 === t3 && (e4.byteshuffle_filter = wb.Filter.ByteShuffle.read(r4, r4.readVarint() + r4.pos), e4.filter = "byteshuffle_filter");
        }, wb.Filter.Delta = {}, wb.Filter.Delta.read = function(t3, e4) {
          return t3.readFields(wb.Filter.Delta._readField, { block_size: 0 }, e4);
        }, wb.Filter.Delta._readField = function(t3, e4, r4) {
          1 === t3 && (e4.block_size = r4.readVarint());
        }, wb.Filter.Zigzag = {}, wb.Filter.Zigzag.read = function(t3, e4) {
          return t3.readFields(wb.Filter.Zigzag._readField, {}, e4);
        }, wb.Filter.Zigzag._readField = function(t3, e4, r4) {
        }, wb.Filter.BitShuffle = {}, wb.Filter.BitShuffle.read = function(t3, e4) {
          return t3.readFields(wb.Filter.BitShuffle._readField, {}, e4);
        }, wb.Filter.BitShuffle._readField = function(t3, e4, r4) {
        }, wb.Filter.ByteShuffle = {}, wb.Filter.ByteShuffle.read = function(t3, e4) {
          return t3.readFields(wb.Filter.ByteShuffle._readField, {}, e4);
        }, wb.Filter.ByteShuffle._readField = function(t3, e4, r4) {
        }, wb.Codec = {}, wb.Codec.read = function(t3, e4) {
          return t3.readFields(wb.Codec._readField, { gzip_data: null, codec: null, jpeg_image: null, webp_image: null, png_image: null }, e4);
        }, wb.Codec._readField = function(t3, e4, r4) {
          1 === t3 ? (e4.gzip_data = wb.Codec.GzipData.read(r4, r4.readVarint() + r4.pos), e4.codec = "gzip_data") : 2 === t3 ? (e4.jpeg_image = wb.Codec.JpegImage.read(r4, r4.readVarint() + r4.pos), e4.codec = "jpeg_image") : 3 === t3 ? (e4.webp_image = wb.Codec.WebpImage.read(r4, r4.readVarint() + r4.pos), e4.codec = "webp_image") : 4 === t3 && (e4.png_image = wb.Codec.PngImage.read(r4, r4.readVarint() + r4.pos), e4.codec = "png_image");
        }, wb.Codec.GzipData = {}, wb.Codec.GzipData.read = function(t3, e4) {
          return t3.readFields(wb.Codec.GzipData._readField, {}, e4);
        }, wb.Codec.GzipData._readField = function(t3, e4, r4) {
        }, wb.Codec.JpegImage = {}, wb.Codec.JpegImage.read = function(t3, e4) {
          return t3.readFields(wb.Codec.JpegImage._readField, {}, e4);
        }, wb.Codec.JpegImage._readField = function(t3, e4, r4) {
        }, wb.Codec.WebpImage = {}, wb.Codec.WebpImage.read = function(t3, e4) {
          return t3.readFields(wb.Codec.WebpImage._readField, {}, e4);
        }, wb.Codec.WebpImage._readField = function(t3, e4, r4) {
        }, wb.Codec.PngImage = {}, wb.Codec.PngImage.read = function(t3, e4) {
          return t3.readFields(wb.Codec.PngImage._readField, {}, e4);
        }, wb.Codec.PngImage._readField = function(t3, e4, r4) {
        }, wb.DataIndexEntry = {}, wb.DataIndexEntry.read = function(t3, e4) {
          return t3.readFields(wb.DataIndexEntry._readField, { first_byte: 0, last_byte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, e4);
        }, wb.DataIndexEntry._readField = function(t3, e4, r4) {
          1 === t3 ? e4.first_byte = r4.readFixed64() : 2 === t3 ? e4.last_byte = r4.readFixed64() : 3 === t3 ? e4.filters.push(wb.Filter.read(r4, r4.readVarint() + r4.pos)) : 4 === t3 ? e4.codec = wb.Codec.read(r4, r4.readVarint() + r4.pos) : 5 === t3 ? e4.offset = r4.readFloat() : 6 === t3 ? e4.scale = r4.readFloat() : 7 === t3 && e4.bands.push(r4.readString());
        }, wb.Layer = {}, wb.Layer.read = function(t3, e4) {
          return t3.readFields(wb.Layer._readField, { version: 0, name: "", units: "", tilesize: 0, buffer: 0, pixel_format: 0, data_index: [] }, e4);
        }, wb.Layer._readField = function(t3, e4, r4) {
          1 === t3 ? e4.version = r4.readVarint() : 2 === t3 ? e4.name = r4.readString() : 3 === t3 ? e4.units = r4.readString() : 4 === t3 ? e4.tilesize = r4.readVarint() : 5 === t3 ? e4.buffer = r4.readVarint() : 6 === t3 ? e4.pixel_format = r4.readVarint() : 7 === t3 && e4.data_index.push(wb.DataIndexEntry.read(r4, r4.readVarint() + r4.pos));
        };
        const Mb = { read: function(t3, e4) {
          return t3.readFields(Mb._readField, { uint32_values: null, values: null, fixed32_values: null }, e4);
        }, _readField: function(t3, e4, r4) {
          2 === t3 ? (e4.uint32_values = Mb.Uint32Values.read(r4, r4.readVarint() + r4.pos), e4.values = "uint32_values") : 3 === t3 && (e4.fixed32_values = Mb.Fixed32Values.read(r4, r4.readVarint() + r4.pos), e4.values = "fixed32_values");
        }, Uint32Values: {} };
        Mb.Uint32Values.read = function(t3, e4) {
          return t3.readFields(Mb.Uint32Values._readField, { values: [] }, e4);
        }, Mb.Uint32Values._readField = function(t3, e4, r4) {
          1 === t3 && (e4.readValuesInto = function(t4) {
            if (2 !== t4.type)
              throw new Error(`Unsupported pbf type "${t4.type}"`);
            const e5 = function(t5) {
              return 2 === t5.type ? t5.readVarint() + t5.pos : t5.pos + 1;
            }(t4), r5 = t4.pos;
            return t4.pos = e5, function(n3) {
              t4.pos = r5;
              let i3 = 0;
              for (; t4.pos < e5; ) {
                const e6 = t4.readVarint();
                n3[i3++] = e6;
              }
              return n3;
            };
          }(r4));
        }, Mb.Fixed32Values = {}, Mb.Fixed32Values.read = function(t3, e4) {
          return t3.readFields(Mb.Fixed32Values._readField, { values: [] }, e4);
        }, Mb.Fixed32Values._readField = function(t3, e4, r4) {
          throw new Error("Not implemented");
        };
        class Ab {
          constructor(t3 = 0, e4 = 0, r4 = false) {
            this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.max = t3, this.resetTtl = r4, this.size = 0, this.ttl = e4;
          }
          clear() {
            return this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this;
          }
          delete(t3) {
            if (this.has(t3)) {
              const e4 = this.items[t3];
              delete this.items[t3], this.size--, null !== e4.prev && (e4.prev.next = e4.next), null !== e4.next && (e4.next.prev = e4.prev), this.first === e4 && (this.first = e4.next), this.last === e4 && (this.last = e4.prev);
            }
            return this;
          }
          entries(t3 = this.keys()) {
            return t3.map((t4) => [t4, this.get(t4)]);
          }
          evict(t3 = false) {
            if (t3 || this.size > 0) {
              const t4 = this.first;
              delete this.items[t4.key], 0 == --this.size ? (this.first = null, this.last = null) : (this.first = t4.next, this.first.prev = null);
            }
            return this;
          }
          expiresAt(t3) {
            let e4;
            return this.has(t3) && (e4 = this.items[t3].expiry), e4;
          }
          get(t3) {
            let e4;
            if (this.has(t3)) {
              const r4 = this.items[t3];
              this.ttl > 0 && r4.expiry <= Date.now() ? this.delete(t3) : (e4 = r4.value, this.set(t3, e4, true));
            }
            return e4;
          }
          has(t3) {
            return t3 in this.items;
          }
          keys() {
            const t3 = [];
            let e4 = this.first;
            for (; null !== e4; )
              t3.push(e4.key), e4 = e4.next;
            return t3;
          }
          set(t3, e4, r4 = false, n3 = this.resetTtl) {
            let i3;
            if (r4 || this.has(t3)) {
              if (i3 = this.items[t3], i3.value = e4, false === r4 && n3 && (i3.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.last !== i3) {
                const t4 = this.last, e5 = i3.next, r5 = i3.prev;
                this.first === i3 && (this.first = i3.next), i3.next = null, i3.prev = this.last, t4.next = i3, null !== r5 && (r5.next = e5), null !== e5 && (e5.prev = r5);
              }
            } else
              this.max > 0 && this.size === this.max && this.evict(true), i3 = this.items[t3] = { expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl, key: t3, prev: this.last, next: null, value: e4 }, 1 == ++this.size ? this.first = i3 : this.last.next = i3;
            return this.last = i3, this;
          }
          values(t3 = this.keys()) {
            return t3.map((t4) => this.get(t4));
          }
        }
        function Sb(t3, e4) {
          if (4 !== e4.length)
            throw new Error(`Expected data of dimension 4 but got ${e4.length}.`);
          let r4 = e4[3];
          for (let n3 = 2; n3 >= 1; n3--) {
            const i3 = 1 === n3 ? 1 : 0, s4 = 2 === n3 ? 1 : 0;
            for (let n4 = 0; n4 < e4[0]; n4++) {
              const a3 = e4[1] * n4;
              for (let n5 = i3; n5 < e4[1]; n5++) {
                const i4 = e4[2] * (n5 + a3);
                for (let n6 = s4; n6 < e4[2]; n6++) {
                  const s5 = e4[3] * (n6 + i4);
                  for (let n7 = 0; n7 < e4[3]; n7++) {
                    const e5 = s5 + n7;
                    t3[e5] += t3[e5 - r4];
                  }
                }
              }
            }
            r4 *= e4[n3];
          }
          return t3;
        }
        function Ib(t3) {
          for (let e4 = 0, r4 = t3.length; e4 < r4; e4++)
            t3[e4] = t3[e4] >>> 1 ^ -(1 & t3[e4]);
          return t3;
        }
        function kb(t3, e4) {
          switch (e4) {
            case "uint32":
              return t3;
            case "uint16":
              for (let e5 = 0; e5 < t3.length; e5 += 2) {
                const r4 = t3[e5], n3 = t3[e5 + 1];
                t3[e5] = (240 & r4) >> 4 | (61440 & r4) >> 8 | (240 & n3) << 4 | 61440 & n3, t3[e5 + 1] = 15 & r4 | (3840 & r4) >> 4 | (15 & n3) << 8 | (3840 & n3) << 4;
              }
              return t3;
            case "uint8":
              for (let e5 = 0; e5 < t3.length; e5 += 4) {
                const r4 = t3[e5], n3 = t3[e5 + 1], i3 = t3[e5 + 2], s4 = t3[e5 + 3];
                t3[e5 + 0] = (192 & r4) >> 6 | (192 & n3) >> 4 | (192 & i3) >> 2 | 192 & s4, t3[e5 + 1] = (48 & r4) >> 4 | (48 & n3) >> 2 | 48 & i3 | (48 & s4) << 2, t3[e5 + 2] = (12 & r4) >> 2 | 12 & n3 | (12 & i3) << 2 | (12 & s4) << 4, t3[e5 + 3] = 3 & r4 | (3 & n3) << 2 | (3 & i3) << 4 | (3 & s4) << 6;
              }
              return t3;
            default:
              throw new Error(`Invalid pixel format, "${e4}"`);
          }
        }
        class Pb extends Error {
          constructor(t3) {
            super(t3), this.name = "MRTError";
          }
        }
        var Eb = Uint8Array, zb = Uint16Array, Tb = Int32Array, Bb = new Eb([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Cb = new Eb([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Rb = new Eb([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Vb = function(t3, e4) {
          for (var r4 = new zb(31), n3 = 0; n3 < 31; ++n3)
            r4[n3] = e4 += 1 << t3[n3 - 1];
          var i3 = new Tb(r4[30]);
          for (n3 = 1; n3 < 30; ++n3)
            for (var s4 = r4[n3]; s4 < r4[n3 + 1]; ++s4)
              i3[s4] = s4 - r4[n3] << 5 | n3;
          return { b: r4, r: i3 };
        }, Db = Vb(Bb, 2), Lb = Db.b, Fb = Db.r;
        Lb[28] = 258, Fb[258] = 28;
        for (var Ob = Vb(Cb, 0).b, Ub = new zb(32768), Nb = 0; Nb < 32768; ++Nb) {
          var jb = (43690 & Nb) >> 1 | (21845 & Nb) << 1;
          Ub[Nb] = ((65280 & (jb = (61680 & (jb = (52428 & jb) >> 2 | (13107 & jb) << 2)) >> 4 | (3855 & jb) << 4)) >> 8 | (255 & jb) << 8) >> 1;
        }
        var qb = function(t3, e4, r4) {
          for (var n3 = t3.length, i3 = 0, s4 = new zb(e4); i3 < n3; ++i3)
            t3[i3] && ++s4[t3[i3] - 1];
          var a3, o3 = new zb(e4);
          for (i3 = 1; i3 < e4; ++i3)
            o3[i3] = o3[i3 - 1] + s4[i3 - 1] << 1;
          if (r4) {
            a3 = new zb(1 << e4);
            var l3 = 15 - e4;
            for (i3 = 0; i3 < n3; ++i3)
              if (t3[i3])
                for (var u3 = i3 << 4 | t3[i3], c3 = e4 - t3[i3], h2 = o3[t3[i3] - 1]++ << c3, p3 = h2 | (1 << c3) - 1; h2 <= p3; ++h2)
                  a3[Ub[h2] >> l3] = u3;
          } else
            for (a3 = new zb(n3), i3 = 0; i3 < n3; ++i3)
              t3[i3] && (a3[i3] = Ub[o3[t3[i3] - 1]++] >> 15 - t3[i3]);
          return a3;
        }, $b = new Eb(288);
        for (Nb = 0; Nb < 144; ++Nb)
          $b[Nb] = 8;
        for (Nb = 144; Nb < 256; ++Nb)
          $b[Nb] = 9;
        for (Nb = 256; Nb < 280; ++Nb)
          $b[Nb] = 7;
        for (Nb = 280; Nb < 288; ++Nb)
          $b[Nb] = 8;
        var Gb = new Eb(32);
        for (Nb = 0; Nb < 32; ++Nb)
          Gb[Nb] = 5;
        var Qb = qb($b, 9, 1), Yb = qb(Gb, 5, 1), Xb = function(t3) {
          for (var e4 = t3[0], r4 = 1; r4 < t3.length; ++r4)
            t3[r4] > e4 && (e4 = t3[r4]);
          return e4;
        }, Zb = function(t3, e4, r4) {
          var n3 = e4 / 8 | 0;
          return (t3[n3] | t3[n3 + 1] << 8) >> (7 & e4) & r4;
        }, Kb = function(t3, e4) {
          var r4 = e4 / 8 | 0;
          return (t3[r4] | t3[r4 + 1] << 8 | t3[r4 + 2] << 16) >> (7 & e4);
        }, Wb = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Hb = function(t3, e4, r4) {
          var n3 = new Error(e4 || Wb[t3]);
          if (n3.code = t3, Error.captureStackTrace && Error.captureStackTrace(n3, Hb), !r4)
            throw n3;
          return n3;
        }, Jb = new Eb(0), tv = "undefined" != typeof TextDecoder && new TextDecoder();
        try {
          tv.decode(Jb, { stream: true });
        } catch (t3) {
        }
        const ev = { gzip_data: "gzip" };
        const rv = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, nv = { uint32: 1, uint16: 2, uint8: 4 }, iv = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
        class sv {
          constructor(t3 = 1) {
            this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t3;
          }
          getLayer(t3) {
            return this.layers[t3];
          }
          getHeaderLength(t3) {
            const e4 = new Uint8Array(t3), r4 = new DataView(t3);
            if (13 !== e4[0])
              throw new Pb("File is not a valid MRT.");
            return r4.getUint32(1, true);
          }
          parseHeader(t3) {
            const e4 = new Uint8Array(t3), r4 = this.getHeaderLength(t3);
            if (e4.length < r4)
              throw new Pb(`Expected header with length >= ${r4} but got buffer of length ${e4.length}`);
            const n3 = new wm(e4.subarray(0, r4)), i3 = wb.read(n3);
            if (!isNaN(this.x) && (this.x !== i3.x || this.y !== i3.y || this.z !== i3.z))
              throw new Pb(`Invalid attempt to parse header ${i3.z}/${i3.x}/${i3.y} for tile ${this.z}/${this.x}/${this.y}`);
            this.x = i3.x, this.y = i3.y, this.z = i3.z;
            for (const t4 of i3.layers)
              this.layers[t4.name] = new av(t4, { cacheSize: this._cacheSize });
            return this;
          }
          createDecodingTask(t3) {
            const e4 = [], r4 = this.getLayer(t3.layerName);
            for (let n3 = 0; n3 < r4.dataIndex.length; n3++) {
              const i3 = r4.dataIndex[n3], s4 = i3.first_byte - t3.firstByte, a3 = i3.last_byte + 1 - t3.firstByte;
              if (n3 < t3.firstBlock || n3 > t3.lastBlock)
                continue;
              if (r4._blocksInProgress.has(n3))
                continue;
              const o3 = { layerName: r4.name, firstByte: s4, lastByte: a3, pixelFormat: r4.pixelFormat, blockIndex: n3, blockShape: [i3.bands.length].concat(r4.bandShape), buffer: r4.buffer, codec: i3.codec.codec, filters: i3.filters.map((t4) => t4.filter) };
              r4._blocksInProgress.add(n3), e4.push(o3);
            }
            return new ov(e4, () => {
              e4.forEach((t4) => r4._blocksInProgress.delete(t4.blockIndex));
            }, (t4, n3) => {
              if (e4.forEach((t5) => r4._blocksInProgress.delete(t5.blockIndex)), t4)
                throw t4;
              n3.forEach((t5) => {
                this.getLayer(t5.layerName).processDecodedData(t5);
              });
            });
          }
        }
        class av {
          constructor({ version: t3, name: e4, units: r4, tilesize: n3, pixel_format: i3, buffer: s4, data_index: a3 }, o3) {
            if (this.version = t3, 1 !== this.version)
              throw new Pb(`Cannot parse raster layer encoded with MRT version ${t3}`);
            this.name = e4, this.units = r4, this.tileSize = n3, this.buffer = s4, this.pixelFormat = rv[i3], this.dataIndex = a3, this.bandShape = [n3 + 2 * s4, n3 + 2 * s4, nv[this.pixelFormat]], this._decodedBlocks = function(t4 = 1e3, e5 = 0, r5 = false) {
              if (isNaN(t4) || t4 < 0)
                throw new TypeError("Invalid max value");
              if (isNaN(e5) || e5 < 0)
                throw new TypeError("Invalid ttl value");
              if ("boolean" != typeof r5)
                throw new TypeError("Invalid resetTtl value");
              return new Ab(t4, e5, r5);
            }(o3 ? o3.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
          }
          processDecodedData(t3) {
            const e4 = t3.blockIndex.toString();
            this._decodedBlocks.get(e4) || this._decodedBlocks.set(e4, t3.data);
          }
          getBlockForBand(t3) {
            let e4 = 0;
            switch (typeof t3) {
              case "string":
                for (const [r4, n3] of this.dataIndex.entries()) {
                  for (const [i3, s4] of n3.bands.entries())
                    if (s4 === t3)
                      return { bandIndex: e4 + i3, blockIndex: r4, blockBandIndex: i3 };
                  e4 += n3.bands.length;
                }
                break;
              case "number":
                for (const [r4, n3] of this.dataIndex.entries()) {
                  if (t3 >= e4 && t3 < e4 + n3.bands.length)
                    return { bandIndex: t3, blockIndex: r4, blockBandIndex: t3 - e4 };
                  e4 += n3.bands.length;
                }
                break;
              default:
                throw new Pb(`Invalid band \`${JSON.stringify(t3)}\`. Expected string or integer.`);
            }
            throw new Pb(`Band not found: ${JSON.stringify(t3)}`);
          }
          getDataRange(t3) {
            let e4 = 1 / 0, r4 = -1 / 0, n3 = 1 / 0, i3 = -1 / 0;
            for (const s4 of t3) {
              const { blockIndex: t4 } = this.getBlockForBand(s4);
              if (t4 < 0)
                throw new Pb(`Invalid band: ${JSON.stringify(s4)}`);
              const a3 = this.dataIndex[t4];
              n3 = Math.min(n3, t4), i3 = Math.max(i3, t4), e4 = Math.min(e4, a3.first_byte), r4 = Math.max(r4, a3.last_byte);
            }
            return { layerName: this.name, firstByte: e4, lastByte: r4, firstBlock: n3, lastBlock: i3 };
          }
          hasBand(t3) {
            const { blockIndex: e4 } = this.getBlockForBand(t3);
            return e4 >= 0;
          }
          hasDataForBand(t3) {
            const { blockIndex: e4 } = this.getBlockForBand(t3);
            return e4 >= 0 && !!this._decodedBlocks.get(e4.toString());
          }
          getBandView(t3) {
            const { blockIndex: e4, blockBandIndex: r4 } = this.getBlockForBand(t3), n3 = this._decodedBlocks.get(e4.toString());
            if (!n3)
              throw new Pb(`Data for band ${JSON.stringify(t3)} of layer "${this.name}" not decoded.`);
            const i3 = this.dataIndex[e4], s4 = this.bandShape.reduce((t4, e5) => t4 * e5, 1), a3 = r4 * s4, o3 = n3.subarray(a3, a3 + s4);
            return { data: o3, bytes: new Uint8Array(o3.buffer).subarray(o3.byteOffset, o3.byteOffset + o3.byteLength), tileSize: this.tileSize, buffer: this.buffer, offset: i3.offset, scale: i3.scale };
          }
        }
        class ov {
          constructor(t3, e4, r4) {
            this.tasks = t3, this._onCancel = e4, this._onComplete = r4, this._finalized = false;
          }
          cancel() {
            this._finalized || (this._onCancel(), this._finalized = true);
          }
          complete(t3, e4) {
            this._finalized || (this._onComplete(t3, e4), this._finalized = true);
          }
        }
        sv.performDecoding = function(t3, e4) {
          return Promise.all(e4.tasks.map((e5) => {
            const { layerName: r4, firstByte: n3, lastByte: i3, pixelFormat: s4, blockShape: a3, blockIndex: o3, filters: l3, codec: u3 } = e5, c3 = new Uint8Array(t3).subarray(n3, i3 + 1), h2 = new Uint32Array(a3[0] * a3[1] * a3[2]);
            let p3;
            if ("gzip_data" !== u3)
              throw new Error(`Unhandled codec: ${u3}`);
            return p3 = function(t4, e6) {
              if (!globalThis.DecompressionStream && "gzip_data" === e6)
                return Promise.resolve(((s5 = function(t5) {
                  31 == t5[0] && 139 == t5[1] && 8 == t5[2] || Hb(6, "invalid gzip data");
                  var e7 = t5[3], r6 = 10;
                  4 & e7 && (r6 += 2 + (t5[10] | t5[11] << 8));
                  for (var n5 = (e7 >> 3 & 1) + (e7 >> 4 & 1); n5 > 0; n5 -= !t5[r6++])
                    ;
                  return r6 + (2 & e7);
                }(i4 = t4)) + 8 > i4.length && Hb(6, "invalid gzip data"), function(t5, e7, r6, n5) {
                  var i5 = t5.length;
                  if (!i5 || e7.f && !e7.l)
                    return r6 || new Eb(0);
                  var s6 = !r6, a5 = s6 || 2 != e7.i, o5 = e7.i;
                  s6 && (r6 = new Eb(3 * i5));
                  var l4, u4, c4 = function(t6) {
                    var e8 = r6.length;
                    if (t6 > e8) {
                      var n6 = new Eb(Math.max(2 * e8, t6));
                      n6.set(r6), r6 = n6;
                    }
                  }, h3 = e7.f || 0, p4 = e7.p || 0, f2 = e7.b || 0, d2 = e7.l, m2 = e7.d, y3 = e7.m, g3 = e7.n, x3 = 8 * i5;
                  do {
                    if (!d2) {
                      h3 = Zb(t5, p4, 1);
                      var b2 = Zb(t5, p4 + 1, 3);
                      if (p4 += 3, !b2) {
                        var v3 = t5[(T2 = 4 + ((p4 + 7) / 8 | 0)) - 4] | t5[T2 - 3] << 8, _3 = T2 + v3;
                        if (_3 > i5) {
                          o5 && Hb(0);
                          break;
                        }
                        a5 && c4(f2 + v3), r6.set(t5.subarray(T2, _3), f2), e7.b = f2 += v3, e7.p = p4 = 8 * _3, e7.f = h3;
                        continue;
                      }
                      if (1 == b2)
                        d2 = Qb, m2 = Yb, y3 = 9, g3 = 5;
                      else if (2 == b2) {
                        var w2 = Zb(t5, p4, 31) + 257, M3 = Zb(t5, p4 + 10, 15) + 4, A2 = w2 + Zb(t5, p4 + 5, 31) + 1;
                        p4 += 14;
                        for (var S2 = new Eb(A2), I2 = new Eb(19), k2 = 0; k2 < M3; ++k2)
                          I2[Rb[k2]] = Zb(t5, p4 + 3 * k2, 7);
                        p4 += 3 * M3;
                        var P2 = Xb(I2), E2 = (1 << P2) - 1, z3 = qb(I2, P2, 1);
                        for (k2 = 0; k2 < A2; ) {
                          var T2, B2 = z3[Zb(t5, p4, E2)];
                          if (p4 += 15 & B2, (T2 = B2 >> 4) < 16)
                            S2[k2++] = T2;
                          else {
                            var C2 = 0, R3 = 0;
                            for (16 == T2 ? (R3 = 3 + Zb(t5, p4, 3), p4 += 2, C2 = S2[k2 - 1]) : 17 == T2 ? (R3 = 3 + Zb(t5, p4, 7), p4 += 3) : 18 == T2 && (R3 = 11 + Zb(t5, p4, 127), p4 += 7); R3--; )
                              S2[k2++] = C2;
                          }
                        }
                        var V2 = S2.subarray(0, w2), D2 = S2.subarray(w2);
                        y3 = Xb(V2), g3 = Xb(D2), d2 = qb(V2, y3, 1), m2 = qb(D2, g3, 1);
                      } else
                        Hb(1);
                      if (p4 > x3) {
                        o5 && Hb(0);
                        break;
                      }
                    }
                    a5 && c4(f2 + 131072);
                    for (var L2 = (1 << y3) - 1, F2 = (1 << g3) - 1, O2 = p4; ; O2 = p4) {
                      var U2 = (C2 = d2[Kb(t5, p4) & L2]) >> 4;
                      if ((p4 += 15 & C2) > x3) {
                        o5 && Hb(0);
                        break;
                      }
                      if (C2 || Hb(2), U2 < 256)
                        r6[f2++] = U2;
                      else {
                        if (256 == U2) {
                          O2 = p4, d2 = null;
                          break;
                        }
                        var N2 = U2 - 254;
                        U2 > 264 && (N2 = Zb(t5, p4, (1 << ($2 = Bb[k2 = U2 - 257])) - 1) + Lb[k2], p4 += $2);
                        var j3 = m2[Kb(t5, p4) & F2], q3 = j3 >> 4;
                        if (j3 || Hb(3), p4 += 15 & j3, D2 = Ob[q3], q3 > 3) {
                          var $2 = Cb[q3];
                          D2 += Kb(t5, p4) & (1 << $2) - 1, p4 += $2;
                        }
                        if (p4 > x3) {
                          o5 && Hb(0);
                          break;
                        }
                        a5 && c4(f2 + 131072);
                        var G2 = f2 + N2;
                        if (f2 < D2) {
                          var Q2 = 0 - D2, Y2 = Math.min(D2, G2);
                          for (Q2 + f2 < 0 && Hb(3); f2 < Y2; ++f2)
                            r6[f2] = (void 0)[Q2 + f2];
                        }
                        for (; f2 < G2; ++f2)
                          r6[f2] = r6[f2 - D2];
                      }
                    }
                    e7.l = d2, e7.p = O2, e7.b = f2, e7.f = h3, d2 && (h3 = 1, e7.m = y3, e7.d = m2, e7.n = g3);
                  } while (!h3);
                  return f2 != r6.length && s6 ? (l4 = r6, (null == (u4 = f2) || u4 > l4.length) && (u4 = l4.length), new Eb(l4.subarray(0, u4))) : r6.subarray(0, f2);
                }(i4.subarray(s5, -8), { i: 2 }, new Eb(((r5 = i4)[(n4 = r5.length) - 4] | r5[n4 - 3] << 8 | r5[n4 - 2] << 16 | r5[n4 - 1] << 24) >>> 0))));
              var r5, n4, i4, s5;
              const a4 = ev[e6];
              if (!a4)
                throw new Error(`Unhandled codec: ${e6}`);
              const o4 = new globalThis.DecompressionStream(a4);
              return new Response(new Blob([t4]).stream().pipeThrough(o4)).arrayBuffer().then((t5) => new Uint8Array(t5));
            }(c3, u3).then((t4) => {
              const e6 = Mb.read(new wm(t4));
              if ("uint32_values" === e6.values)
                return e6.uint32_values.readValuesInto(h2), new (0, iv[s4])(h2.buffer);
              throw new Error(`Unhandled numeric data "${e6.values}"`);
            }), p3.then((t4) => {
              for (let e6 = l3.length - 1; e6 >= 0; e6--)
                switch (l3[e6]) {
                  case "delta_filter":
                    Sb(t4, a3);
                    break;
                  case "zigzag_filter":
                    Ib(t4);
                    break;
                  case "bitshuffle_filter":
                    kb(t4, s4);
                    break;
                  default:
                    throw new Error(`Unhandled filter "${l3[e6]}"`);
                }
              return { layerName: r4, blockIndex: o3, data: t4 };
            }).catch((t4) => {
              throw t4;
            });
          }));
        }, fo(ov, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
        const lv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class uv {
          static from(t3) {
            if (!(t3 instanceof ArrayBuffer))
              throw new Error("Data must be an instance of ArrayBuffer.");
            const [e4, r4] = new Uint8Array(t3, 0, 2);
            if (219 !== e4)
              throw new Error("Data does not appear to be in a KDBush format.");
            const n3 = r4 >> 4;
            if (1 !== n3)
              throw new Error(`Got v${n3} data when expected v1.`);
            const i3 = lv[15 & r4];
            if (!i3)
              throw new Error("Unrecognized array type.");
            const [s4] = new Uint16Array(t3, 2, 1), [a3] = new Uint32Array(t3, 4, 1);
            return new uv(a3, s4, i3, t3);
          }
          constructor(t3, e4 = 64, r4 = Float64Array, n3) {
            if (isNaN(t3) || t3 < 0)
              throw new Error(`Unpexpected numItems value: ${t3}.`);
            this.numItems = +t3, this.nodeSize = Math.min(Math.max(+e4, 2), 65535), this.ArrayType = r4, this.IndexArrayType = t3 < 65536 ? Uint16Array : Uint32Array;
            const i3 = lv.indexOf(this.ArrayType), s4 = 2 * t3 * this.ArrayType.BYTES_PER_ELEMENT, a3 = t3 * this.IndexArrayType.BYTES_PER_ELEMENT, o3 = (8 - a3 % 8) % 8;
            if (i3 < 0)
              throw new Error(`Unexpected typed array class: ${r4}.`);
            n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + a3 + o3, 2 * t3), this._pos = 2 * t3, this._finished = true) : (this.data = new ArrayBuffer(8 + s4 + a3 + o3), this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + a3 + o3, 2 * t3), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i3]), new Uint16Array(this.data, 2, 1)[0] = e4, new Uint32Array(this.data, 4, 1)[0] = t3);
          }
          add(t3, e4) {
            const r4 = this._pos >> 1;
            return this.ids[r4] = r4, this.coords[this._pos++] = t3, this.coords[this._pos++] = e4, r4;
          }
          finish() {
            const t3 = this._pos >> 1;
            if (t3 !== this.numItems)
              throw new Error(`Added ${t3} items when expected ${this.numItems}.`);
            return cv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t3, e4, r4, n3) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i3, coords: s4, nodeSize: a3 } = this, o3 = [0, i3.length - 1, 0], l3 = [];
            for (; o3.length; ) {
              const u3 = o3.pop() || 0, c3 = o3.pop() || 0, h2 = o3.pop() || 0;
              if (c3 - h2 <= a3) {
                for (let a4 = h2; a4 <= c3; a4++) {
                  const o4 = s4[2 * a4], u4 = s4[2 * a4 + 1];
                  o4 >= t3 && o4 <= r4 && u4 >= e4 && u4 <= n3 && l3.push(i3[a4]);
                }
                continue;
              }
              const p3 = h2 + c3 >> 1, f2 = s4[2 * p3], d2 = s4[2 * p3 + 1];
              f2 >= t3 && f2 <= r4 && d2 >= e4 && d2 <= n3 && l3.push(i3[p3]), (0 === u3 ? t3 <= f2 : e4 <= d2) && (o3.push(h2), o3.push(p3 - 1), o3.push(1 - u3)), (0 === u3 ? r4 >= f2 : n3 >= d2) && (o3.push(p3 + 1), o3.push(c3), o3.push(1 - u3));
            }
            return l3;
          }
          within(t3, e4, r4) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n3, coords: i3, nodeSize: s4 } = this, a3 = [0, n3.length - 1, 0], o3 = [], l3 = r4 * r4;
            for (; a3.length; ) {
              const u3 = a3.pop() || 0, c3 = a3.pop() || 0, h2 = a3.pop() || 0;
              if (c3 - h2 <= s4) {
                for (let r5 = h2; r5 <= c3; r5++)
                  dv(i3[2 * r5], i3[2 * r5 + 1], t3, e4) <= l3 && o3.push(n3[r5]);
                continue;
              }
              const p3 = h2 + c3 >> 1, f2 = i3[2 * p3], d2 = i3[2 * p3 + 1];
              dv(f2, d2, t3, e4) <= l3 && o3.push(n3[p3]), (0 === u3 ? t3 - r4 <= f2 : e4 - r4 <= d2) && (a3.push(h2), a3.push(p3 - 1), a3.push(1 - u3)), (0 === u3 ? t3 + r4 >= f2 : e4 + r4 >= d2) && (a3.push(p3 + 1), a3.push(c3), a3.push(1 - u3));
            }
            return o3;
          }
        }
        function cv(t3, e4, r4, n3, i3, s4) {
          if (i3 - n3 <= r4)
            return;
          const a3 = n3 + i3 >> 1;
          hv(t3, e4, a3, n3, i3, s4), cv(t3, e4, r4, n3, a3 - 1, 1 - s4), cv(t3, e4, r4, a3 + 1, i3, 1 - s4);
        }
        function hv(t3, e4, r4, n3, i3, s4) {
          for (; i3 > n3; ) {
            if (i3 - n3 > 600) {
              const a4 = i3 - n3 + 1, o4 = r4 - n3 + 1, l4 = Math.log(a4), u3 = 0.5 * Math.exp(2 * l4 / 3), c3 = 0.5 * Math.sqrt(l4 * u3 * (a4 - u3) / a4) * (o4 - a4 / 2 < 0 ? -1 : 1);
              hv(t3, e4, r4, Math.max(n3, Math.floor(r4 - o4 * u3 / a4 + c3)), Math.min(i3, Math.floor(r4 + (a4 - o4) * u3 / a4 + c3)), s4);
            }
            const a3 = e4[2 * r4 + s4];
            let o3 = n3, l3 = i3;
            for (pv(t3, e4, n3, r4), e4[2 * i3 + s4] > a3 && pv(t3, e4, n3, i3); o3 < l3; ) {
              for (pv(t3, e4, o3, l3), o3++, l3--; e4[2 * o3 + s4] < a3; )
                o3++;
              for (; e4[2 * l3 + s4] > a3; )
                l3--;
            }
            e4[2 * n3 + s4] === a3 ? pv(t3, e4, n3, l3) : (l3++, pv(t3, e4, l3, i3)), l3 <= r4 && (n3 = l3 + 1), r4 <= l3 && (i3 = l3 - 1);
          }
        }
        function pv(t3, e4, r4, n3) {
          fv(t3, r4, n3), fv(e4, 2 * r4, 2 * n3), fv(e4, 2 * r4 + 1, 2 * n3 + 1);
        }
        function fv(t3, e4, r4) {
          const n3 = t3[e4];
          t3[e4] = t3[r4], t3[r4] = n3;
        }
        function dv(t3, e4, r4, n3) {
          const i3 = t3 - r4, s4 = e4 - n3;
          return i3 * i3 + s4 * s4;
        }
        t2.$ = class {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e4) {
            return function([t4, e5]) {
              const r4 = dr([1, t4, e5]);
              return { x: r4.x, y: r4.y, z: r4.z };
            }(t3.expression.evaluate(e4));
          }
          interpolate(t3, e4, r4) {
            return { x: qn(t3.x, e4.x, r4), y: qn(t3.y, e4.y, r4), z: qn(t3.z, e4.z, r4) };
          }
        }, t2.A = rl, t2.B = Qa, t2.C = zi, t2.D = qa, t2.E = Dn, t2.F = function(t3) {
          const e4 = t3.value;
          let r4 = [];
          if (!e4)
            return r4;
          const n3 = Si(e4);
          return "string" !== n3 ? (r4 = r4.concat([new Hg(t3.key, e4, `string expected, "${n3}" found`)]), r4) : (Jg(e4, true) || (r4 = r4.concat([new Hg(t3.key, e4, `invalid url "${e4}"`)])), r4);
        }, t2.G = el, t2.H = Ho, t2.I = ty, t2.J = Zo, t2.K = class {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e4) {
            return dr(t3.expression.evaluate(e4));
          }
          interpolate(t3, e4, r4) {
            return { x: qn(t3.x, e4.x, r4), y: qn(t3.y, e4.y, r4), z: qn(t3.z, e4.z, r4), azimuthal: qn(t3.azimuthal, e4.azimuthal, r4), polar: qn(t3.polar, e4.polar, r4) };
          }
        }, t2.L = qo, t2.M = class {
          constructor(t3, e4, r4, n3) {
            this.id = t3, this.position = null != e4 ? new ac(e4[0], e4[1]) : new ac(0, 0), this.orientation = null != r4 ? r4 : [0, 0, 0], this.nodes = n3, this.uploaded = false, this.aabb = new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
          }
          _applyTransformations(e4, r4) {
            if (t2.a9.multiply(e4.matrix, r4, e4.matrix), e4.meshes)
              for (const t3 of e4.meshes) {
                const r5 = mh.applyTransform(t3.aabb, e4.matrix);
                this.aabb.encapsulate(r5);
              }
            if (e4.children)
              for (const t3 of e4.children)
                this._applyTransformations(t3, e4.matrix);
          }
          computeBoundsAndApplyParent() {
            const e4 = t2.a9.identity([]);
            for (const t3 of this.nodes)
              this._applyTransformations(t3, e4);
          }
          computeModelMatrix(t3, e4, r4, n3, i3, s4, a3 = false) {
            ox(this.matrix, this, t3.transform, this.position, e4, r4, n3, i3, s4, a3);
          }
          upload(t3) {
            if (!this.uploaded) {
              for (const e4 of this.nodes)
                cx(e4, t3);
              for (const t4 of this.nodes)
                hx(t4);
              this.uploaded = true;
            }
          }
          destroy() {
            for (const t3 of this.nodes)
              px(t3);
          }
        }, t2.N = Uo, t2.O = Ec, t2.P = Ue, t2.R = Zr, t2.S = Ke, t2.T = bg, t2.U = Xo, t2.V = Hg, t2.W = Oh, t2.X = qn, t2.Y = is, t2.Z = io, t2._ = $n, t2.a = Vn, t2.a$ = sr, t2.a0 = function(t3, e4, r4 = 0, n3 = true) {
          const i3 = new Ue(r4, r4), s4 = t3.sub(i3), a3 = e4.add(i3), o3 = [s4, new Ue(a3.x, s4.y), a3, new Ue(s4.x, a3.y)];
          return n3 && o3.push(s4.clone()), o3;
        }, t2.a1 = function(t3, e4) {
          const r4 = [];
          for (let n3 = 0; n3 < t3.length; n3++) {
            const i3 = We(n3 - 1, -1, t3.length - 1), s4 = We(n3 + 1, -1, t3.length - 1), a3 = t3[n3], o3 = t3[s4], l3 = t3[i3].sub(a3).unit(), u3 = o3.sub(a3).unit(), c3 = u3.angleWithSep(l3.x, l3.y), h2 = l3.add(u3).unit().mult(-1 * e4 / Math.sin(c3 / 2));
            r4.push(a3.add(h2));
          }
          return r4;
        }, t2.a2 = By, t2.a3 = Hc, t2.a4 = function(e4, r4, n3 = 0) {
          return t2.Q.fromValues(((r4.x - n3) * e4.scale - e4.x) * is, (r4.y * e4.scale - e4.y) * is, Mc(r4.z, r4.y));
        }, t2.a5 = lh, t2.a6 = Pd, t2.a7 = function(t3) {
          let e4 = 1 / 0, r4 = 1 / 0, n3 = -1 / 0, i3 = -1 / 0;
          for (const s4 of t3)
            e4 = Math.min(e4, s4.x), r4 = Math.min(r4, s4.y), n3 = Math.max(n3, s4.x), i3 = Math.max(i3, s4.y);
          return { min: new Ue(e4, r4), max: new Ue(n3, i3) };
        }, t2.a8 = xc, t2.aA = jn, t2.aB = Ml, t2.aC = Ba, t2.aD = tu, t2.aE = mu, t2.aF = er, t2.aG = nu, t2.aH = ug, t2.aI = function() {
          Oo.isLoading() || Oo.isLoaded() || "deferred" !== Lo() || Fo();
        }, t2.aJ = nl, t2.aK = Fc, t2.aL = ab, t2.aM = yr, t2.aN = Sd, t2.aO = $p, t2.aP = Lc, t2.aQ = Sl, t2.aR = Kl, t2.aS = bh, t2.aT = Op, t2.aU = xg, t2.aV = function(e4, r4) {
          const n3 = Oh(r4.zoom);
          if (0 === n3)
            return Sh(e4);
          const i3 = Eh(e4), s4 = zh(i3), a3 = xc(i3.getWest()) * r4.worldSize, o3 = xc(i3.getEast()) * r4.worldSize, l3 = bc(i3.getNorth()) * r4.worldSize, u3 = bc(i3.getSouth()) * r4.worldSize, c3 = [a3, l3, 0], h2 = [o3, l3, 0], p3 = [a3, u3, 0], f2 = [o3, u3, 0], d2 = t2.a9.invert([], r4.globeMatrix);
          return t2.Q.transformMat4(c3, c3, d2), t2.Q.transformMat4(h2, h2, d2), t2.Q.transformMat4(p3, p3, d2), t2.Q.transformMat4(f2, f2, d2), s4[0] = Ih(s4[0], p3, n3), s4[1] = Ih(s4[1], f2, n3), s4[2] = Ih(s4[2], h2, n3), s4[3] = Ih(s4[3], c3, n3), mh.fromPoints(s4);
        }, t2.aW = Rh, t2.aX = Th, t2.aY = Ih, t2.aZ = Il, t2.a_ = xh, t2.ab = Wc, t2.ac = Tc, t2.ad = Ze, t2.ae = Xu, t2.af = function(t3, e4) {
          const r4 = {};
          for (let n3 = 0; n3 < e4.length; n3++) {
            const i3 = e4[n3];
            i3 in t3 && (r4[i3] = t3[i3]);
          }
          return r4;
        }, t2.ag = oc, t2.ah = bc, t2.ai = class {
          constructor(t3) {
            this.entries = {}, this.scheduler = t3;
          }
          request(t3, e4, r4, n3) {
            const i3 = this.entries[t3] = this.entries[t3] || { callbacks: [] };
            if (i3.result) {
              const [t4, r5] = i3.result;
              return this.scheduler ? this.scheduler.add(() => {
                n3(t4, r5);
              }, e4) : n3(t4, r5), () => {
              };
            }
            return i3.callbacks.push(n3), i3.cancel || (i3.cancel = r4((r5, n4) => {
              i3.result = [r5, n4];
              for (const t4 of i3.callbacks)
                this.scheduler ? this.scheduler.add(() => {
                  t4(r5, n4);
                }, e4) : t4(r5, n4);
              setTimeout(() => delete this.entries[t3], 3e3);
            })), () => {
              i3.result || (i3.callbacks = i3.callbacks.filter((t4) => t4 !== n3), i3.callbacks.length || (i3.cancel(), delete this.entries[t3]));
            };
          }
        }, t2.aj = yl, t2.ak = function(t3, e4, r4) {
          const n3 = JSON.stringify(t3.request);
          return t3.data && (this.deduped.entries[n3] = { result: [null, t3.data] }), this.deduped.request(n3, { type: "parseTile", isSymbolTile: t3.isSymbolTile, zoom: t3.tileZoom }, (e5) => {
            const n4 = Jr(t3.request, (t4, n5, i3, s4) => {
              t4 ? e5(t4) : n5 && e5(null, { vectorTile: r4 ? void 0 : new pf(new wm(n5)), rawData: n5, cacheControl: i3, expires: s4 });
            });
            return () => {
              n4.cancel(), e5();
            };
          }, e4);
        }, t2.al = function(t3) {
          Nr++, Nr > Dr && (t3.getActor().send("enforceCacheSizeLimit", Vr), Nr = 0);
        }, t2.am = mn, t2.an = zr, t2.ao = function(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t3) / Math.LN2));
        }, t2.ap = pc, t2.aq = Ig, t2.ar = Eg, t2.as = Ag, t2.at = function(t3, e4) {
          const r4 = document.createElement("video");
          r4.muted = true, r4.onloadstart = function() {
            e4(null, r4);
          };
          for (let e5 = 0; e5 < t3.length; e5++) {
            const n3 = document.createElement("source");
            tn(t3[e5]) || (r4.crossOrigin = "Anonymous"), n3.src = t3[e5], r4.appendChild(n3);
          }
          return { cancel: () => {
          } };
        }, t2.au = vg, t2.av = Ty, t2.aw = _c, t2.ax = wc, t2.ay = kl, t2.az = ql, t2.b = Rn, t2.b$ = oy, t2.b0 = sv, t2.b1 = Jr, t2.b2 = function(t3) {
          const e4 = [];
          for (const r4 in t3)
            e4.push(t3[r4]);
          return e4;
        }, t2.b3 = function(t3, e4) {
          const r4 = [];
          for (const n3 in t3)
            n3 in e4 || r4.push(n3);
          return r4;
        }, t2.b4 = He, t2.b5 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t2.b6 = function(e4, r4) {
          const { x: n3, y: i3 } = e4.point, s4 = Fh(n3, i3, e4.worldSize / e4._pixelsPerMercatorPixel, 0, 0);
          return t2.a9.multiply(s4, s4, Vh(Sh(r4)));
        }, t2.b8 = Xd, t2.b9 = Pm, t2.bA = Ku, t2.bB = function(e4) {
          const r4 = t2.a9.identity(new Float64Array(16));
          t2.a9.multiply(r4, e4.pixelMatrix, e4.globeMatrix);
          const n3 = [0, tc, 0], i3 = [0, ec, 0];
          return t2.Q.transformMat4(n3, n3, r4), t2.Q.transformMat4(i3, i3, r4), [n3[0] > 0 && n3[0] <= e4.width && n3[1] > 0 && n3[1] <= e4.height && !Nh(e4, new ac(e4.center.lat, 90)), i3[0] > 0 && i3[0] <= e4.width && i3[1] > 0 && i3[1] <= e4.height && !Nh(e4, new ac(e4.center.lat, -90))];
        }, t2.bC = function(e4, r4) {
          const { scale: n3 } = e4.tileTransform, i3 = n3 * is / (e4.tileSize * Math.pow(2, r4.zoom - e4.tileID.overscaledZ + e4.tileID.canonical.z));
          return t2.b7.scale(new Float32Array(4), r4.inverseAdjustmentMatrix, [i3, i3]);
        }, t2.bD = Lg, t2.bE = Vg, t2.bF = function(e4) {
          const r4 = Vg(e4, true);
          return t2.b7.invert([], [r4[0], r4[1], r4[4], r4[5]]);
        }, t2.bG = uh, t2.bH = function(t3) {
          const { x: e4, y: r4 } = t3.point, { lng: n3, lat: i3 } = t3._center;
          return Fh(e4, r4, t3.worldSize, n3, i3);
        }, t2.bI = $e, t2.bJ = Zu, t2.bK = function(t3) {
          const e4 = Math.round((t3 + 45 + 360) % 360 / 90) % 4;
          return Ge[e4];
        }, t2.bL = 45, t2.bM = gc, t2.bN = Tu, t2.bO = Iu, t2.bP = ku, t2.bQ = Su, t2.bR = Au, t2.bS = Pu, t2.bT = function(t3, e4, r4) {
          const n3 = Math.sqrt(t3 * t3 + e4 * e4 + r4 * r4), i3 = n3 > 0 ? Math.acos(r4 / n3) * je : 0;
          let s4 = 0 !== t3 || 0 !== e4 ? Math.atan2(-e4, -t3) * je + 90 : 0;
          return s4 < 0 && (s4 += 360), [n3, s4, i3];
        }, t2.bU = Pc, t2.bV = mh, t2.bW = dr, t2.bX = function(t3) {
          return [Math.pow(t3[0], 1 / 2.2), Math.pow(t3[1], 1 / 2.2), Math.pow(t3[2], 1 / 2.2)];
        }, t2.bY = function(t3) {
          return t3({ pluginStatus: Bo, pluginURL: Co }), Do.on("pluginStateChange", t3), t3;
        }, t2.bZ = yx, t2.b_ = wx, t2.ba = Yd, t2.bb = function(t3, e4, r4, n3, i3) {
          const s4 = 5 * e4 + 2;
          t3.float32[s4 + 0] = r4, t3.float32[s4 + 1] = n3, t3.float32[s4 + 2] = i3;
        }, t2.bc = sg, t2.bd = Wm, t2.be = jc, t2.bf = $d, t2.bg = _y, t2.bh = vy, t2.bi = Om, t2.bj = uv, t2.bk = We, t2.bm = qe, t2.bn = Sr, t2.bo = vc, t2.bp = function(t3, e4, r4) {
          t3[4 * e4 + 0] = r4[0], t3[4 * e4 + 1] = r4[1], t3[4 * e4 + 2] = r4[2], t3[4 * e4 + 3] = r4[3];
        }, t2.bq = ac, t2.br = Jy, t2.bs = hc, t2.bt = dh, t2.bu = Dg, t2.bv = cc, t2.bw = Ph, t2.bx = function(t3, e4, r4, n3, i3, s4, a3, o3, l3) {
          if ("globe" === l3.name)
            return Ph(t3, e4, new cc(r4, n3, i3), false);
          const u3 = Ty({ z: r4, x: n3, y: i3 }, l3);
          return new mh([(s4 + u3.x / u3.scale) * e4, e4 * (u3.y / u3.scale), a3], [(s4 + u3.x2 / u3.scale) * e4, e4 * (u3.y2 / u3.scale), o3]);
        }, t2.by = function(t3, e4, r4) {
          let n3 = 0;
          for (let r5 = 0; r5 < 2; ++r5) {
            const i3 = 0;
            t3[r5] > i3 && (n3 += (t3[r5] - i3) * (t3[r5] - i3)), e4[r5] < i3 && (n3 += (i3 - e4[r5]) * (i3 - e4[r5]));
          }
          return n3;
        }, t2.bz = Ac, t2.c = eb, t2.c$ = [1, 1, 1], t2.c0 = ay, t2.c1 = Wr, t2.c2 = Ro, t2.c3 = s3, t2.c4 = Cr, t2.c5 = Tn, t2.c6 = ur, t2.c7 = function(t3, e4, r4) {
          return "custom" === t3.type ? new zg(t3, e4) : new _b[t3.type](t3, e4, r4);
        }, t2.c8 = function(t3) {
          const e4 = t3.indexOf(ml);
          return e4 >= 0 ? t3.slice(0, e4) : t3;
        }, t2.c9 = function(t3) {
          return t3.indexOf(ml) >= 0;
        }, t2.cA = (t3) => ({ u_matrix: new Tu(t3), u_pixels_to_tile_units: new Ru(t3), u_device_pixel_ratio: new Su(t3), u_units_to_pixels: new Iu(t3), u_dash_image: new Au(t3), u_gradient_image: new Au(t3), u_image_height: new Su(t3), u_texsize: new Iu(t3), u_tile_units_to_pixels: new Su(t3), u_alpha_discard_threshold: new Su(t3), u_trim_offset: new Iu(t3), u_emissive_strength: new Su(t3) }), t2.cB = (t3) => ({ u_matrix: new Tu(t3), u_texsize: new Iu(t3), u_pixels_to_tile_units: new Ru(t3), u_device_pixel_ratio: new Su(t3), u_image: new Au(t3), u_units_to_pixels: new Iu(t3), u_tile_units_to_pixels: new Su(t3), u_alpha_discard_threshold: new Su(t3), u_trim_offset: new Iu(t3) }), t2.cC = Nl, t2.cD = qd, t2.cE = Zd, t2.cF = Qh, t2.cG = (t3, e4, r4, n3, i3, s4) => {
          const a3 = t3.transform, o3 = "globe" === a3.projection.name;
          let l3;
          if ("map" === s4.paint.get("circle-pitch-alignment"))
            if (o3) {
              const t4 = Lh(a3.zoom, e4.canonical) * a3._pixelsPerMercatorPixel;
              l3 = Float32Array.from([t4, 0, 0, t4]);
            } else
              l3 = a3.calculatePixelsToTileUnitsMatrix(r4);
          else
            l3 = new Float32Array([a3.pixelsToGLUnits[0], 0, 0, a3.pixelsToGLUnits[1]]);
          const u3 = { u_camera_to_center_distance: t3.transform.getCameraToCenterDistance(a3.projection), u_matrix: t3.translatePosMatrix(e4.projMatrix, r4, s4.paint.get("circle-translate"), s4.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Tr.devicePixelRatio, u_extrude_scale: l3, u_inv_rot_matrix: Gh, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s4.paint.get("circle-emissive-strength") };
          if (o3) {
            u3.u_inv_rot_matrix = n3, u3.u_merc_center = i3, u3.u_tile_id = [e4.canonical.x, e4.canonical.y, 1 << e4.canonical.z], u3.u_zoom_transition = Oh(a3.zoom);
            const t4 = i3[0] * is, r5 = i3[1] * is;
            u3.u_up_dir = a3.projection.upVector(new cc(0, 0, 0), t4, r5);
          }
          return u3;
        }, t2.cH = Td, t2.cI = (t3, e4, r4, n3, i3, s4) => {
          const a3 = t3.transform;
          return { u_matrix: zd(t3, e4, r4, n3), u_texsize: e4.imageAtlasTexture ? e4.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: a3.calculatePixelsToTileUnitsMatrix(e4), u_device_pixel_ratio: i3, u_image: 0, u_tile_units_to_pixels: Ed(e4, a3), u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: s4 };
        }, t2.cJ = (t3, e4, r4, n3, i3, s4, a3) => {
          const o3 = t3.transform, l3 = o3.calculatePixelsToTileUnitsMatrix(e4);
          return { u_matrix: zd(t3, e4, r4, n3), u_pixels_to_tile_units: l3, u_device_pixel_ratio: s4, u_units_to_pixels: [1 / o3.pixelsToGLUnits[0], 1 / o3.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i3, u_texsize: Bd(r4) && e4.lineAtlasTexture ? e4.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ed(e4, t3.transform), u_alpha_discard_threshold: 0, u_trim_offset: a3, u_emissive_strength: r4.paint.get("line-emissive-strength") };
        }, t2.cK = nr, t2.cL = op, t2.cM = ad, t2.cN = dc, t2.cO = Hf, t2.cP = Nf, t2.cQ = 450, t2.cR = 7, t2.cS = Sg, t2.cT = 256, t2.cU = Vh, t2.cV = Wl, t2.cW = Yl, t2.cX = Xl, t2.cY = function(t3, e4, r4, n3, i3) {
          return Ze((t3 - e4) / (r4 - e4) * (i3 - n3) + n3, n3, i3);
        }, t2.cZ = Ic, t2.c_ = qg, t2.ca = function(t3) {
          const e4 = t3.indexOf(ml);
          return e4 >= 0 ? t3.slice(e4 + 1) : "";
        }, t2.cb = function(t3) {
          const e4 = [], r4 = t3.id;
          return void 0 === r4 && e4.push({ message: `layers.${r4}: missing required property "id"` }), void 0 === t3.render && e4.push({ message: `layers.${r4}: missing required method "render"` }), t3.renderingMode && "2d" !== t3.renderingMode && "3d" !== t3.renderingMode && e4.push({ message: `layers.${r4}: property "renderingMode" must be either "2d" or "3d"` }), e4;
        }, t2.cc = lr, t2.cd = Do, t2.ce = Hr, t2.cf = Eu, t2.cg = class extends Mu {
          constructor(t3) {
            super(t3), this.current = Bu;
          }
          set(t3, e4, r4) {
            if (this.fetchUniformLocation(t3, e4)) {
              for (let t4 = 0; t4 < 9; t4++)
                if (r4[t4] !== this.current[t4]) {
                  this.current = r4, this.gl.uniformMatrix3fv(this.location, false, r4);
                  break;
                }
            }
          }
        }, t2.ch = Qe, t2.ci = function(t3, e4, r4) {
          const n3 = Oh(r4.zoom), i3 = t3.style.map._antialias, s4 = e4.options.extStandardDerivativesForceOff || t3.terrain && t3.terrain.exaggeration() > 0;
          return 0 === n3 && !i3 && !s4;
        }, t2.cj = function(e4) {
          const r4 = e4.pixelsPerMeter, n3 = r4 / vc(1, e4.center.lat), i3 = t2.a9.identity(new Float64Array(16));
          return t2.a9.translate(i3, i3, [e4.point.x, e4.point.y, 0]), t2.a9.scale(i3, i3, [n3, n3, r4]), Float32Array.from(i3);
        }, t2.ck = Eh, t2.cl = function(t3) {
          const e4 = Ac - 5;
          t3 = Ze(t3, -e4, e4) / e4 * 90;
          const r4 = Math.pow(Math.abs(Math.sin(qe(t3))), 3);
          return Math.round(r4 * (Ju.length - 1));
        }, t2.cm = function(e4, r4, n3, i3) {
          const s4 = r4.getNorth(), a3 = r4.getSouth(), o3 = r4.getWest(), l3 = r4.getEast(), u3 = 1 << e4.z, c3 = l3 - o3, h2 = s4 - a3, p3 = c3 / Hu, f2 = -h2 / Ju[n3], d2 = [0, p3, 0, f2, 0, 0, s4, o3, 0];
          if (e4.z > 0) {
            const e5 = 180 / i3;
            t2.ct.multiply(d2, d2, [e5 / c3 + 1, 0, 0, 0, e5 / h2 + 1, 0, -0.5 * e5 / p3, 0.5 * e5 / f2, 1]);
          }
          return d2[2] = u3, d2[5] = e4.x, d2[8] = e4.y, d2;
        }, t2.cn = Sh, t2.co = function(e4, r4, n3) {
          const i3 = t2.a9.identity(new Float64Array(16)), s4 = (r4 / (1 << e4) - 0.5) * Math.PI * 2;
          return t2.a9.rotateY(i3, n3.globeMatrix, s4), Float32Array.from(i3);
        }, t2.cp = class {
          isDataAvailableAtPoint(t3) {
            const e4 = this._source();
            if (this.isUsingMockSource() || !e4 || t3.y < 0 || t3.y > 1)
              return false;
            const r4 = e4.getSource().maxzoom, n3 = 1 << r4, i3 = Math.floor(t3.x), s4 = Math.floor((t3.x - i3) * n3), a3 = Math.floor(t3.y * n3), o3 = this.findDEMTileFor(new pc(r4, i3, r4, s4, a3));
            return !(!o3 || !o3.dem);
          }
          getAtPointOrZero(t3, e4 = 0) {
            return this.getAtPoint(t3, e4) || 0;
          }
          getAtPoint(t3, e4, r4 = true) {
            if (this.isUsingMockSource())
              return null;
            null == e4 && (e4 = null);
            const n3 = this._source();
            if (!n3)
              return e4;
            if (t3.y < 0 || t3.y > 1)
              return e4;
            const i3 = n3.getSource().maxzoom, s4 = 1 << i3, a3 = Math.floor(t3.x), o3 = t3.x - a3, l3 = new pc(i3, a3, i3, Math.floor(o3 * s4), Math.floor(t3.y * s4)), u3 = this.findDEMTileFor(l3);
            if (!u3 || !u3.dem)
              return e4;
            const c3 = u3.dem, h2 = 1 << u3.tileID.canonical.z, p3 = (o3 * h2 - u3.tileID.canonical.x) * c3.dim, f2 = (t3.y * h2 - u3.tileID.canonical.y) * c3.dim, d2 = Math.floor(p3), m2 = Math.floor(f2);
            return (r4 ? this.exaggeration() : 1) * qn(qn(c3.get(d2, m2), c3.get(d2, m2 + 1), f2 - m2), qn(c3.get(d2 + 1, m2), c3.get(d2 + 1, m2 + 1), f2 - m2), p3 - d2);
          }
          getAtTileOffset(t3, e4, r4) {
            const n3 = 1 << t3.canonical.z;
            return this.getAtPointOrZero(new Ec(t3.wrap + (t3.canonical.x + e4 / is) / n3, (t3.canonical.y + r4 / is) / n3));
          }
          getAtTileOffsetFunc(e4, r4, n3, i3) {
            return (s4) => {
              const a3 = this.getAtTileOffset(e4, s4.x, s4.y), o3 = i3.upVector(e4.canonical, s4.x, s4.y), l3 = i3.upVectorScale(e4.canonical, r4, n3).metersToTile;
              return t2.Q.scale(o3, o3, a3 * l3), o3;
            };
          }
          getForTilePoints(t3, e4, r4, n3) {
            if (this.isUsingMockSource())
              return false;
            const i3 = Rf.create(this, t3, n3);
            return !!i3 && (e4.forEach((t4) => {
              t4[2] = this.exaggeration() * i3.getElevationAt(t4[0], t4[1], r4);
            }), true);
          }
          getMinMaxForTile(t3) {
            if (this.isUsingMockSource())
              return null;
            const e4 = this.findDEMTileFor(t3);
            if (!e4 || !e4.dem)
              return null;
            const r4 = e4.dem.tree, n3 = e4.tileID, i3 = 1 << t3.canonical.z - n3.canonical.z;
            let s4 = t3.canonical.x / i3 - n3.canonical.x, a3 = t3.canonical.y / i3 - n3.canonical.y, o3 = 0;
            for (let e5 = 0; e5 < t3.canonical.z - n3.canonical.z && !r4.leaves[o3]; e5++) {
              s4 *= 2, a3 *= 2;
              const t4 = 2 * Math.floor(a3) + Math.floor(s4);
              o3 = r4.childOffsets[o3] + t4, s4 %= 1, a3 %= 1;
            }
            return { min: this.exaggeration() * r4.minimums[o3], max: this.exaggeration() * r4.maximums[o3] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(t3, e4, r4) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(t3) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(t3) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
          getMinMaxForVisibleTiles() {
            const t3 = this.visibleDemTiles;
            if (0 === t3.length)
              return null;
            let e4 = false, r4 = Number.MAX_VALUE, n3 = Number.MIN_VALUE;
            for (const i3 of t3) {
              const t4 = this.getMinMaxForTile(i3.tileID);
              t4 && (r4 = Math.min(r4, t4.min), n3 = Math.max(n3, t4.max), e4 = true);
            }
            return e4 ? { min: r4, max: n3 } : null;
          }
        }, t2.cq = vh, t2.cr = ip, t2.cs = function(t3, e4) {
          return [Math.pow(t3[0], 2.2) * e4, Math.pow(t3[1], 2.2) * e4, Math.pow(t3[2], 2.2) * e4];
        }, t2.cu = Lh, t2.cv = Er, t2.cw = Pr, t2.cx = 256, t2.cy = function(e4, r4) {
          const n3 = [0, 0, 0], i3 = Rh(Sh(r4.canonical));
          return t2.Q.transformMat4(n3, n3, i3), t2.Q.transformMat4(n3, n3, e4), n3;
        }, t2.cz = (t3) => ({ u_camera_to_center_distance: new Su(t3), u_extrude_scale: new Ru(t3), u_device_pixel_ratio: new Su(t3), u_matrix: new Tu(t3), u_inv_rot_matrix: new Tu(t3), u_merc_center: new Iu(t3), u_tile_id: new ku(t3), u_zoom_transition: new Su(t3), u_up_dir: new ku(t3), u_emissive_strength: new Su(t3) }), t2.d = sn, t2.d$ = mx, t2.d0 = Rf, t2.d1 = ax, t2.d2 = Fl, t2.d3 = class {
          constructor() {
            this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [];
          }
          clear() {
            this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
          }
          get updateTime() {
            return this._updateTime;
          }
          getReplacementRegionsForTile(t3) {
            const e4 = xf(new Ue(0, 0), new Ue(is, is), t3), r4 = [];
            for (const n3 of this._activeRegions) {
              if (n3.hiddenByOverlap)
                continue;
              if (!gf(e4, n3))
                continue;
              const i3 = bf(n3.min, n3.max, t3);
              r4.push({ min: i3.min, max: i3.max, sourceId: this._sourceIds[n3.priority], footprint: n3.footprint, footprintTileId: n3.tileId });
            }
            return r4;
          }
          setSources(t3) {
            this._setSources(t3.map((t4) => ({ getSourceId: () => t4.cache.id, getFootprints: () => {
              const e4 = [];
              for (const r4 of t4.cache.getVisibleCoordinates()) {
                const n3 = t4.cache.getTile(r4).buckets[t4.layer];
                if (n3)
                  for (const t5 of n3.getNodesInfo()) {
                    const n4 = t5.node;
                    n4.footprint && e4.push({ footprint: n4.footprint, id: r4.toUnwrapped() });
                  }
              }
              return e4;
            } })));
          }
          _addSource(t3) {
            const e4 = t3.getFootprints();
            if (0 !== e4.length) {
              for (const t4 of e4) {
                if (!t4.footprint)
                  continue;
                const e5 = xf(t4.footprint.min, t4.footprint.max, t4.id);
                this._activeRegions.push({ min: e5.min, max: e5.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t4.id, footprint: t4.footprint });
              }
              this._sourceIds.push(t3.getSourceId());
            }
          }
          _computeReplacement() {
            this._activeRegions.sort((t4, e4) => t4.priority - e4.priority || mf(t4.min, e4.min) || mf(t4.max, e4.max));
            let t3 = this._activeRegions.length !== this._prevRegions.length;
            if (!t3) {
              let e4 = 0, r4 = 0;
              for (; !t3 && e4 !== this._activeRegions.length; ) {
                const n3 = this._activeRegions[e4], i3 = this._prevRegions[r4];
                t3 = n3.priority !== i3.priority || !yf(n3, i3), ++e4, ++r4;
              }
            }
            if (t3) {
              ++this._updateTime;
              const t4 = (t5) => {
                const e4 = this._activeRegions;
                if (t5 >= e4.length)
                  return t5;
                const r4 = e4[t5].priority;
                for (; t5 < e4.length && e4[t5].priority === r4; )
                  ++t5;
                return t5;
              };
              if (this._sourceIds.length > 1) {
                let e4 = 0, r4 = t4(e4);
                for (; e4 !== r4; ) {
                  let n3 = e4;
                  const i3 = e4;
                  for (; n3 !== r4; ) {
                    const t5 = this._activeRegions[n3];
                    t5.hiddenByOverlap = false;
                    for (let e5 = 0; e5 < i3; e5++) {
                      const r5 = this._activeRegions[e5];
                      if (!r5.hiddenByOverlap && gf(t5, r5) && (t5.hiddenByOverlap = _f(t5.footprint, t5.tileId, r5.footprint, r5.tileId), t5.hiddenByOverlap))
                        break;
                    }
                    ++n3;
                  }
                  e4 = r4, r4 = t4(e4);
                }
              }
            }
          }
          _setSources(t3) {
            [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
            for (let e4 = t3.length - 1; e4 >= 0; e4--)
              this._addSource(t3[e4]);
            this._computeReplacement();
          }
        }, t2.d4 = class {
          constructor(t3) {
            this._createGrid(t3), this._createPoles(t3);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const t3 of this._poleSegments)
              t3.destroy();
            for (const t3 of this._gridSegments)
              t3.withSkirts.destroy(), t3.withoutSkirts.destroy();
          }
          _fillGridMeshWithLods(t3, e4) {
            const r4 = new Sl(), n3 = new ql(), i3 = [], s4 = t3 + 1 + 2, a3 = e4[0] + 1, o3 = e4[0] + 1 + (1 + e4.length), l3 = (t4, e5, r5) => {
              let n4 = t4 === s4 - 1 ? t4 - 2 : 0 === t4 ? t4 : t4 - 1;
              return n4 += r5 ? 24575 : 0, [n4, e5];
            };
            for (let t4 = 0; t4 < s4; ++t4)
              r4.emplaceBack(...l3(t4, 0, true));
            for (let t4 = 0; t4 < a3; ++t4)
              for (let e5 = 0; e5 < s4; ++e5)
                r4.emplaceBack(...l3(e5, t4, (0 === e5 || e5 === s4 - 1) && true));
            for (let t4 = 0; t4 < e4.length; ++t4) {
              const n4 = e4[t4];
              for (let t5 = 0; t5 < s4; ++t5)
                r4.emplaceBack(...l3(t5, n4, true));
            }
            for (let t4 = 0; t4 < e4.length; ++t4) {
              const a4 = n3.length, l4 = e4[t4] + 1 + 2, u3 = new ql();
              for (let r5 = 0; r5 < l4 - 1; r5++) {
                const i4 = r5 === l4 - 2, a5 = i4 ? s4 * (o3 - e4.length + t4 - r5) : s4;
                for (let t5 = 0; t5 < s4 - 1; t5++) {
                  const e5 = r5 * s4 + t5;
                  0 === r5 || i4 || 0 === t5 || t5 === s4 - 2 ? (u3.emplaceBack(e5 + 1, e5, e5 + a5), u3.emplaceBack(e5 + a5, e5 + a5 + 1, e5 + 1)) : (n3.emplaceBack(e5 + 1, e5, e5 + a5), n3.emplaceBack(e5 + a5, e5 + a5 + 1, e5 + 1));
                }
              }
              const c3 = mu.simpleSegment(0, a4, r4.length, n3.length - a4);
              for (let t5 = 0; t5 < u3.uint16.length; t5 += 3)
                n3.emplaceBack(u3.uint16[t5], u3.uint16[t5 + 1], u3.uint16[t5 + 2]);
              const h2 = mu.simpleSegment(0, a4, r4.length, n3.length - a4);
              i3.push({ withoutSkirts: c3, withSkirts: h2 });
            }
            return { vertices: r4, indices: n3, segments: i3 };
          }
          _createGrid(t3) {
            const e4 = this._fillGridMeshWithLods(Hu, Ju);
            this._gridSegments = e4.segments, this._gridBuffer = t3.createVertexBuffer(e4.vertices, bh.members), this._gridIndexBuffer = t3.createIndexBuffer(e4.indices, true);
          }
          _createPoles(t3) {
            const e4 = new ql();
            for (let t4 = 0; t4 <= Hu; t4++)
              e4.emplaceBack(0, t4 + 1, t4 + 2);
            this._poleIndexBuffer = t3.createIndexBuffer(e4, true);
            const r4 = new Yl(), n3 = new Yl(), i3 = new Yl(), s4 = new Yl();
            this._poleSegments = [];
            for (let t4 = 0, e5 = 0; t4 < Zu; t4++) {
              const a3 = 360 / (1 << t4);
              r4.emplaceBack(0, -Xu, 0, 0.5, 0), n3.emplaceBack(0, -Xu, 0, 0.5, 1), i3.emplaceBack(0, -Xu, 0, 0.5, 0.5), s4.emplaceBack(0, -Xu, 0, 0.5, 0.5);
              for (let t5 = 0; t5 <= Hu; t5++) {
                let e6 = t5 / Hu, o3 = 0;
                const l3 = qn(0, a3, e6), [u3, c3, h2] = rc(qh, $h, l3, Xu);
                r4.emplaceBack(u3, c3, h2, e6, o3), n3.emplaceBack(u3, c3, h2, e6, 1 - o3);
                const p3 = qe(l3);
                e6 = 0.5 + 0.5 * Math.sin(p3), o3 = 0.5 + 0.5 * Math.cos(p3), i3.emplaceBack(u3, c3, h2, e6, o3), s4.emplaceBack(u3, c3, h2, e6, 1 - o3);
              }
              this._poleSegments.push(mu.simpleSegment(e5, 0, 66, 64)), e5 += 66;
            }
            this._poleNorthVertexBuffer = t3.createVertexBuffer(r4, gh, false), this._poleSouthVertexBuffer = t3.createVertexBuffer(n3, gh, false), this._texturedPoleNorthVertexBuffer = t3.createVertexBuffer(i3, gh, false), this._texturedPoleSouthVertexBuffer = t3.createVertexBuffer(s4, gh, false);
          }
          getGridBuffers(t3, e4) {
            return [this._gridBuffer, this._gridIndexBuffer, e4 ? this._gridSegments[t3].withSkirts : this._gridSegments[t3].withoutSkirts];
          }
          getPoleBuffers(t3, e4) {
            return [e4 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e4 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t3]];
          }
        }, t2.d5 = function(t3) {
          return An.has(t3);
        }, t2.d6 = Ye, t2.d7 = function() {
          return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, t2.d8 = Xe, t2.d9 = kc, t2.dA = vx, t2.dB = function(t3) {
          const e4 = Or();
          if (!e4)
            return;
          const r4 = e4.delete(Rr);
          t3 && r4.catch(t3).then(() => t3());
        }, t2.dC = gx, t2.dD = Ex, t2.dE = function(t3) {
          Ax = Tr.resolveURL(t3), Px || (Px = new yx(wx(), new Dn())), Px.broadcast("setDracoUrl", Ax);
        }, t2.dF = zx, t2.dG = function(t3) {
          Ix = Tr.resolveURL(t3), Px || (Px = new yx(wx(), new Dn())), Px.broadcast("setMeshoptUrl", Ix);
        }, t2.dH = fo, t2.dI = rp, t2.dJ = sy, t2.dK = ib, t2.dL = ob, t2.dM = _d, t2.dN = or, t2.dO = ey, t2.dP = function(t3, e4, r4, n3, i3, s4, a3, o3, l3, u3, c3) {
          t3.createArrays(), t3.tilePixelRatio = is / (512 * t3.overscaling), t3.compareText = {}, t3.iconsNeedLinear = false;
          const h2 = t3.layers[0].layout, p3 = t3.layers[0]._unevaluatedLayout._values, f2 = {};
          if ("composite" === t3.textSizeData.kind) {
            const { minZoom: e5, maxZoom: r5 } = t3.textSizeData;
            f2.compositeTextSizes = [p3["text-size"].possiblyEvaluate(new Uo(e5), o3), p3["text-size"].possiblyEvaluate(new Uo(r5), o3)];
          }
          if ("composite" === t3.iconSizeData.kind) {
            const { minZoom: e5, maxZoom: r5 } = t3.iconSizeData;
            f2.compositeIconSizes = [p3["icon-size"].possiblyEvaluate(new Uo(e5), o3), p3["icon-size"].possiblyEvaluate(new Uo(r5), o3)];
          }
          f2.layoutTextSize = p3["text-size"].possiblyEvaluate(new Uo(l3 + 1), o3), f2.layoutIconSize = p3["icon-size"].possiblyEvaluate(new Uo(l3 + 1), o3), f2.textMaxSize = p3["text-size"].possiblyEvaluate(new Uo(18), o3);
          const d2 = "map" === h2.get("text-rotation-alignment") && "point" !== h2.get("symbol-placement"), m2 = h2.get("text-size");
          let y3 = false;
          for (const e5 of t3.features)
            if (e5.icon && e5.icon.nameSecondary) {
              y3 = true;
              break;
            }
          for (const s5 of t3.features) {
            const l4 = h2.get("text-font").evaluate(s5, {}, o3).join(","), p4 = m2.evaluate(s5, {}, o3), g3 = f2.layoutTextSize.evaluate(s5, {}, o3), x3 = (f2.layoutIconSize.evaluate(s5, {}, o3), { horizontal: {}, vertical: void 0 }), b2 = s5.text;
            let v3, _3 = [0, 0];
            if (b2) {
              const n4 = b2.toString(), a4 = h2.get("text-letter-spacing").evaluate(s5, {}, o3) * $d, u4 = h2.get("text-line-height").evaluate(s5, {}, o3) * $d, c4 = _o(n4) ? a4 : 0, f3 = h2.get("text-anchor").evaluate(s5, {}, o3), m3 = h2.get("text-variable-anchor");
              if (!m3) {
                const t4 = h2.get("text-radial-offset").evaluate(s5, {}, o3);
                _3 = t4 ? vy(f3, [t4 * $d, xy]) : h2.get("text-offset").evaluate(s5, {}, o3).map((t5) => t5 * $d);
              }
              let y4 = d2 ? "center" : h2.get("text-justify").evaluate(s5, {}, o3);
              const v4 = "point" === h2.get("symbol-placement"), w3 = v4 ? h2.get("text-max-width").evaluate(s5, {}, o3) * $d : 1 / 0, M4 = (s6) => {
                t3.allowVerticalPlacement && vo(n4) && (x3.vertical = Tm(b2, e4, r4, i3, l4, w3, u4, f3, s6, c4, _3, Pm.vertical, true, g3, p4));
              };
              if (!d2 && m3) {
                const t4 = "auto" === y4 ? m3.map((t5) => _y(t5)) : [y4];
                let n5 = false;
                for (let s6 = 0; s6 < t4.length; s6++) {
                  const a5 = t4[s6];
                  if (!x3.horizontal[a5])
                    if (n5)
                      x3.horizontal[a5] = x3.horizontal[0];
                    else {
                      const t5 = Tm(b2, e4, r4, i3, l4, w3, u4, "center", a5, c4, _3, Pm.horizontal, false, g3, p4);
                      t5 && (x3.horizontal[a5] = t5, n5 = 1 === t5.positionedLines.length);
                    }
                }
                M4("left");
              } else {
                if ("auto" === y4 && (y4 = _y(f3)), v4 || h2.get("text-writing-mode").indexOf("horizontal") >= 0 || !vo(n4)) {
                  const t4 = Tm(b2, e4, r4, i3, l4, w3, u4, f3, y4, c4, _3, Pm.horizontal, false, g3, p4);
                  t4 && (x3.horizontal[y4] = t4);
                }
                M4(v4 ? "left" : y4);
              }
            }
            let w2 = false;
            if (s5.icon && s5.icon.namePrimary) {
              const e5 = n3[s5.icon.namePrimary];
              e5 && (v3 = Nm(i3[s5.icon.namePrimary], s5.icon.nameSecondary ? i3[s5.icon.nameSecondary] : void 0, h2.get("icon-offset").evaluate(s5, {}, o3), h2.get("icon-anchor").evaluate(s5, {}, o3)), w2 = e5.sdf, void 0 === t3.sdfIcons ? t3.sdfIcons = e5.sdf : t3.sdfIcons !== e5.sdf && hr("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e5.pixelRatio !== t3.pixelRatio || 0 !== h2.get("icon-rotate").constantOr(1)) && (t3.iconsNeedLinear = true));
            }
            const M3 = Iy(x3.horizontal) || x3.vertical;
            t3.iconsInText || (t3.iconsInText = !!M3 && M3.iconsInText), (M3 || v3) && wy(t3, s5, x3, v3, n3, f2, g3, 0, _3, w2, a3, o3, u3, c3, y3);
          }
          s4 && t3.generateCollisionDebugBuffers(l3, t3.collisionBoxArray);
        }, t2.dQ = pf, t2.dR = wm, t2.dS = Cf, t2.dT = ff, t2.dU = Jp, t2.dV = Fe, t2.dW = em, t2.dX = h, t2.dY = function(t3) {
          let e4 = 0;
          if (new Uint32Array(t3, 0, 1)[0] !== Ox) {
            const r4 = new Uint32Array(t3, 0, 7), [, , n3, i3, s4, a3] = r4;
            e4 = r4.byteLength + i3 + s4 + a3 + s4, (n3 !== t3.byteLength || e4 >= t3.byteLength) && hr("Invalid b3dm header information.");
          }
          return Gx(t3, e4);
        }, t2.dZ = function(t3, e4) {
          const r4 = eb(t3);
          for (const t4 of r4) {
            for (const e5 of t4.meshes)
              rb(e5);
            t4.lights && (t4.lightMeshIndex = t4.meshes.length, t4.meshes.push(nb(t4.lights, e4)));
          }
          return r4;
        }, t2.d_ = yb, t2.da = nc, t2.db = function([t3, e4, r4]) {
          const n3 = Math.hypot(t3, e4, r4), i3 = Math.atan2(t3, r4), s4 = 0.5 * Math.PI - Math.acos(-e4 / n3);
          return new ac($e(i3), $e(s4));
        }, t2.dc = ic, t2.dd = n2, t2.de = Nh, t2.df = Uh, t2.dg = function(e4) {
          const r4 = [0, 0, 0], n3 = t2.a9.identity(new Float64Array(16));
          return t2.a9.multiply(n3, e4.pixelMatrix, e4.globeMatrix), t2.Q.transformMat4(r4, r4, n3), new Ue(r4[0], r4[1]);
        }, t2.dh = function(t3) {
          const e4 = t3.navigator ? t3.navigator.userAgent : null;
          return !!function(t4) {
            if (null == Mr) {
              const e5 = t4.navigator ? t4.navigator.userAgent : null;
              Mr = !!t4.safari || !(!e5 || !(/\b(iPad|iPhone|iPod)\b/.test(e5) || e5.match("Safari") && !e5.match("Chrome")));
            }
            return Mr;
          }(t3) && e4 && (e4.match("Version/15.4") || e4.match("Version/15.5") || e4.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t2.di = class {
          constructor(t3, e4, r4) {
            this._transformRequestFn = t3, this._customAccessToken = e4, this._silenceAuthErrors = !!r4, this._createSkuToken();
          }
          _createSkuToken() {
            const t3 = function() {
              let t4 = "";
              for (let e4 = 0; e4 < 10; e4++)
                t4 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", an, t4].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t3.token, this._skuTokenExpiresAt = t3.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t3, e4) {
            return this._transformRequestFn && this._transformRequestFn(t3, e4) || { url: t3 };
          }
          normalizeStyleURL(t3, r4) {
            if (!s3(t3))
              return t3;
            const n3 = un(t3);
            return n3.params.push(`sdk=js-${e3}`), n3.path = `/styles/v1${n3.path}`, this._makeAPIURL(n3, this._customAccessToken || r4);
          }
          normalizeGlyphsURL(t3, e4) {
            if (!s3(t3))
              return t3;
            const r4 = un(t3);
            return r4.path = `/fonts/v1${r4.path}`, this._makeAPIURL(r4, this._customAccessToken || e4);
          }
          normalizeModelURL(t3, e4) {
            if (!s3(t3))
              return t3;
            const r4 = un(t3);
            return r4.path = `/models/v1${r4.path}`, this._makeAPIURL(r4, this._customAccessToken || e4);
          }
          normalizeSourceURL(t3, e4, r4, n3) {
            if (!s3(t3))
              return t3;
            const i3 = un(t3);
            return i3.path = `/v4/${i3.authority}.json`, i3.params.push("secure"), r4 && i3.params.push(`language=${r4}`), n3 && i3.params.push(`worldview=${n3}`), this._makeAPIURL(i3, this._customAccessToken || e4);
          }
          normalizeSpriteURL(t3, e4, r4, n3) {
            const i3 = un(t3);
            return s3(t3) ? (i3.path = `/styles/v1${i3.path}/sprite${e4}${r4}`, this._makeAPIURL(i3, this._customAccessToken || n3)) : (i3.path += `${e4}${r4}`, cn2(i3));
          }
          normalizeTileURL(t3, e4, r4) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t3 && !s3(t3))
              return t3;
            const i3 = un(t3);
            i3.path = i3.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e4 || r4 && "raster" !== i3.authority && 512 === r4 ? "@2x" : ""}${jr.supported ? ".webp" : "$1"}`), "raster" === i3.authority ? i3.path = `/${n2.RASTER_URL_PREFIX}${i3.path}` : "rasterarrays" === i3.authority ? i3.path = `/${n2.RASTERARRAYS_URL_PREFIX}${i3.path}` : (i3.path = i3.path.replace(/^.+\/v4\//, "/"), i3.path = `/${n2.TILE_URL_VERSION}${i3.path}`);
            const a3 = this._customAccessToken || function(t4) {
              for (const e5 of t4) {
                const t5 = e5.match(/^access_token=(.*)$/);
                if (t5)
                  return t5[1];
              }
              return null;
            }(i3.params) || n2.ACCESS_TOKEN;
            return n2.REQUIRE_ACCESS_TOKEN && a3 && this._skuToken && i3.params.push(`sku=${this._skuToken}`), this._makeAPIURL(i3, a3);
          }
          canonicalizeTileURL(t3, e4) {
            const r4 = un(t3);
            if (!r4.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !r4.path.match(/\.[\w]+$/))
              return t3;
            let i3 = "mapbox://";
            r4.path.match(/^\/raster\/v1\//) ? i3 += `raster/${r4.path.replace(`/${n2.RASTER_URL_PREFIX}/`, "")}` : r4.path.match(/^\/rasterarrays\/v1\//) ? i3 += `rasterarrays/${r4.path.replace(`/${n2.RASTERARRAYS_URL_PREFIX}/`, "")}` : i3 += `tiles/${r4.path.replace(`/${n2.TILE_URL_VERSION}/`, "")}`;
            let s4 = r4.params;
            return e4 && (s4 = s4.filter((t4) => !t4.match(/^access_token=/))), s4.length && (i3 += `?${s4.join("&")}`), i3;
          }
          canonicalizeTileset(t3, e4) {
            const r4 = !!e4 && s3(e4), n3 = [];
            for (const e5 of t3.tiles || [])
              i2(e5) ? n3.push(this.canonicalizeTileURL(e5, r4)) : n3.push(e5);
            return n3;
          }
          _makeAPIURL(t3, e4) {
            const r4 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", i3 = un(n2.API_URL);
            if (t3.protocol = i3.protocol, t3.authority = i3.authority, "http" === t3.protocol) {
              const e5 = t3.params.indexOf("secure");
              e5 >= 0 && t3.params.splice(e5, 1);
            }
            if ("/" !== i3.path && (t3.path = `${i3.path}${t3.path}`), !n2.REQUIRE_ACCESS_TOKEN)
              return cn2(t3);
            if (e4 = e4 || n2.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!e4)
                throw new Error(`An API access token is required to use Mapbox GL. ${r4}`);
              if ("s" === e4[0])
                throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r4}`);
            }
            return t3.params = t3.params.filter((t4) => -1 === t4.indexOf("access_token")), t3.params.push(`access_token=${e4 || ""}`), cn2(t3);
          }
        }, t2.dj = function(t3, e4) {
          e4 ? An.add(t3) : An.delete(t3);
        }, t2.dk = jr, t2.dl = _n, t2.dm = Mn, t2.dn = on, t2.dp = gn, t2.dq = bn, t2.dr = function(t3) {
          An.delete(t3);
        }, t2.ds = wn, t2.dt = yn, t2.du = e3, t2.dv = function(t3, e4) {
          Vr = t3, Dr = e4;
        }, t2.dw = function(t3, e4, r4 = false) {
          if (Bo === Po || Bo === Eo || Bo === zo)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          Co = Tr.resolveURL(t3), Bo = Po, To = e4, Vo(), r4 || Fo();
        }, t2.dx = Lo, t2.dy = function() {
          wx().acquire(bx);
        }, t2.dz = function() {
          const t3 = _x;
          t3 && (t3.isPreloaded() && 1 === t3.numActive() ? (t3.release(bx), _x = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t2.e = Je, t2.e0 = Oo, t2.e1 = function(t3) {
          Ur(), Lr && Lr.then((e4) => {
            e4.keys().then((r4) => {
              for (let n3 = 0; n3 < r4.length - t3; n3++)
                e4.delete(r4[n3]);
            });
          });
        }, t2.f = Tr, t2.g = function(t3, e4) {
          return Hr(Je(t3, { type: "json" }), e4);
        }, t2.h = np, t2.i = class extends Hg {
        }, t2.j = Si, t2.k = Qn, t2.l = function(t3) {
          return fetch(t3).then((t4) => t4.arrayBuffer()).then((e4) => Gx(e4, 0, t3));
        }, t2.m = ja, t2.n = $a, t2.o = eo, t2.p = Hm, t2.q = tl, t2.r = so, t2.s = Ga, t2.t = ro, t2.u = Jo, t2.v = Os, t2.w = hr, t2.x = Ns, t2.y = Fs;
      });
      define2(["./shared"], function(e3) {
        "use strict";
        function t2(e4) {
          const t3 = e4 ? e4.url.toString() : void 0;
          return t3 ? performance.getEntriesByName(t3) : [];
        }
        function s3(e4) {
          if ("number" == typeof e4 || "boolean" == typeof e4 || "string" == typeof e4 || null == e4)
            return JSON.stringify(e4);
          if (Array.isArray(e4)) {
            let t4 = "[";
            for (const i3 of e4)
              t4 += `${s3(i3)},`;
            return `${t4}]`;
          }
          let t3 = "{";
          for (const i3 of Object.keys(e4).sort())
            t3 += `${i3}:${s3(e4[i3])},`;
          return `${t3}}`;
        }
        function i2(t3) {
          let i3 = "";
          for (const o3 of e3.b5)
            i3 += `/${s3(t3[o3])}`;
          return i3;
        }
        class o2 {
          constructor(e4) {
            this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e4 && this.replace(e4);
          }
          replace(e4, t3) {
            this._layerConfigs = {}, this._layers = {}, this.update(e4, [], t3);
          }
          update(t3, s4, o3) {
            this._options = o3;
            for (const s5 of t3)
              this._layerConfigs[s5.id] = s5, (this._layers[s5.id] = e3.c7(s5, this.scope, this._options)).compileFilter(), this.keyCache[s5.id] && delete this.keyCache[s5.id];
            for (const e4 of s4)
              delete this.keyCache[e4], delete this._layerConfigs[e4], delete this._layers[e4];
            this.familiesBySource = {};
            const r4 = function(e4, t4) {
              const s5 = {};
              for (let o5 = 0; o5 < e4.length; o5++) {
                const r5 = t4 && t4[e4[o5].id] || i2(e4[o5]);
                t4 && (t4[e4[o5].id] = r5);
                let n3 = s5[r5];
                n3 || (n3 = s5[r5] = []), n3.push(e4[o5]);
              }
              const o4 = [];
              for (const e5 in s5)
                o4.push(s5[e5]);
              return o4;
            }(e3.b2(this._layerConfigs), this.keyCache);
            for (const e4 of r4) {
              const t4 = e4.map((e5) => this._layers[e5.id]), s5 = t4[0];
              if ("none" === s5.visibility)
                continue;
              const i3 = s5.source || "";
              let o4 = this.familiesBySource[i3];
              o4 || (o4 = this.familiesBySource[i3] = {});
              const r5 = s5.sourceLayer || "_geojsonTileLayer";
              let n3 = o4[r5];
              n3 || (n3 = o4[r5] = []), n3.push(t4);
            }
          }
        }
        const r3 = 1 * e3.dJ;
        class n2 {
          constructor(t3) {
            const s4 = {}, i3 = [];
            for (const e4 in t3) {
              const o4 = t3[e4], n4 = s4[e4] = {};
              for (const e5 in o4.glyphs) {
                const t4 = o4.glyphs[+e5];
                if (!t4 || 0 === t4.bitmap.width || 0 === t4.bitmap.height)
                  continue;
                const s5 = t4.metrics.localGlyph ? r3 : 1, a4 = { x: 0, y: 0, w: t4.bitmap.width + 2 * s5, h: t4.bitmap.height + 2 * s5 };
                i3.push(a4), n4[e5] = a4;
              }
            }
            const { w: o3, h: n3 } = e3.p(i3), a3 = new e3.dI({ width: o3 || 1, height: n3 || 1 });
            for (const i4 in t3) {
              const o4 = t3[i4];
              for (const t4 in o4.glyphs) {
                const n4 = o4.glyphs[+t4];
                if (!n4 || 0 === n4.bitmap.width || 0 === n4.bitmap.height)
                  continue;
                const l3 = s4[i4][t4], h2 = n4.metrics.localGlyph ? r3 : 1;
                e3.dI.copy(n4.bitmap, a3, { x: 0, y: 0 }, { x: l3.x + h2, y: l3.y + h2 }, n4.bitmap);
              }
            }
            this.image = a3, this.positions = s4;
          }
        }
        e3.dH(n2, "GlyphAtlas");
        class a2 {
          constructor(t3) {
            this.tileID = new e3.ap(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.tileZoom = t3.tileZoom, this.uid = t3.uid, this.zoom = t3.zoom, this.canonical = t3.tileID.canonical, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.scope = t3.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.promoteId = t3.promoteId, this.isSymbolTile = t3.isSymbolTile, this.tileTransform = e3.av(t3.tileID.canonical, t3.projection), this.projection = t3.projection, this.brightness = t3.brightness, this.extraShadowCaster = !!t3.extraShadowCaster;
          }
          parse(t3, s4, i3, o3, r4) {
            this.status = "parsing", this.data = t3, this.collisionBoxArray = new e3.aG();
            const a3 = new e3.dK(Object.keys(t3.layers).sort()), h2 = new e3.dL(this.tileID, this.promoteId);
            h2.bucketLayerIDs = [];
            const c3 = {}, u3 = new e3.dM(256, 256), d2 = { featureIndex: h2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: u3, availableImages: i3, brightness: this.brightness }, p3 = s4.familiesBySource[this.source];
            for (const s5 in p3) {
              const o4 = t3.layers[s5];
              if (!o4)
                continue;
              let r5 = false, n3 = false, u4 = false;
              for (const e4 of p3[s5])
                "symbol" === e4[0].type ? r5 = true : n3 = true, e4[0].is3D() && "model" !== e4[0].type && (u4 = true);
              if (this.extraShadowCaster && !u4)
                continue;
              if (true === this.isSymbolTile && !r5)
                continue;
              if (false === this.isSymbolTile && !n3)
                continue;
              1 === o4.version && e3.w(`Vector tile source "${this.source}" layer "${s5}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const f3 = a3.encode(s5), g4 = [];
              for (let e4 = 0; e4 < o4.length; e4++) {
                const t4 = o4.feature(e4), i4 = h2.getId(t4, s5);
                g4.push({ feature: t4, id: i4, index: e4, sourceLayerIndex: f3 });
              }
              for (const e4 of p3[s5]) {
                const t4 = e4[0];
                (!this.extraShadowCaster || t4.is3D() && "model" !== t4.type) && (void 0 !== this.isSymbolTile && "symbol" === t4.type !== this.isSymbolTile || t4.minzoom && this.zoom < Math.floor(t4.minzoom) || t4.maxzoom && this.zoom >= t4.maxzoom || "none" !== t4.visibility && (l2(e4, this.zoom, d2.brightness, i3), (c3[t4.id] = t4.createBucket({ index: h2.bucketLayerIDs.length, layers: e4, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: f3, sourceID: this.source, projection: this.projection.spec })).populate(g4, d2, this.tileID.canonical, this.tileTransform), h2.bucketLayerIDs.push(e4.map((e5) => e5.id))));
              }
            }
            let f2, g3, m2, y3;
            u3.trim();
            const v3 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, x3 = () => {
              if (f2)
                return this.status = "done", r4(f2);
              if (this.extraShadowCaster)
                this.status = "done", r4(null, { buckets: e3.b2(c3).filter((e4) => !e4.isEmpty()), featureIndex: h2, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: d2.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
              else if (g3 && m2 && y3) {
                const t4 = new n2(g3), s5 = new e3.dO(m2, y3);
                for (const o4 in c3) {
                  const r5 = c3[o4];
                  r5 instanceof e3.aH ? (l2(r5.layers, this.zoom, d2.brightness, i3), e3.dP(r5, g3, t4.positions, m2, s5.iconPositions, this.showCollisionBoxes, i3, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : r5.hasPattern && (r5 instanceof e3.aN || r5 instanceof e3.aO || r5 instanceof e3.cO) && (l2(r5.layers, this.zoom, d2.brightness, i3), r5.addFeatures(d2, this.tileID.canonical, s5.patternPositions, i3, this.tileTransform, this.brightness));
                }
                this.status = "done", r4(null, { buckets: e3.b2(c3).filter((e4) => !e4.isEmpty()), featureIndex: h2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t4.image, lineAtlas: u3, imageAtlas: s5, brightness: d2.brightness });
              }
            };
            if (!this.extraShadowCaster) {
              const t4 = e3.dN(d2.glyphDependencies, (e4) => Object.keys(e4).map(Number));
              Object.keys(t4).length ? o3.send("getGlyphs", { uid: this.uid, stacks: t4, scope: this.scope }, (e4, t5) => {
                f2 || (f2 = e4, g3 = t5, x3());
              }, void 0, false, v3) : g3 = {};
              const s5 = Object.keys(d2.iconDependencies);
              s5.length ? o3.send("getImages", { icons: s5, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e4, t5) => {
                f2 || (f2 = e4, m2 = t5, x3());
              }, void 0, false, v3) : m2 = {};
              const i4 = Object.keys(d2.patternDependencies);
              i4.length ? o3.send("getImages", { icons: i4, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e4, t5) => {
                f2 || (f2 = e4, y3 = t5, x3());
              }, void 0, false, v3) : y3 = {};
            }
            x3();
          }
        }
        function l2(t3, s4, i3, o3) {
          const r4 = new e3.N(s4, { brightness: i3 });
          for (const e4 of t3)
            e4.recalculate(r4, o3);
        }
        class h extends e3.E {
          constructor(t3, s4, i3, o3, r4, n3) {
            super(), this.actor = t3, this.layerIndex = s4, this.availableImages = i3, this.loadVectorData = r4 || e3.ak, this.loading = {}, this.loaded = {}, this.deduped = new e3.ai(t3.scheduler), this.isSpriteLoaded = o3, this.scheduler = t3.scheduler, this.brightness = n3;
          }
          loadTile(s4, i3) {
            const o3 = s4.uid, r4 = s4 && s4.request, n3 = r4 && r4.collectResourceTiming, l3 = this.loading[o3] = new a2(s4);
            l3.abort = this.loadVectorData(s4, (a3, h2) => {
              const c3 = !this.loading[o3];
              if (delete this.loading[o3], c3 || a3 || !h2)
                return l3.status = "done", c3 || (this.loaded[o3] = l3), i3(a3);
              const u3 = h2.rawData, d2 = {};
              h2.expires && (d2.expires = h2.expires), h2.cacheControl && (d2.cacheControl = h2.cacheControl), l3.vectorTile = h2.vectorTile || new e3.dQ(new e3.dR(u3));
              const p3 = () => {
                l3.parse(l3.vectorTile, this.layerIndex, this.availableImages, this.actor, (s5, o4) => {
                  if (s5 || !o4)
                    return i3(s5);
                  const a4 = {};
                  if (n3) {
                    const e4 = t2(r4);
                    e4.length > 0 && (a4.resourceTiming = JSON.parse(JSON.stringify(e4)));
                  }
                  i3(null, e3.e({ rawTileData: u3.slice(0) }, o4, d2, a4));
                });
              };
              this.isSpriteLoaded ? p3() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(p3, { type: "parseTile", isSymbolTile: s4.isSymbolTile, zoom: s4.tileZoom }) : p3();
              }), this.loaded = this.loaded || {}, this.loaded[o3] = l3;
            });
          }
          reloadTile(t3, s4) {
            const i3 = this.loaded, o3 = t3.uid, r4 = this;
            if (i3 && i3[o3]) {
              const n3 = i3[o3];
              n3.showCollisionBoxes = t3.showCollisionBoxes, n3.projection = t3.projection, n3.brightness = t3.brightness, n3.tileTransform = e3.av(t3.tileID.canonical, t3.projection), n3.extraShadowCaster = t3.extraShadowCaster;
              const a3 = (e4, t4) => {
                const i4 = n3.reloadCallback;
                i4 && (delete n3.reloadCallback, n3.parse(n3.vectorTile, r4.layerIndex, this.availableImages, r4.actor, i4)), s4(e4, t4);
              };
              "parsing" === n3.status ? n3.reloadCallback = a3 : "done" === n3.status && (n3.vectorTile ? n3.parse(n3.vectorTile, this.layerIndex, this.availableImages, this.actor, a3) : a3());
            } else
              s4(null, void 0);
          }
          abortTile(e4, t3) {
            const s4 = e4.uid, i3 = this.loading[s4];
            i3 && (i3.abort && i3.abort(), delete this.loading[s4]), t3();
          }
          removeTile(e4, t3) {
            const s4 = this.loaded, i3 = e4.uid;
            s4 && s4[i3] && delete s4[i3], t3();
          }
        }
        class c2 {
          loadTile(t3, s4) {
            const { uid: i3, encoding: o3, rawImageData: r4, padding: n3 } = t3, a3 = ImageBitmap && r4 instanceof ImageBitmap ? this.getImageData(r4, n3) : r4;
            s4(null, new e3.dS(i3, a3, o3, n3 < 1));
          }
          getImageData(e4, t3) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e4.width, e4.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e4.width, this.offscreenCanvas.height = e4.height, this.offscreenCanvasContext.drawImage(e4, 0, 0, e4.width, e4.height);
            const s4 = this.offscreenCanvasContext.getImageData(-t3, -t3, e4.width + 2 * t3, e4.height + 2 * t3);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s4;
          }
        }
        class u2 {
          decodeRasterArray({ task: t3, buffer: s4 }, i3) {
            e3.b0.performDecoding(s4, t3).then((e4) => {
              i3(null, e4);
            }, (e4) => {
              i3(e4);
            });
          }
        }
        const d = e3.dT.prototype.toGeoJSON;
        let p2 = class {
          constructor(t3) {
            this._feature = t3, this.extent = e3.Y, this.type = t3.type, this.properties = t3.tags, "id" in t3 && !isNaN(t3.id) && (this.id = parseInt(t3.id, 10));
          }
          loadGeometry() {
            if (1 === this._feature.type) {
              const t3 = [];
              for (const s4 of this._feature.geometry)
                t3.push([new e3.P(s4[0], s4[1])]);
              return t3;
            }
            {
              const t3 = [];
              for (const s4 of this._feature.geometry) {
                const i3 = [];
                for (const t4 of s4)
                  i3.push(new e3.P(t4[0], t4[1]));
                t3.push(i3);
              }
              return t3;
            }
          }
          toGeoJSON(e4, t3, s4) {
            return d.call(this, e4, t3, s4);
          }
        }, f = class {
          constructor(t3) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e3.Y, this.length = t3.length, this._features = t3;
          }
          feature(e4) {
            return new p2(this._features[e4]);
          }
        };
        var g2 = { exports: {} }, m = e3.dV, y2 = e3.dU.VectorTileFeature, v2 = x2;
        function x2(e4, t3) {
          this.options = t3 || {}, this.features = e4, this.length = e4.length;
        }
        function w(e4, t3) {
          this.id = "number" == typeof e4.id ? e4.id : void 0, this.type = e4.type, this.rawGeometry = 1 === e4.type ? [e4.geometry] : e4.geometry, this.properties = e4.tags, this.extent = t3 || 4096;
        }
        x2.prototype.feature = function(e4) {
          return new w(this.features[e4], this.options.extent);
        }, w.prototype.loadGeometry = function() {
          var e4 = this.rawGeometry;
          this.geometry = [];
          for (var t3 = 0; t3 < e4.length; t3++) {
            for (var s4 = e4[t3], i3 = [], o3 = 0; o3 < s4.length; o3++)
              i3.push(new m(s4[o3][0], s4[o3][1]));
            this.geometry.push(i3);
          }
          return this.geometry;
        }, w.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e4 = this.geometry, t3 = 1 / 0, s4 = -1 / 0, i3 = 1 / 0, o3 = -1 / 0, r4 = 0; r4 < e4.length; r4++)
            for (var n3 = e4[r4], a3 = 0; a3 < n3.length; a3++) {
              var l3 = n3[a3];
              t3 = Math.min(t3, l3.x), s4 = Math.max(s4, l3.x), i3 = Math.min(i3, l3.y), o3 = Math.max(o3, l3.y);
            }
          return [t3, i3, s4, o3];
        }, w.prototype.toGeoJSON = y2.prototype.toGeoJSON;
        var S = e3.dW, b = v2;
        function I(e4) {
          var t3 = new S();
          return function(e5, t4) {
            for (var s4 in e5.layers)
              t4.writeMessage(3, M2, e5.layers[s4]);
          }(e4, t3), t3.finish();
        }
        function M2(e4, t3) {
          var s4;
          t3.writeVarintField(15, e4.version || 1), t3.writeStringField(1, e4.name || ""), t3.writeVarintField(5, e4.extent || 4096);
          var i3 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (s4 = 0; s4 < e4.length; s4++)
            i3.feature = e4.feature(s4), t3.writeMessage(2, k, i3);
          var o3 = i3.keys;
          for (s4 = 0; s4 < o3.length; s4++)
            t3.writeStringField(3, o3[s4]);
          var r4 = i3.values;
          for (s4 = 0; s4 < r4.length; s4++)
            t3.writeMessage(4, L, r4[s4]);
        }
        function k(e4, t3) {
          var s4 = e4.feature;
          void 0 !== s4.id && t3.writeVarintField(1, s4.id), t3.writeMessage(2, T, e4), t3.writeVarintField(3, s4.type), t3.writeMessage(4, C, s4);
        }
        function T(e4, t3) {
          var s4 = e4.feature, i3 = e4.keys, o3 = e4.values, r4 = e4.keycache, n3 = e4.valuecache;
          for (var a3 in s4.properties) {
            var l3 = s4.properties[a3], h2 = r4[a3];
            if (null !== l3) {
              void 0 === h2 && (i3.push(a3), r4[a3] = h2 = i3.length - 1), t3.writeVarint(h2);
              var c3 = typeof l3;
              "string" !== c3 && "boolean" !== c3 && "number" !== c3 && (l3 = JSON.stringify(l3));
              var u3 = c3 + ":" + l3, d2 = n3[u3];
              void 0 === d2 && (o3.push(l3), n3[u3] = d2 = o3.length - 1), t3.writeVarint(d2);
            }
          }
        }
        function P(e4, t3) {
          return (t3 << 3) + (7 & e4);
        }
        function _2(e4) {
          return e4 << 1 ^ e4 >> 31;
        }
        function C(e4, t3) {
          for (var s4 = e4.loadGeometry(), i3 = e4.type, o3 = 0, r4 = 0, n3 = s4.length, a3 = 0; a3 < n3; a3++) {
            var l3 = s4[a3], h2 = 1;
            1 === i3 && (h2 = l3.length), t3.writeVarint(P(1, h2));
            for (var c3 = 3 === i3 ? l3.length - 1 : l3.length, u3 = 0; u3 < c3; u3++) {
              1 === u3 && 1 !== i3 && t3.writeVarint(P(2, c3 - 1));
              var d2 = l3[u3].x - o3, p3 = l3[u3].y - r4;
              t3.writeVarint(_2(d2)), t3.writeVarint(_2(p3)), o3 += d2, r4 += p3;
            }
            3 === i3 && t3.writeVarint(P(7, 1));
          }
        }
        function L(e4, t3) {
          var s4 = typeof e4;
          "string" === s4 ? t3.writeStringField(1, e4) : "boolean" === s4 ? t3.writeBooleanField(7, e4) : "number" === s4 && (e4 % 1 != 0 ? t3.writeDoubleField(3, e4) : e4 < 0 ? t3.writeSVarintField(6, e4) : t3.writeVarintField(5, e4));
        }
        g2.exports = I, g2.exports.fromVectorTileJs = I, g2.exports.fromGeojsonVt = function(e4, t3) {
          t3 = t3 || {};
          var s4 = {};
          for (var i3 in e4)
            s4[i3] = new b(e4[i3].features, t3), s4[i3].name = i3, s4[i3].version = t3.version, s4[i3].extent = t3.extent;
          return I({ layers: s4 });
        }, g2.exports.GeoJSONWrapper = b;
        var D = e3.dX(g2.exports);
        const j2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e4) => e4 }, O = Math.fround || (z2 = new Float32Array(1), (e4) => (z2[0] = +e4, z2[0]));
        var z2;
        const Z2 = 3, A = 5, N = 6;
        class E {
          constructor(e4) {
            this.options = Object.assign(Object.create(j2), e4), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e4) {
            const { log: t3, minZoom: s4, maxZoom: i3 } = this.options;
            t3 && console.time("total time");
            const o3 = `prepare ${e4.length} points`;
            t3 && console.time(o3), this.points = e4;
            const r4 = [];
            for (let t4 = 0; t4 < e4.length; t4++) {
              const s5 = e4[t4];
              if (!s5.geometry)
                continue;
              const [i4, o4] = s5.geometry.coordinates, n4 = O(B(i4)), a3 = O(J(o4));
              r4.push(n4, a3, 1 / 0, t4, -1, 1), this.options.reduce && r4.push(0);
            }
            let n3 = this.trees[i3 + 1] = this._createTree(r4);
            t3 && console.timeEnd(o3);
            for (let e5 = i3; e5 >= s4; e5--) {
              const s5 = +Date.now();
              n3 = this.trees[e5] = this._createTree(this._cluster(n3, e5)), t3 && console.log("z%d: %d clusters in %dms", e5, n3.numItems, +Date.now() - s5);
            }
            return t3 && console.timeEnd("total time"), this;
          }
          getClusters(e4, t3) {
            let s4 = ((e4[0] + 180) % 360 + 360) % 360 - 180;
            const i3 = Math.max(-90, Math.min(90, e4[1]));
            let o3 = 180 === e4[2] ? 180 : ((e4[2] + 180) % 360 + 360) % 360 - 180;
            const r4 = Math.max(-90, Math.min(90, e4[3]));
            if (e4[2] - e4[0] >= 360)
              s4 = -180, o3 = 180;
            else if (s4 > o3) {
              const e5 = this.getClusters([s4, i3, 180, r4], t3), n4 = this.getClusters([-180, i3, o3, r4], t3);
              return e5.concat(n4);
            }
            const n3 = this.trees[this._limitZoom(t3)], a3 = n3.range(B(s4), J(r4), B(o3), J(i3)), l3 = n3.data, h2 = [];
            for (const e5 of a3) {
              const t4 = this.stride * e5;
              h2.push(l3[t4 + A] > 1 ? F(l3, t4, this.clusterProps) : this.points[l3[t4 + Z2]]);
            }
            return h2;
          }
          getChildren(e4) {
            const t3 = this._getOriginId(e4), s4 = this._getOriginZoom(e4), i3 = "No cluster with the specified id.", o3 = this.trees[s4];
            if (!o3)
              throw new Error(i3);
            const r4 = o3.data;
            if (t3 * this.stride >= r4.length)
              throw new Error(i3);
            const n3 = this.options.radius / (this.options.extent * Math.pow(2, s4 - 1)), a3 = o3.within(r4[t3 * this.stride], r4[t3 * this.stride + 1], n3), l3 = [];
            for (const t4 of a3) {
              const s5 = t4 * this.stride;
              r4[s5 + 4] === e4 && l3.push(r4[s5 + A] > 1 ? F(r4, s5, this.clusterProps) : this.points[r4[s5 + Z2]]);
            }
            if (0 === l3.length)
              throw new Error(i3);
            return l3;
          }
          getLeaves(e4, t3, s4) {
            const i3 = [];
            return this._appendLeaves(i3, e4, t3 = t3 || 10, s4 = s4 || 0, 0), i3;
          }
          getTile(e4, t3, s4) {
            const i3 = this.trees[this._limitZoom(e4)], o3 = Math.pow(2, e4), { extent: r4, radius: n3 } = this.options, a3 = n3 / r4, l3 = (s4 - a3) / o3, h2 = (s4 + 1 + a3) / o3, c3 = { features: [] };
            return this._addTileFeatures(i3.range((t3 - a3) / o3, l3, (t3 + 1 + a3) / o3, h2), i3.data, t3, s4, o3, c3), 0 === t3 && this._addTileFeatures(i3.range(1 - a3 / o3, l3, 1, h2), i3.data, o3, s4, o3, c3), t3 === o3 - 1 && this._addTileFeatures(i3.range(0, l3, a3 / o3, h2), i3.data, -1, s4, o3, c3), c3.features.length ? c3 : null;
          }
          getClusterExpansionZoom(e4) {
            let t3 = this._getOriginZoom(e4) - 1;
            for (; t3 <= this.options.maxZoom; ) {
              const s4 = this.getChildren(e4);
              if (t3++, 1 !== s4.length)
                break;
              e4 = s4[0].properties.cluster_id;
            }
            return t3;
          }
          _appendLeaves(e4, t3, s4, i3, o3) {
            const r4 = this.getChildren(t3);
            for (const t4 of r4) {
              const r5 = t4.properties;
              if (r5 && r5.cluster ? o3 + r5.point_count <= i3 ? o3 += r5.point_count : o3 = this._appendLeaves(e4, r5.cluster_id, s4, i3, o3) : o3 < i3 ? o3++ : e4.push(t4), e4.length === s4)
                break;
            }
            return o3;
          }
          _createTree(t3) {
            const s4 = new e3.bj(t3.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e4 = 0; e4 < t3.length; e4 += this.stride)
              s4.add(t3[e4], t3[e4 + 1]);
            return s4.finish(), s4.data = t3, s4;
          }
          _addTileFeatures(e4, t3, s4, i3, o3, r4) {
            for (const n3 of e4) {
              const e5 = n3 * this.stride, a3 = t3[e5 + A] > 1;
              let l3, h2, c3;
              if (a3)
                l3 = W(t3, e5, this.clusterProps), h2 = t3[e5], c3 = t3[e5 + 1];
              else {
                const s5 = this.points[t3[e5 + Z2]];
                l3 = s5.properties;
                const [i4, o4] = s5.geometry.coordinates;
                h2 = B(i4), c3 = J(o4);
              }
              const u3 = { type: 1, geometry: [[Math.round(this.options.extent * (h2 * o3 - s4)), Math.round(this.options.extent * (c3 * o3 - i3))]], tags: l3 };
              let d2;
              d2 = a3 || this.options.generateId ? t3[e5 + Z2] : this.points[t3[e5 + Z2]].id, void 0 !== d2 && (u3.id = d2), r4.features.push(u3);
            }
          }
          _limitZoom(e4) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e4), this.options.maxZoom + 1));
          }
          _cluster(e4, t3) {
            const { radius: s4, extent: i3, reduce: o3, minPoints: r4 } = this.options, n3 = s4 / (i3 * Math.pow(2, t3)), a3 = e4.data, l3 = [], h2 = this.stride;
            for (let s5 = 0; s5 < a3.length; s5 += h2) {
              if (a3[s5 + 2] <= t3)
                continue;
              a3[s5 + 2] = t3;
              const i4 = a3[s5], c3 = a3[s5 + 1], u3 = e4.within(a3[s5], a3[s5 + 1], n3), d2 = a3[s5 + A];
              let p3 = d2;
              for (const e5 of u3) {
                const s6 = e5 * h2;
                a3[s6 + 2] > t3 && (p3 += a3[s6 + A]);
              }
              if (p3 > d2 && p3 >= r4) {
                let e5, r5 = i4 * d2, n4 = c3 * d2, f2 = -1;
                const g3 = (s5 / h2 << 5) + (t3 + 1) + this.points.length;
                for (const i5 of u3) {
                  const l4 = i5 * h2;
                  if (a3[l4 + 2] <= t3)
                    continue;
                  a3[l4 + 2] = t3;
                  const c4 = a3[l4 + A];
                  r5 += a3[l4] * c4, n4 += a3[l4 + 1] * c4, a3[l4 + 4] = g3, o3 && (e5 || (e5 = this._map(a3, s5, true), f2 = this.clusterProps.length, this.clusterProps.push(e5)), o3(e5, this._map(a3, l4)));
                }
                a3[s5 + 4] = g3, l3.push(r5 / p3, n4 / p3, 1 / 0, g3, -1, p3), o3 && l3.push(f2);
              } else {
                for (let e5 = 0; e5 < h2; e5++)
                  l3.push(a3[s5 + e5]);
                if (p3 > 1)
                  for (const e5 of u3) {
                    const s6 = e5 * h2;
                    if (!(a3[s6 + 2] <= t3)) {
                      a3[s6 + 2] = t3;
                      for (let e6 = 0; e6 < h2; e6++)
                        l3.push(a3[s6 + e6]);
                    }
                  }
              }
            }
            return l3;
          }
          _getOriginId(e4) {
            return e4 - this.points.length >> 5;
          }
          _getOriginZoom(e4) {
            return (e4 - this.points.length) % 32;
          }
          _map(e4, t3, s4) {
            if (e4[t3 + A] > 1) {
              const i4 = this.clusterProps[e4[t3 + N]];
              return s4 ? Object.assign({}, i4) : i4;
            }
            const i3 = this.points[e4[t3 + Z2]].properties, o3 = this.options.map(i3);
            return s4 && o3 === i3 ? Object.assign({}, o3) : o3;
          }
        }
        function F(e4, t3, s4) {
          return { type: "Feature", id: e4[t3 + Z2], properties: W(e4, t3, s4), geometry: { type: "Point", coordinates: [(i3 = e4[t3], 360 * (i3 - 0.5)), G(e4[t3 + 1])] } };
          var i3;
        }
        function W(e4, t3, s4) {
          const i3 = e4[t3 + A], o3 = i3 >= 1e4 ? `${Math.round(i3 / 1e3)}k` : i3 >= 1e3 ? Math.round(i3 / 100) / 10 + "k" : i3, r4 = e4[t3 + N], n3 = -1 === r4 ? {} : Object.assign({}, s4[r4]);
          return Object.assign(n3, { cluster: true, cluster_id: e4[t3 + Z2], point_count: i3, point_count_abbreviated: o3 });
        }
        function B(e4) {
          return e4 / 360 + 0.5;
        }
        function J(e4) {
          const t3 = Math.sin(e4 * Math.PI / 180), s4 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return s4 < 0 ? 0 : s4 > 1 ? 1 : s4;
        }
        function G(e4) {
          const t3 = (180 - 360 * e4) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
        }
        var Y = { exports: {} };
        Y.exports = function() {
          function e4(s5, i4, o4, r5) {
            for (var n4, a4 = r5, l4 = o4 - i4 >> 1, h3 = o4 - i4, c4 = s5[i4], u4 = s5[i4 + 1], d3 = s5[o4], p4 = s5[o4 + 1], f3 = i4 + 3; f3 < o4; f3 += 3) {
              var g4 = t3(s5[f3], s5[f3 + 1], c4, u4, d3, p4);
              if (g4 > a4)
                n4 = f3, a4 = g4;
              else if (g4 === a4) {
                var m3 = Math.abs(f3 - l4);
                m3 < h3 && (n4 = f3, h3 = m3);
              }
            }
            a4 > r5 && (n4 - i4 > 3 && e4(s5, i4, n4, r5), s5[n4 + 2] = a4, o4 - n4 > 3 && e4(s5, n4, o4, r5));
          }
          function t3(e5, t4, s5, i4, o4, r5) {
            var n4 = o4 - s5, a4 = r5 - i4;
            if (0 !== n4 || 0 !== a4) {
              var l4 = ((e5 - s5) * n4 + (t4 - i4) * a4) / (n4 * n4 + a4 * a4);
              l4 > 1 ? (s5 = o4, i4 = r5) : l4 > 0 && (s5 += n4 * l4, i4 += a4 * l4);
            }
            return (n4 = e5 - s5) * n4 + (a4 = t4 - i4) * a4;
          }
          function s4(e5, t4, s5, o4) {
            var r5 = { id: void 0 === e5 ? null : e5, type: t4, geometry: s5, tags: o4, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e6) {
              var t5 = e6.geometry, s6 = e6.type;
              if ("Point" === s6 || "MultiPoint" === s6 || "LineString" === s6)
                i3(e6, t5);
              else if ("Polygon" === s6 || "MultiLineString" === s6)
                for (var o5 = 0; o5 < t5.length; o5++)
                  i3(e6, t5[o5]);
              else if ("MultiPolygon" === s6)
                for (o5 = 0; o5 < t5.length; o5++)
                  for (var r6 = 0; r6 < t5[o5].length; r6++)
                    i3(e6, t5[o5][r6]);
            }(r5), r5;
          }
          function i3(e5, t4) {
            for (var s5 = 0; s5 < t4.length; s5 += 3)
              e5.minX = Math.min(e5.minX, t4[s5]), e5.minY = Math.min(e5.minY, t4[s5 + 1]), e5.maxX = Math.max(e5.maxX, t4[s5]), e5.maxY = Math.max(e5.maxY, t4[s5 + 1]);
          }
          function o3(e5, t4, i4, l4) {
            if (t4.geometry) {
              var h3 = t4.geometry.coordinates, c4 = t4.geometry.type, u4 = Math.pow(i4.tolerance / ((1 << i4.maxZoom) * i4.extent), 2), d3 = [], p4 = t4.id;
              if (i4.promoteId ? p4 = t4.properties[i4.promoteId] : i4.generateId && (p4 = l4 || 0), "Point" === c4)
                r4(h3, d3);
              else if ("MultiPoint" === c4)
                for (var f3 = 0; f3 < h3.length; f3++)
                  r4(h3[f3], d3);
              else if ("LineString" === c4)
                n3(h3, d3, u4, false);
              else if ("MultiLineString" === c4) {
                if (i4.lineMetrics) {
                  for (f3 = 0; f3 < h3.length; f3++)
                    n3(h3[f3], d3 = [], u4, false), e5.push(s4(p4, "LineString", d3, t4.properties));
                  return;
                }
                a3(h3, d3, u4, false);
              } else if ("Polygon" === c4)
                a3(h3, d3, u4, true);
              else {
                if ("MultiPolygon" !== c4) {
                  if ("GeometryCollection" === c4) {
                    for (f3 = 0; f3 < t4.geometry.geometries.length; f3++)
                      o3(e5, { id: p4, geometry: t4.geometry.geometries[f3], properties: t4.properties }, i4, l4);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (f3 = 0; f3 < h3.length; f3++) {
                  var g4 = [];
                  a3(h3[f3], g4, u4, true), d3.push(g4);
                }
              }
              e5.push(s4(p4, c4, d3, t4.properties));
            }
          }
          function r4(e5, t4) {
            t4.push(l3(e5[0])), t4.push(h2(e5[1])), t4.push(0);
          }
          function n3(t4, s5, i4, o4) {
            for (var r5, n4, a4 = 0, c4 = 0; c4 < t4.length; c4++) {
              var u4 = l3(t4[c4][0]), d3 = h2(t4[c4][1]);
              s5.push(u4), s5.push(d3), s5.push(0), c4 > 0 && (a4 += o4 ? (r5 * d3 - u4 * n4) / 2 : Math.sqrt(Math.pow(u4 - r5, 2) + Math.pow(d3 - n4, 2))), r5 = u4, n4 = d3;
            }
            var p4 = s5.length - 3;
            s5[2] = 1, e4(s5, 0, p4, i4), s5[p4 + 2] = 1, s5.size = Math.abs(a4), s5.start = 0, s5.end = s5.size;
          }
          function a3(e5, t4, s5, i4) {
            for (var o4 = 0; o4 < e5.length; o4++) {
              var r5 = [];
              n3(e5[o4], r5, s5, i4), t4.push(r5);
            }
          }
          function l3(e5) {
            return e5 / 360 + 0.5;
          }
          function h2(e5) {
            var t4 = Math.sin(e5 * Math.PI / 180), s5 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
            return s5 < 0 ? 0 : s5 > 1 ? 1 : s5;
          }
          function c3(e5, t4, i4, o4, r5, n4, a4, l4) {
            if (o4 /= t4, n4 >= (i4 /= t4) && a4 < o4)
              return e5;
            if (a4 < i4 || n4 >= o4)
              return null;
            for (var h3 = [], c4 = 0; c4 < e5.length; c4++) {
              var p4 = e5[c4], g4 = p4.geometry, m3 = p4.type, y4 = 0 === r5 ? p4.minX : p4.minY, v4 = 0 === r5 ? p4.maxX : p4.maxY;
              if (y4 >= i4 && v4 < o4)
                h3.push(p4);
              else if (!(v4 < i4 || y4 >= o4)) {
                var x4 = [];
                if ("Point" === m3 || "MultiPoint" === m3)
                  u3(g4, x4, i4, o4, r5);
                else if ("LineString" === m3)
                  d2(g4, x4, i4, o4, r5, false, l4.lineMetrics);
                else if ("MultiLineString" === m3)
                  f2(g4, x4, i4, o4, r5, false);
                else if ("Polygon" === m3)
                  f2(g4, x4, i4, o4, r5, true);
                else if ("MultiPolygon" === m3)
                  for (var w3 = 0; w3 < g4.length; w3++) {
                    var S3 = [];
                    f2(g4[w3], S3, i4, o4, r5, true), S3.length && x4.push(S3);
                  }
                if (x4.length) {
                  if (l4.lineMetrics && "LineString" === m3) {
                    for (w3 = 0; w3 < x4.length; w3++)
                      h3.push(s4(p4.id, m3, x4[w3], p4.tags));
                    continue;
                  }
                  "LineString" !== m3 && "MultiLineString" !== m3 || (1 === x4.length ? (m3 = "LineString", x4 = x4[0]) : m3 = "MultiLineString"), "Point" !== m3 && "MultiPoint" !== m3 || (m3 = 3 === x4.length ? "Point" : "MultiPoint"), h3.push(s4(p4.id, m3, x4, p4.tags));
                }
              }
            }
            return h3.length ? h3 : null;
          }
          function u3(e5, t4, s5, i4, o4) {
            for (var r5 = 0; r5 < e5.length; r5 += 3) {
              var n4 = e5[r5 + o4];
              n4 >= s5 && n4 <= i4 && (t4.push(e5[r5]), t4.push(e5[r5 + 1]), t4.push(e5[r5 + 2]));
            }
          }
          function d2(e5, t4, s5, i4, o4, r5, n4) {
            for (var a4, l4, h3 = p3(e5), c4 = 0 === o4 ? m2 : y3, u4 = e5.start, d3 = 0; d3 < e5.length - 3; d3 += 3) {
              var f3 = e5[d3], v4 = e5[d3 + 1], x4 = e5[d3 + 2], w3 = e5[d3 + 3], S3 = e5[d3 + 4], b3 = 0 === o4 ? f3 : v4, I3 = 0 === o4 ? w3 : S3, M4 = false;
              n4 && (a4 = Math.sqrt(Math.pow(f3 - w3, 2) + Math.pow(v4 - S3, 2))), b3 < s5 ? I3 > s5 && (l4 = c4(h3, f3, v4, w3, S3, s5), n4 && (h3.start = u4 + a4 * l4)) : b3 > i4 ? I3 < i4 && (l4 = c4(h3, f3, v4, w3, S3, i4), n4 && (h3.start = u4 + a4 * l4)) : g3(h3, f3, v4, x4), I3 < s5 && b3 >= s5 && (l4 = c4(h3, f3, v4, w3, S3, s5), M4 = true), I3 > i4 && b3 <= i4 && (l4 = c4(h3, f3, v4, w3, S3, i4), M4 = true), !r5 && M4 && (n4 && (h3.end = u4 + a4 * l4), t4.push(h3), h3 = p3(e5)), n4 && (u4 += a4);
            }
            var k3 = e5.length - 3;
            f3 = e5[k3], v4 = e5[k3 + 1], x4 = e5[k3 + 2], (b3 = 0 === o4 ? f3 : v4) >= s5 && b3 <= i4 && g3(h3, f3, v4, x4), k3 = h3.length - 3, r5 && k3 >= 3 && (h3[k3] !== h3[0] || h3[k3 + 1] !== h3[1]) && g3(h3, h3[0], h3[1], h3[2]), h3.length && t4.push(h3);
          }
          function p3(e5) {
            var t4 = [];
            return t4.size = e5.size, t4.start = e5.start, t4.end = e5.end, t4;
          }
          function f2(e5, t4, s5, i4, o4, r5) {
            for (var n4 = 0; n4 < e5.length; n4++)
              d2(e5[n4], t4, s5, i4, o4, r5, false);
          }
          function g3(e5, t4, s5, i4) {
            e5.push(t4), e5.push(s5), e5.push(i4);
          }
          function m2(e5, t4, s5, i4, o4, r5) {
            var n4 = (r5 - t4) / (i4 - t4);
            return e5.push(r5), e5.push(s5 + (o4 - s5) * n4), e5.push(1), n4;
          }
          function y3(e5, t4, s5, i4, o4, r5) {
            var n4 = (r5 - s5) / (o4 - s5);
            return e5.push(t4 + (i4 - t4) * n4), e5.push(r5), e5.push(1), n4;
          }
          function v3(e5, t4) {
            for (var i4 = [], o4 = 0; o4 < e5.length; o4++) {
              var r5, n4 = e5[o4], a4 = n4.type;
              if ("Point" === a4 || "MultiPoint" === a4 || "LineString" === a4)
                r5 = x3(n4.geometry, t4);
              else if ("MultiLineString" === a4 || "Polygon" === a4) {
                r5 = [];
                for (var l4 = 0; l4 < n4.geometry.length; l4++)
                  r5.push(x3(n4.geometry[l4], t4));
              } else if ("MultiPolygon" === a4)
                for (r5 = [], l4 = 0; l4 < n4.geometry.length; l4++) {
                  for (var h3 = [], c4 = 0; c4 < n4.geometry[l4].length; c4++)
                    h3.push(x3(n4.geometry[l4][c4], t4));
                  r5.push(h3);
                }
              i4.push(s4(n4.id, a4, r5, n4.tags));
            }
            return i4;
          }
          function x3(e5, t4) {
            var s5 = [];
            s5.size = e5.size, void 0 !== e5.start && (s5.start = e5.start, s5.end = e5.end);
            for (var i4 = 0; i4 < e5.length; i4 += 3)
              s5.push(e5[i4] + t4, e5[i4 + 1], e5[i4 + 2]);
            return s5;
          }
          function w2(e5, t4) {
            if (e5.transformed)
              return e5;
            var s5, i4, o4, r5 = 1 << e5.z, n4 = e5.x, a4 = e5.y;
            for (s5 = 0; s5 < e5.features.length; s5++) {
              var l4 = e5.features[s5], h3 = l4.geometry, c4 = l4.type;
              if (l4.geometry = [], 1 === c4)
                for (i4 = 0; i4 < h3.length; i4 += 2)
                  l4.geometry.push(S2(h3[i4], h3[i4 + 1], t4, r5, n4, a4));
              else
                for (i4 = 0; i4 < h3.length; i4++) {
                  var u4 = [];
                  for (o4 = 0; o4 < h3[i4].length; o4 += 2)
                    u4.push(S2(h3[i4][o4], h3[i4][o4 + 1], t4, r5, n4, a4));
                  l4.geometry.push(u4);
                }
            }
            return e5.transformed = true, e5;
          }
          function S2(e5, t4, s5, i4, o4, r5) {
            return [Math.round(s5 * (e5 * i4 - o4)), Math.round(s5 * (t4 * i4 - r5))];
          }
          function b2(e5, t4, s5, i4, o4) {
            for (var r5 = t4 === o4.maxZoom ? 0 : o4.tolerance / ((1 << t4) * o4.extent), n4 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: s5, y: i4, z: t4, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a4 = 0; a4 < e5.length; a4++) {
              n4.numFeatures++, I2(n4, e5[a4], r5, o4);
              var l4 = e5[a4].minX, h3 = e5[a4].minY, c4 = e5[a4].maxX, u4 = e5[a4].maxY;
              l4 < n4.minX && (n4.minX = l4), h3 < n4.minY && (n4.minY = h3), c4 > n4.maxX && (n4.maxX = c4), u4 > n4.maxY && (n4.maxY = u4);
            }
            return n4;
          }
          function I2(e5, t4, s5, i4) {
            var o4 = t4.geometry, r5 = t4.type, n4 = [];
            if ("Point" === r5 || "MultiPoint" === r5)
              for (var a4 = 0; a4 < o4.length; a4 += 3)
                n4.push(o4[a4]), n4.push(o4[a4 + 1]), e5.numPoints++, e5.numSimplified++;
            else if ("LineString" === r5)
              M3(n4, o4, e5, s5, false, false);
            else if ("MultiLineString" === r5 || "Polygon" === r5)
              for (a4 = 0; a4 < o4.length; a4++)
                M3(n4, o4[a4], e5, s5, "Polygon" === r5, 0 === a4);
            else if ("MultiPolygon" === r5)
              for (var l4 = 0; l4 < o4.length; l4++) {
                var h3 = o4[l4];
                for (a4 = 0; a4 < h3.length; a4++)
                  M3(n4, h3[a4], e5, s5, true, 0 === a4);
              }
            if (n4.length) {
              var c4 = t4.tags || null;
              if ("LineString" === r5 && i4.lineMetrics) {
                for (var u4 in c4 = {}, t4.tags)
                  c4[u4] = t4.tags[u4];
                c4.mapbox_clip_start = o4.start / o4.size, c4.mapbox_clip_end = o4.end / o4.size;
              }
              var d3 = { geometry: n4, type: "Polygon" === r5 || "MultiPolygon" === r5 ? 3 : "LineString" === r5 || "MultiLineString" === r5 ? 2 : 1, tags: c4 };
              null !== t4.id && (d3.id = t4.id), e5.features.push(d3);
            }
          }
          function M3(e5, t4, s5, i4, o4, r5) {
            var n4 = i4 * i4;
            if (i4 > 0 && t4.size < (o4 ? n4 : i4))
              s5.numPoints += t4.length / 3;
            else {
              for (var a4 = [], l4 = 0; l4 < t4.length; l4 += 3)
                (0 === i4 || t4[l4 + 2] > n4) && (s5.numSimplified++, a4.push(t4[l4]), a4.push(t4[l4 + 1])), s5.numPoints++;
              o4 && function(e6, t5) {
                for (var s6 = 0, i5 = 0, o5 = e6.length, r6 = o5 - 2; i5 < o5; r6 = i5, i5 += 2)
                  s6 += (e6[i5] - e6[r6]) * (e6[i5 + 1] + e6[r6 + 1]);
                if (s6 > 0 === t5)
                  for (i5 = 0, o5 = e6.length; i5 < o5 / 2; i5 += 2) {
                    var n5 = e6[i5], a5 = e6[i5 + 1];
                    e6[i5] = e6[o5 - 2 - i5], e6[i5 + 1] = e6[o5 - 1 - i5], e6[o5 - 2 - i5] = n5, e6[o5 - 1 - i5] = a5;
                  }
              }(a4, r5), e5.push(a4);
            }
          }
          function k2(e5, t4) {
            var s5 = (t4 = this.options = function(e6, t5) {
              for (var s6 in t5)
                e6[s6] = t5[s6];
              return e6;
            }(Object.create(this.options), t4)).debug;
            if (s5 && console.time("preprocess data"), t4.maxZoom < 0 || t4.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t4.promoteId && t4.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var i4 = function(e6, t5) {
              var s6 = [];
              if ("FeatureCollection" === e6.type)
                for (var i5 = 0; i5 < e6.features.length; i5++)
                  o3(s6, e6.features[i5], t5, i5);
              else
                o3(s6, "Feature" === e6.type ? e6 : { geometry: e6 }, t5);
              return s6;
            }(e5, t4);
            this.tiles = {}, this.tileCoords = [], s5 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t4.indexMaxZoom, t4.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i4 = function(e6, t5) {
              var s6 = t5.buffer / t5.extent, i5 = e6, o4 = c3(e6, 1, -1 - s6, s6, 0, -1, 2, t5), r5 = c3(e6, 1, 1 - s6, 2 + s6, 0, -1, 2, t5);
              return (o4 || r5) && (i5 = c3(e6, 1, -s6, 1 + s6, 0, -1, 2, t5) || [], o4 && (i5 = v3(o4, 1).concat(i5)), r5 && (i5 = i5.concat(v3(r5, -1)))), i5;
            }(i4, t4)).length && this.splitTile(i4, 0, 0, 0), s5 && (i4.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function T2(e5, t4, s5) {
            return 32 * ((1 << e5) * s5 + t4) + e5;
          }
          return k2.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, k2.prototype.splitTile = function(e5, t4, s5, i4, o4, r5, n4) {
            for (var a4 = [e5, t4, s5, i4], l4 = this.options, h3 = l4.debug; a4.length; ) {
              i4 = a4.pop(), s5 = a4.pop(), t4 = a4.pop(), e5 = a4.pop();
              var u4 = 1 << t4, d3 = T2(t4, s5, i4), p4 = this.tiles[d3];
              if (!p4 && (h3 > 1 && console.time("creation"), p4 = this.tiles[d3] = b2(e5, t4, s5, i4, l4), this.tileCoords.push({ z: t4, x: s5, y: i4 }), h3)) {
                h3 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t4, s5, i4, p4.numFeatures, p4.numPoints, p4.numSimplified), console.timeEnd("creation"));
                var f3 = "z" + t4;
                this.stats[f3] = (this.stats[f3] || 0) + 1, this.total++;
              }
              if (p4.source = e5, o4) {
                if (t4 === l4.maxZoom || t4 === o4)
                  continue;
                var g4 = 1 << o4 - t4;
                if (s5 !== Math.floor(r5 / g4) || i4 !== Math.floor(n4 / g4))
                  continue;
              } else if (t4 === l4.indexMaxZoom || p4.numPoints <= l4.indexMaxPoints)
                continue;
              if (p4.source = null, 0 !== e5.length) {
                h3 > 1 && console.time("clipping");
                var m3, y4, v4, x4, w3, S3, I3 = 0.5 * l4.buffer / l4.extent, M4 = 0.5 - I3, k3 = 0.5 + I3, P2 = 1 + I3;
                m3 = y4 = v4 = x4 = null, w3 = c3(e5, u4, s5 - I3, s5 + k3, 0, p4.minX, p4.maxX, l4), S3 = c3(e5, u4, s5 + M4, s5 + P2, 0, p4.minX, p4.maxX, l4), e5 = null, w3 && (m3 = c3(w3, u4, i4 - I3, i4 + k3, 1, p4.minY, p4.maxY, l4), y4 = c3(w3, u4, i4 + M4, i4 + P2, 1, p4.minY, p4.maxY, l4), w3 = null), S3 && (v4 = c3(S3, u4, i4 - I3, i4 + k3, 1, p4.minY, p4.maxY, l4), x4 = c3(S3, u4, i4 + M4, i4 + P2, 1, p4.minY, p4.maxY, l4), S3 = null), h3 > 1 && console.timeEnd("clipping"), a4.push(m3 || [], t4 + 1, 2 * s5, 2 * i4), a4.push(y4 || [], t4 + 1, 2 * s5, 2 * i4 + 1), a4.push(v4 || [], t4 + 1, 2 * s5 + 1, 2 * i4), a4.push(x4 || [], t4 + 1, 2 * s5 + 1, 2 * i4 + 1);
              }
            }
          }, k2.prototype.getTile = function(e5, t4, s5) {
            var i4 = this.options, o4 = i4.extent, r5 = i4.debug;
            if (e5 < 0 || e5 > 24)
              return null;
            var n4 = 1 << e5, a4 = T2(e5, t4 = (t4 % n4 + n4) % n4, s5);
            if (this.tiles[a4])
              return w2(this.tiles[a4], o4);
            r5 > 1 && console.log("drilling down to z%d-%d-%d", e5, t4, s5);
            for (var l4, h3 = e5, c4 = t4, u4 = s5; !l4 && h3 > 0; )
              h3--, c4 = Math.floor(c4 / 2), u4 = Math.floor(u4 / 2), l4 = this.tiles[T2(h3, c4, u4)];
            return l4 && l4.source ? (r5 > 1 && console.log("found parent tile z%d-%d-%d", h3, c4, u4), r5 > 1 && console.time("drilling down"), this.splitTile(l4.source, h3, c4, u4, e5, t4, s5), r5 > 1 && console.timeEnd("drilling down"), this.tiles[a4] ? w2(this.tiles[a4], o4) : null) : null;
          }, function(e5, t4) {
            return new k2(e5, t4);
          };
        }();
        var R2 = e3.dX(Y.exports);
        function X2(e4, t3) {
          const s4 = e4.tileID.canonical;
          if (!this._geoJSONIndex)
            return t3(null, null);
          const i3 = this._geoJSONIndex.getTile(s4.z, s4.x, s4.y);
          if (!i3)
            return t3(null, null);
          const o3 = new f(i3.features);
          let r4 = D(o3);
          0 === r4.byteOffset && r4.byteLength === r4.buffer.byteLength || (r4 = new Uint8Array(r4)), t3(null, { vectorTile: o3, rawData: r4.buffer });
        }
        class V extends h {
          constructor(e4, t3, s4, i3, o3, r4) {
            super(e4, t3, s4, i3, X2, r4), o3 && (this.loadGeoJSON = o3), this._featureMap = /* @__PURE__ */ new Map();
          }
          loadData(s4, i3) {
            const o3 = s4 && s4.request, r4 = o3 && o3.collectResourceTiming;
            this.loadGeoJSON(s4, (n3, a3) => {
              if (n3 || !a3)
                return i3(n3);
              if ("object" != typeof a3)
                return i3(new Error(`Input data given to '${s4.source}' is not a valid GeoJSON object.`));
              {
                try {
                  if (s4.filter) {
                    const t3 = e3.t(s4.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === t3.result)
                      throw new Error(t3.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
                    a3.features = a3.features.filter((e4) => t3.value.evaluate({ zoom: 0 }, e4));
                  }
                  if (s4.dynamic) {
                    "Feature" === a3.type && (a3 = { type: "FeatureCollection", features: [a3] }), s4.append || this._featureMap.clear();
                    for (const e4 of a3.features || []) {
                      const t3 = e4.id;
                      void 0 !== t3 && (e4.geometry ? this._featureMap.set(t3, e4) : this._featureMap.delete(t3));
                    }
                    a3.features = [...this._featureMap.values()];
                  }
                  this._geoJSONIndex = s4.cluster ? new E(function({ superclusterOptions: t3, clusterProperties: s5 }) {
                    if (!s5 || !t3)
                      return t3;
                    const i4 = {}, o4 = {}, r5 = { accumulated: null, zoom: 0 }, n4 = { properties: null }, a4 = Object.keys(s5);
                    for (const t4 of a4) {
                      const [r6, n5] = s5[t4], a5 = e3.t(n5), l4 = e3.t("string" == typeof r6 ? [r6, ["accumulated"], ["get", t4]] : r6);
                      i4[t4] = a5.value, o4[t4] = l4.value;
                    }
                    return t3.map = (e4) => {
                      n4.properties = e4;
                      const t4 = {};
                      for (const e5 of a4)
                        t4[e5] = i4[e5].evaluate(r5, n4);
                      return t4;
                    }, t3.reduce = (e4, t4) => {
                      n4.properties = t4;
                      for (const t5 of a4)
                        r5.accumulated = e4[t5], e4[t5] = o4[t5].evaluate(r5, n4);
                    }, t3;
                  }(s4)).load(a3.features) : R2(a3, s4.geojsonVtOptions);
                } catch (n4) {
                  return i3(n4);
                }
                this.loaded = {};
                const l3 = {};
                if (r4) {
                  const e4 = t2(o3);
                  e4 && (l3.resourceTiming = {}, l3.resourceTiming[s4.source] = JSON.parse(JSON.stringify(e4)));
                }
                i3(null, l3);
              }
            });
          }
          reloadTile(e4, t3) {
            const s4 = this.loaded;
            return s4 && s4[e4.uid] ? super.reloadTile(e4, t3) : this.loadTile(e4, t3);
          }
          loadGeoJSON(t3, s4) {
            if (t3.request)
              e3.g(t3.request, s4);
            else {
              if ("string" != typeof t3.data)
                return s4(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              try {
                return s4(null, JSON.parse(t3.data));
              } catch (e4) {
                return s4(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(e4, t3) {
            try {
              t3(null, this._geoJSONIndex.getClusterExpansionZoom(e4.clusterId));
            } catch (e5) {
              t3(e5);
            }
          }
          getClusterChildren(e4, t3) {
            try {
              t3(null, this._geoJSONIndex.getChildren(e4.clusterId));
            } catch (e5) {
              t3(e5);
            }
          }
          getClusterLeaves(e4, t3) {
            try {
              t3(null, this._geoJSONIndex.getLeaves(e4.clusterId, e4.limit, e4.offset));
            } catch (e5) {
              t3(e5);
            }
          }
        }
        class $ {
          constructor(t3, s4) {
            this.tileID = new e3.ap(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.tileZoom = t3.tileZoom, this.uid = t3.uid, this.zoom = t3.zoom, this.canonical = t3.tileID.canonical, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t3.projection, this.brightness = s4;
          }
          parse(t3, s4, i3, o3) {
            this.status = "parsing";
            const r4 = new e3.ap(i3.tileID.overscaledZ, i3.tileID.wrap, i3.tileID.canonical.z, i3.tileID.canonical.x, i3.tileID.canonical.y), n3 = {}, a3 = s4.familiesBySource[i3.source], l3 = new e3.dL(r4, i3.promoteId);
            return l3.bucketLayerIDs = [], l3.is3DTile = true, e3.dY(t3).then((t4) => {
              if (!t4)
                return o3(new Error("Could not parse tile"));
              const s5 = e3.dZ(t4, 1 / e3.bU(i3.tileID.canonical)), h2 = t4.json.extensionsUsed && t4.json.extensionsUsed.includes("MAPBOX_mesh_features") || t4.json.asset.extras && t4.json.asset.extras.MAPBOX_mesh_features, c3 = t4.json.extensionsUsed && t4.json.extensionsUsed.includes("EXT_meshopt_compression"), u3 = new e3.N(this.zoom, { brightness: this.brightness });
              for (const t5 in a3)
                for (const i4 of a3[t5]) {
                  const t6 = i4[0];
                  l3.bucketLayerIDs.push(i4.map((e4) => e4.id)), t6.recalculate(u3, []);
                  const o4 = new e3.d_(s5, r4, h2, c3, this.brightness, l3);
                  h2 || (o4.needsUpload = true), n3[t6.fqid] = o4, o4.evaluate(t6);
                }
              this.status = "done", o3(null, { buckets: n3, featureIndex: l3 });
            }).catch((e4) => o3(new Error(e4.message)));
          }
        }
        class U {
          constructor(e4, t3, s4, i3, o3, r4) {
            this.actor = e4, this.layerIndex = t3, this.brightness = r4, this.loading = {}, this.loaded = {};
          }
          loadTile(t3, s4) {
            const i3 = t3.uid, o3 = this.loading[i3] = new $(t3, this.brightness);
            e3.b1(t3.request, (e4, r4) => {
              const n3 = !this.loading[i3];
              return delete this.loading[i3], n3 || e4 ? (o3.status = "done", n3 || (this.loaded[i3] = o3), s4(e4)) : r4 && 0 !== r4.byteLength ? void o3.parse(r4, this.layerIndex, t3, (e5, t4) => {
                o3.status = "done", this.loaded = this.loaded || {}, this.loaded[i3] = o3, e5 || !t4 ? s4(e5) : s4(null, t4);
              }) : (o3.status = "done", this.loaded[i3] = o3, s4());
            });
          }
          reloadTile(e4, t3) {
            const s4 = this.loaded, i3 = e4.uid;
            if (s4 && s4[i3]) {
              const o3 = s4[i3];
              o3.projection = e4.projection, o3.brightness = e4.brightness;
              const r4 = (s5, i4) => {
                o3.reloadCallback && (delete o3.reloadCallback, this.loadTile(e4, t3)), t3(s5, i4);
              };
              "parsing" === o3.status ? o3.reloadCallback = r4 : "done" === o3.status && this.loadTile(e4, t3);
            }
          }
          abortTile(e4, t3) {
            const s4 = e4.uid;
            this.loading[s4] && delete this.loading[s4], t3();
          }
          removeTile(e4, t3) {
            const s4 = this.loaded, i3 = e4.uid;
            s4 && s4[i3] && delete s4[i3], t3();
          }
        }
        class q2 {
          constructor(t3) {
            this.self = t3, this.actor = new e3.d$(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e3.br({ name: "mercator" }), this.workerSourceTypes = { vector: h, geojson: V, "batched-model": U }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e4, t4) => {
              if (this.workerSourceTypes[e4])
                throw new Error(`Worker source with name "${e4}" already registered.`);
              this.workerSourceTypes[e4] = t4;
            }, this.self.registerRTLTextPlugin = (t4) => {
              if (e3.e0.isParsed())
                throw new Error("RTL text plugin already registered.");
              e3.e0.applyArabicShaping = t4.applyArabicShaping, e3.e0.processBidirectionalText = t4.processBidirectionalText, e3.e0.processStyledBidirectionalText = t4.processStyledBidirectionalText;
            };
          }
          clearCaches(e4, t3, s4) {
            delete this.layerIndexes[e4], delete this.availableImages[e4], delete this.workerSources[e4], delete this.demWorkerSources[e4], delete this.rasterArrayWorkerSource, s4();
          }
          checkIfReady(e4, t3, s4) {
            s4();
          }
          setReferrer(e4, t3) {
            this.referrer = t3;
          }
          spriteLoaded(t3, { scope: s4, isLoaded: i3 }) {
            if (this.isSpriteLoaded[t3] || (this.isSpriteLoaded[t3] = {}), this.isSpriteLoaded[t3][s4] = i3, this.workerSources[t3] && this.workerSources[t3][s4])
              for (const o3 in this.workerSources[t3][s4]) {
                const r4 = this.workerSources[t3][s4][o3];
                for (const t4 in r4)
                  r4[t4] instanceof h && (r4[t4].isSpriteLoaded = i3, r4[t4].fire(new e3.b("isSpriteLoaded")));
              }
          }
          setImages(e4, { scope: t3, images: s4 }, i3) {
            if (this.availableImages[e4] || (this.availableImages[e4] = {}), this.availableImages[e4][t3] = s4, this.workerSources[e4] && this.workerSources[e4][t3]) {
              for (const i4 in this.workerSources[e4][t3]) {
                const o3 = this.workerSources[e4][t3][i4];
                for (const e5 in o3)
                  o3[e5].availableImages = s4;
              }
              i3();
            } else
              i3();
          }
          setProjection(t3, s4) {
            this.projections[t3] = e3.br(s4);
          }
          setBrightness(e4, t3, s4) {
            this.brightness = t3, s4();
          }
          setLayers(e4, t3, s4) {
            this.getLayerIndex(e4, t3.scope).replace(t3.layers, t3.options), s4();
          }
          updateLayers(e4, t3, s4) {
            this.getLayerIndex(e4, t3.scope).update(t3.layers, t3.removedIds, t3.options), s4();
          }
          loadTile(e4, t3, s4) {
            t3.projection = this.projections[e4] || this.defaultProjection, this.getWorkerSource(e4, t3.type, t3.source, t3.scope).loadTile(t3, s4);
          }
          loadDEMTile(e4, t3, s4) {
            this.getDEMWorkerSource(e4, t3.source, t3.scope).loadTile(t3, s4);
          }
          decodeRasterArray(e4, t3, s4) {
            this.getRasterArrayWorkerSource().decodeRasterArray(t3, s4);
          }
          reloadTile(e4, t3, s4) {
            t3.projection = this.projections[e4] || this.defaultProjection, this.getWorkerSource(e4, t3.type, t3.source, t3.scope).reloadTile(t3, s4);
          }
          abortTile(e4, t3, s4) {
            this.getWorkerSource(e4, t3.type, t3.source, t3.scope).abortTile(t3, s4);
          }
          removeTile(e4, t3, s4) {
            this.getWorkerSource(e4, t3.type, t3.source, t3.scope).removeTile(t3, s4);
          }
          removeSource(e4, t3, s4) {
            if (!(this.workerSources[e4] && this.workerSources[e4][t3.scope] && this.workerSources[e4][t3.scope][t3.type] && this.workerSources[e4][t3.scope][t3.type][t3.source]))
              return;
            const i3 = this.workerSources[e4][t3.scope][t3.type][t3.source];
            delete this.workerSources[e4][t3.scope][t3.type][t3.source], void 0 !== i3.removeSource ? i3.removeSource(t3, s4) : s4();
          }
          loadWorkerSource(e4, t3, s4) {
            try {
              this.self.importScripts(t3.url), s4();
            } catch (e5) {
              s4(e5.toString());
            }
          }
          syncRTLPluginState(t3, s4, i3) {
            try {
              e3.e0.setState(s4);
              const t4 = e3.e0.getPluginURL();
              if (e3.e0.isLoaded() && !e3.e0.isParsed() && null != t4) {
                this.self.importScripts(t4);
                const s5 = e3.e0.isParsed();
                i3(s5 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), s5);
              }
            } catch (e4) {
              i3(e4.toString());
            }
          }
          setDracoUrl(e4, t3) {
            this.dracoUrl = t3;
          }
          getAvailableImages(e4, t3) {
            this.availableImages[e4] || (this.availableImages[e4] = {});
            let s4 = this.availableImages[e4][t3];
            return s4 || (s4 = []), s4;
          }
          getLayerIndex(e4, t3) {
            this.layerIndexes[e4] || (this.layerIndexes[e4] = {});
            let s4 = this.layerIndexes[e4][t3];
            return s4 || (s4 = this.layerIndexes[e4][t3] = new o2(), s4.scope = t3), s4;
          }
          getWorkerSource(e4, t3, s4, i3) {
            if (this.workerSources[e4] || (this.workerSources[e4] = {}), this.workerSources[e4][i3] || (this.workerSources[e4][i3] = {}), this.workerSources[e4][i3][t3] || (this.workerSources[e4][i3][t3] = {}), this.isSpriteLoaded[e4] || (this.isSpriteLoaded[e4] = {}), !this.workerSources[e4][i3][t3][s4]) {
              const o3 = { send: (t4, s5, i4, o4, r4, n3) => {
                this.actor.send(t4, s5, i4, e4, r4, n3);
              }, scheduler: this.actor.scheduler };
              this.workerSources[e4][i3][t3][s4] = new this.workerSourceTypes[t3](o3, this.getLayerIndex(e4, i3), this.getAvailableImages(e4, i3), this.isSpriteLoaded[e4][i3], void 0, this.brightness);
            }
            return this.workerSources[e4][i3][t3][s4];
          }
          getDEMWorkerSource(e4, t3, s4) {
            return this.demWorkerSources[e4] || (this.demWorkerSources[e4] = {}), this.demWorkerSources[e4][s4] || (this.demWorkerSources[e4][s4] = {}), this.demWorkerSources[e4][s4][t3] || (this.demWorkerSources[e4][s4][t3] = new c2()), this.demWorkerSources[e4][s4][t3];
          }
          getRasterArrayWorkerSource() {
            return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new u2()), this.rasterArrayWorkerSource;
          }
          enforceCacheSizeLimit(t3, s4) {
            e3.e1(s4);
          }
          getWorkerPerformanceMetrics(e4, t3, s4) {
            s4(void 0, void 0);
          }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new q2(self)), q2;
      });
      define2(["./shared"], function(e3) {
        "use strict";
        function t2(e4, i3) {
          if (Array.isArray(e4)) {
            if (!Array.isArray(i3) || e4.length !== i3.length)
              return false;
            for (let o3 = 0; o3 < e4.length; o3++)
              if (!t2(e4[o3], i3[o3]))
                return false;
            return true;
          }
          if ("object" == typeof e4 && null !== e4 && null !== i3) {
            if ("object" != typeof i3)
              return false;
            if (Object.keys(e4).length !== Object.keys(i3).length)
              return false;
            for (const o3 in e4)
              if (!t2(e4[o3], i3[o3]))
                return false;
            return true;
          }
          return e4 === i3;
        }
        var i2 = o2;
        function o2(e4) {
          return !function(e5) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return false;
              var e6, t4, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
              try {
                t4 = new Worker(o3), e6 = true;
              } catch (t5) {
                e6 = false;
              }
              return t4 && t4.terminate(), URL.revokeObjectURL(o3), e6;
            }() ? function() {
              var e6 = document.createElement("canvas");
              e6.width = e6.height = 1;
              var t4 = e6.getContext("2d");
              if (!t4)
                return false;
              var i3 = t4.getImageData(0, 0, 1, 1);
              return i3 && i3.width === e6.width;
            }() ? (void 0 === r3[t3 = e5 && e5.failIfMajorPerformanceCaveat] && (r3[t3] = function(e6) {
              var t4, i3 = function(e7) {
                var t5 = document.createElement("canvas"), i4 = Object.create(o2.webGLContextAttributes);
                return i4.failIfMajorPerformanceCaveat = e7, t5.getContext("webgl2", i4);
              }(e6);
              if (!i3)
                return false;
              try {
                t4 = i3.createShader(i3.VERTEX_SHADER);
              } catch (e7) {
                return false;
              }
              return !(!t4 || i3.isContextLost()) && (i3.shaderSource(t4, "void main() {}"), i3.compileShader(t4), true === i3.getShaderParameter(t4, i3.COMPILE_STATUS));
            }(t3)), r3[t3] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
            var t3;
          }(e4);
        }
        var r3 = {};
        function s3(e4, t3, i3) {
          const o3 = document.createElement(e4);
          return null != t3 && (o3.className = t3), i3 && i3.appendChild(o3), o3;
        }
        function n2(e4, t3, i3) {
          const o3 = document.createElementNS("http://www.w3.org/2000/svg", e4);
          for (const e5 of Object.keys(t3))
            o3.setAttributeNS(null, e5, String(t3[e5]));
          return i3 && i3.appendChild(o3), o3;
        }
        o2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        const a2 = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, l2 = a2 && void 0 !== a2.userSelect ? "userSelect" : "WebkitUserSelect";
        let c2;
        function h() {
          a2 && l2 && (c2 = a2[l2], a2[l2] = "none");
        }
        function u2() {
          a2 && l2 && (a2[l2] = c2);
        }
        function d(e4) {
          e4.preventDefault(), e4.stopPropagation(), window.removeEventListener("click", d, true);
        }
        function _2() {
          window.addEventListener("click", d, true), window.setTimeout(() => {
            window.removeEventListener("click", d, true);
          }, 0);
        }
        function p2(e4, t3) {
          const i3 = e4.getBoundingClientRect();
          return g2(e4, i3, t3);
        }
        function f(e4, t3) {
          const i3 = e4.getBoundingClientRect(), o3 = [];
          for (let r4 = 0; r4 < t3.length; r4++)
            o3.push(g2(e4, i3, t3[r4]));
          return o3;
        }
        function m(e4) {
          return void 0 !== window.InstallTrigger && 2 === e4.button && e4.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e4.button;
        }
        function g2(t3, i3, o3) {
          const r4 = t3.offsetWidth === i3.width ? 1 : t3.offsetWidth / i3.width;
          return new e3.P((o3.clientX - i3.left) * r4, (o3.clientY - i3.top) * r4);
        }
        class v2 {
          constructor() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
          }
          isDirty() {
            return this._changed;
          }
          setDirty() {
            this._changed = true;
          }
          getUpdatedSourceCaches() {
            return this._updatedSourceCaches;
          }
          updateSourceCache(e4, t3) {
            this._updatedSourceCaches[e4] = t3, this.setDirty();
          }
          discardSourceCacheUpdate(e4) {
            delete this._updatedSourceCaches[e4];
          }
          updateLayer(e4) {
            const t3 = e4.scope;
            this._updatedLayers[t3] = this._updatedLayers[t3] || /* @__PURE__ */ new Set(), this._updatedLayers[t3].add(e4.id), this.setDirty();
          }
          removeLayer(e4) {
            const t3 = e4.scope;
            this._removedLayers[t3] = this._removedLayers[t3] || {}, this._updatedLayers[t3] = this._updatedLayers[t3] || /* @__PURE__ */ new Set(), this._removedLayers[t3][e4.id] = e4, this._updatedLayers[t3].delete(e4.id), this._updatedPaintProps.delete(e4.fqid), this.setDirty();
          }
          getRemovedLayer(e4) {
            return this._removedLayers[e4.scope] ? this._removedLayers[e4.scope][e4.id] : null;
          }
          discardLayerRemoval(e4) {
            this._removedLayers[e4.scope] && delete this._removedLayers[e4.scope][e4.id];
          }
          getLayerUpdatesByScope() {
            const e4 = {};
            for (const t3 in this._updatedLayers)
              e4[t3] = e4[t3] || {}, e4[t3].updatedIds = Array.from(this._updatedLayers[t3].values());
            for (const t3 in this._removedLayers)
              e4[t3] = e4[t3] || {}, e4[t3].removedIds = Object.keys(this._removedLayers[t3]);
            return e4;
          }
          getUpdatedPaintProperties() {
            return this._updatedPaintProps;
          }
          updatePaintProperties(e4) {
            this._updatedPaintProps.add(e4.fqid), this.setDirty();
          }
          getUpdatedImages() {
            return Array.from(this._updatedImages.values());
          }
          updateImage(e4) {
            this._updatedImages.add(e4), this.setDirty();
          }
          resetUpdatedImages() {
            this._updatedImages.clear();
          }
          reset() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
          }
        }
        class x2 extends e3.E {
          constructor(e4) {
            super(), this.requestManager = e4, this.models = { "": {} }, this.numModelsLoading = {};
          }
          loadModel(t3, i3) {
            return e3.l(this.requestManager.transformRequest(i3, e3.R.Model).url).then((i4) => {
              if (!i4)
                return;
              const o3 = e3.c(i4), r4 = new e3.M(t3, void 0, void 0, o3);
              return r4.computeBoundsAndApplyParent(), r4;
            }).catch((o3) => {
              if (o3 && 404 === o3.status)
                return null;
              this.fire(new e3.a(new Error(`Could not load model ${t3} from ${i3}: ${o3.message}`)));
            });
          }
          load(t3, i3) {
            this.models[i3] || (this.models[i3] = {});
            const o3 = Object.keys(t3);
            this.numModelsLoading[i3] = (this.numModelsLoading[i3] || 0) + o3.length;
            const r4 = [];
            for (const e4 of o3)
              r4.push(this.loadModel(e4, t3[e4]));
            Promise.allSettled(r4).then((t4) => {
              for (let e4 = 0; e4 < t4.length; e4++) {
                const { status: r5, value: s4 } = t4[e4];
                "fulfilled" === r5 && s4 && (this.models[i3][o3[e4]] = { model: s4, numReferences: 1 });
              }
              this.numModelsLoading[i3] -= o3.length, this.fire(new e3.b("data", { dataType: "style" }));
            }).catch((t4) => {
              this.fire(new e3.a(new Error(`Could not load models: ${t4.message}`)));
            });
          }
          isLoaded() {
            for (const e4 in this.numModelsLoading)
              if (this.numModelsLoading[e4] > 0)
                return false;
            return true;
          }
          hasModel(e4, t3) {
            return !!this.getModel(e4, t3);
          }
          getModel(e4, t3) {
            return this.models[t3] || (this.models[t3] = {}), this.models[t3][e4] ? this.models[t3][e4].model : void 0;
          }
          addModel(e4, t3, i3) {
            this.models[i3] || (this.models[i3] = {}), this.hasModel(e4, i3) && this.models[i3][e4].numReferences++, this.load({ [e4]: this.requestManager.normalizeModelURL(t3) }, i3);
          }
          addModels(e4, t3) {
            this.models[t3] || (this.models[t3] = {});
            const i3 = {};
            for (const o3 in e4)
              this.models[t3][o3] = {}, i3[o3] = this.requestManager.normalizeModelURL(e4[o3]);
            this.load(i3, t3);
          }
          addModelsFromBucket(e4, t3) {
            this.models[t3] || (this.models[t3] = {});
            const i3 = {};
            for (const o3 of e4)
              this.hasModel(o3, t3) ? this.models[t3][o3].numReferences++ : i3[o3] = this.requestManager.normalizeModelURL(o3);
            this.load(i3, t3);
          }
          removeModel(e4, t3) {
            if (this.models[t3] && this.models[t3][e4] && (this.models[t3][e4].numReferences--, 0 === this.models[t3][e4].numReferences)) {
              const i3 = this.models[t3][e4].model;
              delete this.models[t3][e4], i3.destroy();
            }
          }
          listModels(e4) {
            return this.models[e4] || (this.models[e4] = {}), Object.keys(this.models[e4]);
          }
          upload(e4, t3) {
            this.models[t3] || (this.models[t3] = {});
            for (const i3 in this.models[t3])
              this.models[t3][i3].model && this.models[t3][i3].model.upload(e4.context);
          }
        }
        class y2 {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t3, i3, o3) {
            const r4 = String(i3);
            if (this.stateChanges[t3] = this.stateChanges[t3] || {}, this.stateChanges[t3][r4] = this.stateChanges[t3][r4] || {}, e3.e(this.stateChanges[t3][r4], o3), null === this.deletedStates[t3]) {
              this.deletedStates[t3] = {};
              for (const e4 in this.state[t3])
                e4 !== r4 && (this.deletedStates[t3][e4] = null);
            } else if (this.deletedStates[t3] && null === this.deletedStates[t3][r4]) {
              this.deletedStates[t3][r4] = {};
              for (const e4 in this.state[t3][r4])
                o3[e4] || (this.deletedStates[t3][r4][e4] = null);
            } else
              for (const e4 in o3)
                this.deletedStates[t3] && this.deletedStates[t3][r4] && null === this.deletedStates[t3][r4][e4] && delete this.deletedStates[t3][r4][e4];
          }
          removeFeatureState(e4, t3, i3) {
            if (null === this.deletedStates[e4])
              return;
            const o3 = String(t3);
            if (this.deletedStates[e4] = this.deletedStates[e4] || {}, i3 && void 0 !== t3)
              null !== this.deletedStates[e4][o3] && (this.deletedStates[e4][o3] = this.deletedStates[e4][o3] || {}, this.deletedStates[e4][o3][i3] = null);
            else if (void 0 !== t3)
              if (this.stateChanges[e4] && this.stateChanges[e4][o3])
                for (i3 in this.deletedStates[e4][o3] = {}, this.stateChanges[e4][o3])
                  this.deletedStates[e4][o3][i3] = null;
              else
                this.deletedStates[e4][o3] = null;
            else
              this.deletedStates[e4] = null;
          }
          getState(t3, i3) {
            const o3 = String(i3), r4 = e3.e({}, (this.state[t3] || {})[o3], (this.stateChanges[t3] || {})[o3]);
            if (null === this.deletedStates[t3])
              return {};
            if (this.deletedStates[t3]) {
              const e4 = this.deletedStates[t3][i3];
              if (null === e4)
                return {};
              for (const t4 in e4)
                delete r4[t4];
            }
            return r4;
          }
          initializeTileState(e4, t3) {
            e4.setFeatureState(this.state, t3);
          }
          coalesceChanges(t3, i3) {
            const o3 = {};
            for (const t4 in this.stateChanges) {
              this.state[t4] = this.state[t4] || {};
              const i4 = {};
              for (const o4 in this.stateChanges[t4])
                this.state[t4][o4] || (this.state[t4][o4] = {}), e3.e(this.state[t4][o4], this.stateChanges[t4][o4]), i4[o4] = this.state[t4][o4];
              o3[t4] = i4;
            }
            for (const t4 in this.deletedStates) {
              this.state[t4] = this.state[t4] || {};
              const i4 = {};
              if (null === this.deletedStates[t4])
                for (const e4 in this.state[t4])
                  i4[e4] = {}, this.state[t4][e4] = {};
              else
                for (const e4 in this.deletedStates[t4]) {
                  if (null === this.deletedStates[t4][e4])
                    this.state[t4][e4] = {};
                  else if (this.state[t4][e4])
                    for (const i5 of Object.keys(this.deletedStates[t4][e4]))
                      delete this.state[t4][e4][i5];
                  i4[e4] = this.state[t4][e4];
                }
              o3[t4] = o3[t4] || {}, e3.e(o3[t4], i4);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o3).length)
              for (const e4 in t3)
                t3[e4].setFeatureState(o3, i3);
          }
        }
        function b(e4) {
          const { userImage: t3 } = e4;
          return !!(t3 && t3.render && t3.render()) && (e4.data.replace(new Uint8Array(t3.data.buffer)), true);
        }
        class w extends e3.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = true;
          }
          createScope(t3) {
            this.images[t3] = {}, this.loaded[t3] = false, this.updatedImages[t3] = {}, this.patterns[t3] = {}, this.callbackDispatchedThisFrame[t3] = {}, this.atlasImage[t3] = new e3.h({ width: 1, height: 1 });
          }
          isLoaded() {
            for (const e4 in this.loaded)
              if (!this.loaded[e4])
                return false;
            return true;
          }
          setLoaded(e4, t3) {
            if (this.loaded[t3] !== e4 && (this.loaded[t3] = e4, e4)) {
              for (const { ids: e5, callback: i3 } of this.requestors)
                this._notify(e5, t3, i3);
              this.requestors = [];
            }
          }
          hasImage(e4, t3) {
            return !!this.getImage(e4, t3);
          }
          getImage(e4, t3) {
            return this.images[t3][e4];
          }
          addImage(e4, t3, i3) {
            this._validate(e4, i3) && (this.images[t3][e4] = i3);
          }
          _validate(t3, i3) {
            let o3 = true;
            return this._validateStretch(i3.stretchX, i3.data && i3.data.width) || (this.fire(new e3.a(new Error(`Image "${t3}" has invalid "stretchX" value`))), o3 = false), this._validateStretch(i3.stretchY, i3.data && i3.data.height) || (this.fire(new e3.a(new Error(`Image "${t3}" has invalid "stretchY" value`))), o3 = false), this._validateContent(i3.content, i3) || (this.fire(new e3.a(new Error(`Image "${t3}" has invalid "content" value`))), o3 = false), o3;
          }
          _validateStretch(e4, t3) {
            if (!e4)
              return true;
            let i3 = 0;
            for (const o3 of e4) {
              if (o3[0] < i3 || o3[1] < o3[0] || t3 < o3[1])
                return false;
              i3 = o3[1];
            }
            return true;
          }
          _validateContent(e4, t3) {
            return !(e4 && (4 !== e4.length || e4[0] < 0 || t3.data.width < e4[0] || e4[1] < 0 || t3.data.height < e4[1] || e4[2] < 0 || t3.data.width < e4[2] || e4[3] < 0 || t3.data.height < e4[3] || e4[2] < e4[0] || e4[3] < e4[1]));
          }
          updateImage(e4, t3, i3) {
            i3.version = this.images[t3][e4].version + 1, this.images[t3][e4] = i3, this.updatedImages[t3][e4] = true;
          }
          removeImage(e4, t3) {
            const i3 = this.images[t3][e4];
            delete this.images[t3][e4], delete this.patterns[t3][e4], i3.userImage && i3.userImage.onRemove && i3.userImage.onRemove();
          }
          listImages(e4) {
            return Object.keys(this.images[e4]);
          }
          getImages(e4, t3, i3) {
            let o3 = true;
            const r4 = !!this.loaded[t3];
            if (!r4)
              for (const i4 of e4)
                this.images[t3][i4] || (o3 = false);
            r4 || o3 ? this._notify(e4, t3, i3) : this.requestors.push({ ids: e4, scope: t3, callback: i3 });
          }
          getUpdatedImages(e4) {
            return this.updatedImages[e4];
          }
          _notify(t3, i3, o3) {
            const r4 = {};
            for (const o4 of t3) {
              this.images[i3][o4] || this.fire(new e3.b("styleimagemissing", { id: o4 }));
              const t4 = this.images[i3][o4];
              t4 ? r4[o4] = { data: t4.data.clone(), pixelRatio: t4.pixelRatio, sdf: t4.sdf, version: t4.version, stretchX: t4.stretchX, stretchY: t4.stretchY, content: t4.content, hasRenderCallback: Boolean(t4.userImage && t4.userImage.render) } : e3.w(`Image "${o4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            o3(null, r4);
          }
          getPixelSize(e4) {
            const { width: t3, height: i3 } = this.atlasImage[e4];
            return { width: t3, height: i3 };
          }
          getPattern(t3, i3) {
            const o3 = this.patterns[i3][t3], r4 = this.getImage(t3, i3);
            if (!r4)
              return null;
            if (o3 && o3.position.version === r4.version)
              return o3.position;
            if (o3)
              o3.position.version = r4.version;
            else {
              const o4 = { w: r4.data.width + 2, h: r4.data.height + 2, x: 0, y: 0 }, s4 = new e3.I(o4, r4);
              this.patterns[i3][t3] = { bin: o4, position: s4 };
            }
            return this._updatePatternAtlas(i3), this.patterns[i3][t3].position;
          }
          bind(t3, i3) {
            const o3 = t3.gl;
            let r4 = this.atlasTexture[i3];
            r4 ? this.dirty && (r4.update(this.atlasImage[i3]), this.dirty = false) : (r4 = new e3.T(t3, this.atlasImage[i3], o3.RGBA), this.atlasTexture[i3] = r4), r4.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas(t3) {
            const i3 = [];
            for (const e4 in this.patterns[t3])
              i3.push(this.patterns[t3][e4].bin);
            const { w: o3, h: r4 } = e3.p(i3), s4 = this.atlasImage[t3];
            s4.resize({ width: o3 || 1, height: r4 || 1 });
            for (const i4 in this.patterns[t3]) {
              const { bin: o4 } = this.patterns[t3][i4], r5 = o4.x + 1, n3 = o4.y + 1, a3 = this.images[t3][i4].data, l3 = a3.width, c3 = a3.height;
              e3.h.copy(a3, s4, { x: 0, y: 0 }, { x: r5, y: n3 }, { width: l3, height: c3 }), e3.h.copy(a3, s4, { x: 0, y: c3 - 1 }, { x: r5, y: n3 - 1 }, { width: l3, height: 1 }), e3.h.copy(a3, s4, { x: 0, y: 0 }, { x: r5, y: n3 + c3 }, { width: l3, height: 1 }), e3.h.copy(a3, s4, { x: l3 - 1, y: 0 }, { x: r5 - 1, y: n3 }, { width: 1, height: c3 }), e3.h.copy(a3, s4, { x: 0, y: 0 }, { x: r5 + l3, y: n3 }, { width: 1, height: c3 });
            }
            this.dirty = true;
          }
          beginFrame() {
            for (const e4 in this.images)
              this.callbackDispatchedThisFrame[e4] = {};
          }
          dispatchRenderCallbacks(e4, t3) {
            for (const i3 of e4) {
              if (this.callbackDispatchedThisFrame[t3][i3])
                continue;
              this.callbackDispatchedThisFrame[t3][i3] = true;
              const e5 = this.images[t3][i3];
              b(e5) && this.updateImage(i3, t3, e5);
            }
          }
        }
        function T(t3) {
          const i3 = t3.key, o3 = t3.value, r4 = t3.valueSpec || {}, s4 = t3.objectElementValidators || {}, n3 = t3.style, a3 = t3.styleSpec;
          let l3 = [];
          const c3 = e3.j(o3);
          if ("object" !== c3)
            return [new e3.V(i3, o3, `object expected, ${c3} found`)];
          for (const t4 in o3) {
            const c4 = t4.split(".")[0];
            let h2;
            s4[c4] ? h2 = s4[c4] : r4[c4] ? h2 = W : s4["*"] ? h2 = s4["*"] : r4["*"] && (h2 = W), h2 ? l3 = l3.concat(h2({ key: (i3 ? `${i3}.` : i3) + t4, value: o3[t4], valueSpec: r4[c4] || r4["*"], style: n3, styleSpec: a3, object: o3, objectKey: t4 }, o3)) : l3.push(new e3.i(i3, o3[t4], `unknown property "${t4}"`));
          }
          for (const t4 in r4)
            s4[t4] || r4[t4].required && void 0 === r4[t4].default && void 0 === o3[t4] && l3.push(new e3.V(i3, o3, `missing required property "${t4}"`));
          return l3;
        }
        function E(t3) {
          const i3 = t3.value, o3 = t3.valueSpec, r4 = t3.style, s4 = t3.styleSpec, n3 = t3.key, a3 = t3.arrayElementValidator || W;
          if ("array" !== e3.j(i3))
            return [new e3.V(n3, i3, `array expected, ${e3.j(i3)} found`)];
          if (o3.length && i3.length !== o3.length)
            return [new e3.V(n3, i3, `array length ${o3.length} expected, length ${i3.length} found`)];
          if (o3["min-length"] && i3.length < o3["min-length"])
            return [new e3.V(n3, i3, `array length at least ${o3["min-length"]} expected, length ${i3.length} found`)];
          let l3 = { type: o3.value, values: o3.values, minimum: o3.minimum, maximum: o3.maximum, function: void 0 };
          s4.$version < 7 && (l3.function = o3.function), "object" === e3.j(o3.value) && (l3 = o3.value);
          let c3 = [];
          for (let e4 = 0; e4 < i3.length; e4++)
            c3 = c3.concat(a3({ array: i3, arrayIndex: e4, value: i3[e4], valueSpec: l3, style: r4, styleSpec: s4, key: `${n3}[${e4}]` }, true));
          return c3;
        }
        function S(t3) {
          const i3 = t3.key, o3 = t3.value, r4 = t3.valueSpec;
          let s4 = e3.j(o3);
          if ("number" === s4 && o3 != o3 && (s4 = "NaN"), "number" !== s4)
            return [new e3.V(i3, o3, `number expected, ${s4} found`)];
          if ("minimum" in r4) {
            let s5 = r4.minimum;
            if ("array" === e3.j(r4.minimum) && (s5 = r4.minimum[t3.arrayIndex]), o3 < s5)
              return [new e3.V(i3, o3, `${o3} is less than the minimum value ${s5}`)];
          }
          if ("maximum" in r4) {
            let s5 = r4.maximum;
            if ("array" === e3.j(r4.maximum) && (s5 = r4.maximum[t3.arrayIndex]), o3 > s5)
              return [new e3.V(i3, o3, `${o3} is greater than the maximum value ${s5}`)];
          }
          return [];
        }
        function C(t3) {
          const i3 = t3.valueSpec, o3 = e3.u(t3.value.type);
          let r4, s4, n3, a3 = {};
          const l3 = "categorical" !== o3 && void 0 === t3.value.property, c3 = !l3, h2 = "array" === e3.j(t3.value.stops) && "array" === e3.j(t3.value.stops[0]) && "object" === e3.j(t3.value.stops[0][0]), u3 = T({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
            if ("identity" === o3)
              return [new e3.V(t4.key, t4.value, 'identity function may not have a "stops" property')];
            let i4 = [];
            const r5 = t4.value;
            return i4 = i4.concat(E({ key: t4.key, value: r5, valueSpec: t4.valueSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: d2 })), "array" === e3.j(r5) && 0 === r5.length && i4.push(new e3.V(t4.key, r5, "array must have at least one stop")), i4;
          }, default: function(e4) {
            return W({ key: e4.key, value: e4.value, valueSpec: i3, style: e4.style, styleSpec: e4.styleSpec });
          } } });
          return "identity" === o3 && l3 && u3.push(new e3.V(t3.key, t3.value, 'missing required property "property"')), "identity" === o3 || t3.value.stops || u3.push(new e3.V(t3.key, t3.value, 'missing required property "stops"')), "exponential" === o3 && t3.valueSpec.expression && !e3.s(t3.valueSpec) && u3.push(new e3.V(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (c3 && !e3.m(t3.valueSpec) ? u3.push(new e3.V(t3.key, t3.value, "property functions not supported")) : l3 && !e3.n(t3.valueSpec) && u3.push(new e3.V(t3.key, t3.value, "zoom functions not supported"))), "categorical" !== o3 && !h2 || void 0 !== t3.value.property || u3.push(new e3.V(t3.key, t3.value, '"property" property is required')), u3;
          function d2(t4) {
            let o4 = [];
            const r5 = t4.value, l4 = t4.key;
            if ("array" !== e3.j(r5))
              return [new e3.V(l4, r5, `array expected, ${e3.j(r5)} found`)];
            if (2 !== r5.length)
              return [new e3.V(l4, r5, `array length 2 expected, length ${r5.length} found`)];
            if (h2) {
              if ("object" !== e3.j(r5[0]))
                return [new e3.V(l4, r5, `object expected, ${e3.j(r5[0])} found`)];
              if (void 0 === r5[0].zoom)
                return [new e3.V(l4, r5, "object stop key must have zoom")];
              if (void 0 === r5[0].value)
                return [new e3.V(l4, r5, "object stop key must have value")];
              const i4 = e3.u(r5[0].zoom);
              if ("number" != typeof i4)
                return [new e3.V(l4, r5[0].zoom, "stop zoom values must be numbers")];
              if (n3 && n3 > i4)
                return [new e3.V(l4, r5[0].zoom, "stop zoom values must appear in ascending order")];
              i4 !== n3 && (n3 = i4, s4 = void 0, a3 = {}), o4 = o4.concat(T({ key: `${l4}[0]`, value: r5[0], valueSpec: { zoom: {} }, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: S, value: _3 } }));
            } else
              o4 = o4.concat(_3({ key: `${l4}[0]`, value: r5[0], valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec }, r5));
            return e3.o(e3.q(r5[1])) ? o4.concat([new e3.V(`${l4}[1]`, r5[1], "expressions are not allowed in function stops.")]) : o4.concat(W({ key: `${l4}[1]`, value: r5[1], valueSpec: i3, style: t4.style, styleSpec: t4.styleSpec }));
          }
          function _3(t4, n4) {
            const l4 = e3.j(t4.value), c4 = e3.u(t4.value), h3 = null !== t4.value ? t4.value : n4;
            if (r4) {
              if (l4 !== r4)
                return [new e3.V(t4.key, h3, `${l4} stop domain type must match previous stop domain type ${r4}`)];
            } else
              r4 = l4;
            if ("number" !== l4 && "string" !== l4 && "boolean" !== l4 && "number" != typeof c4 && "string" != typeof c4 && "boolean" != typeof c4)
              return [new e3.V(t4.key, h3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== l4 && "categorical" !== o3) {
              let r5 = `number expected, ${l4} found`;
              return e3.m(i3) && void 0 === o3 && (r5 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new e3.V(t4.key, h3, r5)];
            }
            return "categorical" !== o3 || "number" !== l4 || "number" == typeof c4 && isFinite(c4) && Math.floor(c4) === c4 ? "categorical" !== o3 && "number" === l4 && "number" == typeof c4 && "number" == typeof s4 && void 0 !== s4 && c4 < s4 ? [new e3.V(t4.key, h3, "stop domain values must appear in ascending order")] : (s4 = c4, "categorical" === o3 && c4 in a3 ? [new e3.V(t4.key, h3, "stop domain values must be unique")] : (a3[c4] = true, [])) : [new e3.V(t4.key, h3, `integer expected, found ${String(c4)}`)];
          }
        }
        function I(t3) {
          const i3 = ("property" === t3.expressionContext ? e3.r : e3.t)(e3.q(t3.value), t3.valueSpec);
          if ("error" === i3.result)
            return i3.value.map((i4) => new e3.V(`${t3.key}${i4.key}`, t3.value, i4.message));
          const o3 = i3.value.expression || i3.value._styleExpression.expression;
          if ("property" === t3.expressionContext && "text-font" === t3.propertyKey && !o3.outputDefined())
            return [new e3.V(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t3.expressionContext && "layout" === t3.propertyType && !e3.v(o3))
            return [new e3.V(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t3.expressionContext)
            return D(o3, t3);
          if (t3.expressionContext && 0 === t3.expressionContext.indexOf("cluster")) {
            if (!e3.x(o3, ["zoom", "feature-state"]))
              return [new e3.V(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t3.expressionContext && !e3.y(o3))
              return [new e3.V(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function D(t3, i3) {
          const o3 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (i3.valueSpec && i3.valueSpec.expression)
            for (const e4 of i3.valueSpec.expression.parameters)
              o3.delete(e4);
          if (0 === o3.size)
            return [];
          const r4 = [];
          return t3 instanceof e3.C && o3.has(t3.name) ? [new e3.V(i3.key, i3.value, `["${t3.name}"] expression is not supported in a filter for a ${i3.object.type} layer with id: ${i3.object.id}`)] : (t3.eachChild((e4) => {
            r4.push(...D(e4, i3));
          }), r4);
        }
        function R2(t3) {
          const i3 = t3.key, o3 = t3.value, r4 = t3.valueSpec, s4 = [];
          return Array.isArray(r4.values) ? -1 === r4.values.indexOf(e3.u(o3)) && s4.push(new e3.V(i3, o3, `expected one of [${r4.values.join(", ")}], ${JSON.stringify(o3)} found`)) : -1 === Object.keys(r4.values).indexOf(e3.u(o3)) && s4.push(new e3.V(i3, o3, `expected one of [${Object.keys(r4.values).join(", ")}], ${JSON.stringify(o3)} found`)), s4;
        }
        function A(t3) {
          return e3.A(e3.q(t3.value)) ? I(e3.k({}, t3, { expressionContext: "filter", valueSpec: t3.styleSpec[`filter_${t3.layerType || "fill"}`] })) : P(t3);
        }
        function P(t3) {
          const i3 = t3.value, o3 = t3.key;
          if ("array" !== e3.j(i3))
            return [new e3.V(o3, i3, `array expected, ${e3.j(i3)} found`)];
          const r4 = t3.styleSpec;
          let s4, n3 = [];
          if (i3.length < 1)
            return [new e3.V(o3, i3, "filter array must have at least 1 element")];
          switch (n3 = n3.concat(R2({ key: `${o3}[0]`, value: i3[0], valueSpec: r4.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), e3.u(i3[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              i3.length >= 2 && "$type" === e3.u(i3[1]) && n3.push(new e3.V(o3, i3, `"$type" cannot be use with operator "${i3[0]}"`));
            case "==":
            case "!=":
              3 !== i3.length && n3.push(new e3.V(o3, i3, `filter array for operator "${i3[0]}" must have 3 elements`));
            case "in":
            case "!in":
              i3.length >= 2 && (s4 = e3.j(i3[1]), "string" !== s4 && n3.push(new e3.V(`${o3}[1]`, i3[1], `string expected, ${s4} found`)));
              for (let a3 = 2; a3 < i3.length; a3++)
                s4 = e3.j(i3[a3]), "$type" === e3.u(i3[1]) ? n3 = n3.concat(R2({ key: `${o3}[${a3}]`, value: i3[a3], valueSpec: r4.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : "string" !== s4 && "number" !== s4 && "boolean" !== s4 && n3.push(new e3.V(`${o3}[${a3}]`, i3[a3], `string, number, or boolean expected, ${s4} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let e4 = 1; e4 < i3.length; e4++)
                n3 = n3.concat(P({ key: `${o3}[${e4}]`, value: i3[e4], style: t3.style, styleSpec: t3.styleSpec }));
              break;
            case "has":
            case "!has":
              s4 = e3.j(i3[1]), 2 !== i3.length ? n3.push(new e3.V(o3, i3, `filter array for "${i3[0]}" operator must have 2 elements`)) : "string" !== s4 && n3.push(new e3.V(`${o3}[1]`, i3[1], `string expected, ${s4} found`));
          }
          return n3;
        }
        function L(t3, i3) {
          const o3 = t3.key, r4 = t3.style, s4 = t3.layer, n3 = t3.styleSpec, a3 = t3.value, l3 = t3.objectKey, c3 = n3[`${i3}_${t3.layerType}`];
          if (!c3)
            return [];
          const h2 = l3.match(/^(.*)-transition$/);
          if ("paint" === i3 && h2 && c3[h2[1]] && c3[h2[1]].transition)
            return W({ key: o3, value: a3, valueSpec: n3.transition, style: r4, styleSpec: n3 });
          const u3 = t3.valueSpec || c3[l3];
          if (!u3)
            return [new e3.i(o3, a3, `unknown property "${l3}"`)];
          let d2;
          if ("string" === e3.j(a3) && e3.m(u3) && !u3.tokens && (d2 = /^{([^}]+)}$/.exec(a3))) {
            const t4 = `\`{ "type": "identity", "property": ${d2 ? JSON.stringify(d2[1]) : '"_"'} }\``;
            return [new e3.V(o3, a3, `"${l3}" does not support interpolation syntax
Use an identity property function instead: ${t4}.`)];
          }
          const _3 = [];
          if ("symbol" === t3.layerType)
            "text-field" !== l3 || !r4 || r4.glyphs || r4.imports || _3.push(new e3.V(o3, a3, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l3 && e3.B(e3.q(a3)) && "identity" === e3.u(a3.type) && _3.push(new e3.V(o3, a3, '"text-font" does not support identity functions'));
          else if ("model" === t3.layerType && "paint" === i3 && s4 && s4.layout && s4.layout.hasOwnProperty("model-id") && e3.m(u3) && (e3.D(u3) || e3.n(u3))) {
            const t4 = e3.r(e3.q(a3), u3), i4 = t4.value.expression || t4.value._styleExpression.expression;
            i4 && !e3.x(i4, ["measure-light"]) && ("model-emissive-strength" === l3 && e3.y(i4) && e3.v(i4) || _3.push(new e3.V(o3, a3, `${l3} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
          }
          return _3.concat(W({ key: t3.key, value: a3, valueSpec: u3, style: r4, styleSpec: n3, expressionContext: "property", propertyType: i3, propertyKey: l3 }));
        }
        function M2(e4) {
          return L(e4, "paint");
        }
        function z2(e4) {
          return L(e4, "layout");
        }
        function O(t3) {
          let i3 = [];
          const o3 = t3.value, r4 = t3.key, s4 = t3.style, n3 = t3.styleSpec;
          o3.type || o3.ref || i3.push(new e3.V(r4, o3, 'either "type" or "ref" is required'));
          let a3 = e3.u(o3.type);
          const l3 = e3.u(o3.ref);
          if (o3.id) {
            const n4 = e3.u(o3.id);
            for (let a4 = 0; a4 < t3.arrayIndex; a4++) {
              const t4 = s4.layers[a4];
              e3.u(t4.id) === n4 && i3.push(new e3.V(r4, o3.id, `duplicate layer id "${o3.id}", previously used at line ${t4.id.__line__}`));
            }
          }
          if ("ref" in o3) {
            let t4;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
              t5 in o3 && i3.push(new e3.V(r4, o3[t5], `"${t5}" is prohibited for ref layers`));
            }), s4.layers.forEach((i4) => {
              e3.u(i4.id) === l3 && (t4 = i4);
            }), t4 ? t4.ref ? i3.push(new e3.V(r4, o3.ref, "ref cannot reference another ref layer")) : a3 = e3.u(t4.type) : "string" == typeof l3 && i3.push(new e3.V(r4, o3.ref, `ref layer "${l3}" not found`));
          } else if ("background" !== a3 && "sky" !== a3 && "slot" !== a3)
            if (o3.source) {
              const t4 = s4.sources && s4.sources[o3.source], n4 = t4 && e3.u(t4.type);
              t4 ? "vector" === n4 && "raster" === a3 ? i3.push(new e3.V(r4, o3.source, `layer "${o3.id}" requires a raster source`)) : "raster" === n4 && "raster" !== a3 ? i3.push(new e3.V(r4, o3.source, `layer "${o3.id}" requires a vector source`)) : "vector" !== n4 || o3["source-layer"] ? "raster-dem" === n4 && "hillshade" !== a3 ? i3.push(new e3.V(r4, o3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n4 || ["raster", "raster-particle"].includes(a3) ? "line" !== a3 || !o3.paint || !o3.paint["line-gradient"] && !o3.paint["line-trim-offset"] || "geojson" === n4 && t4.lineMetrics ? "raster-particle" === a3 && "raster-array" !== n4 && i3.push(new e3.V(r4, o3.source, `layer "${o3.id}" requires a 'raster-array' source.`)) : i3.push(new e3.V(r4, o3, `layer "${o3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : i3.push(new e3.V(r4, o3.source, "raster-array source can only be used with layer type 'raster'.")) : i3.push(new e3.V(r4, o3, `layer "${o3.id}" must specify a "source-layer"`)) : i3.push(new e3.V(r4, o3.source, `source "${o3.source}" not found`));
            } else
              i3.push(new e3.V(r4, o3, 'missing required property "source"'));
          return i3 = i3.concat(T({ key: r4, value: o3, valueSpec: n3.layer, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": () => [], type: () => W({ key: `${r4}.type`, value: o3.type, valueSpec: n3.layer.type, style: t3.style, styleSpec: t3.styleSpec, object: o3, objectKey: "type" }), filter: (t4) => A(e3.k({ layerType: a3 }, t4)), layout: (t4) => T({ layer: o3, key: t4.key, value: t4.value, valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => z2(e3.k({ layerType: a3 }, t5)) } }), paint: (t4) => T({ layer: o3, key: t4.key, value: t4.value, valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => M2(e3.k({ layerType: a3, layer: o3 }, t5)) } }) } })), i3;
        }
        function F(t3) {
          const i3 = t3.value, o3 = t3.key, r4 = e3.j(i3);
          return "string" !== r4 ? [new e3.V(o3, i3, `string expected, ${r4} found`)] : [];
        }
        const B = { promoteId: function({ key: t3, value: i3 }) {
          if ("string" === e3.j(i3))
            return F({ key: t3, value: i3 });
          {
            const e4 = [];
            for (const o3 in i3)
              e4.push(...F({ key: `${t3}.${o3}`, value: i3[o3] }));
            return e4;
          }
        } };
        function k(t3) {
          const i3 = t3.value, o3 = t3.key, r4 = t3.styleSpec, s4 = t3.style;
          if (!i3.type)
            return [new e3.V(o3, i3, '"type" is required')];
          const n3 = e3.u(i3.type);
          let a3 = [];
          switch (["vector", "raster", "raster-dem", "raster-array"].includes(n3) && (i3.url || i3.tiles || a3.push(new e3.i(o3, i3, 'Either "url" or "tiles" is required.'))), n3) {
            case "vector":
            case "raster":
            case "raster-dem":
            case "raster-array":
              return a3 = a3.concat(T({ key: o3, value: i3, valueSpec: r4[`source_${n3.replace("-", "_")}`], style: t3.style, styleSpec: r4, objectElementValidators: B })), a3;
            case "geojson":
              if (a3 = T({ key: o3, value: i3, valueSpec: r4.source_geojson, style: s4, styleSpec: r4, objectElementValidators: B }), i3.cluster)
                for (const e4 in i3.clusterProperties) {
                  const [t4, r5] = i3.clusterProperties[e4], s5 = "string" == typeof t4 ? [t4, ["accumulated"], ["get", e4]] : t4;
                  a3.push(...I({ key: `${o3}.${e4}.map`, value: r5, expressionContext: "cluster-map" })), a3.push(...I({ key: `${o3}.${e4}.reduce`, value: s5, expressionContext: "cluster-reduce" }));
                }
              return a3;
            case "video":
              return T({ key: o3, value: i3, valueSpec: r4.source_video, style: s4, styleSpec: r4 });
            case "image":
              return T({ key: o3, value: i3, valueSpec: r4.source_image, style: s4, styleSpec: r4 });
            case "canvas":
              return [new e3.V(o3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return R2({ key: `${o3}.type`, value: i3.type, valueSpec: { values: N(r4) }, style: s4, styleSpec: r4 });
          }
        }
        function N(e4) {
          return e4.source.reduce((t3, i3) => {
            const o3 = e4[i3];
            return "enum" === o3.type.type && (t3 = t3.concat(Object.keys(o3.type.values))), t3;
          }, []);
        }
        function U(t3) {
          const i3 = t3.value, o3 = t3.styleSpec, r4 = o3.light, s4 = t3.style;
          let n3 = [];
          const a3 = e3.j(i3);
          if (void 0 === i3)
            return n3;
          if ("object" !== a3)
            return n3 = n3.concat([new e3.V("light", i3, `object expected, ${a3} found`)]), n3;
          for (const t4 in i3) {
            const a4 = t4.match(/^(.*)-transition$/);
            n3 = n3.concat(a4 && r4[a4[1]] && r4[a4[1]].transition ? W({ key: t4, value: i3[t4], valueSpec: o3.transition, style: s4, styleSpec: o3 }) : r4[t4] ? W({ key: t4, value: i3[t4], valueSpec: r4[t4], style: s4, styleSpec: o3 }) : [new e3.V(t4, i3[t4], `unknown property "${t4}"`)]);
          }
          return n3;
        }
        function G(t3) {
          const i3 = t3.value;
          let o3 = [];
          if (!i3)
            return o3;
          const r4 = e3.j(i3);
          if ("object" !== r4)
            return o3 = o3.concat([new e3.V("light-3d", i3, `object expected, ${r4} found`)]), o3;
          const s4 = t3.styleSpec, n3 = s4["light-3d"], a3 = t3.key, l3 = t3.style, c3 = t3.style.lights;
          for (const t4 of ["type", "id"])
            if (!(t4 in i3))
              return o3 = o3.concat([new e3.V("light-3d", i3, `missing property ${t4} on light`)]), o3;
          if (i3.type && c3)
            for (let r5 = 0; r5 < t3.arrayIndex; r5++) {
              const t4 = e3.u(i3.type), s5 = c3[r5];
              e3.u(s5.type) === t4 && o3.push(new e3.V(a3, i3.id, `duplicate light type "${i3.type}", previously defined at line ${s5.id.__line__}`));
            }
          const h2 = `properties_light_${i3.type}`;
          if (!(h2 in s4))
            return o3 = o3.concat([new e3.V("light-3d", i3, `Invalid light type ${i3.type}`)]), o3;
          const u3 = s4[h2];
          for (const r5 in i3)
            if ("properties" === r5) {
              const n4 = i3[r5], a4 = e3.j(n4);
              if ("object" !== a4)
                return o3 = o3.concat([new e3.V("properties", n4, `object expected, ${a4} found`)]), o3;
              for (const i4 in n4)
                o3 = o3.concat(u3[i4] ? W({ key: i4, value: n4[i4], valueSpec: u3[i4], style: l3, styleSpec: s4 }) : [new e3.i(t3.key, n4[i4], `unknown property "${i4}"`)]);
            } else {
              const t4 = r5.match(/^(.*)-transition$/);
              o3 = o3.concat(t4 && n3[t4[1]] && n3[t4[1]].transition ? W({ key: r5, value: i3[r5], valueSpec: s4.transition, style: l3, styleSpec: s4 }) : n3[r5] ? W({ key: r5, value: i3[r5], valueSpec: n3[r5], style: l3, styleSpec: s4 }) : [new e3.i(r5, i3[r5], `unknown property "${r5}"`)]);
            }
          return o3;
        }
        function j2(t3) {
          const i3 = t3.value, o3 = t3.key, r4 = t3.style, s4 = t3.styleSpec, n3 = s4.terrain;
          let a3 = [];
          const l3 = e3.j(i3);
          if (void 0 === i3)
            return a3;
          if ("null" === l3)
            return a3;
          if ("object" !== l3)
            return a3 = a3.concat([new e3.V("terrain", i3, `object expected, ${l3} found`)]), a3;
          for (const t4 in i3) {
            const o4 = t4.match(/^(.*)-transition$/);
            a3 = a3.concat(o4 && n3[o4[1]] && n3[o4[1]].transition ? W({ key: t4, value: i3[t4], valueSpec: s4.transition, style: r4, styleSpec: s4 }) : n3[t4] ? W({ key: t4, value: i3[t4], valueSpec: n3[t4], style: r4, styleSpec: s4 }) : [new e3.i(t4, i3[t4], `unknown property "${t4}"`)]);
          }
          if (i3.source) {
            const t4 = r4.sources && r4.sources[i3.source], s5 = t4 && e3.u(t4.type);
            t4 ? "raster-dem" !== s5 && a3.push(new e3.V(o3, i3.source, `terrain cannot be used with a source of type ${String(s5)}, it only be used with a "raster-dem" source type`)) : a3.push(new e3.V(o3, i3.source, `source "${i3.source}" not found`));
          } else
            a3.push(new e3.V(o3, i3, 'terrain is missing required property "source"'));
          return a3;
        }
        function V(t3) {
          const i3 = t3.value, o3 = t3.style, r4 = t3.styleSpec, s4 = r4.fog;
          let n3 = [];
          const a3 = e3.j(i3);
          if (void 0 === i3)
            return n3;
          if ("object" !== a3)
            return n3 = n3.concat([new e3.V("fog", i3, `object expected, ${a3} found`)]), n3;
          for (const t4 in i3) {
            const a4 = t4.match(/^(.*)-transition$/);
            n3 = n3.concat(a4 && s4[a4[1]] && s4[a4[1]].transition ? W({ key: t4, value: i3[t4], valueSpec: r4.transition, style: o3, styleSpec: r4 }) : s4[t4] ? W({ key: t4, value: i3[t4], valueSpec: s4[t4], style: o3, styleSpec: r4 }) : [new e3.i(t4, i3[t4], `unknown property "${t4}"`)]);
          }
          return n3;
        }
        const Z2 = { "*": () => [], array: E, boolean: function(t3) {
          const i3 = t3.value, o3 = t3.key, r4 = e3.j(i3);
          return "boolean" !== r4 ? [new e3.V(o3, i3, `boolean expected, ${r4} found`)] : [];
        }, number: S, color: function(t3) {
          const i3 = t3.key, o3 = t3.value, r4 = e3.j(o3);
          return "string" !== r4 ? [new e3.V(i3, o3, `color expected, ${r4} found`)] : null === e3.z(o3) ? [new e3.V(i3, o3, `color expected, "${o3}" found`)] : [];
        }, enum: R2, filter: A, function: C, layer: O, object: T, source: k, model: e3.F, light: U, "light-3d": G, terrain: j2, fog: V, string: F, formatted: function(e4) {
          return 0 === F(e4).length ? [] : I(e4);
        }, resolvedImage: function(e4) {
          return 0 === F(e4).length ? [] : I(e4);
        }, projection: function(t3) {
          const i3 = t3.value, o3 = t3.styleSpec, r4 = o3.projection, s4 = t3.style;
          let n3 = [];
          const a3 = e3.j(i3);
          if ("object" === a3)
            for (const e4 in i3)
              n3 = n3.concat(W({ key: e4, value: i3[e4], valueSpec: r4[e4], style: s4, styleSpec: o3 }));
          else
            "string" !== a3 && (n3 = n3.concat([new e3.V("projection", i3, `object or string expected, ${a3} found`)]));
          return n3;
        }, import: function(t3) {
          const { value: i3, styleSpec: o3 } = t3, { data: r4, ...s4 } = i3;
          Object.defineProperty(s4, "__line__", { value: i3.__line__, enumerable: false });
          let n3 = T(e3.k({}, t3, { value: s4, valueSpec: o3.import }));
          return "" === e3.u(s4.id) && n3.push(new e3.V(`${t3.key}.id`, s4, "import id can't be an empty string")), r4 && (n3 = n3.concat(q2(r4, o3, { key: `${t3.key}.data` }))), n3;
        } };
        function W(t3, i3 = false) {
          const o3 = t3.value, r4 = t3.valueSpec, s4 = t3.styleSpec;
          if (r4.expression && e3.B(e3.u(o3)))
            return C(t3);
          if (r4.expression && e3.o(e3.q(o3)))
            return I(t3);
          if (r4.type && Z2[r4.type]) {
            const o4 = Z2[r4.type](t3);
            return true === i3 && o4.length > 0 && "array" === e3.j(t3.value) ? I(t3) : o4;
          }
          return T(e3.k({}, t3, { valueSpec: r4.type ? s4[r4.type] : r4 }));
        }
        function H(t3) {
          const i3 = t3.value, o3 = t3.key, r4 = F(t3);
          return r4.length || (-1 === i3.indexOf("{fontstack}") && r4.push(new e3.V(o3, i3, '"glyphs" url must include a "{fontstack}" token')), -1 === i3.indexOf("{range}") && r4.push(new e3.V(o3, i3, '"glyphs" url must include a "{range}" token'))), r4;
        }
        function q2(t3, i3 = e3.G, o3 = {}) {
          return W({ key: o3.key || "", value: t3, valueSpec: i3.$root, styleSpec: i3, style: t3, objectElementValidators: { glyphs: H, "*": () => [] } });
        }
        function Q(t3, i3 = e3.G) {
          return se(q2(t3, i3));
        }
        const $ = (e4) => se(k(e4)), X2 = (e4) => se(U(e4)), Y = (e4) => se(G(e4)), J = (e4) => se(j2(e4)), K = (e4) => se(V(e4)), ee = (e4) => se(O(e4)), te = (e4) => se(A(e4)), ie2 = (e4) => se(M2(e4)), oe = (e4) => se(z2(e4)), re = (t3) => se(e3.F(t3));
        function se(e4) {
          return e4.slice().sort((e5, t3) => e5.line && t3.line ? e5.line - t3.line : 0);
        }
        function ne(t3, i3) {
          let o3 = false;
          if (i3 && i3.length)
            for (const r4 of i3)
              r4 instanceof e3.i ? e3.w(r4.message) : (t3.fire(new e3.a(new Error(r4.message))), o3 = true);
          return o3;
        }
        const ae = new e3.H({ anchor: new e3.J(e3.G.light.anchor), position: new e3.K(e3.G.light.position), color: new e3.J(e3.G.light.color), intensity: new e3.J(e3.G.light.intensity) });
        class le extends e3.E {
          constructor(t3, i3 = "flat") {
            super(), this._transitionable = new e3.L(ae), this.setLight(t3, i3), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e4, t3, i3 = {}) {
            this._validate(X2, e4, i3) || (this._transitionable.setTransitionOrValue(e4), this.id = t3);
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          _validate(t3, i3, o3) {
            return (!o3 || false !== o3.validate) && ne(this, t3.call(Q, e3.e({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: e3.G })));
          }
        }
        const ce2 = new e3.H({ source: new e3.J(e3.G.terrain.source), exaggeration: new e3.J(e3.G.terrain.exaggeration) });
        let he = class extends e3.E {
          constructor(t3, i3, o3, r4) {
            super(), this.scope = o3, this._transitionable = new e3.L(ce2, o3, r4), this._transitionable.setTransitionOrValue(t3, r4), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i3;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(e4, t3) {
            this._transitionable.setTransitionOrValue(e4, t3);
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          getExaggeration(t3) {
            return this._transitioning.possiblyEvaluate(new e3.N(t3)).get("exaggeration");
          }
          isZoomDependent() {
            const t3 = this._transitionable._values.exaggeration;
            return null != t3 && null != t3.value && null != t3.value.expression && t3.value.expression instanceof e3.Z;
          }
        };
        const ue = 45, de = 65, _e = 0.05;
        function pe(t3, i3, o3, r4) {
          const s4 = e3.S(ue, de, o3), [n3, a3] = fe(t3, r4);
          let l3 = 1 - Math.min(1, Math.exp((i3 - n3) / (a3 - n3) * -6));
          return l3 *= l3 * l3, l3 = Math.min(1, 1.00747 * l3), l3 * s4 * t3.alpha;
        }
        function fe(e4, t3) {
          const i3 = 0.5 / Math.tan(0.5 * t3);
          return [e4.range[0] + i3, e4.range[1] + i3];
        }
        function me(t3, i3, o3, r4, s4) {
          const n3 = e3.Q.transformMat4([], [i3, o3, r4], s4.mercatorFogMatrix);
          return pe(t3, e3.Q.length(n3), s4.pitch, s4._fov);
        }
        function ge(t3, i3, o3, r4, s4, n3, a3) {
          const l3 = [[o3, r4, 0], [s4, r4, 0], [s4, n3, 0], [o3, n3, 0]];
          let c3 = Number.MAX_VALUE, h2 = -Number.MAX_VALUE;
          for (const t4 of l3) {
            const o4 = e3.Q.transformMat4([], t4, i3), r5 = e3.Q.length(o4);
            c3 = Math.min(c3, r5), h2 = Math.max(h2, r5);
          }
          return [pe(t3, c3, a3.pitch, a3._fov), pe(t3, h2, a3.pitch, a3._fov)];
        }
        const ve = new e3.H({ range: new e3.J(e3.G.fog.range), color: new e3.J(e3.G.fog.color), "high-color": new e3.J(e3.G.fog["high-color"]), "space-color": new e3.J(e3.G.fog["space-color"]), "horizon-blend": new e3.J(e3.G.fog["horizon-blend"]), "star-intensity": new e3.J(e3.G.fog["star-intensity"]), "vertical-range": new e3.J(e3.G.fog["vertical-range"]) });
        class xe extends e3.E {
          constructor(t3, i3, o3, r4) {
            super(), this._transitionable = new e3.L(ve, o3, new Map(r4)), this.set(t3, r4), this._transitioning = this._transitionable.untransitioned(), this._transform = i3, this.properties = new e3.U(ve);
          }
          get state() {
            const t3 = this._transform, i3 = "globe" === t3.projection.name, o3 = e3.W(t3.zoom), r4 = this.properties.get("range"), s4 = [0.5, 3];
            return { range: i3 ? [e3.X(s4[0], r4[0], o3), e3.X(s4[1], r4[1], o3)] : r4, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t3, i3, o3 = {}) {
            if (this._validate(K, t3, o3))
              return;
            const r4 = e3.e({}, t3);
            for (const t4 of Object.keys(e3.G.fog))
              void 0 === r4[t4] && (r4[t4] = e3.G.fog[t4].default);
            this._options = r4, this._transitionable.setTransitionOrValue(this._options, i3);
          }
          getOpacity(t3) {
            if (!this._transform.projection.supportsFog)
              return 0;
            const i3 = this.properties && this.properties.get("color") || 1;
            return ("globe" === this._transform.projection.name ? 1 : e3.S(ue, de, t3)) * i3.a;
          }
          getOpacityAtLatLng(t3, i3) {
            return this._transform.projection.supportsFog ? function(t4, i4, o3) {
              const r4 = e3.O.fromLngLat(i4), s4 = o3.elevation ? o3.elevation.getAtPointOrZero(r4) : 0;
              return me(t4, r4.x, r4.y, s4, o3);
            }(this.state, t3, i3) : 0;
          }
          getOpacityForTile(t3) {
            if (!this._transform.projection.supportsFog)
              return [1, 1];
            const i3 = this._transform.calculateFogTileMatrix(t3.toUnwrapped());
            return ge(this.state, i3, 0, 0, e3.Y, e3.Y, this._transform);
          }
          getOpacityForBounds(e4, t3, i3, o3, r4) {
            return this._transform.projection.supportsFog ? ge(this.state, e4, t3, i3, o3, r4, this._transform) : [1, 1];
          }
          getFovAdjustedRange(e4) {
            return this._transform.projection.supportsFog ? fe(this.state, e4) : [0, 1];
          }
          isVisibleOnFrustum(t3) {
            if (!this._transform.projection.supportsFog)
              return false;
            const i3 = [4, 5, 6, 7];
            for (const o3 of i3) {
              const i4 = t3.points[o3];
              let r4;
              if (i4[2] >= 0)
                r4 = i4;
              else {
                const s4 = t3.points[o3 - 4];
                r4 = e3._(s4, i4, s4[2] / (s4[2] - i4[2]));
              }
              if (me(this.state, r4[0], r4[1], 0, this._transform) >= _e)
                return true;
            }
            return false;
          }
          updateConfig(e4) {
            this._transitionable.setTransitionOrValue(this._options, new Map(e4));
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          _validate(t3, i3, o3) {
            return (!o3 || false !== o3.validate) && ne(this, t3.call(Q, e3.e({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: e3.G })));
          }
        }
        class ye extends e3.E {
          constructor(t3, i3, o3, r4) {
            super(), this.scope = o3, this._options = t3, this.properties = new e3.U(i3), this._transitionable = new e3.L(i3, o3, new Map(r4)), this._transitionable.setTransitionOrValue(t3.properties), this._transitioning = this._transitionable.untransitioned();
          }
          updateConfig(e4) {
            this._transitionable.setTransitionOrValue(this._options.properties, new Map(e4));
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          get() {
            return this._options.properties = this._transitionable.serialize(), this._options;
          }
          set(e4, t3) {
            this._options = e4, this._transitionable.setTransitionOrValue(e4.properties, t3);
          }
          shadowsEnabled() {
            return !!this.properties && true === this.properties.get("cast-shadows");
          }
        }
        const be = new e3.H({ color: new e3.J(e3.G.properties_light_ambient.color), intensity: new e3.J(e3.G.properties_light_ambient.intensity) }), we = new e3.H({ direction: new e3.$(e3.G.properties_light_directional.direction), color: new e3.J(e3.G.properties_light_directional.color), intensity: new e3.J(e3.G.properties_light_directional.intensity), "cast-shadows": new e3.J(e3.G.properties_light_directional["cast-shadows"]), "shadow-intensity": new e3.J(e3.G.properties_light_directional["shadow-intensity"]) });
        class Te {
          constructor(e4, t3, i3, o3) {
            this.screenBounds = e4, this.cameraPoint = t3, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i3, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o3);
          }
          static createFromScreenPoints(t3, i3) {
            let o3, r4;
            if (t3 instanceof e3.P || "number" == typeof t3[0]) {
              const s4 = e3.P.convert(t3);
              o3 = [s4], r4 = i3.isPointAboveHorizon(s4);
            } else {
              const s4 = e3.P.convert(t3[0]), n3 = e3.P.convert(t3[1]);
              o3 = [s4, n3], r4 = e3.a0(s4, n3).every((e4) => i3.isPointAboveHorizon(e4));
            }
            return new Te(o3, i3.getCameraPoint(), r4, i3);
          }
          isPointQuery() {
            return 1 === this.screenBounds.length;
          }
          bufferedScreenGeometry(t3) {
            return e3.a0(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t3);
          }
          bufferedCameraGeometry(t3) {
            const i3 = this.screenBounds[0], o3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e3.P(1, 1)) : this.screenBounds[1], r4 = e3.a0(i3, o3, 0, false);
            return this.cameraPoint.y > o3.y && (this.cameraPoint.x > i3.x && this.cameraPoint.x < o3.x ? r4.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o3.x ? r4[2] = this.cameraPoint : this.cameraPoint.x <= i3.x && (r4[3] = this.cameraPoint)), e3.a1(r4, t3);
          }
          bufferedCameraGeometryGlobe(t3) {
            const i3 = this.screenBounds[0], o3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e3.P(1, 1)) : this.screenBounds[1], r4 = e3.a0(i3, o3, t3), s4 = this.cameraPoint.clone();
            switch (3 * ((s4.y > i3.y) + (s4.y > o3.y)) + ((s4.x > i3.x) + (s4.x > o3.x))) {
              case 0:
                r4[0] = s4, r4[4] = s4.clone();
                break;
              case 1:
                r4.splice(1, 0, s4);
                break;
              case 2:
                r4[1] = s4;
                break;
              case 3:
                r4.splice(4, 0, s4);
                break;
              case 5:
                r4.splice(2, 0, s4);
                break;
              case 6:
                r4[3] = s4;
                break;
              case 7:
                r4.splice(3, 0, s4);
                break;
              case 8:
                r4[2] = s4;
            }
            return r4;
          }
          containsTile(t3, i3, o3, r4 = 0) {
            const s4 = t3.queryPadding / i3._pixelsPerMercatorPixel + 1, n3 = o3 ? this._bufferedCameraMercator(s4, i3) : this._bufferedScreenMercator(s4, i3);
            let a3 = t3.tileID.wrap + (n3.unwrapped ? r4 : 0);
            const l3 = n3.polygon.map((i4) => e3.a2(t3.tileTransform, i4, a3));
            if (!e3.a3(l3, 0, 0, e3.Y, e3.Y))
              return;
            a3 = t3.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r4 : 0);
            const c3 = this.screenGeometryMercator.polygon.map((i4) => e3.a4(t3.tileTransform, i4, a3)), h2 = c3.map((t4) => new e3.P(t4[0], t4[1])), u3 = i3.getFreeCameraOptions().position || new e3.O(0, 0, 0), d2 = e3.a4(t3.tileTransform, u3, a3), _3 = c3.map((t4) => {
              const i4 = e3.Q.sub(t4, t4, d2);
              return e3.Q.normalize(i4, i4), new e3.a5(d2, i4);
            }), p3 = e3.a6(t3, 1, i3.zoom) * i3._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: h2, tilespaceRays: _3, bufferedTilespaceGeometry: l3, bufferedTilespaceBounds: (f2 = e3.a7(l3), f2.min.x = e3.ad(f2.min.x, 0, e3.Y), f2.min.y = e3.ad(f2.min.y, 0, e3.Y), f2.max.x = e3.ad(f2.max.x, 0, e3.Y), f2.max.y = e3.ad(f2.max.y, 0, e3.Y), f2), tile: t3, tileID: t3.tileID, pixelToTileUnitsFactor: p3 };
            var f2;
          }
          _bufferedScreenMercator(e4, t3) {
            const i3 = Ce(e4);
            if (this._screenRaycastCache[i3])
              return this._screenRaycastCache[i3];
            {
              let o3;
              return o3 = "globe" === t3.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e4), t3) : { polygon: this.bufferedScreenGeometry(e4).map((e5) => t3.pointCoordinate3D(e5)), unwrapped: true }, this._screenRaycastCache[i3] = o3, o3;
            }
          }
          _bufferedCameraMercator(e4, t3) {
            const i3 = Ce(e4);
            if (this._cameraRaycastCache[i3])
              return this._cameraRaycastCache[i3];
            {
              let o3;
              return o3 = "globe" === t3.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e4), t3) : { polygon: this.bufferedCameraGeometry(e4).map((e5) => t3.pointCoordinate3D(e5)), unwrapped: true }, this._cameraRaycastCache[i3] = o3, o3;
            }
          }
          _projectAndResample(t3, i3) {
            const o3 = function(t4, i4) {
              const o4 = e3.a9.multiply([], i4.pixelMatrix, i4.globeMatrix), r5 = [0, -e3.ae, 0, 1], s4 = [0, e3.ae, 0, 1], n3 = [0, 0, 0, 1];
              e3.aa.transformMat4(r5, r5, o4), e3.aa.transformMat4(s4, s4, o4), e3.aa.transformMat4(n3, n3, o4);
              const a3 = new e3.P(r5[0] / r5[3], r5[1] / r5[3]), l3 = new e3.P(s4[0] / s4[3], s4[1] / s4[3]), c3 = e3.ab(t4, a3) && r5[3] < n3[3], h2 = e3.ab(t4, l3) && s4[3] < n3[3];
              if (!c3 && !h2)
                return null;
              const u3 = function(e4, t5, i5) {
                for (let o5 = 1; o5 < e4.length; o5++) {
                  const r6 = Se(t5.pointCoordinate3D(e4[o5 - 1]).x), s5 = Se(t5.pointCoordinate3D(e4[o5]).x);
                  if (i5 < 0) {
                    if (r6 < s5)
                      return { idx: o5, t: -r6 / (s5 - 1 - r6) };
                  } else if (s5 < r6)
                    return { idx: o5, t: (1 - r6) / (s5 + 1 - r6) };
                }
                return null;
              }(t4, i4, c3 ? -1 : 1);
              if (!u3)
                return null;
              const { idx: d2, t: _3 } = u3;
              let p3 = d2 > 1 ? Ee(t4.slice(0, d2), i4) : [], f2 = d2 < t4.length ? Ee(t4.slice(d2), i4) : [];
              p3 = p3.map((t5) => new e3.P(Se(t5.x), t5.y)), f2 = f2.map((t5) => new e3.P(Se(t5.x), t5.y));
              const m2 = [...p3];
              0 === m2.length && m2.push(f2[f2.length - 1]);
              const g3 = e3.X(m2[m2.length - 1].y, (0 === f2.length ? p3[0] : f2[0]).y, _3);
              let v3;
              return v3 = c3 ? [new e3.P(0, g3), new e3.P(0, 0), new e3.P(1, 0), new e3.P(1, g3)] : [new e3.P(1, g3), new e3.P(1, 1), new e3.P(0, 1), new e3.P(0, g3)], m2.push(...v3), 0 === f2.length ? m2.push(p3[0]) : m2.push(...f2), { polygon: m2.map((t5) => new e3.O(t5.x, t5.y)), unwrapped: false };
            }(t3, i3);
            if (o3)
              return o3;
            const r4 = function(t4, i4) {
              let o4 = false, r5 = -1 / 0, s4 = 0;
              for (let e4 = 0; e4 < t4.length - 1; e4++)
                t4[e4].x > r5 && (r5 = t4[e4].x, s4 = e4);
              for (let e4 = 0; e4 < t4.length - 1; e4++) {
                const i5 = (s4 + e4) % (t4.length - 1), r6 = t4[i5], n4 = t4[i5 + 1];
                Math.abs(r6.x - n4.x) > 0.5 && (r6.x < n4.x ? (r6.x += 1, 0 === i5 && (t4[t4.length - 1].x += 1)) : (n4.x += 1, i5 + 1 === t4.length - 1 && (t4[0].x += 1)), o4 = true);
              }
              const n3 = e3.a8(i4.center.lng);
              return o4 && n3 < Math.abs(n3 - 1) && t4.forEach((e4) => {
                e4.x -= 1;
              }), { polygon: t4, unwrapped: o4 };
            }(Ee(t3, i3).map((t4) => new e3.P(Se(t4.x), t4.y)), i3);
            return { polygon: r4.polygon.map((t4) => new e3.O(t4.x, t4.y)), unwrapped: r4.unwrapped };
          }
        }
        function Ee(t3, i3) {
          return e3.ac(t3, (e4) => {
            const t4 = i3.pointCoordinate3D(e4);
            e4.x = t4.x, e4.y = t4.y;
          }, 1 / 256);
        }
        function Se(e4) {
          return e4 < 0 ? 1 + e4 % 1 : e4 % 1;
        }
        function Ce(e4) {
          return 100 * e4 | 0;
        }
        function Ie(t3, i3, o3, r4, s4) {
          const n3 = function(o4, r5) {
            if (o4)
              return s4(o4);
            if (r5) {
              t3.url && r5.tiles && t3.tiles && delete t3.tiles;
              const o5 = e3.af(e3.e(r5, t3), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              r5.vector_layers && (o5.vectorLayers = r5.vector_layers, o5.vectorLayerIds = o5.vectorLayers.map((e4) => e4.id)), r5.raster_layers && (o5.rasterLayers = r5.raster_layers, o5.rasterLayerIds = o5.rasterLayers.map((e4) => e4.id)), o5.tiles = i3.canonicalizeTileset(o5, t3.url), s4(null, o5);
            }
          };
          return t3.url ? e3.g(i3.transformRequest(i3.normalizeSourceURL(t3.url, null, o3, r4), e3.R.Source), n3) : e3.f.frame(() => n3(null, t3));
        }
        class De {
          constructor(t3, i3, o3) {
            this.bounds = e3.ag.convert(this.validateBounds(t3)), this.minzoom = i3 || 0, this.maxzoom = o3 || 24;
          }
          validateBounds(e4) {
            return Array.isArray(e4) && 4 === e4.length ? [Math.max(-180, e4[0]), Math.max(-90, e4[1]), Math.min(180, e4[2]), Math.min(90, e4[3])] : [-180, -90, 180, 90];
          }
          contains(t3) {
            const i3 = Math.pow(2, t3.z), o3 = Math.floor(e3.a8(this.bounds.getWest()) * i3), r4 = Math.floor(e3.ah(this.bounds.getNorth()) * i3), s4 = Math.ceil(e3.a8(this.bounds.getEast()) * i3), n3 = Math.ceil(e3.ah(this.bounds.getSouth()) * i3);
            return t3.x >= o3 && t3.x < s4 && t3.y >= r4 && t3.y < n3;
          }
        }
        class Re extends e3.E {
          constructor(t3, i3, o3, r4) {
            if (super(), this.id = t3, this.dispatcher = o3, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e3.e(this, e3.af(i3, ["url", "scheme", "tileSize", "promoteId"])), this._options = e3.e({ type: "vector" }, i3), this._collectResourceTiming = !!i3.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(r4), this._tileWorkers = {}, this._deduped = new e3.ai();
          }
          load(t3) {
            this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" }));
            const i3 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o3 = this.map._worldview;
            this._tileJSONRequest = Ie(this._options, this.map._requestManager, i3, o3, (r4, s4) => {
              this._tileJSONRequest = null, this._loaded = true, r4 ? (i3 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i3}`), o3 && 2 !== o3.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o3}`), this.fire(new e3.a(r4))) : s4 && (e3.e(this, s4), s4.bounds && (this.tileBounds = new De(s4.bounds, this.minzoom, this.maxzoom)), e3.am(s4.tiles, this.map._requestManager._customAccessToken), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }))), t3 && t3(r4);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e4) {
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t3 = e3.aj(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t3));
          }
          setTiles(e4) {
            return this._options.tiles = e4, this.reload(), this;
          }
          setUrl(e4) {
            return this.url = e4, this._options.url = e4, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e3.e({}, this._options);
          }
          loadTile(t3, i3) {
            const o3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme)), r4 = { request: this.map._requestManager.transformRequest(o3, e3.R.Tile), data: void 0, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e3.f.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t3.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t3.isExtraShadowCaster };
            if (r4.request.collectResourceTiming = this._collectResourceTiming, t3.actor && "expired" !== t3.state)
              "loading" === t3.state ? t3.reloadCallback = i3 : t3.request = t3.actor.send("reloadTile", r4, s4.bind(this));
            else if (t3.actor = this._tileWorkers[o3] = this._tileWorkers[o3] || this.dispatcher.getActor(), this.dispatcher.ready)
              t3.request = t3.actor.send("loadTile", r4, s4.bind(this), void 0, true);
            else {
              const i4 = e3.ak.call({ deduped: this._deduped }, r4, (e4, i5) => {
                e4 || !i5 ? s4.call(this, e4) : (r4.data = { cacheControl: i5.cacheControl, expires: i5.expires, rawData: i5.rawData.slice(0) }, t3.actor && t3.actor.send("loadTile", r4, s4.bind(this), void 0, true));
              }, true);
              t3.request = { cancel: i4 };
            }
            function s4(o4, r5) {
              return delete t3.request, t3.aborted ? i3(null) : o4 && 404 !== o4.status ? i3(o4) : (r5 && r5.resourceTiming && (t3.resourceTiming = r5.resourceTiming), this.map._refreshExpiredTiles && r5 && t3.setExpiryData(r5), t3.loadVectorData(r5, this.map.painter), e3.al(this.dispatcher), i3(null), void (t3.reloadCallback && (this.loadTile(t3, t3.reloadCallback), t3.reloadCallback = null)));
            }
          }
          abortTile(e4) {
            e4.request && (e4.request.cancel(), delete e4.request), e4.actor && e4.actor.send("abortTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope });
          }
          unloadTile(e4) {
            e4.actor && e4.actor.send("removeTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope }), e4.destroy();
          }
          hasTransition() {
            return false;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Ae extends e3.E {
          constructor(t3, i3, o3, r4) {
            super(), this.id = t3, this.dispatcher = o3, this.setEventedParent(r4), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e3.e({ type: "raster" }, i3), e3.e(this, e3.af(i3, ["url", "scheme", "tileSize"]));
          }
          load(t3) {
            this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" })), this._tileJSONRequest = Ie(this._options, this.map._requestManager, null, null, (i3, o3) => {
              this._tileJSONRequest = null, this._loaded = true, i3 ? this.fire(new e3.a(i3)) : o3 && (e3.e(this, o3), o3.bounds && (this.tileBounds = new De(o3.bounds, this.minzoom, this.maxzoom)), e3.am(o3.tiles), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }))), t3 && t3(i3);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t3 = e3.aj(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t3));
          }
          setTiles(e4) {
            return this._options.tiles = e4, this.reload(), this;
          }
          setUrl(e4) {
            return this.url = e4, this._options.url = e4, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e3.e({}, this._options);
          }
          hasTile(e4) {
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          loadTile(t3, i3) {
            const o3 = e3.f.devicePixelRatio >= 2, r4 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), o3, this.tileSize);
            t3.request = e3.d(this.map._requestManager.transformRequest(r4, e3.R.Tile), (o4, r5, s4, n3) => (delete t3.request, t3.aborted ? (t3.state = "unloaded", i3(null)) : o4 ? (t3.state = "errored", i3(o4)) : r5 ? (this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: s4, expires: n3 }), t3.setTexture(r5, this.map.painter), t3.state = "loaded", e3.al(this.dispatcher), void i3(null)) : i3(null)));
          }
          abortTile(e4, t3) {
            e4.request && (e4.request.cancel(), delete e4.request), t3();
          }
          unloadTile(t3, i3) {
            t3.texture && t3.texture instanceof e3.T ? (t3.destroy(true), t3.texture && t3.texture instanceof e3.T && this.map.painter.saveTileTexture(t3.texture)) : t3.destroy(), i3();
          }
          hasTransition() {
            return false;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Pe extends Ae {
          constructor(t3, i3, o3, r4) {
            super(t3, i3, o3, r4), this.type = "raster-array", this.maxzoom = 22, this._options = e3.e({ type: "raster-array" }, i3);
          }
          triggerRepaint(e4) {
            const t3 = this.map.painter._terrain, i3 = this.map.style.getSourceCache(this.id);
            t3 && t3.enabled && i3 && t3._clearRenderCacheForTile(i3.id, e4.tileID), this.map.triggerRepaint();
          }
          loadTile(t3, i3) {
            const o3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), r4 = this.map._requestManager.transformRequest(o3, e3.R.Tile);
            t3.requestParams = r4, t3.actor || (t3.actor = this.dispatcher.getActor()), t3.request = t3.fetchHeader(void 0, (e4, o4, r5, s4) => {
              if (delete t3.request, t3.aborted)
                return t3.state = "unloaded", i3(null);
              if (e4) {
                if (20 === e4.code)
                  return;
                return t3.state = "errored", i3(e4);
              }
              this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: r5, expires: s4 }), t3.state = "empty", i3(null);
            });
          }
          unloadTile(t3) {
            const i3 = t3.texture;
            i3 && i3 instanceof e3.T ? (t3.destroy(true), this.map.painter.saveTileTexture(i3)) : (t3.destroy(), t3.flushQueues(), t3._isHeaderLoaded = false, delete t3._mrt, delete t3.textureDescriptor), t3.fbo && (t3.fbo.destroy(), delete t3.fbo), delete t3.request, delete t3.requestParams, delete t3.neighboringTiles, t3.state = "unloaded";
          }
          prepareTile(t3, i3, o3) {
            t3._isHeaderLoaded && ("empty" !== t3.state && (t3.state = "reloading"), t3.fetchBand(i3, o3, (i4, o4) => {
              if (i4)
                return t3.state = "errored", this.fire(new e3.a(i4)), void this.triggerRepaint(t3);
              o4 && (t3.setTexture(o4, this.map.painter), t3.state = "loaded", this.triggerRepaint(t3));
            }));
          }
          getInitialBand(e4) {
            if (!this.rasterLayers)
              return 0;
            const t3 = this.rasterLayers.find(({ id: t4 }) => t4 === e4), i3 = t3 && t3.fields, o3 = i3 && i3.bands && i3.bands;
            return o3 ? o3[0] : 0;
          }
          getTextureDescriptor(t3, i3, o3) {
            if (!t3)
              return;
            const r4 = i3.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
            if (!r4)
              return;
            let s4 = null;
            i3 instanceof e3.aq ? s4 = i3.paint.get("raster-array-band") : i3 instanceof e3.ar && (s4 = i3.paint.get("raster-particle-array-band"));
            const n3 = s4 || this.getInitialBand(r4);
            if (null != n3)
              if (t3.textureDescriptor) {
                if (!t3.updateNeeded(r4, n3) || o3)
                  return Object.assign({}, t3.textureDescriptor, { texture: t3.texture });
              } else
                this.prepareTile(t3, r4, n3);
          }
        }
        const Le = 32, Me = 33, ze = new Uint16Array(8184);
        for (let e4 = 0; e4 < 2046; e4++) {
          let t3 = e4 + 2, i3 = 0, o3 = 0, r4 = 0, s4 = 0, n3 = 0, a3 = 0;
          for (1 & t3 ? r4 = s4 = n3 = Le : i3 = o3 = a3 = Le; (t3 >>= 1) > 1; ) {
            const e5 = i3 + r4 >> 1, l4 = o3 + s4 >> 1;
            1 & t3 ? (r4 = i3, s4 = o3, i3 = n3, o3 = a3) : (i3 = r4, o3 = s4, r4 = n3, s4 = a3), n3 = e5, a3 = l4;
          }
          const l3 = 4 * e4;
          ze[l3 + 0] = i3, ze[l3 + 1] = o3, ze[l3 + 2] = r4, ze[l3 + 3] = s4;
        }
        const Oe = new Uint16Array(2178), Fe = new Uint8Array(1089), Be = new Uint16Array(1089);
        function ke(e4) {
          return 0 === e4 ? -0.03125 : 32 === e4 ? 0.03125 : 0;
        }
        class Ne {
          constructor(e4, t3, i3, o3) {
            this.id = Ne.uniqueIdxCounter, Ne.uniqueIdxCounter++, this.context = e4;
            const r4 = e4.gl;
            this.buffer = r4.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), e4.bindElementBuffer.set(this.buffer), r4.bufferData(r4.ELEMENT_ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? r4.DYNAMIC_DRAW : r4.STATIC_DRAW), this.dynamicDraw || o3 || t3.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e4) {
            this.id = Ne.uniqueIdxCounter, Ne.uniqueIdxCounter++;
            const t3 = this.context.gl;
            this.context.unbindVAO(), this.bind(), t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, 0, e4.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        Ne.uniqueIdxCounter = 0;
        const Ue = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Ge {
          constructor(e4, t3, i3, o3, r4, s4) {
            this.length = t3.length, this.attributes = i3, this.itemSize = t3.bytesPerElement, this.dynamicDraw = o3, this.instanceCount = s4, this.context = e4;
            const n3 = e4.gl;
            this.buffer = n3.createBuffer(), e4.bindVertexBuffer.set(this.buffer), n3.bufferData(n3.ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? n3.DYNAMIC_DRAW : n3.STATIC_DRAW), this.dynamicDraw || r4 || t3.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e4) {
            const t3 = this.context.gl;
            this.bind(), t3.bufferSubData(t3.ARRAY_BUFFER, 0, e4.arrayBuffer);
          }
          enableAttributes(e4, t3) {
            for (let i3 = 0; i3 < this.attributes.length; i3++) {
              const o3 = t3.attributes[this.attributes[i3].name];
              void 0 !== o3 && e4.enableVertexAttribArray(o3);
            }
          }
          setVertexAttribPointers(e4, t3, i3) {
            for (let o3 = 0; o3 < this.attributes.length; o3++) {
              const r4 = this.attributes[o3], s4 = t3.attributes[r4.name];
              void 0 !== s4 && e4.vertexAttribPointer(s4, r4.components, e4[Ue[r4.type]], false, this.itemSize, r4.offset + this.itemSize * (i3 || 0));
            }
          }
          setVertexAttribDivisor(e4, t3, i3) {
            for (let o3 = 0; o3 < this.attributes.length; o3++) {
              const r4 = t3.attributes[this.attributes[o3].name];
              void 0 !== r4 && this.instanceCount && this.instanceCount > 0 && e4.vertexAttribDivisor(r4, i3);
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class je {
          constructor(e4) {
            this.gl = e4.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e4) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ve extends je {
          getDefault() {
            return e3.aA.transparent;
          }
          set(e4) {
            const t3 = this.current;
            (e4.r !== t3.r || e4.g !== t3.g || e4.b !== t3.b || e4.a !== t3.a || this.dirty) && (this.gl.clearColor(e4.r, e4.g, e4.b, e4.a), this.current = e4, this.dirty = false);
          }
        }
        class Ze extends je {
          getDefault() {
            return 1;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.clearDepth(e4), this.current = e4, this.dirty = false);
          }
        }
        class We extends je {
          getDefault() {
            return 0;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.clearStencil(e4), this.current = e4, this.dirty = false);
          }
        }
        class He extends je {
          getDefault() {
            return [true, true, true, true];
          }
          set(e4) {
            const t3 = this.current;
            (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || e4[3] !== t3[3] || this.dirty) && (this.gl.colorMask(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
          }
        }
        class qe extends je {
          getDefault() {
            return true;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.depthMask(e4), this.current = e4, this.dirty = false);
          }
        }
        class Qe extends je {
          getDefault() {
            return 255;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.stencilMask(e4), this.current = e4, this.dirty = false);
          }
        }
        class $e extends je {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e4) {
            const t3 = this.current;
            (e4.func !== t3.func || e4.ref !== t3.ref || e4.mask !== t3.mask || this.dirty) && (this.gl.stencilFunc(e4.func, e4.ref, e4.mask), this.current = e4, this.dirty = false);
          }
        }
        class Xe extends je {
          getDefault() {
            const e4 = this.gl;
            return [e4.KEEP, e4.KEEP, e4.KEEP];
          }
          set(e4) {
            const t3 = this.current;
            (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || this.dirty) && (this.gl.stencilOp(e4[0], e4[1], e4[2]), this.current = e4, this.dirty = false);
          }
        }
        class Ye extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e4 ? t3.enable(t3.STENCIL_TEST) : t3.disable(t3.STENCIL_TEST), this.current = e4, this.dirty = false;
          }
        }
        class Je extends je {
          getDefault() {
            return [0, 1];
          }
          set(e4) {
            const t3 = this.current;
            (e4[0] !== t3[0] || e4[1] !== t3[1] || this.dirty) && (this.gl.depthRange(e4[0], e4[1]), this.current = e4, this.dirty = false);
          }
        }
        class Ke extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e4 ? t3.enable(t3.DEPTH_TEST) : t3.disable(t3.DEPTH_TEST), this.current = e4, this.dirty = false;
          }
        }
        class et extends je {
          getDefault() {
            return this.gl.LESS;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.depthFunc(e4), this.current = e4, this.dirty = false);
          }
        }
        class tt extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e4 ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), this.current = e4, this.dirty = false;
          }
        }
        class it extends je {
          getDefault() {
            const e4 = this.gl;
            return [e4.ONE, e4.ZERO, e4.ONE, e4.ZERO];
          }
          set(e4) {
            const t3 = this.current;
            (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || e4[3] !== t3[3] || this.dirty) && (this.gl.blendFuncSeparate(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
          }
        }
        class ot extends je {
          getDefault() {
            return e3.aA.transparent;
          }
          set(e4) {
            const t3 = this.current;
            (e4.r !== t3.r || e4.g !== t3.g || e4.b !== t3.b || e4.a !== t3.a || this.dirty) && (this.gl.blendColor(e4.r, e4.g, e4.b, e4.a), this.current = e4, this.dirty = false);
          }
        }
        class rt extends je {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e4, e4), this.current = e4, this.dirty = false);
          }
        }
        class st extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e4 ? t3.enable(t3.CULL_FACE) : t3.disable(t3.CULL_FACE), this.current = e4, this.dirty = false;
          }
        }
        class nt extends je {
          getDefault() {
            return this.gl.BACK;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.cullFace(e4), this.current = e4, this.dirty = false);
          }
        }
        class at extends je {
          getDefault() {
            return this.gl.CCW;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.frontFace(e4), this.current = e4, this.dirty = false);
          }
        }
        let lt = class extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.useProgram(e4), this.current = e4, this.dirty = false);
          }
        };
        class ct extends je {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.activeTexture(e4), this.current = e4, this.dirty = false);
          }
        }
        class ht extends je {
          getDefault() {
            const e4 = this.gl;
            return [0, 0, e4.drawingBufferWidth, e4.drawingBufferHeight];
          }
          set(e4) {
            const t3 = this.current;
            (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || e4[3] !== t3[3] || this.dirty) && (this.gl.viewport(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
          }
        }
        class ut extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindFramebuffer(t3.FRAMEBUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class dt extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindRenderbuffer(t3.RENDERBUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class _t extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindTexture(t3.TEXTURE_2D, e4), this.current = e4, this.dirty = false;
          }
        }
        class pt2 extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindBuffer(t3.ARRAY_BUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class ft extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            const t3 = this.gl;
            t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class mt extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            this.gl && (e4 !== this.current || this.dirty) && (this.gl.bindVertexArray(e4), this.current = e4, this.dirty = false);
          }
        }
        class gt extends je {
          getDefault() {
            return 4;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_ALIGNMENT, e4), this.current = e4, this.dirty = false;
          }
        }
        class vt extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e4), this.current = e4, this.dirty = false;
          }
        }
        class xt extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, e4), this.current = e4, this.dirty = false;
          }
        }
        class yt extends je {
          constructor(e4, t3) {
            super(e4), this.context = e4, this.parent = t3;
          }
          getDefault() {
            return null;
          }
        }
        class bt extends yt {
          setDirty() {
            this.dirty = true;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t3 = this.gl;
            t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e4, 0), this.current = e4, this.dirty = false;
          }
        }
        class wt extends yt {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t3 = this.gl;
            t3.framebufferRenderbuffer(t3.FRAMEBUFFER, this.attachment(), t3.RENDERBUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class Tt extends yt {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t3 = this.gl;
            t3.framebufferTexture2D(t3.FRAMEBUFFER, this.attachment(), t3.TEXTURE_2D, e4, 0), this.current = e4, this.dirty = false;
          }
        }
        class Et extends wt {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        class St {
          constructor(e4, t3, i3, o3, r4) {
            this.context = e4, this.width = t3, this.height = i3;
            const s4 = this.framebuffer = e4.gl.createFramebuffer();
            o3 && (this.colorAttachment = new bt(e4, s4)), r4 && (this.depthAttachmentType = r4, this.depthAttachment = "renderbuffer" === r4 ? new wt(e4, s4) : new Tt(e4, s4));
          }
          destroy() {
            const e4 = this.context.gl;
            if (this.colorAttachment) {
              const t3 = this.colorAttachment.get();
              t3 && e4.deleteTexture(t3);
            }
            if (this.depthAttachment && this.depthAttachmentType)
              if ("renderbuffer" === this.depthAttachmentType) {
                const t3 = this.depthAttachment.get();
                t3 && e4.deleteRenderbuffer(t3);
              } else {
                const t3 = this.depthAttachment.get();
                t3 && e4.deleteTexture(t3);
              }
            e4.deleteFramebuffer(this.framebuffer);
          }
        }
        class Ct {
          constructor(e4, t3, i3) {
            this.func = e4, this.mask = t3, this.range = i3;
          }
        }
        Ct.ReadOnly = false, Ct.ReadWrite = true, Ct.disabled = new Ct(519, Ct.ReadOnly, [0, 1]);
        const It = 7680;
        class Dt {
          constructor(e4, t3, i3, o3, r4, s4) {
            this.test = e4, this.ref = t3, this.mask = i3, this.fail = o3, this.depthFail = r4, this.pass = s4;
          }
        }
        Dt.disabled = new Dt({ func: 519, mask: 0 }, 0, 0, It, It, It);
        const Rt = 771;
        class At {
          constructor(e4, t3, i3, o3) {
            this.blendFunction = e4, this.blendColor = t3, this.mask = i3, this.blendEquation = o3;
          }
        }
        At.Replace = [1, 0, 1, 0], At.disabled = new At(At.Replace, e3.aA.transparent, [false, false, false, false]), At.unblended = new At(At.Replace, e3.aA.transparent, [true, true, true, true]), At.alphaBlended = new At([1, Rt, 1, Rt], e3.aA.transparent, [true, true, true, true]), At.multiply = new At([774, 0, 774, 0], e3.aA.transparent, [true, true, true, true]);
        const Pt = 1029, Lt = 2305;
        class Mt {
          constructor(e4, t3, i3) {
            this.enable = e4, this.mode = t3, this.frontFace = i3;
          }
        }
        Mt.disabled = new Mt(false, Pt, Lt), Mt.backCCW = new Mt(true, Pt, Lt), Mt.backCW = new Mt(true, Pt, 2304), Mt.frontCW = new Mt(true, 1028, 2304), Mt.frontCCW = new Mt(true, 1028, Lt);
        class zt {
          constructor(e4, t3) {
            this.gl = e4, this.clearColor = new Ve(this), this.clearDepth = new Ze(this), this.clearStencil = new We(this), this.colorMask = new He(this), this.depthMask = new qe(this), this.stencilMask = new Qe(this), this.stencilFunc = new $e(this), this.stencilOp = new Xe(this), this.stencilTest = new Ye(this), this.depthRange = new Je(this), this.depthTest = new Ke(this), this.depthFunc = new et(this), this.blend = new tt(this), this.blendFunc = new it(this), this.blendColor = new ot(this), this.blendEquation = new rt(this), this.cullFace = new st(this), this.cullFaceSide = new nt(this), this.frontFace = new at(this), this.program = new lt(this), this.activeTexture = new ct(this), this.viewport = new ht(this), this.bindFramebuffer = new ut(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new pt2(this), this.bindElementBuffer = new ft(this), this.bindVertexArrayOES = new mt(this), this.pixelStoreUnpack = new gt(this), this.pixelStoreUnpackPremultiplyAlpha = new vt(this), this.pixelStoreUnpackFlipY = new xt(this), this.options = t3 ? { ...t3 } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e4.getExtension("EXT_texture_filter_anisotropic") || e4.getExtension("MOZ_EXT_texture_filter_anisotropic") || e4.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e4.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e4.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e4.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e4.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e4.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e4.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e4.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e4.getParameter(e4.MAX_TEXTURE_SIZE), this.maxPointSize = e4.getParameter(e4.ALIASED_POINT_SIZE_RANGE)[1];
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e4, t3, i3) {
            return new Ne(this, e4, t3, i3);
          }
          createVertexBuffer(e4, t3, i3, o3, r4) {
            return new Ge(this, e4, t3, i3, o3, r4);
          }
          createRenderbuffer(e4, t3, i3) {
            const o3 = this.gl, r4 = o3.createRenderbuffer();
            return this.bindRenderbuffer.set(r4), o3.renderbufferStorage(o3.RENDERBUFFER, e4, t3, i3), this.bindRenderbuffer.set(null), r4;
          }
          createFramebuffer(e4, t3, i3, o3) {
            return new St(this, e4, t3, i3, o3);
          }
          clear({ color: e4, depth: t3, stencil: i3, colorMask: o3 }) {
            const r4 = this.gl;
            let s4 = 0;
            e4 && (s4 |= r4.COLOR_BUFFER_BIT, this.clearColor.set(e4), this.colorMask.set(o3 || [true, true, true, true])), void 0 !== t3 && (s4 |= r4.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t3), this.depthMask.set(true)), void 0 !== i3 && (s4 |= r4.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), r4.clear(s4);
          }
          setCullFace(e4) {
            false === e4.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e4.mode), this.frontFace.set(e4.frontFace));
          }
          setDepthMode(e4) {
            e4.func !== this.gl.ALWAYS || e4.mask ? (this.depthTest.set(true), this.depthFunc.set(e4.func), this.depthMask.set(e4.mask), this.depthRange.set(e4.range)) : this.depthTest.set(false);
          }
          setStencilMode(e4) {
            e4.test.func !== this.gl.ALWAYS || e4.mask ? (this.stencilTest.set(true), this.stencilMask.set(e4.mask), this.stencilOp.set([e4.fail, e4.depthFail, e4.pass]), this.stencilFunc.set({ func: e4.test.func, ref: e4.ref, mask: e4.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e4) {
            t2(e4.blendFunction, At.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e4.blendFunction), this.blendColor.set(e4.blendColor), e4.blendEquation ? this.blendEquation.set(e4.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(e4.mask);
          }
          unbindVAO() {
            this.bindVertexArrayOES.set(null);
          }
        }
        var Ot = e3.aB([{ name: "a_index", type: "Int16", components: 1 }]);
        const Ft = 0.15000000000000002;
        class Bt {
          constructor(t3, i3, o3, r4) {
            const s4 = { width: o3[0], height: o3[1], data: null }, n3 = t3.gl;
            this.targetColorTexture = new e3.T(t3, s4, n3.RGBA, { useMipmap: false }), this.backgroundColorTexture = new e3.T(t3, s4, n3.RGBA, { useMipmap: false }), this.context = t3, this.setParticleTextureDimension(i3, r4), this.lastInvalidatedAt = 0;
          }
          setParticleTextureDimension(t3, i3) {
            if (this.particleTextureDimension === i3)
              return;
            (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
            const o3 = this.context.gl, r4 = i3 * i3, s4 = new Uint8Array(4 * r4), n3 = 0.7692307692307692, a3 = e3.aC(t3.key);
            for (let e4 = 0; e4 < s4.length; e4 += 4) {
              const t4 = n3 * (a3() + Ft), i4 = n3 * (a3() + Ft), o4 = 255 * t4 % 1, r5 = 255 * i4 % 1, l4 = o4, c4 = i4 - r5 / 255, h2 = r5;
              s4[e4 + 0] = Math.floor(255 * (t4 - o4 / 255)), s4[e4 + 1] = Math.floor(255 * l4), s4[e4 + 2] = Math.floor(255 * c4), s4[e4 + 3] = Math.floor(255 * h2);
            }
            const l3 = new e3.h({ width: i3, height: i3 }, s4);
            this.particleTexture0 = new e3.T(this.context, l3, o3.RGBA, { premultiply: false, useMipmap: false }), this.particleTexture1 = new e3.T(this.context, l3, o3.RGBA, { premultiply: false, useMipmap: false });
            const c3 = new e3.aD();
            c3.reserve(r4);
            for (let e4 = 0; e4 < r4; e4++)
              c3.emplaceBack(e4);
            this.particleIndexBuffer = this.context.createVertexBuffer(c3, Ot.members, true), this.particleSegment = e3.aE.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i3;
          }
          update(t3) {
            return !(this.lastInvalidatedAt < t3 && (this.lastInvalidatedAt = e3.f.now(), 1));
          }
          destroy() {
            this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
          }
        }
        const kt = { type: 2, extent: e3.Y, loadGeometry: () => [[new e3.P(0, 0), new e3.P(e3.Y + 1, 0), new e3.P(e3.Y + 1, e3.Y + 1), new e3.P(0, e3.Y + 1), new e3.P(0, 0)]] };
        class Nt {
          constructor(t3, i3, o3, r4, s4) {
            this.tileID = t3, this.uid = e3.aF(), this.uses = 0, this.tileSize = i3, this.tileZoom = o3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = s4, r4 && r4.style && (this._lastUpdatedBrightness = r4.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", r4 && r4.transform && (this.projection = r4.transform.projection);
          }
          registerFadeDuration(t3) {
            const i3 = t3 + this.timeAdded;
            i3 < e3.f.now() || this.fadeEndTime && i3 < this.fadeEndTime || (this.fadeEndTime = i3);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = e3.av(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t3, i3, o3) {
            if (this.unloadVectorData(), this.state = "loaded", t3) {
              t3.featureIndex && (this.latestFeatureIndex = t3.featureIndex, t3.rawTileData ? (this.latestRawTileData = t3.rawTileData, this.latestFeatureIndex.rawTileData = t3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t3.collisionBoxArray, this.buckets = function(e4, t4) {
                const i4 = {};
                if (!t4)
                  return i4;
                for (const o4 of e4) {
                  const e5 = o4.layerIds.map((e6) => t4.getLayer(e6)).filter(Boolean);
                  if (0 !== e5.length) {
                    o4.layers = e5, o4.stateDependentLayerIds && (o4.stateDependentLayers = o4.stateDependentLayerIds.map((t5) => e5.filter((e6) => e6.id === t5)[0]));
                    for (const t5 of e5)
                      i4[t5.fqid] = o4;
                  }
                }
                return i4;
              }(t3.buckets, i3.style), this.hasSymbolBuckets = false;
              for (const t4 in this.buckets) {
                const i4 = this.buckets[t4];
                if (i4 instanceof e3.aH) {
                  if (this.hasSymbolBuckets = true, !o3)
                    break;
                  i4.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const t4 in this.buckets) {
                  const i4 = this.buckets[t4];
                  if (i4 instanceof e3.aH && i4.hasRTLText) {
                    this.hasRTLText = true, e3.aI();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const e4 in this.buckets) {
                const t4 = this.buckets[e4], o4 = i3.style.getOwnLayer(e4);
                if (!o4)
                  continue;
                const r4 = o4.queryRadius(t4);
                this.queryPadding = Math.max(this.queryPadding, r4);
              }
              t3.imageAtlas && (this.imageAtlas = t3.imageAtlas), t3.glyphAtlasImage && (this.glyphAtlasImage = t3.glyphAtlasImage), t3.lineAtlas && (this.lineAtlas = t3.lineAtlas), this._lastUpdatedBrightness = t3.brightness;
            } else
              this.collisionBoxArray = new e3.aG();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const e4 in this.buckets)
                this.buckets[e4].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          getBucket(e4) {
            return this.buckets[e4.fqid];
          }
          upload(t3) {
            for (const e4 in this.buckets) {
              const i4 = this.buckets[e4];
              i4.uploadPending() && i4.upload(t3);
            }
            const i3 = t3.gl, o3 = this.imageAtlas;
            if (o3 && !o3.uploaded) {
              const r4 = !!Object.keys(o3.patternPositions).length;
              this.imageAtlasTexture = new e3.T(t3, o3.image, i3.RGBA, { useMipmap: r4 }), this.imageAtlas.uploaded = true;
            }
            this.glyphAtlasImage && (this.glyphAtlasTexture = new e3.T(t3, this.glyphAtlasImage, i3.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e3.T(t3, this.lineAtlas.image, i3.R8), this.lineAtlas.uploaded = true);
          }
          prepare(e4, t3, i3) {
            if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e4, this.imageAtlasTexture, i3), !t3 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
              return;
            const o3 = t3.style.getBrightness();
            (this._lastUpdatedBrightness || o3) && (this._lastUpdatedBrightness && o3 && Math.abs(this._lastUpdatedBrightness - o3) < 1e-3 || (this._lastUpdatedBrightness = o3, this.updateBuckets(void 0, t3)));
          }
          queryRenderedFeatures(e4, t3, i3, o3, r4, s4, n3, a3) {
            return this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) ? this.latestFeatureIndex.query({ tileResult: o3, pixelPosMatrix: n3, transform: s4, params: r4, tileTransform: this.tileTransform }, e4, t3, i3) : {};
          }
          querySourceFeatures(t3, i3) {
            const o3 = this.latestFeatureIndex;
            if (!o3 || !o3.rawTileData)
              return;
            const r4 = o3.loadVTLayers(), s4 = i3 ? i3.sourceLayer : "", n3 = r4._geojsonTileLayer || r4[s4];
            if (!n3)
              return;
            const a3 = e3.aJ(i3 && i3.filter), { z: l3, x: c3, y: h2 } = this.tileID.canonical, u3 = { z: l3, x: c3, y: h2 };
            for (let i4 = 0; i4 < n3.length; i4++) {
              const r5 = n3.feature(i4);
              if (a3.needGeometry) {
                const t4 = e3.aK(r5, true);
                if (!a3.filter(new e3.N(this.tileID.overscaledZ), t4, this.tileID.canonical))
                  continue;
              } else if (!a3.filter(new e3.N(this.tileID.overscaledZ), r5))
                continue;
              const d2 = o3.getId(r5, s4), _3 = new e3.aL(r5, l3, c3, h2, d2);
              _3.tile = u3, t3.push(_3);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          bucketsLoaded() {
            for (const e4 in this.buckets)
              if (this.buckets[e4].uploadPending())
                return false;
            return true;
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t3) {
            const i3 = this.expirationTime;
            if (t3.cacheControl) {
              const i4 = e3.aM(t3.cacheControl);
              i4["max-age"] && (this.expirationTime = Date.now() + 1e3 * i4["max-age"]);
            } else
              t3.expires && (this.expirationTime = new Date(t3.expires).getTime());
            if (this.expirationTime) {
              const e4 = Date.now();
              let t4 = false;
              if (this.expirationTime > e4)
                t4 = false;
              else if (i3)
                if (this.expirationTime < i3)
                  t4 = true;
                else {
                  const o3 = this.expirationTime - i3;
                  o3 ? this.expirationTime = e4 + Math.max(o3, 3e4) : t4 = true;
                }
              else
                t4 = true;
              t4 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e4, t3) {
            this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(e4).length && t3 && this.updateBuckets(e4, t3);
          }
          updateBuckets(t3, i3) {
            if (!this.latestFeatureIndex)
              return;
            const o3 = this.latestFeatureIndex.loadVTLayers(), r4 = i3.style.listImages(), s4 = i3.style.getBrightness();
            for (const n3 in this.buckets) {
              if (!i3.style.hasLayer(n3))
                continue;
              const a3 = this.buckets[n3], l3 = a3.layers[0].sourceLayer || "_geojsonTileLayer", c3 = o3[l3];
              let h2 = {};
              if (t3 && (h2 = t3[l3], !c3 || !h2 || 0 === Object.keys(h2).length))
                continue;
              if (a3.update(h2, c3, r4, this.imageAtlas && this.imageAtlas.patternPositions || {}, s4), a3 instanceof e3.aN || a3 instanceof e3.aO) {
                const e4 = i3.style.getOwnSourceCache(a3.layers[0].source);
                i3._terrain && i3._terrain.enabled && e4 && a3.programConfigurations.needsUpload && i3._terrain._clearRenderCacheForTile(e4.id, this.tileID);
              }
              const u3 = i3 && i3.style && i3.style.getOwnLayer(n3);
              u3 && (this.queryPadding = Math.max(this.queryPadding, u3.queryRadius(a3)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e3.f.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t3) {
            this.symbolFadeHoldUntil = e3.f.now() + t3;
          }
          setTexture(t3, i3) {
            const o3 = i3.context, r4 = o3.gl;
            this.texture = this.texture || i3.getTileTexture(t3.width), this.texture && this.texture instanceof e3.T ? this.texture.update(t3, { useMipmap: true }) : (this.texture = new e3.T(o3, t3, r4.RGBA, { useMipmap: true }), this.texture.bind(r4.LINEAR, r4.CLAMP_TO_EDGE));
          }
          setDependencies(e4, t3) {
            const i3 = {};
            for (const e5 of t3)
              i3[e5] = true;
            this.dependencies[e4] = i3;
          }
          hasDependency(e4, t3) {
            for (const i3 of e4) {
              const e5 = this.dependencies[i3];
              if (e5) {
                for (const i4 of t3)
                  if (e5[i4])
                    return true;
              }
            }
            return false;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t3, i3) {
            if (!i3 || "mercator" === i3.name || this._tileDebugBuffer)
              return;
            const o3 = e3.aP(kt, this.tileID.canonical, this.tileTransform)[0], r4 = new e3.aQ(), s4 = new e3.aR();
            for (let e4 = 0; e4 < o3.length; e4++) {
              const { x: t4, y: i4 } = o3[e4];
              r4.emplaceBack(t4, i4), s4.emplaceBack(e4);
            }
            s4.emplaceBack(0), this._tileDebugIndexBuffer = t3.createIndexBuffer(s4), this._tileDebugBuffer = t3.createVertexBuffer(r4, e3.aS.members), this._tileDebugSegments = e3.aE.simpleSegment(0, 0, r4.length, s4.length);
          }
          _makeTileBoundsBuffers(t3, i3) {
            if (this._tileBoundsBuffer || !i3 || "mercator" === i3.name)
              return;
            const o3 = e3.aP(kt, this.tileID.canonical, this.tileTransform)[0];
            let r4, s4;
            if (this.isRaster) {
              const t4 = function(t5, i4) {
                const o4 = e3.av(t5, i4), r5 = Math.pow(2, t5.z);
                for (let s6 = 0; s6 < Me; s6++)
                  for (let n4 = 0; n4 < Me; n4++) {
                    const a4 = e3.aw((t5.x + (n4 + ke(n4)) / Le) / r5), l4 = e3.ax((t5.y + (s6 + ke(s6)) / Le) / r5), c4 = i4.project(a4, l4), h2 = s6 * Me + n4;
                    Oe[2 * h2 + 0] = Math.round((c4.x * o4.scale - o4.x) * e3.Y), Oe[2 * h2 + 1] = Math.round((c4.y * o4.scale - o4.y) * e3.Y);
                  }
                Fe.fill(0), Be.fill(0);
                for (let e4 = 2045; e4 >= 0; e4--) {
                  const t6 = 4 * e4, i5 = ze[t6 + 0], o5 = ze[t6 + 1], r6 = ze[t6 + 2], s6 = ze[t6 + 3], n4 = i5 + r6 >> 1, a4 = o5 + s6 >> 1, l4 = n4 + a4 - o5, c4 = a4 + i5 - n4, h2 = o5 * Me + i5, u3 = s6 * Me + r6, d2 = a4 * Me + n4, _3 = Math.hypot((Oe[2 * h2 + 0] + Oe[2 * u3 + 0]) / 2 - Oe[2 * d2 + 0], (Oe[2 * h2 + 1] + Oe[2 * u3 + 1]) / 2 - Oe[2 * d2 + 1]) >= 16;
                  Fe[d2] = Fe[d2] || (_3 ? 1 : 0), e4 < 1022 && (Fe[d2] = Fe[d2] || Fe[(o5 + c4 >> 1) * Me + (i5 + l4 >> 1)] || Fe[(s6 + c4 >> 1) * Me + (r6 + l4 >> 1)]);
                }
                const s5 = new e3.ay(), n3 = new e3.az();
                let a3 = 0;
                function l3(t6, i5) {
                  const o5 = i5 * Me + t6;
                  return 0 === Be[o5] && (s5.emplaceBack(Oe[2 * o5 + 0], Oe[2 * o5 + 1], t6 * e3.Y / Le, i5 * e3.Y / Le), Be[o5] = ++a3), Be[o5] - 1;
                }
                function c3(e4, t6, i5, o5, r6, s6) {
                  const a4 = e4 + i5 >> 1, h2 = t6 + o5 >> 1;
                  if (Math.abs(e4 - r6) + Math.abs(t6 - s6) > 1 && Fe[h2 * Me + a4])
                    c3(r6, s6, e4, t6, a4, h2), c3(i5, o5, r6, s6, a4, h2);
                  else {
                    const a5 = l3(e4, t6), c4 = l3(i5, o5), h3 = l3(r6, s6);
                    n3.emplaceBack(a5, c4, h3);
                  }
                }
                return c3(0, 0, Le, Le, Le, 0), c3(Le, Le, 0, 0, 0, Le), { vertices: s5, indices: n3 };
              }(this.tileID.canonical, i3);
              r4 = t4.vertices, s4 = t4.indices;
            } else {
              r4 = new e3.ay(), s4 = new e3.az();
              for (const { x: e4, y: t5 } of o3)
                r4.emplaceBack(e4, t5, 0, 0);
              const t4 = e3.aT(r4.int16, void 0, 4);
              for (let e4 = 0; e4 < t4.length; e4 += 3)
                s4.emplaceBack(t4[e4], t4[e4 + 1], t4[e4 + 2]);
            }
            this._tileBoundsBuffer = t3.createVertexBuffer(r4, e3.aU.members), this._tileBoundsIndexBuffer = t3.createIndexBuffer(s4), this._tileBoundsSegments = e3.aE.simpleSegment(0, 0, r4.length, s4.length);
          }
          _makeGlobeTileDebugBuffers(t3, i3) {
            const o3 = i3.projection;
            if (!o3 || "globe" !== o3.name || i3.freezeTileCoverage)
              return;
            const r4 = this.tileID.canonical, s4 = e3.aV(r4, i3), n3 = e3.aW(s4), a3 = e3.W(i3.zoom);
            let l3;
            a3 > 0 && (l3 = e3.a9.invert(new Float64Array(16), i3.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t3, r4, i3, n3, l3, a3), this._makeGlobeTileDebugTextBuffer(t3, r4, i3, n3, l3, a3);
          }
          _globePoint(t3, i3, o3, r4, s4, n3, a3) {
            let l3 = e3.aX(t3, i3, o3);
            if (n3) {
              const s5 = 1 << o3.z, c3 = e3.a8(r4.center.lng), h2 = e3.ah(r4.center.lat), u3 = (o3.x + 0.5) / s5 - c3;
              let d2 = 0;
              u3 > 0.5 ? d2 = -1 : u3 < -0.5 && (d2 = 1);
              let _3 = (t3 / e3.Y + o3.x) / s5 + d2, p3 = (i3 / e3.Y + o3.y) / s5;
              _3 = (_3 - c3) * r4._pixelsPerMercatorPixel + c3, p3 = (p3 - h2) * r4._pixelsPerMercatorPixel + h2;
              const f2 = [_3 * r4.worldSize, p3 * r4.worldSize, 0];
              e3.Q.transformMat4(f2, f2, n3), l3 = e3.aY(l3, f2, a3);
            }
            return e3.Q.transformMat4(l3, l3, s4);
          }
          _makeGlobeTileDebugBorderBuffer(t3, i3, o3, r4, s4, n3) {
            const a3 = new e3.aQ(), l3 = new e3.aR(), c3 = new e3.aZ(), h2 = (e4, t4, h3, u4, d2) => {
              const _3 = (h3 - e4) / (d2 - 1), p3 = (u4 - t4) / (d2 - 1), f2 = a3.length;
              for (let h4 = 0; h4 < d2; h4++) {
                const u5 = e4 + h4 * _3, d3 = t4 + h4 * p3;
                a3.emplaceBack(u5, d3);
                const m2 = this._globePoint(u5, d3, i3, o3, r4, s4, n3);
                c3.emplaceBack(m2[0], m2[1], m2[2]), l3.emplaceBack(f2 + h4);
              }
            }, u3 = e3.Y;
            h2(0, 0, u3, 0, 16), h2(u3, 0, u3, u3, 16), h2(u3, u3, 0, u3, 16), h2(0, u3, 0, 0, 16), this._tileDebugIndexBuffer = t3.createIndexBuffer(l3), this._tileDebugBuffer = t3.createVertexBuffer(a3, e3.aS.members), this._globeTileDebugBorderBuffer = t3.createVertexBuffer(c3, e3.a_.members), this._tileDebugSegments = e3.aE.simpleSegment(0, 0, a3.length, l3.length);
          }
          _makeGlobeTileDebugTextBuffer(t3, i3, o3, r4, s4, n3) {
            const a3 = e3.Y / 4, l3 = new e3.aQ(), c3 = new e3.az(), h2 = new e3.aZ(), u3 = 25;
            c3.reserve(32), l3.reserve(u3), h2.reserve(u3);
            const d2 = (e4, t4) => u3 * e4 + t4;
            for (let e4 = 0; e4 < u3; e4++) {
              const t4 = e4 * a3;
              for (let e5 = 0; e5 < u3; e5++) {
                const c4 = e5 * a3;
                l3.emplaceBack(c4, t4);
                const u4 = this._globePoint(c4, t4, i3, o3, r4, s4, n3);
                h2.emplaceBack(u4[0], u4[1], u4[2]);
              }
            }
            for (let e4 = 0; e4 < 4; e4++)
              for (let t4 = 0; t4 < 4; t4++) {
                const i4 = d2(e4, t4), o4 = d2(e4, t4 + 1), r5 = d2(e4 + 1, t4), s5 = d2(e4 + 1, t4 + 1);
                c3.emplaceBack(i4, o4, r5), c3.emplaceBack(r5, o4, s5);
              }
            this._tileDebugTextIndexBuffer = t3.createIndexBuffer(c3), this._tileDebugTextBuffer = t3.createVertexBuffer(l3, e3.aS.members), this._globeTileDebugTextBuffer = t3.createVertexBuffer(h2, e3.a_.members), this._tileDebugTextSegments = e3.aE.simpleSegment(0, 0, u3, 32);
          }
          destroy(t3 = false) {
            for (const e4 in this.buckets)
              this.buckets[e4].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t3 && this.texture && this.texture instanceof e3.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        const Ut = { vector: Re, raster: Ae, "raster-dem": class extends Ae {
          constructor(t3, i3, o3, r4) {
            super(t3, i3, o3, r4), this.type = "raster-dem", this.maxzoom = 22, this._options = e3.e({ type: "raster-dem" }, i3), this.encoding = i3.encoding || "mapbox";
          }
          loadTile(t3, i3) {
            const o3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
            function r4(e4, o4) {
              e4 && (t3.state = "errored", i3(e4)), o4 && (t3.dem = o4, t3.dem.onDeserialize(), t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true, t3.state = "loaded", i3(null));
            }
            t3.request = e3.d(this.map._requestManager.transformRequest(o3, e3.R.Tile), function(o4, s4, n3, a3) {
              if (delete t3.request, t3.aborted)
                t3.state = "unloaded", i3(null);
              else if (o4)
                t3.state = "errored", i3(o4);
              else if (s4) {
                this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: n3, expires: a3 });
                const i4 = ImageBitmap && s4 instanceof ImageBitmap && e3.an(), o5 = 1 - (s4.width - e3.ao(s4.width)) / 2;
                o5 < 1 || t3.neighboringTiles || (t3.neighboringTiles = this._getNeighboringTiles(t3.tileID));
                const l3 = i4 ? s4 : e3.f.getImageData(s4, o5), c3 = { uid: t3.uid, coord: t3.tileID, source: this.id, scope: this.scope, rawImageData: l3, encoding: this.encoding, padding: o5 };
                t3.actor && "expired" !== t3.state || (t3.actor = this.dispatcher.getActor(), t3.actor.send("loadDEMTile", c3, r4.bind(this), void 0, true));
              }
            }.bind(this));
          }
          _getNeighboringTiles(t3) {
            const i3 = t3.canonical, o3 = Math.pow(2, i3.z), r4 = (i3.x - 1 + o3) % o3, s4 = 0 === i3.x ? t3.wrap - 1 : t3.wrap, n3 = (i3.x + 1 + o3) % o3, a3 = i3.x + 1 === o3 ? t3.wrap + 1 : t3.wrap, l3 = {};
            return l3[new e3.ap(t3.overscaledZ, s4, i3.z, r4, i3.y).key] = { backfilled: false }, l3[new e3.ap(t3.overscaledZ, a3, i3.z, n3, i3.y).key] = { backfilled: false }, i3.y > 0 && (l3[new e3.ap(t3.overscaledZ, s4, i3.z, r4, i3.y - 1).key] = { backfilled: false }, l3[new e3.ap(t3.overscaledZ, t3.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l3[new e3.ap(t3.overscaledZ, a3, i3.z, n3, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < o3 && (l3[new e3.ap(t3.overscaledZ, s4, i3.z, r4, i3.y + 1).key] = { backfilled: false }, l3[new e3.ap(t3.overscaledZ, t3.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l3[new e3.ap(t3.overscaledZ, a3, i3.z, n3, i3.y + 1).key] = { backfilled: false }), l3;
          }
        }, "raster-array": Pe, geojson: class extends e3.E {
          constructor(t3, i3, o3, r4) {
            super(), this.id = t3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o3.getActor(), this.setEventedParent(r4), this._data = i3.data, this._options = e3.e({}, i3), this._collectResourceTiming = i3.collectResourceTiming, void 0 !== i3.maxzoom && (this.maxzoom = i3.maxzoom), void 0 !== i3.minzoom && (this.minzoom = i3.minzoom), i3.type && (this.type = i3.type), i3.attribution && (this.attribution = i3.attribution), this.promoteId = i3.promoteId;
            const s4 = e3.Y / this.tileSize;
            this.workerOptions = e3.e({ source: this.id, scope: this.scope, cluster: i3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i3.buffer ? i3.buffer : 128) * s4, tolerance: (void 0 !== i3.tolerance ? i3.tolerance : 0.375) * s4, extent: e3.Y, maxZoom: this.maxzoom, lineMetrics: i3.lineMetrics || false, generateId: i3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i3.clusterMaxZoom ? i3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i3.clusterMinPoints || 2), extent: e3.Y, radius: (void 0 !== i3.clusterRadius ? i3.clusterRadius : 50) * s4, log: false, generateId: i3.generateId || false }, clusterProperties: i3.clusterProperties, filter: i3.filter, dynamic: i3.dynamic }, i3.workerOptions);
          }
          onAdd(e4) {
            this.map = e4, this.setData(this._data);
          }
          setData(e4) {
            return this._data = e4, this._updateWorkerData(), this;
          }
          updateData(t3) {
            return this._options.dynamic ? (this._data = t3, this._updateWorkerData(true), this) : this.fire(new e3.a(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
          }
          getClusterExpansionZoom(e4, t3) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e4, source: this.id, scope: this.scope }, t3), this;
          }
          getClusterChildren(e4, t3) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: e4, source: this.id, scope: this.scope }, t3), this;
          }
          getClusterLeaves(e4, t3, i3, o3) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e4, limit: t3, offset: i3 }, o3), this;
          }
          _updateWorkerData(t3 = false) {
            if (this._pendingLoad)
              return void (this._coalesce = true);
            this.fire(new e3.b("dataloading", { dataType: "source" })), this._loaded = false;
            const i3 = e3.e({ append: t3 }, this.workerOptions);
            i3.scope = this.scope;
            const o3 = this._data;
            "string" == typeof o3 ? (i3.request = this.map._requestManager.transformRequest(e3.f.resolveURL(o3), e3.R.Source), i3.request.collectResourceTiming = this._collectResourceTiming) : i3.data = JSON.stringify(o3), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i3, (i4, o4) => {
              if (this._loaded = true, this._pendingLoad = null, i4)
                this.fire(new e3.a(i4));
              else {
                const t4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && o4 && o4.resourceTiming && o4.resourceTiming[this.id] && (t4.resourceTiming = o4.resourceTiming[this.id]), this.fire(new e3.b("data", t4)), this._metadataFired = true;
              }
              this._coalesce && (this._updateWorkerData(t3), this._coalesce = false);
            });
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t3, i3) {
            const o3 = t3.actor ? "reloadTile" : "loadTile";
            t3.actor = this.actor;
            const r4 = { type: this.type, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, scope: this.scope, pixelRatio: e3.f.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0 };
            t3.request = this.actor.send(o3, r4, (e4, r5) => (delete t3.request, t3.destroy(), t3.aborted ? i3(null) : e4 ? i3(e4) : (t3.loadVectorData(r5, this.map.painter, "reloadTile" === o3), i3(null))), void 0, "loadTile" === o3);
          }
          abortTile(e4) {
            e4.request && (e4.request.cancel(), delete e4.request), e4.aborted = true;
          }
          unloadTile(e4) {
            this.actor.send("removeTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope }), e4.destroy();
          }
          onRemove() {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return e3.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }, video: class extends e3.as {
          constructor(e4, t3, i3, o3) {
            super(e4, t3, i3, o3), this.roundZoom = true, this.type = "video", this.options = t3;
          }
          load() {
            this._loaded = false;
            const t3 = this.options;
            this.urls = [];
            for (const i3 of t3.urls)
              this.urls.push(this.map._requestManager.transformRequest(i3, e3.R.Source).url);
            e3.at(this.urls, (t4, i3) => {
              this._loaded = true, t4 ? this.fire(new e3.a(t4)) : i3 && (this.video = i3, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t3) {
            if (this.video) {
              const i3 = this.video.seekable;
              t3 < i3.start(0) || t3 > i3.end(0) ? this.fire(new e3.a(new e3.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i3.start(0)} and ${i3.end(0)}-second mark.`))) : this.video.currentTime = t3;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e4) {
            this.map || (this.map = e4, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
              return;
            const t3 = this.map.painter.context, i3 = t3.gl;
            this.texture ? this.video.paused || (this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), i3.texSubImage2D(i3.TEXTURE_2D, 0, 0, 0, i3.RGBA, i3.UNSIGNED_BYTE, this.video)) : (this.texture = new e3.T(t3, this.video, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t3);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: e3.as, model: class extends e3.E {
          constructor(e4, t3, i3, o3) {
            super(), this.id = e4, this.type = "model", this.models = [], this._loaded = false, this._options = t3;
          }
          load() {
            const t3 = [];
            for (const i3 in this._options.models) {
              const o3 = this._options.models[i3], r4 = e3.l(this.map._requestManager.transformRequest(o3.uri, e3.R.Model).url).then((t4) => {
                if (!t4)
                  return;
                const r5 = e3.c(t4), s4 = new e3.M(i3, o3.position, o3.orientation, r5);
                s4.computeBoundsAndApplyParent(), this.models.push(s4);
              }).catch((t4) => {
                this.fire(new e3.a(new Error(`Could not load model ${i3} from ${o3.uri}: ${t4.message}`)));
              });
              t3.push(r4);
            }
            return Promise.allSettled(t3).then(() => {
              this._loaded = true, this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" }));
            }).catch((t4) => {
              this.fire(new e3.a(new Error(`Could not load models: ${t4.message}`)));
            });
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          hasTransition() {
            return false;
          }
          loaded() {
            return this._loaded;
          }
          getModels() {
            return this.models;
          }
          loadTile(e4, t3) {
          }
          serialize() {
            return { type: "model" };
          }
        }, "batched-model": class extends e3.E {
          constructor(e4, t3, i3, o3) {
            super(), this.type = "batched-model", this.id = e4, this.tileSize = 512, this._options = t3, this.tiles = this._options.tiles, this.maxzoom = t3.maxzoom || 19, this.minzoom = t3.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i3, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o3);
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          load(t3) {
            this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" }));
            const i3 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o3 = this.map._worldview;
            this._tileJSONRequest = Ie(this._options, this.map._requestManager, i3, o3, (r4, s4) => {
              this._tileJSONRequest = null, this._loaded = true, r4 ? (i3 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i3}`), o3 && 2 !== o3.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o3}`), this.fire(new e3.a(r4))) : s4 && (e3.e(this, s4), s4.bounds && (this.tileBounds = new De(s4.bounds, this.minzoom, this.maxzoom)), e3.am(s4.tiles, this.map._requestManager._customAccessToken), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }))), t3 && t3(r4);
            });
          }
          hasTransition() {
            return false;
          }
          hasTile(e4) {
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t3, i3) {
            const o3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme)), r4 = { request: this.map._requestManager.transformRequest(o3, e3.R.Tile), data: void 0, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t3.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0 };
            if (t3.actor && "expired" !== t3.state)
              if ("loading" === t3.state)
                t3.reloadCallback = i3;
              else {
                if (t3.buckets) {
                  const e4 = Object.values(t3.buckets);
                  for (const t4 of e4)
                    t4.dirty = true;
                  return void (t3.state = "loaded");
                }
                t3.request = t3.actor.send("reloadTile", r4, s4.bind(this));
              }
            else
              t3.actor = this.dispatcher.getActor(), t3.request = t3.actor.send("loadTile", r4, s4.bind(this), void 0, true);
            function s4(e4, o4) {
              return t3.aborted ? i3(null) : e4 && 404 !== e4.status ? i3(e4) : (o4 && (o4.resourceTiming && (t3.resourceTiming = o4.resourceTiming), this.map._refreshExpiredTiles && t3.setExpiryData(o4), t3.buckets = { ...t3.buckets, ...o4.buckets }, o4.featureIndex && (t3.latestFeatureIndex = o4.featureIndex)), t3.state = "loaded", void i3(null));
            }
          }
          serialize() {
            return e3.e({}, this._options);
          }
        }, canvas: class extends e3.as {
          constructor(t3, i3, o3, r4) {
            super(t3, i3, o3, r4), i3.coordinates ? Array.isArray(i3.coordinates) && 4 === i3.coordinates.length && !i3.coordinates.some((e4) => !Array.isArray(e4) || 2 !== e4.length || e4.some((e5) => "number" != typeof e5)) || this.fire(new e3.a(new e3.V(`sources.${t3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e3.a(new e3.V(`sources.${t3}`, null, 'missing required property "coordinates"'))), i3.animate && "boolean" != typeof i3.animate && this.fire(new e3.a(new e3.V(`sources.${t3}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? "string" == typeof i3.canvas || i3.canvas instanceof HTMLCanvasElement || this.fire(new e3.a(new e3.V(`sources.${t3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e3.a(new e3.V(`sources.${t3}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = void 0 === i3.animate || i3.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e3.a(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e4) {
            this.map = e4, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t3 = true), this._hasInvalidDimensions())
              return;
            if (0 === Object.keys(this.tiles).length)
              return;
            const i3 = this.map.painter.context;
            this.texture ? !t3 && !this._playing || this.texture instanceof e3.au || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e3.T(i3, this.canvas, i3.gl.RGBA, { premultiply: true }), this._prepareData(i3);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e4 of [this.canvas.width, this.canvas.height])
              if (isNaN(e4) || e4 <= 0)
                return true;
            return false;
          }
        }, custom: class extends e3.E {
          constructor(t3, i3, o3, r4) {
            super(), this.id = t3, this.type = "custom", this._dataType = "raster", this._dispatcher = o3, this._implementation = i3, this.setEventedParent(r4), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e3.a(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e3.a(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new De(this._implementation.bounds, this.minzoom, this.maxzoom)), i3.update = this._update.bind(this), i3.clearTiles = this._clearTiles.bind(this), i3.coveringTiles = this._coveringTiles.bind(this), e3.e(this, e3.af(i3, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return e3.af(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = true, this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t3) {
            this._map = t3, this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t3), this.load();
          }
          onRemove(e4) {
            this._implementation.onRemove && this._implementation.onRemove(e4);
          }
          hasTile(e4) {
            if (this._implementation.hasTile) {
              const { x: t3, y: i3, z: o3 } = e4.canonical;
              return this._implementation.hasTile({ x: t3, y: i3, z: o3 });
            }
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          loadTile(e4, t3) {
            const { x: i3, y: o3, z: r4 } = e4.tileID.canonical, s4 = new AbortController();
            e4.request = Promise.resolve(this._implementation.loadTile({ x: i3, y: o3, z: r4 }, { signal: s4.signal })).then(function(i4) {
              return delete e4.request, e4.aborted ? (e4.state = "unloaded", t3(null)) : void 0 === i4 ? (e4.state = "errored", t3(null)) : null === i4 ? (this.loadTileData(e4, { width: this.tileSize, height: this.tileSize, data: null }), e4.state = "loaded", t3(null)) : function(e5) {
                return e5 instanceof ImageData || e5 instanceof HTMLCanvasElement || e5 instanceof ImageBitmap || e5 instanceof HTMLImageElement;
              }(i4) ? (this.loadTileData(e4, i4), e4.state = "loaded", void t3(null)) : (e4.state = "errored", t3(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }.bind(this)).catch((i4) => {
              20 !== i4.code && (e4.state = "errored", t3(i4));
            }), e4.request.cancel = () => s4.abort();
          }
          loadTileData(e4, t3) {
            e4.setTexture(t3, this._map.painter);
          }
          unloadTile(t3, i3) {
            if (t3.texture && t3.texture instanceof e3.T ? (t3.destroy(true), t3.texture && t3.texture instanceof e3.T && this._map.painter.saveTileTexture(t3.texture)) : t3.destroy(), this._implementation.unloadTile) {
              const { x: e4, y: i4, z: o3 } = t3.tileID.canonical;
              this._implementation.unloadTile({ x: e4, y: i4, z: o3 });
            }
            i3();
          }
          abortTile(e4, t3) {
            e4.request && e4.request.cancel && (e4.request.cancel(), delete e4.request), t3();
          }
          hasTransition() {
            return false;
          }
          _coveringTiles() {
            return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e4) => ({ x: e4.canonical.x, y: e4.canonical.y, z: e4.canonical.z }));
          }
          _clearTiles() {
            const t3 = e3.aj(this.id, this.scope);
            this._map.style.clearSource(t3);
          }
          _update() {
            this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, Gt = function(t3, i3, o3, r4) {
          const s4 = new Ut[i3.type](t3, i3, o3, r4);
          if (s4.id !== t3)
            throw new Error(`Expected Source id to be ${t3} instead of ${s4.id}`);
          return e3.a$(["load", "abort", "unload", "serialize", "prepare"], s4), s4;
        };
        function jt(t3, i3) {
          const o3 = e3.a9.identity([]);
          return e3.a9.scale(o3, o3, [0.5 * t3.width, 0.5 * -t3.height, 1]), e3.a9.translate(o3, o3, [1, -1, 0]), e3.a9.multiply(o3, o3, t3.calculateProjMatrix(i3.toUnwrapped())), Float32Array.from(o3);
        }
        function Vt(e4, t3, i3, o3, r4, s4, n3, a3 = false) {
          const l3 = e4.tilesIn(o3, n3, a3);
          l3.sort(Wt);
          const c3 = [];
          for (const o4 of l3)
            c3.push({ wrappedTileID: o4.tile.tileID.wrapped().key, queryResults: o4.tile.queryRenderedFeatures(t3, i3, e4._state, o4, r4, s4, jt(e4.transform, o4.tile.tileID), a3) });
          const h2 = function(e5) {
            const t4 = {}, i4 = {};
            for (const o4 of e5) {
              const e6 = o4.queryResults, r5 = o4.wrappedTileID, s5 = i4[r5] = i4[r5] || {};
              for (const i5 in e6) {
                const o5 = e6[i5], r6 = s5[i5] = s5[i5] || {}, n4 = t4[i5] = t4[i5] || [];
                for (const e7 of o5)
                  r6[e7.featureIndex] || (r6[e7.featureIndex] = true, n4.push(e7));
              }
            }
            return t4;
          }(c3);
          for (const t4 in h2)
            h2[t4].forEach((t5) => {
              const i4 = t5.feature, o4 = i4.layer;
              o4 && "background" !== o4.type && "sky" !== o4.type && "slot" !== o4.type && (i4.source = o4.source, o4["source-layer"] && (i4.sourceLayer = o4["source-layer"]), i4.state = void 0 !== i4.id ? e4.getFeatureState(o4["source-layer"], i4.id) : {});
            });
          return h2;
        }
        function Zt(e4, t3) {
          const i3 = e4.getRenderableIds().map((t4) => e4.getTileByID(t4)), o3 = [], r4 = {};
          for (let e5 = 0; e5 < i3.length; e5++) {
            const s4 = i3[e5], n3 = s4.tileID.canonical.key;
            r4[n3] || (r4[n3] = true, s4.querySourceFeatures(o3, t3));
          }
          return o3;
        }
        function Wt(e4, t3) {
          const i3 = e4.tileID, o3 = t3.tileID;
          return i3.overscaledZ - o3.overscaledZ || i3.canonical.y - o3.canonical.y || i3.wrap - o3.wrap || i3.canonical.x - o3.canonical.x;
        }
        class Ht extends Nt {
          constructor(e4, t3, i3, o3, r4) {
            super(e4, t3, i3, o3, r4), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = false;
          }
          setTexture(t3, i3) {
            const o3 = i3.context, r4 = o3.gl;
            this.texture = this.texture || i3.getTileTexture(t3.width), this.texture && this.texture instanceof e3.T ? this.texture.update(t3, { useMipmap: false, premultiply: false }) : this.texture = new e3.T(o3, t3, r4.RGBA, { useMipmap: false, premultiply: false });
          }
          flushQueues() {
            for (; this._workQueue.length; )
              this._workQueue.pop()();
            for (; this._fetchQueue.length; )
              this._fetchQueue.pop()();
          }
          fetchHeader(t3 = 16384, i3) {
            const o3 = this._mrt = new e3.b0(30), r4 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t3 - 1) } });
            return this.entireBuffer = null, this.request = e3.b1(r4, (e4, r5, s4, n3) => {
              if (e4)
                i3(e4);
              else
                try {
                  const e5 = o3.getHeaderLength(r5);
                  if (e5 > t3)
                    return void (this.request = this.fetchHeader(e5, i3));
                  o3.parseHeader(r5), this._isHeaderLoaded = true;
                  let a3 = 0;
                  for (const e6 of Object.values(o3.layers))
                    a3 = Math.max(a3, e6.dataIndex[e6.dataIndex.length - 1].last_byte);
                  r5.byteLength >= a3 && (this.entireBuffer = r5), i3(null, this.entireBuffer || r5, s4, n3);
                } catch (e5) {
                  i3(e5);
                }
            }), this.request;
          }
          fetchBand(t3, i3, o3) {
            const r4 = this._mrt;
            if (!this._isHeaderLoaded || !r4)
              return void o3(new Error("Tile header is not ready"));
            const s4 = this.actor;
            if (!s4)
              return void o3(new Error("Can't fetch tile band without an actor"));
            let n3;
            const a3 = (e4, r5) => {
              n3.complete(e4, r5), e4 ? o3(e4) : (this.updateTextureDescriptor(t3, i3), o3(null, this.textureDescriptor && this.textureDescriptor.img));
            }, l3 = (e4, t4) => {
              if (e4)
                return o3(e4);
              const i4 = s4.send("decodeRasterArray", { buffer: t4, task: n3 }, a3, void 0, true);
              this._workQueue.push(() => {
                i4 && i4.cancel(), n3.cancel();
              });
            }, c3 = r4.getLayer(t3);
            if (!c3)
              return void o3(new Error(`Unknown sourceLayer "${t3}"`));
            if (c3.hasDataForBand(i3))
              return this.updateTextureDescriptor(t3, i3), void o3(null, this.textureDescriptor ? this.textureDescriptor.img : null);
            const h2 = c3.getDataRange([i3]);
            if (n3 = r4.createDecodingTask(h2), !n3 || n3.tasks.length)
              if (this.flushQueues(), this.entireBuffer)
                l3(null, this.entireBuffer.slice(h2.firstByte, h2.lastByte + 1));
              else {
                const t4 = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${h2.firstByte}-${h2.lastByte}` } }), i4 = e3.b1(t4, l3);
                this._fetchQueue.push(() => {
                  i4.cancel(), n3.cancel();
                });
              }
            else
              o3(null);
          }
          updateNeeded(e4, t3) {
            return (!this.textureDescriptor || this.textureDescriptor.band !== t3 || this.textureDescriptor.layer !== e4) && "errored" !== this.state;
          }
          updateTextureDescriptor(t3, i3) {
            if (!this._mrt)
              return;
            const o3 = this._mrt.getLayer(t3);
            if (!o3 || !o3.hasBand(i3) || !o3.hasDataForBand(i3))
              return;
            const { bytes: r4, tileSize: s4, buffer: n3, offset: a3, scale: l3 } = o3.getBandView(i3), c3 = s4 + 2 * n3, h2 = { data: r4, width: c3, height: c3 }, u3 = this.texture;
            u3 && u3 instanceof e3.T && u3.update(h2, { useMipmap: false, premultiply: false }), this.textureDescriptor = { layer: t3, band: i3, img: h2, buffer: n3, offset: a3, tileSize: s4, format: o3.pixelFormat, mix: [l3, 256 * l3, 65536 * l3, 16777216 * l3] };
          }
        }
        class qt {
          constructor(e4, t3) {
            this.max = e4, this.onRemove = t3, this.reset();
          }
          reset() {
            for (const e4 in this.data)
              for (const t3 of this.data[e4])
                t3.timeout && clearTimeout(t3.timeout), this.onRemove(t3.value);
            return this.data = {}, this.order = [], this;
          }
          add(e4, t3, i3) {
            const o3 = e4.wrapped().key;
            void 0 === this.data[o3] && (this.data[o3] = []);
            const r4 = { value: t3, timeout: void 0 };
            if (void 0 !== i3 && (r4.timeout = setTimeout(() => {
              this.remove(e4, r4);
            }, i3)), this.data[o3].push(r4), this.order.push(o3), this.order.length > this.max) {
              const e5 = this._getAndRemoveByKey(this.order[0]);
              e5 && this.onRemove(e5);
            }
            return this;
          }
          has(e4) {
            return e4.wrapped().key in this.data;
          }
          getAndRemove(e4) {
            return this.has(e4) ? this._getAndRemoveByKey(e4.wrapped().key) : null;
          }
          _getAndRemoveByKey(e4) {
            const t3 = this.data[e4].shift();
            return t3.timeout && clearTimeout(t3.timeout), 0 === this.data[e4].length && delete this.data[e4], this.order.splice(this.order.indexOf(e4), 1), t3.value;
          }
          getByKey(e4) {
            const t3 = this.data[e4];
            return t3 ? t3[0].value : null;
          }
          get(e4) {
            return this.has(e4) ? this.data[e4.wrapped().key][0].value : null;
          }
          remove(e4, t3) {
            if (!this.has(e4))
              return this;
            const i3 = e4.wrapped().key, o3 = void 0 === t3 ? 0 : this.data[i3].indexOf(t3), r4 = this.data[i3][o3];
            return this.data[i3].splice(o3, 1), r4.timeout && clearTimeout(r4.timeout), 0 === this.data[i3].length && delete this.data[i3], this.onRemove(r4.value), this.order.splice(this.order.indexOf(i3), 1), this;
          }
          setMaxSize(e4) {
            for (this.max = e4; this.order.length > this.max; ) {
              const e5 = this._getAndRemoveByKey(this.order[0]);
              e5 && this.onRemove(e5);
            }
            return this;
          }
          filter(e4) {
            const t3 = [];
            for (const i3 in this.data)
              for (const o3 of this.data[i3])
                e4(o3.value) || t3.push(o3);
            for (const e5 of t3)
              this.remove(e5.value.tileID, e5);
          }
        }
        class Qt extends e3.E {
          constructor(e4, t3, i3) {
            super(), this.id = e4, this._onlySymbols = i3, t3.on("data", (e5) => {
              "source" === e5.dataType && "metadata" === e5.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e5.dataType && "content" === e5.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
            }), t3.on("error", () => {
              this._sourceErrored = true;
            }), this._source = t3, this._tiles = {}, this._cache = new qt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t3.minTileCacheSize, this._maxTileCacheSize = t3.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new y2(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
          }
          onAdd(e4) {
            this.map = e4, this._minTileCacheSize = void 0 === this._minTileCacheSize && e4 ? e4._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e4 ? e4._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            for (const e4 in this._tiles) {
              const t3 = this._tiles[e4];
              if ("errored" !== t3.state && ("loaded" !== t3.state || !t3.bucketsLoaded()))
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const e4 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e4 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(e4, t3) {
            return e4.isSymbolTile = this._onlySymbols, e4.isExtraShadowCaster = this._shadowCasterTiles[e4.tileID.key], this._source.loadTile(e4, t3);
          }
          _unloadTile(e4) {
            if (this._source.unloadTile)
              return this._source.unloadTile(e4, () => {
              });
          }
          _abortTile(e4) {
            if (this._source.abortTile)
              return this._source.abortTile(e4, () => {
              });
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e4) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const t3 in this._tiles) {
              const i3 = this._tiles[t3];
              i3.upload(e4), i3.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
            }
          }
          getIds() {
            return e3.b2(this._tiles).map((e4) => e4.tileID).sort($t).map((e4) => e4.key);
          }
          getRenderableIds(t3, i3) {
            const o3 = [];
            for (const e4 in this._tiles)
              this._isIdRenderable(+e4, t3, i3) && o3.push(this._tiles[e4]);
            return t3 ? o3.sort((t4, i4) => {
              const o4 = t4.tileID, r4 = i4.tileID, s4 = new e3.P(o4.canonical.x, o4.canonical.y)._rotate(this.transform.angle), n3 = new e3.P(r4.canonical.x, r4.canonical.y)._rotate(this.transform.angle);
              return o4.overscaledZ - r4.overscaledZ || n3.y - s4.y || n3.x - s4.x;
            }).map((e4) => e4.tileID.key) : o3.map((e4) => e4.tileID).sort($t).map((e4) => e4.key);
          }
          hasRenderableParent(e4) {
            const t3 = this.findLoadedParent(e4, 0);
            return !!t3 && this._isIdRenderable(t3.tileID.key);
          }
          _isIdRenderable(e4, t3, i3) {
            return this._tiles[e4] && this._tiles[e4].hasData() && !this._coveredTiles[e4] && (t3 || !this._tiles[e4].holdingForFade()) && (i3 || !this._shadowCasterTiles[e4]);
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const e4 in this._tiles)
                "errored" !== this._tiles[e4].state && this._reloadTile(+e4, "reloading");
            }
          }
          _reloadTile(e4, t3) {
            const i3 = this._tiles[e4];
            i3 && ("loading" !== i3.state && (i3.state = t3), this._loadTile(i3, this._tileLoaded.bind(this, i3, e4, t3)));
          }
          _tileLoaded(t3, i3, o3, r4) {
            if (r4)
              if (t3.state = "errored", 404 !== r4.status)
                this._source.fire(new e3.a(r4, { tile: t3 }));
              else {
                if (!(t3.tileID.key in this._loadedParentTiles))
                  return void this._source.fire(new e3.b("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id }));
                if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                  const e4 = this.map.painter.terrain;
                  this.update(this.transform, e4.getScaledDemTileSize(), true), e4.resetTileLookupCache(this.id);
                } else
                  this.update(this.transform);
              }
            else
              t3.timeAdded = e3.f.now(), "expired" === o3 && (t3.refreshedUponExpiration = true), this._setTileReloadTimer(i3, t3), "raster-dem" === this._source.type && t3.dem && this._backfillDEM(t3), this._state.initializeTileState(t3, this.map ? this.map.painter : null), this._source.fire(new e3.b("data", { dataType: "source", tile: t3, coord: t3.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(e4) {
            const t3 = this.getRenderableIds();
            for (let o3 = 0; o3 < t3.length; o3++) {
              const r4 = t3[o3];
              if (e4.neighboringTiles && e4.neighboringTiles[r4]) {
                const t4 = this.getTileByID(r4);
                i3(e4, t4), i3(t4, e4);
              }
            }
            function i3(e5, t4) {
              if (!e5.dem || e5.dem.borderReady)
                return;
              e5.needsHillshadePrepare = true, e5.needsDEMTextureUpload = true;
              let i4 = t4.tileID.canonical.x - e5.tileID.canonical.x;
              const o3 = t4.tileID.canonical.y - e5.tileID.canonical.y, r4 = Math.pow(2, e5.tileID.canonical.z), s4 = t4.tileID.key;
              0 === i4 && 0 === o3 || Math.abs(o3) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + r4) ? i4 += r4 : 1 === Math.abs(i4 - r4) && (i4 -= r4)), t4.dem && e5.dem && (e5.dem.backfillBorder(t4.dem, i4, o3), e5.neighboringTiles && e5.neighboringTiles[s4] && (e5.neighboringTiles[s4].backfilled = true)));
            }
          }
          getTile(e4) {
            return this.getTileByID(e4.key);
          }
          getTileByID(e4) {
            return this._tiles[e4];
          }
          _retainLoadedChildren(e4, t3, i3, o3) {
            for (const r4 in this._tiles) {
              let s4 = this._tiles[r4];
              if (o3[r4] || !s4.hasData() || s4.tileID.overscaledZ <= t3 || s4.tileID.overscaledZ > i3)
                continue;
              let n3 = s4.tileID;
              for (; s4 && s4.tileID.overscaledZ > t3 + 1; ) {
                const e5 = s4.tileID.scaledTo(s4.tileID.overscaledZ - 1);
                s4 = this._tiles[e5.key], s4 && s4.hasData() && (n3 = e5);
              }
              let a3 = n3;
              for (; a3.overscaledZ > t3; )
                if (a3 = a3.scaledTo(a3.overscaledZ - 1), e4[a3.key]) {
                  o3[n3.key] = n3;
                  break;
                }
            }
          }
          findLoadedParent(e4, t3) {
            if (e4.key in this._loadedParentTiles) {
              const i3 = this._loadedParentTiles[e4.key];
              return i3 && i3.tileID.overscaledZ >= t3 ? i3 : null;
            }
            for (let i3 = e4.overscaledZ - 1; i3 >= t3; i3--) {
              const t4 = e4.scaledTo(i3), o3 = this._getLoadedTile(t4);
              if (o3)
                return o3;
            }
          }
          _getLoadedTile(e4) {
            const t3 = this._tiles[e4.key];
            return t3 && t3.hasData() ? t3 : this._cache.getByKey(this._source.reparseOverscaled ? e4.wrapped().key : e4.canonical.key);
          }
          updateCacheSize(e4, t3) {
            t3 = t3 || this._source.tileSize;
            const i3 = Math.ceil(e4.width / t3) + 1, o3 = Math.ceil(e4.height / t3) + 1, r4 = Math.floor(i3 * o3 * 5), s4 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r4) : r4, n3 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s4) : s4;
            this._cache.setMaxSize(n3);
          }
          handleWrapJump(e4) {
            const t3 = Math.round((e4 - (void 0 === this._prevLng ? e4 : this._prevLng)) / 360);
            if (this._prevLng = e4, t3) {
              const e5 = {};
              for (const i3 in this._tiles) {
                const o3 = this._tiles[i3];
                o3.tileID = o3.tileID.unwrapTo(o3.tileID.wrap + t3), e5[o3.tileID.key] = o3;
              }
              this._tiles = e5;
              for (const e6 in this._timers)
                clearTimeout(this._timers[e6]), delete this._timers[e6];
              for (const e6 in this._tiles)
                this._setTileReloadTimer(+e6, this._tiles[e6]);
            }
          }
          update(t3, i3, o3, r4) {
            if (this.transform = t3, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
              return;
            if (this.usedForTerrain && !o3)
              return;
            let s4;
            if (this.updateCacheSize(t3, i3), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {}, this.used || this.usedForTerrain)
              if (this._source.tileID)
                s4 = t3.getVisibleUnwrappedCoordinates(this._source.tileID).map((t4) => new e3.ap(t4.canonical.z, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y));
              else if (0 !== this.tileCoverLift) {
                const r5 = t3.clone();
                r5.tileCoverLift = this.tileCoverLift, s4 = r5.coveringTiles({ tileSize: i3 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.minzoom <= 1 && "globe" === t3.projection.name && (s4.push(new e3.ap(1, 0, 1, 0, 0)), s4.push(new e3.ap(1, 0, 1, 1, 0)), s4.push(new e3.ap(1, 0, 1, 0, 1)), s4.push(new e3.ap(1, 0, 1, 1, 1)));
              } else
                s4 = t3.coveringTiles({ tileSize: i3 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (s4 = s4.filter((e4) => this._source.hasTile(e4)));
            else
              s4 = [];
            if (s4.length > 0 && this.castsShadows && r4 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !Xt(this._source.type)) {
              const e4 = t3.coveringZoomLevel({ tileSize: i3 || this._source.tileSize, roundZoom: this._source.roundZoom && !o3 }), n4 = Math.min(e4, this._source.maxzoom), a4 = t3.extendTileCoverForShadows(s4, r4, n4);
              for (const e5 of a4)
                this._shadowCasterTiles[e5.key] = true, s4.push(e5);
            }
            const n3 = this._updateRetainedTiles(s4);
            if (Xt(this._source.type) && 0 !== s4.length) {
              const t4 = {}, i4 = {}, o4 = Object.keys(n3);
              for (const r6 of o4) {
                const o5 = n3[r6], s5 = this._tiles[r6];
                if (!s5 || s5.fadeEndTime && s5.fadeEndTime <= e3.f.now())
                  continue;
                const a4 = this.findLoadedParent(o5, Math.max(o5.overscaledZ - Qt.maxOverzooming, this._source.minzoom));
                a4 && (this._addTile(a4.tileID), t4[a4.tileID.key] = a4.tileID), i4[r6] = o5;
              }
              const r5 = s4[s4.length - 1].overscaledZ;
              for (const e4 in this._tiles) {
                const t5 = this._tiles[e4];
                if (n3[e4] || !t5.hasData())
                  continue;
                let o5 = t5.tileID;
                for (; o5.overscaledZ > r5; ) {
                  o5 = o5.scaledTo(o5.overscaledZ - 1);
                  const r6 = this._tiles[o5.key];
                  if (r6 && r6.hasData() && i4[o5.key]) {
                    n3[e4] = t5.tileID;
                    break;
                  }
                }
              }
              for (const e4 in t4)
                n3[e4] || (this._coveredTiles[e4] = true, n3[e4] = t4[e4]);
            }
            for (const e4 in n3)
              this._tiles[e4].clearFadeHold();
            const a3 = e3.b3(this._tiles, n3);
            for (const e4 of a3) {
              const t4 = this._tiles[e4];
              t4.hasSymbolBuckets && !t4.holdingForFade() ? t4.setHoldDuration(this.map._fadeDuration) : t4.hasSymbolBuckets && !t4.symbolFadeFinished() || this._removeTile(+e4);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const e4 in this._tiles)
              this._tiles[e4].holdingForFade() && this._removeTile(+e4);
          }
          _updateRetainedTiles(e4) {
            const t3 = {};
            if (0 === e4.length)
              return t3;
            const i3 = {}, o3 = e4.reduce((e5, t4) => Math.min(e5, t4.overscaledZ), 1 / 0), r4 = e4[0].overscaledZ, s4 = Math.max(r4 - Qt.maxOverzooming, this._source.minzoom), n3 = Math.max(r4 + Qt.maxUnderzooming, this._source.minzoom), a3 = {};
            for (const i4 of e4) {
              const e5 = this._addTile(i4);
              t3[i4.key] = i4, e5.hasData() || o3 < this._source.maxzoom && (a3[i4.key] = i4);
            }
            this._retainLoadedChildren(a3, o3, n3, t3);
            for (const o4 of e4) {
              let e5 = this._tiles[o4.key];
              if (e5.hasData())
                continue;
              if (o4.canonical.z >= this._source.maxzoom) {
                const e6 = o4.children(this._source.maxzoom)[0], i4 = this.getTile(e6);
                if (i4 && i4.hasData()) {
                  t3[e6.key] = e6;
                  continue;
                }
              } else {
                const e6 = o4.children(this._source.maxzoom);
                if (t3[e6[0].key] && t3[e6[1].key] && t3[e6[2].key] && t3[e6[3].key])
                  continue;
              }
              let r5 = e5.wasRequested();
              for (let n4 = o4.overscaledZ - 1; n4 >= s4; --n4) {
                const s5 = o4.scaledTo(n4);
                if (i3[s5.key])
                  break;
                if (i3[s5.key] = true, e5 = this.getTile(s5), !e5 && r5 && (e5 = this._addTile(s5)), e5 && (t3[s5.key] = s5, r5 = e5.wasRequested(), e5.hasData()))
                  break;
              }
            }
            return t3;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e4 in this._tiles) {
              const t3 = [];
              let i3, o3 = this._tiles[e4].tileID;
              for (; o3.overscaledZ > 0; ) {
                if (o3.key in this._loadedParentTiles) {
                  i3 = this._loadedParentTiles[o3.key];
                  break;
                }
                t3.push(o3.key);
                const e5 = o3.scaledTo(o3.overscaledZ - 1);
                if (i3 = this._getLoadedTile(e5), i3)
                  break;
                o3 = e5;
              }
              for (const e5 of t3)
                this._loadedParentTiles[e5] = i3;
            }
          }
          _addTile(t3) {
            let i3 = this._tiles[t3.key];
            if (i3)
              return true !== i3.isExtraShadowCaster || !!this._shadowCasterTiles[t3.key] || this._reloadTile(t3.key, "reloading"), i3;
            i3 = this._cache.getAndRemove(t3), i3 && (this._setTileReloadTimer(t3.key, i3), i3.tileID = t3, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[t3.key] && (clearTimeout(this._cacheTimers[t3.key]), delete this._cacheTimers[t3.key], this._setTileReloadTimer(t3.key, i3)));
            const o3 = Boolean(i3);
            if (!o3) {
              const e4 = this.map ? this.map.painter : null, o4 = this._source.tileSize * t3.overscaleFactor();
              i3 = "raster-array" === this._source.type ? new Ht(t3, o4, this.transform.tileZoom, e4, this._isRaster) : new Nt(t3, o4, this.transform.tileZoom, e4, this._isRaster), this._loadTile(i3, this._tileLoaded.bind(this, i3, t3.key, i3.state));
            }
            return i3 ? (i3.uses++, this._tiles[t3.key] = i3, o3 || this._source.fire(new e3.b("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3) : null;
          }
          _setTileReloadTimer(e4, t3) {
            e4 in this._timers && (clearTimeout(this._timers[e4]), delete this._timers[e4]);
            const i3 = t3.getExpiryTimeout();
            i3 && (this._timers[e4] = setTimeout(() => {
              this._reloadTile(e4, "expired"), delete this._timers[e4];
            }, i3));
          }
          _removeTile(e4) {
            const t3 = this._tiles[e4];
            t3 && (t3.uses--, delete this._tiles[e4], this._timers[e4] && (clearTimeout(this._timers[e4]), delete this._timers[e4]), t3.uses > 0 || (t3.hasData() && "reloading" !== t3.state || "empty" === t3.state ? this._cache.add(t3.tileID, t3, t3.getExpiryTimeout()) : (t3.aborted = true, this._abortTile(t3), this._unloadTile(t3))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e4 in this._tiles)
              this._removeTile(+e4);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t3, i3, o3) {
            const r4 = [], s4 = this.transform;
            if (!s4)
              return r4;
            const n3 = "globe" === s4.projection.name, a3 = e3.a8(s4.center.lng);
            for (const l3 in this._tiles) {
              const c3 = this._tiles[l3];
              if (o3 && c3.clearQueryDebugViz(), c3.holdingForFade())
                continue;
              let h2;
              if (n3) {
                const t4 = c3.tileID.canonical;
                if (0 === t4.z) {
                  const i4 = [Math.abs(e3.ad(a3, ...Yt(t4, -1)) - a3), Math.abs(e3.ad(a3, ...Yt(t4, 1)) - a3)];
                  h2 = [0, 2 * i4.indexOf(Math.min(...i4)) - 1];
                } else {
                  const i4 = [Math.abs(e3.ad(a3, ...Yt(t4, -1)) - a3), Math.abs(e3.ad(a3, ...Yt(t4, 0)) - a3), Math.abs(e3.ad(a3, ...Yt(t4, 1)) - a3)];
                  h2 = [i4.indexOf(Math.min(...i4)) - 1];
                }
              } else
                h2 = [0];
              for (const e4 of h2) {
                const o4 = t3.containsTile(c3, s4, i3, e4);
                o4 && r4.push(o4);
              }
            }
            return r4;
          }
          getShadowCasterCoordinates() {
            return this._getRenderableCoordinates(false, true);
          }
          getVisibleCoordinates(e4) {
            return this._getRenderableCoordinates(e4);
          }
          _getRenderableCoordinates(e4, t3) {
            const i3 = this.getRenderableIds(e4, t3).map((e5) => this._tiles[e5].tileID), o3 = "globe" === this.transform.projection.name;
            for (const e5 of i3)
              e5.projMatrix = this.transform.calculateProjMatrix(e5.toUnwrapped()), e5.expandedProjMatrix = o3 ? this.transform.calculateProjMatrix(e5.toUnwrapped(), false, true) : e5.projMatrix;
            return i3;
          }
          sortCoordinatesByDistance(e4) {
            const t3 = e4.slice(), i3 = this.transform._camera.position, o3 = this.transform._camera.forward(), r4 = {};
            for (const e5 of t3) {
              const t4 = 1 / (1 << e5.canonical.z);
              r4[e5.key] = ((e5.canonical.x + 0.5) * t4 + e5.wrap - i3[0]) * o3[0] + ((e5.canonical.y + 0.5) * t4 - i3[1]) * o3[1] - i3[2] * o3[2];
            }
            return t3.sort((e5, t4) => r4[e5.key] - r4[t4.key]), t3;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (Xt(this._source.type))
              for (const t3 in this._tiles) {
                const i3 = this._tiles[t3];
                if (void 0 !== i3.fadeEndTime && i3.fadeEndTime >= e3.f.now())
                  return true;
              }
            return false;
          }
          setFeatureState(e4, t3, i3) {
            this._state.updateState(e4 = e4 || "_geojsonTileLayer", t3, i3);
          }
          removeFeatureState(e4, t3, i3) {
            this._state.removeFeatureState(e4 = e4 || "_geojsonTileLayer", t3, i3);
          }
          getFeatureState(e4, t3) {
            return this._state.getState(e4 = e4 || "_geojsonTileLayer", t3);
          }
          setDependencies(e4, t3, i3) {
            const o3 = this._tiles[e4];
            o3 && o3.setDependencies(t3, i3);
          }
          reloadTilesForDependencies(e4, t3) {
            for (const i3 in this._tiles)
              this._tiles[i3].hasDependency(e4, t3) && this._reloadTile(+i3, "reloading");
            this._cache.filter((i3) => !i3.hasDependency(e4, t3));
          }
          _preloadTiles(t3, i3) {
            if (!this._sourceLoaded) {
              const e4 = () => {
                this._sourceLoaded && (this._source.off("data", e4), this._preloadTiles(t3, i3));
              };
              return void this._source.on("data", e4);
            }
            const o3 = /* @__PURE__ */ new Map(), r4 = Array.isArray(t3) ? t3 : [t3], s4 = this.map.painter.terrain, n3 = this.usedForTerrain && s4 ? s4.getScaledDemTileSize() : this._source.tileSize;
            for (const e4 of r4) {
              const t4 = e4.coveringTiles({ tileSize: n3, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const e5 of t4)
                o3.set(e5.key, e5);
              this.usedForTerrain && e4.updateElevation(false);
            }
            const a3 = Array.from(o3.values());
            e3.b4(a3, (e4, t4) => {
              const i4 = new Nt(e4, this._source.tileSize * e4.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(i4, (e5) => {
                "raster-dem" === this._source.type && i4.dem && this._backfillDEM(i4), t4(e5, i4);
              });
            }, i3);
          }
        }
        function $t(e4, t3) {
          const i3 = Math.abs(2 * e4.wrap) - +(e4.wrap < 0), o3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0);
          return e4.overscaledZ - t3.overscaledZ || o3 - i3 || t3.canonical.y - e4.canonical.y || t3.canonical.x - e4.canonical.x;
        }
        function Xt(e4) {
          return "raster" === e4 || "image" === e4 || "video" === e4 || "custom" === e4;
        }
        function Yt(e4, t3) {
          const i3 = 1 << e4.z;
          return [e4.x / i3 + t3, (e4.x + 1) / i3 + t3];
        }
        Qt.maxOverzooming = 10, Qt.maxUnderzooming = 3;
        class Jt {
          constructor(e4) {
            this.style = e4, this.layersGotHidden = false, this.layers = [];
          }
          processLayersChanged() {
            this.layers = [];
            const e4 = false, t3 = false;
            for (const i3 in this.style._mergedLayers) {
              const o3 = this.style._mergedLayers[i3];
              if ("fill-extrusion" === o3.type)
                this.layers.push({ layer: o3, visible: e4, visibilityChanged: t3 });
              else if ("model" === o3.type) {
                const i4 = this.style.getLayerSource(o3);
                i4 && "batched-model" === i4.type && this.layers.push({ layer: o3, visible: e4, visibilityChanged: t3 });
              }
            }
          }
          onNewFrame(e4) {
            this.layersGotHidden = false;
            for (const t3 of this.layers) {
              const i3 = t3.layer;
              let o3 = false;
              "fill-extrusion" === i3.type ? o3 = !i3.isHidden(e4) && i3.paint.get("fill-extrusion-opacity") > 0 : "model" === i3.type && (o3 = !i3.isHidden(e4) && i3.paint.get("model-opacity") > 0), this.layersGotHidden = this.layersGotHidden || !o3 && t3.visible, t3.visible = o3;
            }
          }
          updateZOffset(e4, t3) {
            this.currentBuildingBuckets = [];
            for (const e5 of this.layers) {
              const i4 = e5.layer, o3 = this.style.getLayerSourceCache(i4);
              let r4 = 1;
              "fill-extrusion" === i4.type && (r4 = e5.visible ? i4.paint.get("fill-extrusion-vertical-scale") : 0);
              let s4 = o3 ? o3.getTile(t3) : null;
              if (!s4 && o3 && t3.canonical.z > o3.getSource().minzoom) {
                let e6 = t3.scaledTo(Math.min(o3.getSource().maxzoom, t3.overscaledZ - 1));
                for (; e6.overscaledZ >= o3.getSource().minzoom && (s4 = o3.getTile(e6), !s4 && 0 !== e6.overscaledZ); )
                  e6 = e6.scaledTo(e6.overscaledZ - 1);
              }
              this.currentBuildingBuckets.push({ bucket: s4 ? s4.getBucket(i4) : null, tileID: s4 ? s4.tileID : t3, verticalScale: r4 });
            }
            e4.hasAnyZOffset = false;
            let i3 = false;
            for (let o3 = 0; o3 < e4.symbolInstances.length; o3++) {
              const r4 = e4.symbolInstances.get(o3), s4 = r4.zOffset, n3 = this._getHeightAtTileOffset(t3, r4.tileAnchorX, r4.tileAnchorY);
              r4.zOffset = n3 !== Number.NEGATIVE_INFINITY ? n3 : s4, i3 || s4 === r4.zOffset || (i3 = true), e4.hasAnyZOffset || 0 === r4.zOffset || (e4.hasAnyZOffset = true);
            }
            i3 && (e4.zOffsetBuffersNeedUpload = true, e4.zOffsetSortDirty = true);
          }
          _mapCoordToOverlappingTile(t3, i3, o3, r4) {
            let s4 = i3, n3 = o3;
            if (t3.canonical.z !== r4.canonical.z) {
              const a3 = r4.canonical, l3 = 1 / (1 << t3.canonical.z - a3.z);
              s4 = (i3 + t3.canonical.x * e3.Y) * l3 - a3.x * e3.Y | 0, n3 = (o3 + t3.canonical.y * e3.Y) * l3 - a3.y * e3.Y | 0;
            }
            return { tileX: s4, tileY: n3 };
          }
          _getHeightAtTileOffset(e4, t3, i3) {
            let o3, r4;
            for (let s4 = 0; s4 < this.layers.length; ++s4) {
              if ("fill-extrusion" !== this.layers[s4].layer.type)
                continue;
              const { bucket: n3, tileID: a3, verticalScale: l3 } = this.currentBuildingBuckets[s4];
              if (!n3)
                continue;
              const { tileX: c3, tileY: h2 } = this._mapCoordToOverlappingTile(e4, t3, i3, a3), u3 = n3.getHeightAtTileCoord(c3, h2);
              u3 && void 0 !== u3.height && (u3.hidden ? o3 = u3.height : r4 = Math.max(u3.height * l3, r4 || 0));
            }
            if (void 0 !== r4)
              return r4;
            for (let r5 = 0; r5 < this.layers.length; ++r5) {
              const s4 = this.layers[r5];
              if ("model" !== s4.layer.type || !s4.visible)
                continue;
              const { bucket: n3, tileID: a3 } = this.currentBuildingBuckets[r5];
              if (!n3)
                continue;
              const { tileX: l3, tileY: c3 } = this._mapCoordToOverlappingTile(e4, t3, i3, a3), h2 = n3.getHeightAtTileCoord(l3, c3);
              if (h2 && !h2.hidden)
                return void 0 === h2.height && void 0 !== o3 ? Math.min(h2.maxHeight, o3) * h2.verticalScale : h2.height ? h2.height * h2.verticalScale : Number.NEGATIVE_INFINITY;
            }
            return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
          }
        }
        function Kt(t3, i3) {
          const o3 = {};
          for (const e4 in t3)
            "ref" !== e4 && (o3[e4] = t3[e4]);
          return e3.b5.forEach((e4) => {
            e4 in i3 && (o3[e4] = i3[e4]);
          }), o3;
        }
        function ei(e4) {
          e4 = e4.slice();
          const t3 = /* @__PURE__ */ Object.create(null);
          for (let i3 = 0; i3 < e4.length; i3++)
            t3[e4[i3].id] = e4[i3];
          for (let i3 = 0; i3 < e4.length; i3++)
            "ref" in e4[i3] && (e4[i3] = Kt(e4[i3], t3[e4[i3].ref]));
          return e4;
        }
        const ti = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
        function ii(e4, t3, i3) {
          i3.push({ command: ti.addSource, args: [e4, t3[e4]] });
        }
        function oi(e4, t3, i3) {
          t3.push({ command: ti.removeSource, args: [e4] }), i3[e4] = true;
        }
        function ri(e4, t3, i3, o3) {
          oi(e4, i3, o3), ii(e4, t3, i3);
        }
        function si(e4, i3, o3) {
          let r4;
          for (r4 in e4[o3])
            if (e4[o3].hasOwnProperty(r4) && "data" !== r4 && !t2(e4[o3][r4], i3[o3][r4]))
              return false;
          for (r4 in i3[o3])
            if (i3[o3].hasOwnProperty(r4) && "data" !== r4 && !t2(e4[o3][r4], i3[o3][r4]))
              return false;
          return true;
        }
        function ni(e4, i3, o3, r4, s4, n3) {
          let a3;
          for (a3 in i3 = i3 || {}, e4 = e4 || {})
            e4.hasOwnProperty(a3) && (t2(e4[a3], i3[a3]) || o3.push({ command: n3, args: [r4, a3, i3[a3], s4] }));
          for (a3 in i3)
            i3.hasOwnProperty(a3) && !e4.hasOwnProperty(a3) && (t2(e4[a3], i3[a3]) || o3.push({ command: n3, args: [r4, a3, i3[a3], s4] }));
        }
        function ai(e4) {
          return e4.id;
        }
        function li(e4, t3) {
          return e4[t3.id] = t3, e4;
        }
        class ci {
          constructor(e4, t3) {
            this.reset(e4, t3);
          }
          reset(e4, t3) {
            this.points = e4 || [], this._distances = [0];
            for (let e5 = 1; e5 < this.points.length; e5++)
              this._distances[e5] = this._distances[e5 - 1] + this.points[e5].dist(this.points[e5 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t3) {
            if (1 === this.points.length)
              return this.points[0];
            t3 = e3.ad(t3, 0, 1);
            let i3 = 1, o3 = this._distances[i3];
            const r4 = t3 * this.paddedLength + this.padding;
            for (; o3 < r4 && i3 < this._distances.length; )
              o3 = this._distances[++i3];
            const s4 = i3 - 1, n3 = this._distances[s4], a3 = o3 - n3, l3 = a3 > 0 ? (r4 - n3) / a3 : 0;
            return this.points[s4].mult(1 - l3).add(this.points[i3].mult(l3));
          }
        }
        class hi {
          constructor(e4, t3, i3) {
            const o3 = this.boxCells = [], r4 = this.circleCells = [];
            this.xCellCount = Math.ceil(e4 / i3), this.yCellCount = Math.ceil(t3 / i3);
            for (let e5 = 0; e5 < this.xCellCount * this.yCellCount; e5++)
              o3.push([]), r4.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e4, this.height = t3, this.xScale = this.xCellCount / e4, this.yScale = this.yCellCount / t3, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e4, t3, i3, o3, r4) {
            this._forEachCell(t3, i3, o3, r4, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e4), this.bboxes.push(t3), this.bboxes.push(i3), this.bboxes.push(o3), this.bboxes.push(r4);
          }
          insertCircle(e4, t3, i3, o3) {
            this._forEachCell(t3 - o3, i3 - o3, t3 + o3, i3 + o3, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e4), this.circles.push(t3), this.circles.push(i3), this.circles.push(o3);
          }
          _insertBoxCell(e4, t3, i3, o3, r4, s4) {
            this.boxCells[r4].push(s4);
          }
          _insertCircleCell(e4, t3, i3, o3, r4, s4) {
            this.circleCells[r4].push(s4);
          }
          _query(e4, t3, i3, o3, r4, s4) {
            if (i3 < 0 || e4 > this.width || o3 < 0 || t3 > this.height)
              return !r4 && [];
            const n3 = [];
            if (e4 <= 0 && t3 <= 0 && this.width <= i3 && this.height <= o3) {
              if (r4)
                return true;
              for (let e5 = 0; e5 < this.boxKeys.length; e5++)
                n3.push({ key: this.boxKeys[e5], x1: this.bboxes[4 * e5], y1: this.bboxes[4 * e5 + 1], x2: this.bboxes[4 * e5 + 2], y2: this.bboxes[4 * e5 + 3] });
              for (let e5 = 0; e5 < this.circleKeys.length; e5++) {
                const t4 = this.circles[3 * e5], i4 = this.circles[3 * e5 + 1], o4 = this.circles[3 * e5 + 2];
                n3.push({ key: this.circleKeys[e5], x1: t4 - o4, y1: i4 - o4, x2: t4 + o4, y2: i4 + o4 });
              }
              return s4 ? n3.filter(s4) : n3;
            }
            return this._forEachCell(e4, t3, i3, o3, this._queryCell, n3, { hitTest: r4, seenUids: { box: {}, circle: {} } }, s4), r4 ? n3.length > 0 : n3;
          }
          _queryCircle(e4, t3, i3, o3, r4) {
            const s4 = e4 - i3, n3 = e4 + i3, a3 = t3 - i3, l3 = t3 + i3;
            if (n3 < 0 || s4 > this.width || l3 < 0 || a3 > this.height)
              return !o3 && [];
            const c3 = [];
            return this._forEachCell(s4, a3, n3, l3, this._queryCellCircle, c3, { hitTest: o3, circle: { x: e4, y: t3, radius: i3 }, seenUids: { box: {}, circle: {} } }, r4), o3 ? c3.length > 0 : c3;
          }
          query(e4, t3, i3, o3, r4) {
            return this._query(e4, t3, i3, o3, false, r4);
          }
          hitTest(e4, t3, i3, o3, r4) {
            return this._query(e4, t3, i3, o3, true, r4);
          }
          hitTestCircle(e4, t3, i3, o3) {
            return this._queryCircle(e4, t3, i3, true, o3);
          }
          _queryCell(e4, t3, i3, o3, r4, s4, n3, a3) {
            const l3 = n3.seenUids, c3 = this.boxCells[r4];
            if (null !== c3) {
              const r5 = this.bboxes;
              for (const h3 of c3)
                if (!l3.box[h3]) {
                  l3.box[h3] = true;
                  const c4 = 4 * h3;
                  if (e4 <= r5[c4 + 2] && t3 <= r5[c4 + 3] && i3 >= r5[c4 + 0] && o3 >= r5[c4 + 1] && (!a3 || a3(this.boxKeys[h3]))) {
                    if (n3.hitTest)
                      return s4.push(true), true;
                    s4.push({ key: this.boxKeys[h3], x1: r5[c4], y1: r5[c4 + 1], x2: r5[c4 + 2], y2: r5[c4 + 3] });
                  }
                }
            }
            const h2 = this.circleCells[r4];
            if (null !== h2) {
              const r5 = this.circles;
              for (const c4 of h2)
                if (!l3.circle[c4]) {
                  l3.circle[c4] = true;
                  const h3 = 3 * c4;
                  if (this._circleAndRectCollide(r5[h3], r5[h3 + 1], r5[h3 + 2], e4, t3, i3, o3) && (!a3 || a3(this.circleKeys[c4]))) {
                    if (n3.hitTest)
                      return s4.push(true), true;
                    {
                      const e5 = r5[h3], t4 = r5[h3 + 1], i4 = r5[h3 + 2];
                      s4.push({ key: this.circleKeys[c4], x1: e5 - i4, y1: t4 - i4, x2: e5 + i4, y2: t4 + i4 });
                    }
                  }
                }
            }
          }
          _queryCellCircle(e4, t3, i3, o3, r4, s4, n3, a3) {
            const l3 = n3.circle, c3 = n3.seenUids, h2 = this.boxCells[r4];
            if (null !== h2) {
              const e5 = this.bboxes;
              for (const t4 of h2)
                if (!c3.box[t4]) {
                  c3.box[t4] = true;
                  const i4 = 4 * t4;
                  if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, e5[i4 + 0], e5[i4 + 1], e5[i4 + 2], e5[i4 + 3]) && (!a3 || a3(this.boxKeys[t4])))
                    return s4.push(true), true;
                }
            }
            const u3 = this.circleCells[r4];
            if (null !== u3) {
              const e5 = this.circles;
              for (const t4 of u3)
                if (!c3.circle[t4]) {
                  c3.circle[t4] = true;
                  const i4 = 3 * t4;
                  if (this._circlesCollide(e5[i4], e5[i4 + 1], e5[i4 + 2], l3.x, l3.y, l3.radius) && (!a3 || a3(this.circleKeys[t4])))
                    return s4.push(true), true;
                }
            }
          }
          _forEachCell(e4, t3, i3, o3, r4, s4, n3, a3) {
            const l3 = this._convertToXCellCoord(e4), c3 = this._convertToYCellCoord(t3), h2 = this._convertToXCellCoord(i3), u3 = this._convertToYCellCoord(o3);
            for (let d2 = l3; d2 <= h2; d2++)
              for (let l4 = c3; l4 <= u3; l4++)
                if (r4.call(this, e4, t3, i3, o3, this.xCellCount * l4 + d2, s4, n3, a3))
                  return;
          }
          _convertToXCellCoord(e4) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e4 * this.xScale)));
          }
          _convertToYCellCoord(e4) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e4 * this.yScale)));
          }
          _circlesCollide(e4, t3, i3, o3, r4, s4) {
            const n3 = o3 - e4, a3 = r4 - t3, l3 = i3 + s4;
            return l3 * l3 > n3 * n3 + a3 * a3;
          }
          _circleAndRectCollide(e4, t3, i3, o3, r4, s4, n3) {
            const a3 = (s4 - o3) / 2, l3 = Math.abs(e4 - (o3 + a3));
            if (l3 > a3 + i3)
              return false;
            const c3 = (n3 - r4) / 2, h2 = Math.abs(t3 - (r4 + c3));
            if (h2 > c3 + i3)
              return false;
            if (l3 <= a3 || h2 <= c3)
              return true;
            const u3 = l3 - a3, d2 = h2 - c3;
            return u3 * u3 + d2 * d2 <= i3 * i3;
          }
        }
        const ui = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, di = Math.tan(85 * Math.PI / 180);
        function _i(t3, i3, o3, r4, s4, n3, a3) {
          const l3 = e3.a9.create();
          if (o3)
            if ("globe" === n3.name) {
              const t4 = e3.b6(s4, i3);
              e3.a9.multiply(l3, l3, t4);
            } else {
              const t4 = e3.b7.invert([], a3);
              l3[0] = t4[0], l3[1] = t4[1], l3[4] = t4[2], l3[5] = t4[3], r4 || e3.a9.rotateZ(l3, l3, s4.angle);
            }
          else
            e3.a9.multiply(l3, s4.labelPlaneMatrix, t3);
          return l3;
        }
        function pi(e4, t3, i3, o3, r4, s4, n3) {
          const a3 = _i(e4, t3, i3, o3, r4, s4, n3);
          return "globe" === s4.name && i3 || (a3[2] = a3[6] = a3[10] = a3[14] = 0), a3;
        }
        function fi(t3, i3, o3, r4, s4, n3, a3) {
          if (o3) {
            if ("globe" === n3.name) {
              const l3 = _i(t3, i3, o3, r4, s4, n3, a3);
              return e3.a9.invert(l3, l3), e3.a9.multiply(l3, t3, l3), l3;
            }
            {
              const i4 = e3.a9.clone(t3), o4 = e3.a9.identity([]);
              return o4[0] = a3[0], o4[1] = a3[1], o4[4] = a3[2], o4[5] = a3[3], e3.a9.multiply(i4, i4, o4), r4 || e3.a9.rotateZ(i4, i4, -s4.angle), i4;
            }
          }
          return s4.glCoordMatrix;
        }
        function mi(t3, i3, o3, r4) {
          const s4 = [t3, i3, o3, 1];
          o3 ? e3.aa.transformMat4(s4, s4, r4) : Ii(s4, s4, r4);
          const n3 = s4[3];
          return s4[0] /= n3, s4[1] /= n3, s4[2] /= n3, s4;
        }
        function gi(e4, t3) {
          return Math.min(0.5 + e4 / t3 * 0.5, 1.5);
        }
        function vi(e4, t3) {
          const i3 = e4[0] / e4[3], o3 = e4[1] / e4[3];
          return i3 >= -t3[0] && i3 <= t3[0] && o3 >= -t3[1] && o3 <= t3[1];
        }
        function xi(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2) {
          const u3 = o3.transform, d2 = r4 ? t3.textSizeData : t3.iconSizeData, _3 = e3.b8(d2, o3.transform.zoom), p3 = "globe" === u3.projection.name, f2 = [256 / o3.width * 2 + 1, 256 / o3.height * 2 + 1], m2 = r4 ? t3.text.dynamicLayoutVertexArray : t3.icon.dynamicLayoutVertexArray;
          m2.clear();
          let g3 = null;
          p3 && (g3 = r4 ? t3.text.globeExtVertexArray : t3.icon.globeExtVertexArray);
          const v3 = t3.lineVertexArray, x3 = r4 ? t3.text.placedSymbolArray : t3.icon.placedSymbolArray, y3 = o3.transform.width / o3.transform.height;
          let b2, w2 = false;
          for (let r5 = 0; r5 < x3.length; r5++) {
            const p4 = x3.get(r5), { numGlyphs: T2, writingMode: E2 } = p4;
            if (E2 !== e3.b9.vertical || w2 || b2 === e3.b9.horizontal || (w2 = true), b2 = E2, (p4.hidden || E2 === e3.b9.vertical) && !w2) {
              Ci(T2, m2);
              continue;
            }
            w2 = false;
            const S2 = new e3.P(p4.tileAnchorX, p4.tileAnchorY);
            let { x: C2, y: I2, z: D2 } = u3.projection.projectTilePoint(S2.x, S2.y, h2.canonical);
            if (c3) {
              const [e4, t4, i4] = c3(S2);
              C2 += e4, I2 += t4, D2 += i4;
            }
            const R3 = [C2, I2, D2, 1];
            if (e3.aa.transformMat4(R3, R3, i3), !vi(R3, f2)) {
              Ci(T2, m2);
              continue;
            }
            const A2 = R3[3], P2 = gi(o3.transform.getCameraToCenterDistance(u3.projection), A2), L2 = e3.ba(d2, _3, p4), M3 = a3 ? L2 / P2 : L2 * P2, z3 = mi(C2, I2, D2, s4);
            if (z3[3] <= 0) {
              Ci(T2, m2);
              continue;
            }
            let O2 = {};
            const F2 = a3 ? null : c3, B2 = wi(p4, M3, false, l3, i3, s4, n3, t3.glyphOffsetArray, v3, m2, g3, z3, S2, O2, y3, F2, u3.projection, h2, a3);
            w2 = B2.useVertical, F2 && B2.needsFlipping && (O2 = {}), (B2.notEnoughRoom || w2 || B2.needsFlipping && wi(p4, M3, true, l3, i3, s4, n3, t3.glyphOffsetArray, v3, m2, g3, z3, S2, O2, y3, F2, u3.projection, h2, a3).notEnoughRoom) && Ci(T2, m2);
          }
          r4 ? (t3.text.dynamicLayoutVertexBuffer.updateData(m2), g3 && t3.text.globeExtVertexBuffer && t3.text.globeExtVertexBuffer.updateData(g3)) : (t3.icon.dynamicLayoutVertexBuffer.updateData(m2), g3 && t3.icon.globeExtVertexBuffer && t3.icon.globeExtVertexBuffer.updateData(g3));
        }
        function yi(e4, t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2) {
          const { lineStartIndex: m2, glyphStartIndex: g3, segment: v3 } = a3, x3 = g3 + a3.numGlyphs, y3 = m2 + a3.lineLength, b2 = t3.getoffsetX(g3), w2 = t3.getoffsetX(x3 - 1), T2 = Si(e4 * b2, i3, o3, r4, s4, n3, v3, m2, y3, l3, c3, h2, u3, d2, true, _3, p3, f2);
          if (!T2)
            return null;
          const E2 = Si(e4 * w2, i3, o3, r4, s4, n3, v3, m2, y3, l3, c3, h2, u3, d2, true, _3, p3, f2);
          return E2 ? { first: T2, last: E2 } : null;
        }
        function bi(t3, i3, o3, r4) {
          return t3 === e3.b9.horizontal && Math.abs(r4) > Math.abs(o3) ? { useVertical: true } : t3 === e3.b9.vertical ? r4 > 0 ? { needsFlipping: true } : null : i3 !== ui.unknown && function(e4, t4) {
            return 0 === e4 || Math.abs(t4 / e4) > di;
          }(o3, r4) ? i3 === ui.flipRequired ? { needsFlipping: true } : null : o3 < 0 ? { needsFlipping: true } : null;
        }
        function wi(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2, g3, v3, x3) {
          const y3 = i3 / 24, b2 = t3.lineOffsetX * y3, w2 = t3.lineOffsetY * y3, { lineStartIndex: T2, glyphStartIndex: E2, numGlyphs: S2, segment: C2, writingMode: I2, flipState: D2 } = t3, R3 = T2 + t3.lineLength, A2 = (t4) => {
            if (u3) {
              const [i5, o5, r6] = t4.up, s5 = h2.length;
              e3.bb(u3, s5 + 0, i5, o5, r6), e3.bb(u3, s5 + 1, i5, o5, r6), e3.bb(u3, s5 + 2, i5, o5, r6), e3.bb(u3, s5 + 3, i5, o5, r6);
            }
            const [i4, o4, r5] = t4.point;
            e3.bc(h2, i4, o4, r5, t4.angle);
          };
          if (S2 > 1) {
            const e4 = yi(y3, l3, b2, w2, o3, d2, _3, t3, c3, n3, p3, m2, false, g3, v3, x3);
            if (!e4)
              return { notEnoughRoom: true };
            if (r4 && !o3) {
              let [i4, o4, r5] = e4.first.point, [s5, n4, l4] = e4.last.point;
              [i4, o4] = mi(i4, o4, r5, a3), [s5, n4] = mi(s5, n4, l4, a3);
              const c4 = bi(I2, D2, (s5 - i4) * f2, n4 - o4);
              if (t3.flipState = c4 && c4.needsFlipping ? ui.flipRequired : ui.flipNotRequired, c4)
                return c4;
            }
            A2(e4.first);
            for (let e5 = E2 + 1; e5 < E2 + S2 - 1; e5++) {
              const t4 = Si(y3 * l3.getoffsetX(e5), b2, w2, o3, d2, _3, C2, T2, R3, c3, n3, p3, m2, false, false, g3, v3, x3);
              if (!t4)
                return h2.length -= 4 * (e5 - E2), { notEnoughRoom: true };
              A2(t4);
            }
            A2(e4.last);
          } else {
            if (r4 && !o3) {
              const i5 = mi(_3.x, _3.y, 0, s4), o4 = T2 + C2 + 1, r5 = new e3.P(c3.getx(o4), c3.gety(o4)), n4 = mi(r5.x, r5.y, 0, s4), a4 = n4[3] > 0 ? n4 : Ei(_3, r5, i5, 1, s4, void 0, g3, v3.canonical), l4 = bi(I2, D2, (a4[0] - i5[0]) * f2, a4[1] - i5[1]);
              if (t3.flipState = l4 && l4.needsFlipping ? ui.flipRequired : ui.flipNotRequired, l4)
                return l4;
            }
            const i4 = Si(y3 * l3.getoffsetX(E2), b2, w2, o3, d2, _3, C2, T2, R3, c3, n3, p3, m2, false, false, g3, v3, x3);
            if (!i4)
              return { notEnoughRoom: true };
            A2(i4);
          }
          return {};
        }
        function Ti(e4, t3, i3, o3, r4) {
          const { x: s4, y: n3, z: a3 } = o3.projectTilePoint(e4.x, e4.y, t3);
          if (!r4)
            return mi(s4, n3, a3, i3);
          const [l3, c3, h2] = r4(e4);
          return mi(s4 + l3, n3 + c3, a3 + h2, i3);
        }
        function Ei(t3, i3, o3, r4, s4, n3, a3, l3) {
          const c3 = Ti(t3.sub(i3)._unit()._add(t3), l3, s4, a3, n3);
          return e3.Q.sub(c3, o3, c3), e3.Q.normalize(c3, c3), e3.Q.scaleAndAdd(c3, o3, c3, r4);
        }
        function Si(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2, g3, v3) {
          const x3 = r4 ? t3 - i3 : t3 + i3;
          let y3 = x3 > 0 ? 1 : -1, b2 = 0;
          r4 && (y3 *= -1, b2 = Math.PI), y3 < 0 && (b2 += Math.PI);
          let w2 = l3 + a3 + (y3 > 0 ? 0 : 1) | 0, T2 = s4, E2 = s4, S2 = 0, C2 = 0;
          const I2 = Math.abs(x3), D2 = [], R3 = [];
          let A2 = n3, P2 = A2;
          const L2 = () => Ei(P2, A2, E2, I2 - S2 + 1, u3, _3, m2, g3.canonical);
          for (; S2 + C2 <= I2; ) {
            if (w2 += y3, w2 < l3 || w2 >= c3)
              return null;
            if (E2 = T2, P2 = A2, D2.push(E2), p3 && R3.push(P2), A2 = new e3.P(h2.getx(w2), h2.gety(w2)), T2 = d2[w2], !T2) {
              const e4 = Ti(A2, g3.canonical, u3, m2, _3);
              T2 = e4[3] > 0 ? d2[w2] = e4 : L2();
            }
            S2 += C2, C2 = e3.Q.distance(E2, T2);
          }
          f2 && _3 && (d2[w2] && (T2 = L2(), C2 = e3.Q.distance(E2, T2)), d2[w2] = T2);
          const M3 = (I2 - S2) / C2, z3 = A2.sub(P2)._mult(M3)._add(P2), O2 = e3.Q.sub([], T2, E2), F2 = e3.Q.scaleAndAdd([], E2, O2, M3);
          let B2 = [0, 0, 1], k2 = O2[0], N2 = O2[1];
          if (v3 && (B2 = m2.upVector(g3.canonical, z3.x, z3.y), 0 !== B2[0] || 0 !== B2[1] || 1 !== B2[2])) {
            const t4 = [B2[2], 0, -B2[0]], i4 = e3.Q.cross([], B2, t4);
            e3.Q.normalize(t4, t4), e3.Q.normalize(i4, i4), k2 = e3.Q.dot(O2, t4), N2 = e3.Q.dot(O2, i4);
          }
          if (o3) {
            const t4 = e3.Q.cross([], B2, O2);
            e3.Q.normalize(t4, t4), e3.Q.scaleAndAdd(F2, F2, t4, o3 * y3);
          }
          const U2 = b2 + Math.atan2(N2, k2);
          return D2.push(F2), p3 && R3.push(z3), { point: F2, angle: U2, path: D2, tilePath: R3, up: B2 };
        }
        function Ci(e4, t3) {
          const i3 = t3.length, o3 = i3 + 4 * e4;
          t3.resize(o3), t3.float32.fill(-1 / 0, 4 * i3, 4 * o3);
        }
        function Ii(e4, t3, i3) {
          const o3 = t3[0], r4 = t3[1];
          return e4[0] = i3[0] * o3 + i3[4] * r4 + i3[12], e4[1] = i3[1] * o3 + i3[5] * r4 + i3[13], e4[3] = i3[3] * o3 + i3[7] * r4 + i3[15], e4;
        }
        const Di = 100;
        class Ri {
          constructor(e4, t3, i3 = new hi(e4.width + 200, e4.height + 200, 25), o3 = new hi(e4.width + 200, e4.height + 200, 25)) {
            this.transform = e4, this.grid = i3, this.ignoredGrid = o3, this.pitchfactor = Math.cos(e4._pitch) * e4.cameraToCenterDistance, this.screenRightBoundary = e4.width + Di, this.screenBottomBoundary = e4.height + Di, this.gridRightBoundary = e4.width + 200, this.gridBottomBoundary = e4.height + 200, this.fogState = t3;
          }
          placeCollisionBox(e4, t3, i3, o3, r4, s4, n3, a3) {
            let l3 = i3.projectedAnchorX, c3 = i3.projectedAnchorY, h2 = i3.projectedAnchorZ;
            const u3 = i3.elevation, d2 = i3.tileID, _3 = e4.getProjection();
            if (u3 && d2) {
              const [e5, t4, o4] = _3.upVector(d2.canonical, i3.tileAnchorX, i3.tileAnchorY), r5 = _3.upVectorScale(d2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              l3 += e5 * u3 * r5, c3 += t4 * u3 * r5, h2 += o4 * u3 * r5;
            }
            const p3 = this.projectAndGetPerspectiveRatio(n3, l3, c3, h2, i3.tileID, "globe" === _3.name || !!u3 || this.transform.pitch > 0, _3), f2 = s4 * p3.perspectiveRatio, m2 = (i3.x1 * t3 + o3.x - i3.padding) * f2 + p3.point.x, g3 = (i3.y1 * t3 + o3.y - i3.padding) * f2 + p3.point.y, v3 = (i3.x2 * t3 + o3.x + i3.padding) * f2 + p3.point.x, x3 = (i3.y2 * t3 + o3.y + i3.padding) * f2 + p3.point.y, y3 = p3.perspectiveRatio <= 0.55 || p3.occluded;
            return !this.isInsideGrid(m2, g3, v3, x3) || !r4 && this.grid.hitTest(m2, g3, v3, x3, a3) || y3 ? { box: [], offscreen: false, occluded: p3.occluded } : { box: [m2, g3, v3, x3], offscreen: this.isOffscreen(m2, g3, v3, x3), occluded: false };
          }
          placeCollisionCircles(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2) {
            const m2 = [], g3 = this.transform.elevation, v3 = t3.getProjection(), x3 = g3 ? g3.getAtTileOffsetFunc(f2, this.transform.center.lat, this.transform.worldSize, v3) : null, y3 = new e3.P(o3.tileAnchorX, o3.tileAnchorY);
            let { x: b2, y: w2, z: T2 } = v3.projectTilePoint(y3.x, y3.y, f2.canonical);
            if (x3) {
              const [e4, t4, i4] = x3(y3);
              b2 += e4, w2 += t4, T2 += i4;
            }
            const E2 = "globe" === v3.name, S2 = this.projectAndGetPerspectiveRatio(a3, b2, w2, T2, f2, E2 || !!g3 || this.transform.pitch > 0, v3), { perspectiveRatio: C2 } = S2, I2 = (u3 ? n3 / C2 : n3 * C2) / e3.bf, D2 = mi(b2, w2, T2, l3), R3 = S2.signedDistanceFromCamera > 0 ? yi(I2, s4, o3.lineOffsetX * I2, o3.lineOffsetY * I2, false, D2, y3, o3, r4, l3, {}, g3 && !u3 ? x3 : null, u3 && !!g3, v3, f2, u3) : null;
            let A2 = false, P2 = false, L2 = true;
            if (R3 && !S2.occluded) {
              const t4 = 0.5 * _3 * C2 + p3, o4 = new e3.P(-100, -100), r5 = new e3.P(this.screenRightBoundary, this.screenBottomBoundary), s5 = new ci(), { first: n4, last: a4 } = R3, l4 = n4.path.length;
              let u4 = [];
              for (let e4 = l4 - 1; e4 >= 1; e4--)
                u4.push(n4.path[e4]);
              for (let e4 = 1; e4 < a4.path.length; e4++)
                u4.push(a4.path[e4]);
              const f3 = 2.5 * t4;
              c3 && (u4 = u4.map(([e4, t5, i4], o5) => (x3 && !E2 && (i4 = x3(o5 < l4 - 1 ? n4.tilePath[l4 - 1 - o5] : a4.tilePath[o5 - l4 + 2])[2]), mi(e4, t5, i4, c3))), u4.some((e4) => e4[3] <= 0) && (u4 = []));
              let g4 = [];
              if (u4.length > 0) {
                let t5 = 1 / 0, i4 = -1 / 0, s6 = 1 / 0, n5 = -1 / 0;
                for (const e4 of u4)
                  t5 = Math.min(t5, e4[0]), s6 = Math.min(s6, e4[1]), i4 = Math.max(i4, e4[0]), n5 = Math.max(n5, e4[1]);
                i4 >= o4.x && t5 <= r5.x && n5 >= o4.y && s6 <= r5.y && (g4 = [u4.map((t6) => new e3.P(t6[0], t6[1]))], (t5 < o4.x || i4 > r5.x || s6 < o4.y || n5 > r5.y) && (g4 = e3.bd(g4, o4.x, o4.y, r5.x, r5.y)));
              }
              for (const e4 of g4) {
                s5.reset(e4, 0.25 * t4);
                let o5 = 0;
                o5 = s5.length <= 0.5 * t4 ? 1 : Math.ceil(s5.paddedLength / f3) + 1;
                for (let e5 = 0; e5 < o5; e5++) {
                  const r6 = e5 / Math.max(o5 - 1, 1), n5 = s5.lerp(r6), a5 = n5.x + Di, l5 = n5.y + Di;
                  m2.push(a5, l5, t4, 0);
                  const c4 = a5 - t4, u5 = l5 - t4, _4 = a5 + t4, p4 = l5 + t4;
                  if (L2 = L2 && this.isOffscreen(c4, u5, _4, p4), P2 = P2 || this.isInsideGrid(c4, u5, _4, p4), !i3 && this.grid.hitTestCircle(a5, l5, t4, d2) && (A2 = true, !h2))
                    return { circles: [], offscreen: false, collisionDetected: A2, occluded: false };
                }
              }
            }
            return { circles: !h2 && A2 || !P2 ? [] : m2, offscreen: L2, collisionDetected: A2, occluded: S2.occluded };
          }
          queryRenderedSymbols(t3) {
            if (0 === t3.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            const i3 = [];
            let o3 = 1 / 0, r4 = 1 / 0, s4 = -1 / 0, n3 = -1 / 0;
            for (const a4 of t3) {
              const t4 = new e3.P(a4.x + Di, a4.y + Di);
              o3 = Math.min(o3, t4.x), r4 = Math.min(r4, t4.y), s4 = Math.max(s4, t4.x), n3 = Math.max(n3, t4.y), i3.push(t4);
            }
            const a3 = this.grid.query(o3, r4, s4, n3).concat(this.ignoredGrid.query(o3, r4, s4, n3)), l3 = {}, c3 = {};
            for (const t4 of a3) {
              const o4 = t4.key;
              if (void 0 === l3[o4.bucketInstanceId] && (l3[o4.bucketInstanceId] = {}), l3[o4.bucketInstanceId][o4.featureIndex])
                continue;
              const r5 = [new e3.P(t4.x1, t4.y1), new e3.P(t4.x2, t4.y1), new e3.P(t4.x2, t4.y2), new e3.P(t4.x1, t4.y2)];
              e3.be(i3, r5) && (l3[o4.bucketInstanceId][o4.featureIndex] = true, void 0 === c3[o4.bucketInstanceId] && (c3[o4.bucketInstanceId] = []), c3[o4.bucketInstanceId].push(o4.featureIndex));
            }
            return c3;
          }
          insertCollisionBox(e4, t3, i3, o3, r4) {
            (t3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i3, featureIndex: o3, collisionGroupID: r4 }, e4[0], e4[1], e4[2], e4[3]);
          }
          insertCollisionCircles(e4, t3, i3, o3, r4) {
            const s4 = t3 ? this.ignoredGrid : this.grid, n3 = { bucketInstanceId: i3, featureIndex: o3, collisionGroupID: r4 };
            for (let t4 = 0; t4 < e4.length; t4 += 4)
              s4.insertCircle(n3, e4[t4], e4[t4 + 1], e4[t4 + 2]);
          }
          projectAndGetPerspectiveRatio(t3, i3, o3, r4, s4, n3, a3) {
            const l3 = [i3, o3, r4, 1];
            let c3 = false;
            if (r4 || this.transform.pitch > 0) {
              if (e3.aa.transformMat4(l3, l3, t3), this.fogState && s4 && "globe" !== a3.name) {
                const t4 = function(t5, i4, o4, r5, s5, n4) {
                  const a4 = n4.calculateFogTileMatrix(s5), l4 = [i4, o4, r5];
                  return e3.Q.transformMat4(l4, l4, a4), pe(t5, e3.Q.length(l4), n4.pitch, n4._fov);
                }(this.fogState, i3, o3, r4, s4.toUnwrapped(), this.transform);
                c3 = t4 > 0.9;
              }
            } else
              Ii(l3, l3, t3);
            const h2 = l3[3];
            return { point: new e3.P((l3[0] / h2 + 1) / 2 * this.transform.width + Di, (-l3[1] / h2 + 1) / 2 * this.transform.height + Di), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a3) / h2 * 0.5, 1.5), signedDistanceFromCamera: h2, occluded: n3 && l3[2] > h2 || c3 };
          }
          isOffscreen(e4, t3, i3, o3) {
            return i3 < Di || e4 >= this.screenRightBoundary || o3 < Di || t3 > this.screenBottomBoundary;
          }
          isInsideGrid(e4, t3, i3, o3) {
            return i3 >= 0 && e4 < this.gridRightBoundary && o3 >= 0 && t3 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t3 = e3.a9.identity([]);
            return e3.a9.translate(t3, t3, [-100, -100, 0]), t3;
          }
        }
        function Ai(t3, i3, o3) {
          const r4 = i3.createTileMatrix(t3, t3.worldSize, o3.toUnwrapped());
          return e3.a9.multiply(new Float32Array(16), t3.projMatrix, r4);
        }
        function Pi(e4, t3, i3) {
          if (t3.projection.name === i3.projection.name)
            return e4.projMatrix;
          const o3 = i3.clone();
          return o3.setProjection(t3.projection), Ai(o3, t3.getProjection(), e4);
        }
        function Li(e4, t3, i3) {
          return t3.name === i3.projection.name ? e4.projMatrix : Ai(i3, t3, e4);
        }
        class Mi {
          constructor(e4, t3, i3, o3) {
            this.opacity = e4 ? Math.max(0, Math.min(1, e4.opacity + (e4.placed ? t3 : -t3))) : o3 && i3 ? 1 : 0, this.placed = i3;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class zi {
          constructor(e4, t3, i3, o3, r4, s4 = false) {
            this.text = new Mi(e4 ? e4.text : null, t3, i3, r4), this.icon = new Mi(e4 ? e4.icon : null, t3, o3, r4), this.clipped = s4;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Oi {
          constructor(e4, t3, i3, o3 = false) {
            this.text = e4, this.icon = t3, this.skipFade = i3, this.clipped = o3;
          }
        }
        class Fi {
          constructor() {
            this.invProjMatrix = e3.a9.create(), this.viewportMatrix = e3.a9.create(), this.circles = [];
          }
        }
        class Bi {
          constructor(e4, t3, i3, o3, r4) {
            this.bucketInstanceId = e4, this.featureIndex = t3, this.sourceLayerIndex = i3, this.bucketIndex = o3, this.tileID = r4;
          }
        }
        class ki {
          constructor(e4) {
            this.crossSourceCollisions = e4, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e4) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[e4]) {
              const t3 = ++this.maxGroupID;
              this.collisionGroups[e4] = { ID: t3, predicate: (e5) => e5.collisionGroupID === t3 };
            }
            return this.collisionGroups[e4];
          }
        }
        function Ni(t3, i3, o3, r4, s4) {
          const { horizontalAlign: n3, verticalAlign: a3 } = e3.bi(t3), l3 = -(n3 - 0.5) * i3, c3 = -(a3 - 0.5) * o3, h2 = e3.bh(t3, r4);
          return new e3.P(l3 + h2[0] * s4, c3 + h2[1] * s4);
        }
        function Ui(t3, i3, o3, r4, s4) {
          const n3 = new e3.P(t3, i3);
          return o3 && n3._rotate(r4 ? s4 : -s4), n3;
        }
        class Gi {
          constructor(e4, t3, i3, o3, r4, s4) {
            this.transform = e4.clone(), this.projection = e4.projection.name, this.collisionIndex = new Ri(this.transform, r4), this.buildingIndex = s4, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t3, this.retainedQueryData = {}, this.collisionGroups = new ki(i3), this.collisionCircleArrays = {}, this.prevPlacement = o3, o3 && (o3.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t3, i3, o3, r4) {
            const s4 = o3.getBucket(i3), n3 = o3.latestFeatureIndex;
            if (!s4 || !n3 || i3.fqid !== s4.layerIds[0])
              return;
            const a3 = s4.layers[0].layout, l3 = o3.collisionBoxArray, c3 = Math.pow(2, this.transform.zoom - o3.tileID.overscaledZ), h2 = o3.tileSize / e3.Y, u3 = o3.tileID.toUnwrapped();
            this.transform.setProjection(s4.projection);
            const d2 = (_3 = o3.tileID, p3 = s4.getProjection(), f2 = this.transform, p3.name === this.projection ? f2.calculateProjMatrix(_3.toUnwrapped()) : Ai(f2, p3, _3));
            var _3, p3, f2;
            const m2 = "map" === a3.get("text-pitch-alignment"), g3 = "map" === a3.get("text-rotation-alignment");
            i3.compileFilter();
            const v3 = i3.dynamicFilter(), x3 = i3.dynamicFilterNeedsFeature(), y3 = this.transform.calculatePixelsToTileUnitsMatrix(o3), b2 = pi(d2, o3.tileID.canonical, m2, g3, this.transform, s4.getProjection(), y3);
            let w2 = null;
            if (m2) {
              const t4 = fi(d2, o3.tileID.canonical, m2, g3, this.transform, s4.getProjection(), y3);
              w2 = e3.a9.multiply([], this.transform.labelPlaneMatrix, t4);
            }
            let T2 = null;
            v3 && o3.latestFeatureIndex && (T2 = { unwrappedTileID: u3, dynamicFilter: v3, dynamicFilterNeedsFeature: x3, featureIndex: o3.latestFeatureIndex }), this.retainedQueryData[s4.bucketInstanceId] = new Bi(s4.bucketInstanceId, n3, s4.sourceLayerIndex, s4.index, o3.tileID);
            const E2 = { bucket: s4, layout: a3, posMatrix: d2, textLabelPlaneMatrix: b2, labelToScreenMatrix: w2, clippingData: T2, scale: c3, textPixelRatio: h2, holdingForFade: o3.holdingForFade(), collisionBoxArray: l3, partiallyEvaluatedTextSize: e3.b8(s4.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e3.b8(s4.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s4.sourceID) };
            if (r4)
              for (const e4 of s4.sortKeyRanges) {
                const { sortKey: i4, symbolInstanceStart: o4, symbolInstanceEnd: r5 } = e4;
                t3.push({ sortKey: i4, symbolInstanceStart: o4, symbolInstanceEnd: r5, parameters: E2 });
              }
            else
              t3.push({ symbolInstanceStart: 0, symbolInstanceEnd: s4.symbolInstances.length, parameters: E2 });
          }
          attemptAnchorPlacement(e4, t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2, g3) {
            const { textOffset0: v3, textOffset1: x3, crossTileID: y3 } = u3, b2 = [v3, x3], w2 = Ni(e4, i3, o3, b2, r4), T2 = this.collisionIndex.placeCollisionBox(_3, r4, t3, Ui(w2.x, w2.y, s4, n3, this.transform.angle), h2, a3, l3, c3.predicate);
            if (f2) {
              const e5 = _3.getSymbolInstanceIconSize(g3, this.transform.zoom, u3.placedIconSymbolIndex);
              if (0 === this.collisionIndex.placeCollisionBox(_3, e5, f2, Ui(w2.x, w2.y, s4, n3, this.transform.angle), h2, a3, l3, c3.predicate).box.length)
                return;
            }
            if (T2.box.length > 0) {
              let t4;
              return this.prevPlacement && this.prevPlacement.variableOffsets[y3] && this.prevPlacement.placements[y3] && this.prevPlacement.placements[y3].text && (t4 = this.prevPlacement.variableOffsets[y3].anchor), this.variableOffsets[y3] = { textOffset: b2, width: i3, height: o3, anchor: e4, textScale: r4, prevAnchor: t4 }, this.markUsedJustification(_3, e4, u3, p3), _3.allowVerticalPlacement && (this.markUsedOrientation(_3, p3, u3), this.placedOrientations[y3] = p3), { shift: w2, placedGlyphBoxes: T2 };
            }
          }
          placeLayerBucketPart(t3, i3, o3, r4) {
            const { bucket: s4, layout: n3, posMatrix: a3, textLabelPlaneMatrix: l3, labelToScreenMatrix: c3, clippingData: h2, textPixelRatio: u3, holdingForFade: d2, collisionBoxArray: _3, partiallyEvaluatedTextSize: p3, partiallyEvaluatedIconSize: f2, collisionGroup: m2 } = t3.parameters, g3 = n3.get("text-optional"), v3 = n3.get("icon-optional"), x3 = n3.get("text-allow-overlap"), y3 = n3.get("icon-allow-overlap"), b2 = "map" === n3.get("text-rotation-alignment"), w2 = "map" === n3.get("text-pitch-alignment"), T2 = "viewport-y" === n3.get("symbol-z-order"), E2 = n3.get("symbol-z-elevate");
            this.transform.setProjection(s4.projection);
            let S2 = x3 && (y3 || !s4.hasIconData() || v3), C2 = y3 && (x3 || !s4.hasTextData() || g3);
            !s4.collisionArrays && _3 && s4.deserializeCollisionBoxes(_3), o3 && r4 && s4.updateCollisionDebugBuffers(this.transform.zoom, _3);
            const I2 = (t4, r5, _4) => {
              const { crossTileID: T3, numVerticalGlyphVertices: E3 } = t4;
              if (h2) {
                const o4 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
                let r6 = null;
                if (h2.dynamicFilterNeedsFeature) {
                  const e4 = this.retainedQueryData[s4.bucketInstanceId];
                  r6 = h2.featureIndex.loadFeature({ featureIndex: t4.featureIndex, bucketIndex: e4.bucketIndex, sourceLayerIndex: e4.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (!(0, h2.dynamicFilter)(o4, r6, this.retainedQueryData[s4.bucketInstanceId].tileID.canonical, new e3.P(t4.tileAnchorX, t4.tileAnchorY), this.transform.calculateDistanceTileData(h2.unwrappedTileID)))
                  return this.placements[T3] = new Oi(false, false, false, true), void i3.add(T3);
              }
              if (i3.has(T3))
                return;
              if (d2)
                return void (this.placements[T3] = new Oi(false, false, false));
              let I3 = false, D2 = false, R3 = true, A2 = false, P2 = false, L2 = null, M3 = { box: null, offscreen: null, occluded: null }, z3 = { box: null, offscreen: null, occluded: null }, O2 = null, F2 = null, B2 = null, k2 = 0, N2 = 0, U2 = 0;
              _4.textFeatureIndex ? k2 = _4.textFeatureIndex : t4.useRuntimeCollisionCircles && (k2 = t4.featureIndex), _4.verticalTextFeatureIndex && (N2 = _4.verticalTextFeatureIndex);
              const G2 = (e4) => {
                e4.tileID = this.retainedQueryData[s4.bucketInstanceId].tileID;
                const i4 = this.transform.elevation;
                e4.elevation = t4.zOffset + (i4 ? i4.getAtTileOffset(e4.tileID, e4.tileAnchorX, e4.tileAnchorY) : 0);
              }, j3 = _4.textBox;
              if (j3) {
                G2(j3);
                const i4 = (i5) => {
                  let o5 = e3.b9.horizontal;
                  if (s4.allowVerticalPlacement && !i5 && this.prevPlacement) {
                    const e4 = this.prevPlacement.placedOrientations[T3];
                    e4 && (this.placedOrientations[T3] = e4, o5 = e4, this.markUsedOrientation(s4, o5, t4));
                  }
                  return o5;
                }, o4 = (t5, i5) => {
                  if (s4.allowVerticalPlacement && E3 > 0 && _4.verticalTextBox) {
                    for (const o5 of s4.writingModes)
                      if (o5 === e3.b9.vertical ? (M3 = i5(), z3 = M3) : M3 = t5(), M3 && M3.box && M3.box.length)
                        break;
                  } else
                    M3 = t5();
                };
                if (n3.get("text-variable-anchor")) {
                  let l4 = n3.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[T3]) {
                    const e4 = this.prevPlacement.variableOffsets[T3];
                    l4.indexOf(e4.anchor) > 0 && (l4 = l4.filter((t5) => t5 !== e4.anchor), l4.unshift(e4.anchor));
                  }
                  const c4 = (e4, i5, o5) => {
                    const n4 = s4.getSymbolInstanceTextSize(p3, t4, this.transform.zoom, r5), c5 = (e4.x2 - e4.x1) * n4 + 2 * e4.padding, h4 = (e4.y2 - e4.y1) * n4 + 2 * e4.padding, d3 = t4.hasIconTextFit && !y3 ? i5 : null;
                    d3 && G2(d3);
                    let _5 = { box: [], offscreen: false, occluded: false };
                    const g4 = x3 ? 2 * l4.length : l4.length;
                    for (let i6 = 0; i6 < g4; ++i6) {
                      const g5 = this.attemptAnchorPlacement(l4[i6 % l4.length], e4, c5, h4, n4, b2, w2, u3, a3, m2, i6 >= l4.length, t4, r5, s4, o5, d3, p3, f2);
                      if (g5 && (_5 = g5.placedGlyphBoxes, _5 && _5.box && _5.box.length)) {
                        I3 = true, L2 = g5.shift;
                        break;
                      }
                    }
                    return _5;
                  };
                  o4(() => c4(j3, _4.iconBox, e3.b9.horizontal), () => {
                    const t5 = _4.verticalTextBox;
                    return t5 && G2(t5), s4.allowVerticalPlacement && !(M3 && M3.box && M3.box.length) && E3 > 0 && t5 ? c4(t5, _4.verticalIconBox, e3.b9.vertical) : { box: null, offscreen: null, occluded: null };
                  }), M3 && (I3 = M3.box, R3 = M3.offscreen, A2 = M3.occluded);
                  const h3 = i4(!(!M3 || !M3.box));
                  if (!I3 && this.prevPlacement) {
                    const e4 = this.prevPlacement.variableOffsets[T3];
                    e4 && (this.variableOffsets[T3] = e4, this.markUsedJustification(s4, e4.anchor, t4, h3));
                  }
                } else {
                  const n4 = (i5, o5) => {
                    const n5 = s4.getSymbolInstanceTextSize(p3, t4, this.transform.zoom, r5), l4 = this.collisionIndex.placeCollisionBox(s4, n5, i5, new e3.P(0, 0), x3, u3, a3, m2.predicate);
                    return l4 && l4.box && l4.box.length && (this.markUsedOrientation(s4, o5, t4), this.placedOrientations[T3] = o5), l4;
                  };
                  o4(() => n4(j3, e3.b9.horizontal), () => {
                    const t5 = _4.verticalTextBox;
                    return s4.allowVerticalPlacement && E3 > 0 && t5 ? (G2(t5), n4(t5, e3.b9.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), i4(!!(M3 && M3.box && M3.box.length));
                }
              }
              if (O2 = M3, I3 = O2 && O2.box && O2.box.length > 0, R3 = O2 && O2.offscreen, A2 = O2 && O2.occluded, t4.useRuntimeCollisionCircles) {
                const i4 = s4.text.placedSymbolArray.get(t4.centerJustifiedTextSymbolIndex >= 0 ? t4.centerJustifiedTextSymbolIndex : t4.verticalPlacedTextSymbolIndex), r6 = e3.ba(s4.textSizeData, p3, i4), h3 = n3.get("text-padding");
                F2 = this.collisionIndex.placeCollisionCircles(s4, x3, i4, s4.lineVertexArray, s4.glyphOffsetArray, r6, a3, l3, c3, o3, w2, m2.predicate, t4.collisionCircleDiameter * r6 / e3.bf, h3, this.retainedQueryData[s4.bucketInstanceId].tileID), I3 = x3 || F2.circles.length > 0 && !F2.collisionDetected, R3 = R3 && F2.offscreen, A2 = F2.occluded;
              }
              if (_4.iconFeatureIndex && (U2 = _4.iconFeatureIndex), _4.iconBox) {
                const i4 = (i5) => {
                  G2(i5);
                  const o4 = t4.hasIconTextFit && L2 ? Ui(L2.x, L2.y, b2, w2, this.transform.angle) : new e3.P(0, 0), r6 = s4.getSymbolInstanceIconSize(f2, this.transform.zoom, t4.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(s4, r6, i5, o4, y3, u3, a3, m2.predicate);
                };
                z3 && z3.box && z3.box.length && _4.verticalIconBox ? (B2 = i4(_4.verticalIconBox), D2 = B2.box.length > 0) : (B2 = i4(_4.iconBox), D2 = B2.box.length > 0), R3 = R3 && B2.offscreen, P2 = B2.occluded;
              }
              const V2 = g3 || 0 === t4.numHorizontalGlyphVertices && 0 === E3, Z3 = v3 || 0 === t4.numIconVertices;
              if (V2 || Z3 ? Z3 ? V2 || (D2 = D2 && I3) : I3 = D2 && I3 : D2 = I3 = D2 && I3, I3 && O2 && O2.box && this.collisionIndex.insertCollisionBox(O2.box, n3.get("text-ignore-placement"), s4.bucketInstanceId, z3 && z3.box && N2 ? N2 : k2, m2.ID), D2 && B2 && this.collisionIndex.insertCollisionBox(B2.box, n3.get("icon-ignore-placement"), s4.bucketInstanceId, U2, m2.ID), F2 && (I3 && this.collisionIndex.insertCollisionCircles(F2.circles, n3.get("text-ignore-placement"), s4.bucketInstanceId, k2, m2.ID), o3)) {
                const e4 = s4.bucketInstanceId;
                let t5 = this.collisionCircleArrays[e4];
                void 0 === t5 && (t5 = this.collisionCircleArrays[e4] = new Fi());
                for (let e5 = 0; e5 < F2.circles.length; e5 += 4)
                  t5.circles.push(F2.circles[e5 + 0]), t5.circles.push(F2.circles[e5 + 1]), t5.circles.push(F2.circles[e5 + 2]), t5.circles.push(F2.collisionDetected ? 1 : 0);
              }
              const W2 = "globe" !== s4.projection.name;
              S2 = S2 && (W2 || !A2), C2 = C2 && (W2 || !P2), this.placements[T3] = new Oi(I3 || S2, D2 || C2, R3 || s4.justReloaded), i3.add(T3);
            };
            if (E2 && this.buildingIndex && (this.buildingIndex.updateZOffset(s4, this.retainedQueryData[s4.bucketInstanceId].tileID), s4.updateZOffset()), T2) {
              const t4 = s4.getSortedSymbolIndexes(this.transform.angle);
              for (let e4 = t4.length - 1; e4 >= 0; --e4) {
                const i4 = t4[e4];
                I2(s4.symbolInstances.get(i4), i4, s4.collisionArrays[i4]);
              }
              s4.hasAnyZOffset && e3.w(`${s4.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
            } else if (s4.hasAnyZOffset) {
              const e4 = s4.getSortedIndexesByZOffset();
              for (let t4 = 0; t4 < e4.length; ++t4) {
                const i4 = e4[t4];
                I2(s4.symbolInstances.get(i4), i4, s4.collisionArrays[i4]);
              }
            } else
              for (let e4 = t3.symbolInstanceStart; e4 < t3.symbolInstanceEnd; e4++)
                I2(s4.symbolInstances.get(e4), e4, s4.collisionArrays[e4]);
            if (o3 && s4.bucketInstanceId in this.collisionCircleArrays) {
              const t4 = this.collisionCircleArrays[s4.bucketInstanceId];
              e3.a9.invert(t4.invProjMatrix, a3), t4.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            s4.justReloaded = false;
          }
          markUsedJustification(t3, i3, o3, r4) {
            const { leftJustifiedTextSymbolIndex: s4, centerJustifiedTextSymbolIndex: n3, rightJustifiedTextSymbolIndex: a3, verticalPlacedTextSymbolIndex: l3, crossTileID: c3 } = o3, h2 = e3.bg(i3), u3 = r4 === e3.b9.vertical ? l3 : "left" === h2 ? s4 : "center" === h2 ? n3 : "right" === h2 ? a3 : -1;
            s4 >= 0 && (t3.text.placedSymbolArray.get(s4).crossTileID = u3 >= 0 && s4 !== u3 ? 0 : c3), n3 >= 0 && (t3.text.placedSymbolArray.get(n3).crossTileID = u3 >= 0 && n3 !== u3 ? 0 : c3), a3 >= 0 && (t3.text.placedSymbolArray.get(a3).crossTileID = u3 >= 0 && a3 !== u3 ? 0 : c3), l3 >= 0 && (t3.text.placedSymbolArray.get(l3).crossTileID = u3 >= 0 && l3 !== u3 ? 0 : c3);
          }
          markUsedOrientation(t3, i3, o3) {
            const r4 = i3 === e3.b9.horizontal || i3 === e3.b9.horizontalOnly ? i3 : 0, s4 = i3 === e3.b9.vertical ? i3 : 0, { leftJustifiedTextSymbolIndex: n3, centerJustifiedTextSymbolIndex: a3, rightJustifiedTextSymbolIndex: l3, verticalPlacedTextSymbolIndex: c3 } = o3, h2 = t3.text.placedSymbolArray;
            n3 >= 0 && (h2.get(n3).placedOrientation = r4), a3 >= 0 && (h2.get(a3).placedOrientation = r4), l3 >= 0 && (h2.get(l3).placedOrientation = r4), c3 >= 0 && (h2.get(c3).placedOrientation = s4);
          }
          commit(e4) {
            this.commitTime = e4, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t3 = this.prevPlacement;
            let i3 = false;
            this.prevZoomAdjustment = t3 ? t3.zoomAdjustment(this.transform.zoom) : 0;
            const o3 = t3 ? t3.symbolFadeChange(e4) : 1, r4 = t3 ? t3.opacities : {}, s4 = t3 ? t3.variableOffsets : {}, n3 = t3 ? t3.placedOrientations : {};
            for (const e5 in this.placements) {
              const t4 = this.placements[e5], s5 = r4[e5];
              s5 ? (this.opacities[e5] = new zi(s5, o3, t4.text, t4.icon, null, t4.clipped), i3 = i3 || t4.text !== s5.text.placed || t4.icon !== s5.icon.placed) : (this.opacities[e5] = new zi(null, o3, t4.text, t4.icon, t4.skipFade, t4.clipped), i3 = i3 || t4.text || t4.icon);
            }
            for (const e5 in r4) {
              const t4 = r4[e5];
              if (!this.opacities[e5]) {
                const r5 = new zi(t4, o3, false, false);
                r5.isHidden() || (this.opacities[e5] = r5, i3 = i3 || t4.text.placed || t4.icon.placed);
              }
            }
            for (const e5 in s4)
              this.variableOffsets[e5] || !this.opacities[e5] || this.opacities[e5].isHidden() || (this.variableOffsets[e5] = s4[e5]);
            for (const e5 in n3)
              this.placedOrientations[e5] || !this.opacities[e5] || this.opacities[e5].isHidden() || (this.placedOrientations[e5] = n3[e5]);
            i3 ? this.lastPlacementChangeTime = e4 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t3 ? t3.lastPlacementChangeTime : e4);
          }
          updateLayerOpacities(e4, t3) {
            const i3 = /* @__PURE__ */ new Set();
            for (const o3 of t3) {
              const t4 = o3.getBucket(e4);
              t4 && o3.latestFeatureIndex && e4.fqid === t4.layerIds[0] && (this.updateBucketOpacities(t4, i3, o3.collisionBoxArray), t4.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t4, o3.tileID), t4.updateZOffset()));
            }
          }
          updateBucketOpacities(t3, i3, o3) {
            t3.hasTextData() && t3.text.opacityVertexArray.clear(), t3.hasIconData() && t3.icon.opacityVertexArray.clear(), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexArray.clear(), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexArray.clear();
            const r4 = t3.layers[0].layout, s4 = !!t3.layers[0].dynamicFilter(), n3 = new zi(null, 0, false, false, true), a3 = r4.get("text-allow-overlap"), l3 = r4.get("icon-allow-overlap"), c3 = r4.get("text-variable-anchor"), h2 = "map" === r4.get("text-rotation-alignment"), u3 = "map" === r4.get("text-pitch-alignment"), d2 = new zi(null, 0, a3 && (l3 || !t3.hasIconData() || r4.get("icon-optional")), l3 && (a3 || !t3.hasTextData() || r4.get("text-optional")), true);
            !t3.collisionArrays && o3 && (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) && t3.deserializeCollisionBoxes(o3);
            const _3 = (e4, t4, i4) => {
              for (let o4 = 0; o4 < t4 / 4; o4++)
                e4.opacityVertexArray.emplaceBack(i4);
            };
            let p3 = 0;
            for (let o4 = 0; o4 < t3.symbolInstances.length; o4++) {
              const r5 = t3.symbolInstances.get(o4), { numHorizontalGlyphVertices: a4, numVerticalGlyphVertices: l4, crossTileID: f2, numIconVertices: m2 } = r5, g3 = i3.has(f2);
              let v3 = this.opacities[f2];
              g3 ? v3 = n3 : v3 || (v3 = d2, this.opacities[f2] = v3), i3.add(f2);
              const x3 = a4 > 0 || l4 > 0, y3 = m2 > 0, b2 = this.placedOrientations[f2], w2 = b2 === e3.b9.vertical, T2 = b2 === e3.b9.horizontal || b2 === e3.b9.horizontalOnly;
              if (!x3 && !y3 || v3.isHidden() || p3++, x3) {
                const e4 = Xi(v3.text);
                _3(t3.text, a4, w2 ? Yi : e4), _3(t3.text, l4, T2 ? Yi : e4);
                const i4 = v3.text.isHidden(), { leftJustifiedTextSymbolIndex: o5, centerJustifiedTextSymbolIndex: s5, rightJustifiedTextSymbolIndex: n4, verticalPlacedTextSymbolIndex: c4 } = r5, h3 = t3.text.placedSymbolArray, u4 = i4 || w2 ? 1 : 0;
                o5 >= 0 && (h3.get(o5).hidden = u4), s5 >= 0 && (h3.get(s5).hidden = u4), n4 >= 0 && (h3.get(n4).hidden = u4), c4 >= 0 && (h3.get(c4).hidden = i4 || T2 ? 1 : 0);
                const d3 = this.variableOffsets[f2];
                d3 && this.markUsedJustification(t3, d3.anchor, r5, b2);
                const p4 = this.placedOrientations[f2];
                p4 && (this.markUsedJustification(t3, "left", r5, p4), this.markUsedOrientation(t3, p4, r5));
              }
              if (y3) {
                const e4 = Xi(v3.icon), { placedIconSymbolIndex: i4, verticalPlacedIconSymbolIndex: o5 } = r5, s5 = t3.icon.placedSymbolArray, n4 = v3.icon.isHidden() ? 1 : 0;
                i4 >= 0 && (_3(t3.icon, m2, w2 ? Yi : e4), s5.get(i4).hidden = n4), o5 >= 0 && (_3(t3.icon, r5.numVerticalIconVertices, T2 ? Yi : e4), s5.get(o5).hidden = n4);
              }
              if (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) {
                const i4 = t3.collisionArrays[o4];
                if (i4) {
                  let o5 = new e3.P(0, 0), n4 = true;
                  if (i4.textBox || i4.verticalTextBox) {
                    if (c3) {
                      const e4 = this.variableOffsets[f2];
                      e4 ? (o5 = Ni(e4.anchor, e4.width, e4.height, e4.textOffset, e4.textScale), h2 && o5._rotate(u3 ? this.transform.angle : -this.transform.angle)) : n4 = false;
                    }
                    s4 && (n4 = !v3.clipped), i4.textBox && ji(t3.textCollisionBox.collisionVertexArray, v3.text.placed, !n4 || w2, o5.x, o5.y), i4.verticalTextBox && ji(t3.textCollisionBox.collisionVertexArray, v3.text.placed, !n4 || T2, o5.x, o5.y);
                  }
                  const a5 = n4 && Boolean(!T2 && i4.verticalIconBox);
                  i4.iconBox && ji(t3.iconCollisionBox.collisionVertexArray, v3.icon.placed, a5, r5.hasIconTextFit ? o5.x : 0, r5.hasIconTextFit ? o5.y : 0), i4.verticalIconBox && ji(t3.iconCollisionBox.collisionVertexArray, v3.icon.placed, !a5, r5.hasIconTextFit ? o5.x : 0, r5.hasIconTextFit ? o5.y : 0);
                }
              }
            }
            if (t3.fullyClipped = 0 === p3, t3.sortFeatures(this.transform.angle), this.retainedQueryData[t3.bucketInstanceId] && (this.retainedQueryData[t3.bucketInstanceId].featureSortOrder = t3.featureSortOrder), t3.hasTextData() && t3.text.opacityVertexBuffer && t3.text.opacityVertexBuffer.updateData(t3.text.opacityVertexArray), t3.hasIconData() && t3.icon.opacityVertexBuffer && t3.icon.opacityVertexBuffer.updateData(t3.icon.opacityVertexArray), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexBuffer && t3.iconCollisionBox.collisionVertexBuffer.updateData(t3.iconCollisionBox.collisionVertexArray), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexBuffer && t3.textCollisionBox.collisionVertexBuffer.updateData(t3.textCollisionBox.collisionVertexArray), t3.bucketInstanceId in this.collisionCircleArrays) {
              const e4 = this.collisionCircleArrays[t3.bucketInstanceId];
              t3.placementInvProjMatrix = e4.invProjMatrix, t3.placementViewportMatrix = e4.viewportMatrix, t3.collisionCircleArray = e4.circles, delete this.collisionCircleArrays[t3.bucketInstanceId];
            }
          }
          symbolFadeChange(e4) {
            return 0 === this.fadeDuration ? 1 : (e4 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e4) {
            return Math.max(0, (this.transform.zoom - e4) / 1.5);
          }
          hasTransitions(e4) {
            return this.stale || e4 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e4, t3) {
            const i3 = this.zoomAtLastRecencyCheck === t3 ? 1 - this.zoomAdjustment(t3) : 1;
            return this.zoomAtLastRecencyCheck = t3, this.commitTime + this.fadeDuration * i3 > e4;
          }
          setStale() {
            this.stale = true;
          }
        }
        function ji(e4, t3, i3, o3, r4) {
          e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r4 || 0), e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r4 || 0), e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r4 || 0), e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r4 || 0);
        }
        const Vi = Math.pow(2, 25), Zi = Math.pow(2, 24), Wi = Math.pow(2, 17), Hi = Math.pow(2, 16), qi = Math.pow(2, 9), Qi = Math.pow(2, 8), $i = Math.pow(2, 1);
        function Xi(e4) {
          if (0 === e4.opacity && !e4.placed)
            return 0;
          if (1 === e4.opacity && e4.placed)
            return 4294967295;
          const t3 = e4.placed ? 1 : 0, i3 = Math.floor(127 * e4.opacity);
          return i3 * Vi + t3 * Zi + i3 * Wi + t3 * Hi + i3 * qi + t3 * Qi + i3 * $i + t3;
        }
        const Yi = 0;
        class Ji {
          constructor(e4) {
            this._sortAcrossTiles = "viewport-y" !== e4.layout.get("symbol-z-order") && void 0 !== e4.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
          }
          continuePlacement(e4, t3, i3, o3, r4) {
            const s4 = this._bucketParts;
            for (; this._currentTileIndex < e4.length; )
              if (t3.getBucketParts(s4, o3, e4[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r4())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, s4.sort((e5, t4) => e5.sortKey - t4.sortKey)); this._currentPartIndex < s4.length; ) {
              const e5 = s4[this._currentPartIndex];
              if (t3.placeLayerBucketPart(e5, this._seenCrossTileIDs, i3, 0 === e5.symbolInstanceStart), this._currentPartIndex++, r4())
                return true;
            }
            return false;
          }
        }
        class Ki {
          constructor(e4, t3, i3, o3, r4, s4, n3, a3, l3) {
            this.placement = new Gi(e4, r4, s4, n3, a3, l3), this._currentPlacementIndex = t3.length - 1, this._forceFullPlacement = i3, this._showCollisionBoxes = o3, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t3, i3, o3, r4) {
            const s4 = e3.f.now(), n3 = () => {
              const t4 = e3.f.now() - s4;
              return !this._forceFullPlacement && t4 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const s5 = i3[t3[this._currentPlacementIndex]], a3 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === s5.type && (!s5.minzoom || s5.minzoom <= a3) && (!s5.maxzoom || s5.maxzoom > a3)) {
                const t4 = s5, i4 = t4.layout.get("symbol-z-elevate"), a4 = this._inProgressLayer = this._inProgressLayer || new Ji(t4), l3 = e3.aj(s5.source, s5.scope);
                if (a4.continuePlacement(i4 ? r4[l3] : o3[l3], this.placement, this._showCollisionBoxes, s5, n3))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e4) {
            return this.placement.commit(e4), this.placement;
          }
        }
        const eo = 512 / e3.Y / 2;
        class to {
          constructor(t3, i3, o3) {
            this.tileID = t3, this.bucketInstanceId = o3, this.index = new e3.bj(i3.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
            const r4 = t3.canonical.x * e3.Y, s4 = t3.canonical.y * e3.Y;
            for (let e4 = 0; e4 < i3.length; e4++) {
              const { key: t4, crossTileID: o4, tileAnchorX: n3, tileAnchorY: a3 } = i3.get(e4), l3 = Math.floor((r4 + n3) * eo), c3 = Math.floor((s4 + a3) * eo);
              this.index.add(l3, c3), this.keys.push(t4), this.crossTileIDs.push(o4);
            }
            this.index.finish();
          }
          findMatches(t3, i3, o3) {
            const r4 = this.tileID.canonical.z < i3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i3.canonical.z), s4 = eo / Math.pow(2, i3.canonical.z - this.tileID.canonical.z), n3 = i3.canonical.x * e3.Y, a3 = i3.canonical.y * e3.Y;
            for (let e4 = 0; e4 < t3.length; e4++) {
              const i4 = t3.get(e4);
              if (i4.crossTileID)
                continue;
              const { key: l3, tileAnchorX: c3, tileAnchorY: h2 } = i4, u3 = Math.floor((n3 + c3) * s4), d2 = Math.floor((a3 + h2) * s4), _3 = this.index.range(u3 - r4, d2 - r4, u3 + r4, d2 + r4);
              for (const e5 of _3) {
                const t4 = this.crossTileIDs[e5];
                if (this.keys[e5] === l3 && !o3.has(t4)) {
                  o3.add(t4), i4.crossTileID = t4;
                  break;
                }
              }
            }
          }
        }
        class io {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class oo {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e4) {
            const t3 = Math.round((e4 - this.lng) / 360);
            if (0 !== t3)
              for (const e5 in this.indexes) {
                const i3 = this.indexes[e5], o3 = {};
                for (const e6 in i3) {
                  const r4 = i3[e6];
                  r4.tileID = r4.tileID.unwrapTo(r4.tileID.wrap + t3), o3[r4.tileID.key] = r4;
                }
                this.indexes[e5] = o3;
              }
            this.lng = e4;
          }
          addBucket(e4, t3, i3) {
            if (this.indexes[e4.overscaledZ] && this.indexes[e4.overscaledZ][e4.key]) {
              if (this.indexes[e4.overscaledZ][e4.key].bucketInstanceId === t3.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(e4.overscaledZ, this.indexes[e4.overscaledZ][e4.key]);
            }
            for (let e5 = 0; e5 < t3.symbolInstances.length; e5++)
              t3.symbolInstances.get(e5).crossTileID = 0;
            this.usedCrossTileIDs[e4.overscaledZ] || (this.usedCrossTileIDs[e4.overscaledZ] = /* @__PURE__ */ new Set());
            const o3 = this.usedCrossTileIDs[e4.overscaledZ];
            for (const i4 in this.indexes) {
              const r4 = this.indexes[i4];
              if (Number(i4) > e4.overscaledZ)
                for (const i5 in r4) {
                  const s4 = r4[i5];
                  s4.tileID.isChildOf(e4) && s4.findMatches(t3.symbolInstances, e4, o3);
                }
              else {
                const s4 = r4[e4.scaledTo(Number(i4)).key];
                s4 && s4.findMatches(t3.symbolInstances, e4, o3);
              }
            }
            for (let e5 = 0; e5 < t3.symbolInstances.length; e5++) {
              const r4 = t3.symbolInstances.get(e5);
              r4.crossTileID || (r4.crossTileID = i3.generate(), o3.add(r4.crossTileID));
            }
            return void 0 === this.indexes[e4.overscaledZ] && (this.indexes[e4.overscaledZ] = {}), this.indexes[e4.overscaledZ][e4.key] = new to(e4, t3.symbolInstances, t3.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e4, t3) {
            for (const i3 of t3.crossTileIDs)
              this.usedCrossTileIDs[e4].delete(i3);
          }
          removeStaleBuckets(e4) {
            let t3 = false;
            for (const i3 in this.indexes) {
              const o3 = this.indexes[i3];
              for (const r4 in o3)
                e4[o3[r4].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, o3[r4]), delete o3[r4], t3 = true);
            }
            return t3;
          }
        }
        class ro {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new io(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e4, t3, i3, o3) {
            let r4 = this.layerIndexes[e4.fqid];
            void 0 === r4 && (r4 = this.layerIndexes[e4.fqid] = new oo());
            let s4 = false;
            const n3 = {};
            "globe" !== o3.name && r4.handleWrapJump(i3);
            for (const i4 of t3) {
              const t4 = i4.getBucket(e4);
              t4 && e4.fqid === t4.layerIds[0] && (t4.bucketInstanceId || (t4.bucketInstanceId = ++this.maxBucketInstanceId), r4.addBucket(i4.tileID, t4, this.crossTileIDs) && (s4 = true), n3[t4.bucketInstanceId] = true);
            }
            return r4.removeStaleBuckets(n3) && (s4 = true), s4;
          }
          pruneUnusedLayers(e4) {
            const t3 = {};
            e4.forEach((e5) => {
              t3[e5] = true;
            });
            for (const e5 in this.layerIndexes)
              t3[e5] || delete this.layerIndexes[e5];
          }
        }
        class so {
          constructor(e4 = 0, t3 = 0, i3 = 0, o3 = 0) {
            if (isNaN(e4) || e4 < 0 || isNaN(t3) || t3 < 0 || isNaN(i3) || i3 < 0 || isNaN(o3) || o3 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e4, this.bottom = t3, this.left = i3, this.right = o3;
          }
          interpolate(t3, i3, o3) {
            return null != i3.top && null != t3.top && (this.top = e3.X(t3.top, i3.top, o3)), null != i3.bottom && null != t3.bottom && (this.bottom = e3.X(t3.bottom, i3.bottom, o3)), null != i3.left && null != t3.left && (this.left = e3.X(t3.left, i3.left, o3)), null != i3.right && null != t3.right && (this.right = e3.X(t3.right, i3.right, o3)), this;
          }
          getCenter(t3, i3) {
            const o3 = e3.ad((this.left + t3 - this.right) / 2, 0, t3), r4 = e3.ad((this.top + i3 - this.bottom) / 2, 0, i3);
            return new e3.P(o3, r4);
          }
          equals(e4) {
            return this.top === e4.top && this.bottom === e4.bottom && this.left === e4.left && this.right === e4.right;
          }
          clone() {
            return new so(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function no(t3, i3) {
          const o3 = e3.bn(t3, 3);
          e3.a9.fromQuat(t3, i3), e3.bp(t3, 3, o3);
        }
        function ao(t3, i3) {
          const o3 = e3.bl.identity([]);
          return e3.bl.rotateZ(o3, o3, -i3), e3.bl.rotateX(o3, o3, -t3), o3;
        }
        function lo(t3, i3) {
          const o3 = [t3[0], t3[1], 0], r4 = [i3[0], i3[1], 0];
          if (e3.Q.length(o3) >= 1e-15) {
            const t4 = e3.Q.normalize([], o3);
            e3.Q.scale(r4, t4, e3.Q.dot(r4, t4)), i3[0] = r4[0], i3[1] = r4[1];
          }
          const s4 = e3.Q.cross([], i3, t3);
          if (e3.Q.len(s4) < 1e-15)
            return null;
          const n3 = Math.atan2(-s4[1], s4[0]);
          return ao(Math.atan2(Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]), -t3[2]), n3);
        }
        class co {
          constructor(e4, t3) {
            this.position = e4, this.orientation = t3;
          }
          get position() {
            return this._position;
          }
          set position(t3) {
            if (t3) {
              const i3 = t3 instanceof e3.O ? t3 : new e3.O(t3[0], t3[1], t3[2]);
              this._renderWorldCopies && (i3.x = e3.bk(i3.x, 0, 1)), this._position = i3;
            } else
              this._position = null;
          }
          lookAtPoint(t3, i3) {
            if (this.orientation = null, !this.position)
              return;
            const o3 = this.position, r4 = this._elevation ? this._elevation.getAtPointOrZero(e3.O.fromLngLat(t3)) : 0, s4 = e3.O.fromLngLat(t3, r4), n3 = [s4.x - o3.x, s4.y - o3.y, s4.z - o3.z];
            i3 || (i3 = [0, 0, 1]), i3[2] = Math.abs(i3[2]), this.orientation = lo(n3, i3);
          }
          setPitchBearing(t3, i3) {
            this.orientation = ao(e3.bm(t3), e3.bm(-i3));
          }
        }
        class ho {
          constructor(t3, i3) {
            this._transform = e3.a9.identity([]), this.orientation = i3, this.position = t3;
          }
          get mercatorPosition() {
            const t3 = this.position;
            return new e3.O(t3[0], t3[1], t3[2]);
          }
          get position() {
            const t3 = e3.bn(this._transform, 3);
            return [t3[0], t3[1], t3[2]];
          }
          set position(t3) {
            var i3;
            t3 && e3.bp(this._transform, 3, [(i3 = t3)[0], i3[1], i3[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t3) {
            this._orientation = t3 || e3.bl.identity([]), t3 && no(this._transform, this._orientation);
          }
          getPitchBearing() {
            const e4 = this.forward(), t3 = this.right();
            return { bearing: Math.atan2(-t3[1], t3[0]), pitch: Math.atan2(Math.sqrt(e4[0] * e4[0] + e4[1] * e4[1]), -e4[2]) };
          }
          setPitchBearing(e4, t3) {
            this._orientation = ao(e4, t3), no(this._transform, this._orientation);
          }
          forward() {
            const t3 = e3.bn(this._transform, 2);
            return [-t3[0], -t3[1], -t3[2]];
          }
          up() {
            const t3 = e3.bn(this._transform, 1);
            return [-t3[0], -t3[1], -t3[2]];
          }
          right() {
            const t3 = e3.bn(this._transform, 0);
            return [t3[0], t3[1], t3[2]];
          }
          getCameraToWorld(t3, i3) {
            const o3 = new Float64Array(16);
            return e3.a9.invert(o3, this.getWorldToCamera(t3, i3)), o3;
          }
          getCameraToWorldMercator() {
            return this._transform;
          }
          getWorldToCameraPosition(t3, i3, o3) {
            const r4 = this.position;
            e3.Q.scale(r4, r4, -t3);
            const s4 = new Float64Array(16);
            return e3.a9.fromScaling(s4, [o3, o3, o3]), e3.a9.translate(s4, s4, r4), s4[10] *= i3, s4;
          }
          getWorldToCamera(t3, i3) {
            const o3 = new Float64Array(16), r4 = new Float64Array(4), s4 = this.position;
            return e3.bl.conjugate(r4, this._orientation), e3.Q.scale(s4, s4, -t3), e3.a9.fromQuat(o3, r4), e3.a9.translate(o3, o3, s4), o3[1] *= -1, o3[5] *= -1, o3[9] *= -1, o3[13] *= -1, o3[8] *= i3, o3[9] *= i3, o3[10] *= i3, o3[11] *= i3, o3;
          }
          getCameraToClipPerspective(t3, i3, o3, r4) {
            const s4 = new Float64Array(16);
            return e3.a9.perspective(s4, t3, i3, o3, r4), s4;
          }
          getCameraToClipOrthographic(t3, i3, o3, r4, s4, n3) {
            const a3 = new Float64Array(16);
            return e3.a9.ortho(a3, t3, i3, o3, r4, s4, n3), a3;
          }
          getDistanceToElevation(t3, i3 = false) {
            const o3 = 0 === t3 ? 0 : e3.bo(t3, i3 ? e3.ax(this.position[1]) : this.position[1]), r4 = this.forward();
            return (o3 - this.position[2]) / r4[2];
          }
          clone() {
            return new ho([...this.position], [...this.orientation]);
          }
        }
        const uo = (e4, t3, i3) => (1 - i3) * e4 + i3 * t3, _o = (e4) => e4 * e4 * e4 * e4 * e4;
        class po {
          constructor(t3, i3, o3, r4, s4, n3, a3) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === s4 || s4, this._minZoom = t3 || 0, this._maxZoom = i3 || 22, this._minPitch = null == o3 ? 0 : o3, this._maxPitch = null == r4 ? 60 : r4, this.setProjection(n3), this.setMaxBounds(a3), this.width = 0, this.height = 0, this._center = new e3.bq(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new so(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new ho(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = false, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false;
          }
          clone() {
            const e4 = new po(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
            return e4._elevation = this._elevation, e4._centerAltitude = this._centerAltitude, e4._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e4.tileSize = this.tileSize, e4.mercatorFromTransition = this.mercatorFromTransition, e4.width = this.width, e4.height = this.height, e4.cameraElevationReference = this.cameraElevationReference, e4._center = this._center, e4._setZoom(this.zoom), e4._seaLevelZoom = this._seaLevelZoom, e4.angle = this.angle, e4._fov = this._fov, e4._pitch = this._pitch, e4._nearZ = this._nearZ, e4._farZ = this._farZ, e4._averageElevation = this._averageElevation, e4._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e4._unmodified = this._unmodified, e4._edgeInsets = this._edgeInsets.clone(), e4._camera = this._camera.clone(), e4._calcMatrices(), e4.freezeTileCoverage = this.freezeTileCoverage, e4.frustumCorners = this.frustumCorners, e4;
          }
          get isOrthographic() {
            return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e4) {
            this._elevation !== e4 && (this._elevation = e4, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          get depthOcclusionForSymbolsAndCircles() {
            return "globe" !== this.projection.name && !this.isOrthographic;
          }
          updateElevation(e4, t3 = false) {
            const i3 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (null == this._seaLevelZoom || i3) && this._updateCameraOnTerrain(), (e4 || i3) && this._constrainCamera(t3), this._calcMatrices();
          }
          getProjection() {
            return e3.af(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(i3) {
            this.projectionOptions = i3 || { name: "mercator" };
            const o3 = this.projection ? this.getProjection() : void 0;
            this.projection = e3.br(this.projectionOptions);
            const r4 = !t2(o3, this.getProjection());
            return r4 && this._calcMatrices(), this.mercatorFromTransition = false, r4;
          }
          setOrthographicProjectionAtLowPitch(e4) {
            return this._orthographicProjectionAtLowPitch !== e4 && (this._orthographicProjectionAtLowPitch = e4, this._calcMatrices(), true);
          }
          setMercatorFromTransition() {
            const t3 = this.projection.name;
            this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e3.br({ name: "mercator" });
            const i3 = t3 !== this.projection.name;
            return i3 && this._calcMatrices(), i3;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e4) {
            this._minZoom !== e4 && (this._minZoom = e4, this.zoom = Math.max(this.zoom, e4));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e4) {
            this._maxZoom !== e4 && (this._maxZoom = e4, this.zoom = Math.min(this.zoom, e4));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e4) {
            this._minPitch !== e4 && (this._minPitch = e4, this.pitch = Math.max(this.pitch, e4));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e4) {
            this._maxPitch !== e4 && (this._maxPitch = e4, this.pitch = Math.min(this.pitch, e4));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
          }
          set renderWorldCopies(e4) {
            void 0 === e4 ? e4 = true : null === e4 && (e4 = false), this._renderWorldCopies = e4;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const e4 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e4));
          }
          get cameraWorldSize() {
            const e4 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e4));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return e3.bo(1, this.center.lat) * this.cameraWorldSizeForFog;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e3.P(this.width, this.height);
          }
          get bearing() {
            return e3.bk(this.rotation, -180, 180);
          }
          set bearing(e4) {
            this.rotation = e4;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t3) {
            const i3 = -t3 * Math.PI / 180;
            this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = e3.b7.create(), e3.b7.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t3) {
            const i3 = e3.ad(t3, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const e4 = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / e4);
          }
          set fov(t3) {
            t3 = Math.max(0.01, Math.min(60, t3)), this._fov !== t3 && (this._unmodified = false, this._fov = e3.bm(t3), this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(e4) {
            this._averageElevation = e4, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e4) {
            const t3 = Math.min(Math.max(e4, this.minZoom), this.maxZoom);
            this._zoom !== t3 && (this._unmodified = false, this._setZoom(t3), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(e4) {
            this._zoom = e4, this.scale = this.zoomScale(e4), this.tileZoom = Math.floor(e4), this.zoomFraction = e4 - this.tileZoom;
          }
          get tileCoverLift() {
            return this._tileCoverLift;
          }
          set tileCoverLift(e4) {
            this._tileCoverLift !== e4 && (this._tileCoverLift = e4);
          }
          _updateCameraOnTerrain() {
            const e4 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t3 = this.elevation && e4 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
            if (!this._elevation || e4 === Number.NEGATIVE_INFINITY && (!t3 || !this._centerAltitude))
              return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const i3 = this._elevation;
            t3 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i3.exaggeration() && this._centerAltitudeValidForExaggeration !== i3.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i3.exaggeration(), this._centerAltitudeValidForExaggeration = i3.exaggeration()) : (this._centerAltitude = e4 || 0, this._centerAltitudeValidForExaggeration = i3.exaggeration()), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
          }
          sampleAverageElevation() {
            if (!this._elevation)
              return 0;
            const t3 = this._elevation, i3 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o3 = this.horizonLineFromTop();
            let r4 = 0, s4 = 0;
            for (let n3 = 0; n3 < i3.length; n3++) {
              const a3 = new e3.P(i3[n3][0] * this.width, o3 + i3[n3][1] * (this.height - o3)), l3 = t3.pointCoordinate(a3);
              if (!l3)
                continue;
              const c3 = 1 / Math.hypot(l3[0] - this._camera.position[0], l3[1] - this._camera.position[1]);
              r4 += l3[3] * c3, s4 += c3;
            }
            return 0 === s4 ? NaN : r4 / s4;
          }
          get center() {
            return this._center;
          }
          set center(e4) {
            e4.lat === this._center.lat && e4.lng === this._center.lng || (this._unmodified = false, this._center = e4, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (null == this._seaLevelZoom || !this._elevation)
              return;
            const e4 = this._seaLevelZoom, t3 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i3 = this.pixelsPerMeter / this.worldSize * t3, o3 = this._mercatorZfromZoom(e4), r4 = this._mercatorZfromZoom(this._maxZoom), s4 = Math.max(o3 - i3, r4);
            this._setZoom(this._zoomFromMercatorZ(s4));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e4) {
            this._edgeInsets.equals(e4) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e4, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t3) {
            const i3 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t3.toAltitude()));
            let o3;
            o3 = t3.z < this._camera.position[2] ? [i3.x, i3.y, i3.z] : [t3.x, t3.y, t3.z];
            const r4 = e3.Q.length(e3.Q.sub([], this._camera.position, o3));
            return e3.ad(this._zoomFromMercatorZ(r4), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t3) {
            if (!this.height)
              return;
            if (!t3.position && !t3.orientation)
              return;
            this._updateCameraState();
            let i3 = false;
            if (t3.orientation && !e3.bl.exactEquals(t3.orientation, this._camera.orientation) && (i3 = this._setCameraOrientation(t3.orientation)), t3.position) {
              const o3 = [t3.position.x, t3.position.y, t3.position.z];
              e3.Q.exactEquals(o3, this._camera.position) || (this._setCameraPosition(o3), i3 = true);
            }
            i3 && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t3 = this._camera.position, i3 = new co();
            return i3.position = new e3.O(t3[0], t3[1], t3[2]), i3.orientation = this._camera.orientation, i3._elevation = this.elevation, i3._renderWorldCopies = this.renderWorldCopies, i3;
          }
          _setCameraOrientation(t3) {
            if (!e3.bl.length(t3))
              return false;
            e3.bl.normalize(t3, t3);
            const i3 = e3.Q.transformQuat([], [0, 0, -1], t3), o3 = e3.Q.transformQuat([], [0, -1, 0], t3);
            if (o3[2] < 0)
              return false;
            const r4 = lo(i3, o3);
            return !!r4 && (this._camera.orientation = r4, true);
          }
          _setCameraPosition(t3) {
            const i3 = this.zoomScale(this.minZoom) * this.tileSize, o3 = this.zoomScale(this.maxZoom) * this.tileSize, r4 = this.cameraToCenterDistance;
            t3[2] = e3.ad(t3[2], r4 / o3, r4 / i3), this._camera.position = t3;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(e4) {
            return this._edgeInsets.equals(e4);
          }
          interpolatePadding(e4, t3, i3) {
            this._unmodified = false, this._edgeInsets.interpolate(e4, t3, i3), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e4) {
            const t3 = (e4.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e4.tileSize));
            return Math.max(0, t3);
          }
          getVisibleUnwrappedCoordinates(t3) {
            const i3 = [new e3.bs(0, t3)];
            if (this.renderWorldCopies) {
              const o3 = this.pointCoordinate(new e3.P(0, 0)), r4 = this.pointCoordinate(new e3.P(this.width, 0)), s4 = this.pointCoordinate(new e3.P(this.width, this.height)), n3 = this.pointCoordinate(new e3.P(0, this.height)), a3 = Math.floor(Math.min(o3.x, r4.x, s4.x, n3.x)), l3 = Math.floor(Math.max(o3.x, r4.x, s4.x, n3.x)), c3 = 1;
              for (let o4 = a3 - c3; o4 <= l3 + c3; o4++)
                0 !== o4 && i3.push(new e3.bs(o4, t3));
            }
            return i3;
          }
          isLODDisabled(e4) {
            return (!e4 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
          }
          extendTileCoverForShadows(t3, i3, o3) {
            let r4 = [];
            if (0 === i3[0] && 0 === i3[1])
              return r4;
            for (const o4 of t3) {
              const t4 = o4.canonical, s5 = o4.overscaledZ, n3 = o4.wrap, a3 = 1 << t4.z, l3 = t4.x + 1 < a3, c3 = t4.x > 0, h2 = t4.y + 1 < a3, u3 = t4.y > 0, d2 = o4.wrap - (c3 ? 0 : 1), _3 = o4.wrap + (l3 ? 0 : 1), p3 = c3 ? t4.x - 1 : a3 - 1, f2 = l3 ? t4.x + 1 : 0;
              i3[0] < 0 ? (r4.push(new e3.ap(s5, _3, t4.z, f2, t4.y)), i3[1] < 0 && h2 && (r4.push(new e3.ap(s5, n3, t4.z, t4.x, t4.y + 1)), r4.push(new e3.ap(s5, _3, t4.z, f2, t4.y + 1))), i3[1] > 0 && u3 && (r4.push(new e3.ap(s5, n3, t4.z, t4.x, t4.y - 1)), r4.push(new e3.ap(s5, _3, t4.z, f2, t4.y - 1)))) : i3[0] > 0 ? (r4.push(new e3.ap(s5, d2, t4.z, p3, t4.y)), i3[1] < 0 && h2 && (r4.push(new e3.ap(s5, n3, t4.z, t4.x, t4.y + 1)), r4.push(new e3.ap(s5, d2, t4.z, p3, t4.y + 1))), i3[1] > 0 && u3 && (r4.push(new e3.ap(s5, n3, t4.z, t4.x, t4.y - 1)), r4.push(new e3.ap(s5, d2, t4.z, p3, t4.y - 1)))) : i3[1] < 0 && h2 ? r4.push(new e3.ap(s5, n3, t4.z, t4.x, t4.y + 1)) : u3 && r4.push(new e3.ap(s5, n3, t4.z, t4.x, t4.y - 1));
            }
            if (r4.length > 1) {
              r4.sort((e5, t5) => e5.overscaledZ - t5.overscaledZ || e5.wrap - t5.wrap || e5.canonical.z - t5.canonical.z || e5.canonical.x - t5.canonical.x || e5.canonical.y - t5.canonical.y);
              let e4 = 0, t4 = 0;
              for (; t4 < r4.length; )
                r4[t4].equals(r4[e4]) ? ++t4 : r4[++e4] = r4[t4++];
              r4.length = e4 + 1;
            }
            const s4 = [];
            for (const e4 of r4)
              r4.some((t4) => e4.isChildOf(t4)) || s4.push(e4);
            return r4 = s4.filter((e4) => !t3.some((t4) => !!(e4.overscaledZ < o3 && t4.isChildOf(e4)) || e4.equals(t4) || e4.isChildOf(t4))), r4;
          }
          coveringTiles(t3) {
            let i3 = this.coveringZoomLevel(t3);
            const o3 = i3, r4 = this.elevation && this.elevation.exaggeration(), s4 = r4 && !t3.isTerrainDEM, n3 = "mercator" === this.projection.name;
            if (void 0 !== t3.minzoom && i3 < t3.minzoom)
              return [];
            void 0 !== t3.maxzoom && i3 > t3.maxzoom && (i3 = t3.maxzoom);
            const a3 = this.locationCoordinate(this.center), l3 = this.center.lat, c3 = 1 << i3, h2 = [c3 * a3.x, c3 * a3.y, 0], u3 = "globe" === this.projection.name, d2 = !u3, _3 = e3.bt.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i3, d2), p3 = u3 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f2 = c3 * e3.bo(1, this.center.lat), m2 = this._camera.position[2] / e3.bo(1, this.center.lat), g3 = [c3 * p3.x, c3 * p3.y, m2 * (d2 ? 1 : f2)], v3 = u3 || r4, x3 = this.cameraToCenterDistance / t3.tileSize * (t3.roundZoom ? 1 : 0.502), y3 = this.isLODDisabled(true) ? i3 : 0;
            let b2;
            if (this._elevation && t3.isTerrainDEM)
              b2 = 1e4 * this._elevation.exaggeration();
            else if (this._elevation) {
              const e4 = this._elevation.getMinMaxForVisibleTiles();
              b2 = e4 ? e4.max : this._centerAltitude;
            } else
              b2 = this._centerAltitude;
            const w2 = t3.isTerrainDEM ? -b2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T2 = this.projection.isReprojectedInTileSpace ? e3.bu(this) : 1, E2 = (t4) => {
              const i4 = 1 / 4e4, o4 = new e3.O(t4.x + i4, t4.y, t4.z), r5 = new e3.O(t4.x, t4.y + i4, t4.z), s5 = t4.toLngLat(), n4 = o4.toLngLat(), a4 = r5.toLngLat(), l4 = this.locationCoordinate(s5), c4 = this.locationCoordinate(n4), h3 = this.locationCoordinate(a4), u4 = Math.hypot(c4.x - l4.x, c4.y - l4.y), d3 = Math.hypot(h3.x - l4.x, h3.y - l4.y);
              return Math.sqrt(u4 * d3) * T2 / i4;
            }, S2 = (t4) => {
              const i4 = b2, o4 = w2;
              return { aabb: e3.bx(this, c3, 0, 0, 0, t4, o4, i4, this.projection), zoom: 0, x: 0, y: 0, minZ: o4, maxZ: i4, wrap: t4, fullyVisible: false };
            }, C2 = [];
            let I2 = [];
            const D2 = i3, R3 = t3.reparseOverscaled ? o3 : i3, A2 = (e4) => e4 * e4, P2 = A2((m2 - this._centerAltitude) * f2), L2 = (e4) => {
              if (!this._elevation || !e4.tileID || !n3)
                return;
              const t4 = this._elevation.getMinMaxForTile(e4.tileID), i4 = e4.aabb;
              t4 ? (i4.min[2] = t4.min, i4.max[2] = t4.max, i4.center[2] = (i4.min[2] + i4.max[2]) / 2) : (e4.shouldSplit = M3(e4), e4.shouldSplit || (i4.min[2] = i4.max[2] = i4.center[2] = this._centerAltitude));
            }, M3 = (t4) => {
              if (t4.zoom < y3)
                return true;
              if (t4.zoom === D2)
                return false;
              if (null != t4.shouldSplit)
                return t4.shouldSplit;
              const i4 = t4.aabb.distanceX(g3), r5 = t4.aabb.distanceY(g3);
              let n4 = P2, a4 = 1;
              if (u3) {
                n4 = A2(t4.aabb.distanceZ(g3));
                const i5 = Math.pow(2, t4.zoom), o4 = e3.ax((t4.y + 1) / i5), r6 = e3.ax(t4.y / i5), s5 = Math.min(Math.max(l3, o4), r6), c5 = e3.bM(s5) / e3.bM(l3);
                if (a4 = s5 === l3 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c5 / this._mercatorScaleRatio), this.zoom <= e3.bJ && t4.zoom === D2 - 1 && c5 >= 0.9)
                  return true;
              } else if (s4 && (n4 = A2(t4.aabb.distanceZ(g3) * f2)), this.projection.isReprojectedInTileSpace && o3 <= 5) {
                const i5 = Math.pow(2, t4.zoom), o4 = E2(new e3.O((t4.x + 0.5) / i5, (t4.y + 0.5) / i5));
                a4 = o4 > 0.85 ? 1 : o4;
              }
              const c4 = i4 * i4 + r5 * r5 + n4, h3 = A2((1 << D2 - t4.zoom) * x3 * a4 * ((e4, t5) => {
                if (t5 * A2(0.707) < e4)
                  return 1;
                const i5 = Math.sqrt(t5 / e4);
                return i5 / (1.4144271570014144 + (Math.pow(1.1, i5 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              })(Math.max(n4, P2), c4));
              return c4 < h3;
            };
            if (this.renderWorldCopies)
              for (let e4 = 1; e4 <= 3; e4++)
                C2.push(S2(-e4)), C2.push(S2(e4));
            for (C2.push(S2(0)); C2.length > 0; ) {
              const o4 = C2.pop(), r5 = o4.x, a4 = o4.y;
              let l4 = o4.fullyVisible;
              const d3 = () => "globe" === this.projection.name && (0 === o4.y || o4.y === (1 << o4.zoom) - 1);
              if (!l4) {
                let t4 = v3 ? o4.aabb.intersects(_3) : o4.aabb.intersectsFlat(_3);
                if (0 === t4 && d3()) {
                  const i4 = new e3.bv(o4.zoom, r5, a4);
                  t4 = e3.bw(this, c3, i4, true).intersects(_3);
                }
                if (0 === t4)
                  continue;
                l4 = 2 === t4;
              }
              if (o4.zoom !== D2 && M3(o4))
                for (let t4 = 0; t4 < 4; t4++) {
                  const i4 = (r5 << 1) + t4 % 2, h3 = (a4 << 1) + (t4 >> 1), d4 = { aabb: n3 ? o4.aabb.quadrant(t4) : e3.bx(this, c3, o4.zoom + 1, i4, h3, o4.wrap, o4.minZ, o4.maxZ, this.projection), zoom: o4.zoom + 1, x: i4, y: h3, wrap: o4.wrap, fullyVisible: l4, tileID: void 0, shouldSplit: void 0, minZ: o4.minZ, maxZ: o4.maxZ };
                  s4 && !u3 && (d4.tileID = new e3.ap(o4.zoom + 1 === D2 ? R3 : o4.zoom + 1, o4.wrap, o4.zoom + 1, i4, h3), L2(d4)), C2.push(d4);
                }
              else {
                const s5 = o4.zoom === D2 ? R3 : o4.zoom;
                if (t3.minzoom && t3.minzoom > s5)
                  continue;
                if (!l4) {
                  let t4 = v3 ? o4.aabb.intersectsPrecise(_3) : o4.aabb.intersectsPreciseFlat(_3);
                  if (0 === t4 && d3()) {
                    const i4 = new e3.bv(o4.zoom, r5, a4);
                    t4 = e3.bw(this, c3, i4, true).intersectsPrecise(_3);
                  }
                  if (0 === t4)
                    continue;
                }
                const n4 = h2[0] - (0.5 + r5 + (o4.wrap << o4.zoom)) * (1 << i3 - o4.zoom), u4 = h2[1] - 0.5 - a4, p4 = o4.tileID ? o4.tileID : new e3.ap(s5, o4.wrap, o4.zoom, r5, a4);
                I2.push({ tileID: p4, distanceSq: n4 * n4 + u4 * u4 });
              }
            }
            if (this.fogCullDistSq) {
              const i4 = this.fogCullDistSq, o4 = this.horizonLineFromTop();
              I2 = I2.filter((r5) => {
                const s5 = [0, 0, 0, 1], n4 = [e3.Y, e3.Y, 0, 1], a4 = this.calculateFogTileMatrix(r5.tileID.toUnwrapped());
                e3.aa.transformMat4(s5, s5, a4), e3.aa.transformMat4(n4, n4, a4);
                const l4 = e3.aa.min([], s5, n4), c4 = e3.aa.max([], s5, n4), h3 = e3.by(l4, c4);
                if (0 === h3)
                  return true;
                let u4 = false;
                const d3 = this._elevation;
                if (d3 && h3 > i4 && 0 !== o4) {
                  const i5 = this.calculateProjMatrix(r5.tileID.toUnwrapped());
                  let s6;
                  t3.isTerrainDEM || (s6 = d3.getMinMaxForTile(r5.tileID)), s6 || (s6 = { min: w2, max: b2 });
                  const n5 = e3.bK(this.rotation), a5 = [n5[0] * e3.Y, n5[1] * e3.Y, s6.max];
                  e3.Q.transformMat4(a5, a5, i5), u4 = (1 - a5[1]) * this.height * 0.5 < o4;
                }
                return h3 < i4 || u4;
              });
            }
            return I2.sort((e4, t4) => e4.distanceSq - t4.distanceSq).map((e4) => e4.tileID);
          }
          resize(e4, t3) {
            this.width = e4, this.height = t3, this.pixelsToGLUnits = [2 / e4, -2 / t3], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e4) {
            return Math.pow(2, e4);
          }
          scaleZoom(e4) {
            return Math.log(e4) / Math.LN2;
          }
          project(t3) {
            const i3 = e3.ad(t3.lat, -e3.bz, e3.bz), o3 = this.projection.project(t3.lng, i3);
            return new e3.P(o3.x * this.worldSize, o3.y * this.worldSize);
          }
          unproject(e4) {
            return this.projection.unproject(e4.x / this.worldSize, e4.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / e3.bo(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t3, i3) {
            let o3, r4;
            const s4 = this.centerPoint;
            if ("globe" === this.projection.name) {
              const e4 = this.worldSize;
              o3 = (i3.x - s4.x) / e4, r4 = (i3.y - s4.y) / e4;
            } else {
              const e4 = this.pointCoordinate(i3), t4 = this.pointCoordinate(s4);
              o3 = e4.x - t4.x, r4 = e4.y - t4.y;
            }
            const n3 = this.locationCoordinate(t3);
            this.setLocation(new e3.O(n3.x - o3, n3.y - r4));
          }
          setLocation(e4) {
            this.center = this.coordinateLocation(e4), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(e4) {
            return this.projection.locationPoint(this, e4);
          }
          locationPoint3D(e4) {
            return this.projection.locationPoint(this, e4, true);
          }
          pointLocation(e4) {
            return this.coordinateLocation(this.pointCoordinate(e4));
          }
          pointLocation3D(e4) {
            return this.coordinateLocation(this.pointCoordinate3D(e4));
          }
          locationCoordinate(t3, i3) {
            const o3 = i3 ? e3.bo(i3, t3.lat) : void 0, r4 = this.projection.project(t3.lng, t3.lat);
            return new e3.O(r4.x, r4.y, o3);
          }
          coordinateLocation(e4) {
            return this.projection.unproject(e4.x, e4.y);
          }
          pointRayIntersection(t3, i3) {
            const o3 = null != i3 ? i3 : this._centerAltitude, r4 = [t3.x, t3.y, 0, 1], s4 = [t3.x, t3.y, 1, 1];
            e3.aa.transformMat4(r4, r4, this.pixelMatrixInverse), e3.aa.transformMat4(s4, s4, this.pixelMatrixInverse);
            const n3 = s4[3];
            e3.aa.scale(r4, r4, 1 / r4[3]), e3.aa.scale(s4, s4, 1 / n3);
            const a3 = r4[2], l3 = s4[2];
            return { p0: r4, p1: s4, t: a3 === l3 ? 0 : (o3 - a3) / (l3 - a3) };
          }
          screenPointToMercatorRay(t3) {
            const i3 = [t3.x, t3.y, 0, 1], o3 = [t3.x, t3.y, 1, 1];
            return e3.aa.transformMat4(i3, i3, this.pixelMatrixInverse), e3.aa.transformMat4(o3, o3, this.pixelMatrixInverse), e3.aa.scale(i3, i3, 1 / i3[3]), e3.aa.scale(o3, o3, 1 / o3[3]), i3[2] = e3.bo(i3[2], this._center.lat) * this.worldSize, o3[2] = e3.bo(o3[2], this._center.lat) * this.worldSize, e3.aa.scale(i3, i3, 1 / this.worldSize), e3.aa.scale(o3, o3, 1 / this.worldSize), new e3.a5([i3[0], i3[1], i3[2]], e3.Q.normalize([], e3.Q.sub([], o3, i3)));
          }
          rayIntersectionCoordinate(t3) {
            const { p0: i3, p1: o3, t: r4 } = t3, s4 = e3.bo(i3[2], this._center.lat), n3 = e3.bo(o3[2], this._center.lat);
            return new e3.O(e3.X(i3[0], o3[0], r4) / this.worldSize, e3.X(i3[1], o3[1], r4) / this.worldSize, e3.X(s4, n3, r4));
          }
          pointCoordinate(e4, t3 = this._centerAltitude) {
            return this.projection.pointCoordinate(this, e4.x, e4.y, t3);
          }
          pointCoordinate3D(t3) {
            if (!this.elevation)
              return this.pointCoordinate(t3);
            let i3 = this.projection.pointCoordinate3D(this, t3.x, t3.y);
            if (i3)
              return new e3.O(i3[0], i3[1], i3[2]);
            let o3 = 0, r4 = this.horizonLineFromTop();
            if (t3.y > r4)
              return this.pointCoordinate(t3);
            const s4 = 0.02 * r4, n3 = t3.clone();
            for (let t4 = 0; t4 < 10 && r4 - o3 > s4; t4++) {
              n3.y = e3.X(o3, r4, 0.66);
              const t5 = this.projection.pointCoordinate3D(this, n3.x, n3.y);
              t5 ? (r4 = n3.y, i3 = t5) : o3 = n3.y;
            }
            return i3 ? new e3.O(i3[0], i3[1], i3[2]) : this.pointCoordinate(t3);
          }
          isPointAboveHorizon(e4) {
            return this.projection.isPointAboveHorizon(this, e4);
          }
          isPointOnSurface(t3) {
            if (t3.y < 0 || t3.y > this.height || t3.x < 0 || t3.x > this.width)
              return false;
            if (this.elevation || this.zoom >= e3.bA)
              return !this.isPointAboveHorizon(t3);
            const i3 = this.pointCoordinate(t3);
            return i3.y >= 0 && i3.y <= 1;
          }
          _coordinatePoint(t3, i3) {
            const o3 = i3 && this.elevation ? this.elevation.getAtPointOrZero(t3, this._centerAltitude) : this._centerAltitude, r4 = [t3.x * this.worldSize, t3.y * this.worldSize, o3 + t3.toAltitude(), 1];
            return e3.aa.transformMat4(r4, r4, this.pixelMatrix), r4[3] > 0 ? new e3.P(r4[0] / r4[3], r4[1] / r4[3]) : new e3.P(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t3, left: i3 } = this._edgeInsets, o3 = this.height - this._edgeInsets.bottom, r4 = this.width - this._edgeInsets.right, s4 = this.pointLocation3D(new e3.P(i3, t3)), n3 = this.pointLocation3D(new e3.P(r4, t3)), a3 = this.pointLocation3D(new e3.P(r4, o3)), l3 = this.pointLocation3D(new e3.P(i3, o3));
            let c3 = Math.min(s4.lng, n3.lng, a3.lng, l3.lng), h2 = Math.max(s4.lng, n3.lng, a3.lng, l3.lng), u3 = Math.min(s4.lat, n3.lat, a3.lat, l3.lat), d2 = Math.max(s4.lat, n3.lat, a3.lat, l3.lat);
            const _3 = Math.pow(2, -this.zoom) / 16 * 270, p3 = "globe" === this.projection.name ? 1 : 4, f2 = (t4, i4, o4, r5, s5) => {
              const n4 = (t4 + o4) / 2, a4 = (i4 + r5) / 2, l4 = new e3.P(n4, a4), { lng: m2, lat: g3 } = this.pointLocation3D(l4), v3 = Math.max(0, c3 - m2, u3 - g3, m2 - h2, g3 - d2);
              c3 = Math.min(c3, m2), h2 = Math.max(h2, m2), u3 = Math.min(u3, g3), d2 = Math.max(d2, g3), (s5 < p3 || v3 > _3) && (f2(t4, i4, n4, a4, s5 + 1), f2(n4, a4, o4, r5, s5 + 1));
            };
            if (f2(i3, t3, r4, t3, 1), f2(r4, t3, r4, o3, 1), f2(r4, o3, i3, o3, 1), f2(i3, o3, i3, t3, 1), "globe" === this.projection.name) {
              const [t4, i4] = e3.bB(this);
              t4 ? (d2 = 90, h2 = 180, c3 = -180) : i4 && (u3 = -90, h2 = 180, c3 = -180);
            }
            return new e3.ag(new e3.bq(c3, u3), new e3.bq(h2, d2));
          }
          _getBoundsRectangular(t3, i3) {
            const { top: o3, left: r4 } = this._edgeInsets, s4 = this.height - this._edgeInsets.bottom, n3 = this.width - this._edgeInsets.right, a3 = new e3.P(r4, o3), l3 = new e3.P(n3, o3), c3 = new e3.P(n3, s4), h2 = new e3.P(r4, s4);
            let u3 = this.pointCoordinate(a3, t3), d2 = this.pointCoordinate(l3, t3);
            const _3 = this.pointCoordinate(c3, i3), p3 = this.pointCoordinate(h2, i3), f2 = (e4, t4) => (t4.y - e4.y) / (t4.x - e4.x);
            return u3.y > 1 && d2.y >= 0 ? u3 = new e3.O((1 - p3.y) / f2(p3, u3) + p3.x, 1) : u3.y < 0 && d2.y <= 1 && (u3 = new e3.O(-p3.y / f2(p3, u3) + p3.x, 0)), d2.y > 1 && u3.y >= 0 ? d2 = new e3.O((1 - _3.y) / f2(_3, d2) + _3.x, 1) : d2.y < 0 && u3.y <= 1 && (d2 = new e3.O(-_3.y / f2(_3, d2) + _3.x, 0)), new e3.ag().extend(this.coordinateLocation(u3)).extend(this.coordinateLocation(d2)).extend(this.coordinateLocation(p3)).extend(this.coordinateLocation(_3));
          }
          _getBoundsRectangularTerrain() {
            const e4 = this.elevation;
            if (!e4.visibleDemTiles.length || e4.isUsingMockSource())
              return this._getBoundsRectangular(0, 0);
            const t3 = e4.visibleDemTiles.reduce((e5, t4) => {
              if (t4.dem) {
                const i3 = t4.dem.tree;
                e5.min = Math.min(e5.min, i3.minimums[0]), e5.max = Math.max(e5.max, i3.maximums[0]);
              }
              return e5;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(t3.min * e4.exaggeration(), t3.max * e4.exaggeration());
          }
          getBounds() {
            return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(e4 = true) {
            const t3 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i3 = this.height / 2 - t3 * (1 - this._horizonShift);
            return e4 ? Math.max(0, i3) : i3;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t3) {
            this.maxBounds = t3, this.minLat = -e3.bz, this.maxLat = e3.bz, this.minLng = -180, this.maxLng = 180, t3 && (this.minLat = t3.getSouth(), this.maxLat = t3.getNorth(), this.minLng = t3.getWest(), this.maxLng = t3.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e3.a8(this.minLng) * this.tileSize, this.worldMaxX = e3.a8(this.maxLng) * this.tileSize, this.worldMinY = e3.ah(this.maxLat) * this.tileSize, this.worldMaxY = e3.ah(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(e4, t3) {
            return this.projection.createTileMatrix(this, t3, e4);
          }
          calculateDistanceTileData(t3) {
            const i3 = t3.key, o3 = this._distanceTileDataCache;
            if (o3[i3])
              return o3[i3];
            const r4 = t3.canonical, s4 = 1 / this.height, n3 = this.cameraWorldSize, a3 = n3 / this.zoomScale(r4.z), l3 = (r4.x + Math.pow(2, r4.z) * t3.wrap) * a3, c3 = r4.y * a3, h2 = this.point;
            h2.x *= n3 / this.worldSize, h2.y *= n3 / this.worldSize;
            const u3 = this.angle, d2 = Math.sin(-u3), _3 = -Math.cos(-u3);
            return o3[i3] = { bearing: [d2, _3], center: [(h2.x - l3) * s4, (h2.y - c3) * s4], scale: a3 / e3.Y * s4 }, o3[i3];
          }
          calculateFogTileMatrix(t3) {
            const i3 = t3.key, o3 = this._fogTileMatrixCache;
            if (o3[i3])
              return o3[i3];
            const r4 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t3);
            return e3.a9.multiply(r4, this.worldToFogMatrix, r4), o3[i3] = new Float32Array(r4), o3[i3];
          }
          calculateProjMatrix(t3, i3 = false, o3 = false) {
            const r4 = t3.key;
            let s4;
            if (s4 = o3 ? this._expandedProjMatrixCache : i3 ? this._alignedProjMatrixCache : this._projMatrixCache, s4[r4])
              return s4[r4];
            const n3 = this.calculatePosMatrix(t3, this.worldSize);
            let a3;
            return a3 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o3 ? this.expandedFarZProjMatrix : i3 ? this.alignedProjMatrix : this.projMatrix, e3.a9.multiply(n3, a3, n3), s4[r4] = new Float32Array(n3), s4[r4];
          }
          calculatePixelsToTileUnitsMatrix(t3) {
            const i3 = t3.tileID.key, o3 = this._pixelsToTileUnitsCache;
            if (o3[i3])
              return o3[i3];
            const r4 = e3.bC(t3, this);
            return o3[i3] = r4, o3[i3];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if ("globe" === this.projection.name) {
              const t3 = 1 / this.worldSize, i3 = e3.a9.fromScaling([], [t3, t3, t3]);
              return e3.a9.multiply(i3, i3, this.globeMatrix), i3;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || "globe" === this.projection.name)
              return;
            const t3 = this._elevation;
            this._updateCameraState();
            const i3 = e3.bo(1, this._center.lat) * this.worldSize, o3 = this._computeCameraPosition(i3), r4 = this._camera.forward(), s4 = e3.bo(1, this._center.lat);
            o3[2] /= s4, r4[2] /= s4, e3.Q.normalize(r4, r4);
            const n3 = t3.raycast(o3, r4, t3.exaggeration());
            if (n3) {
              const t4 = e3.Q.scaleAndAdd([], o3, r4, n3), i4 = new e3.O(t4[0], t4[1], e3.bo(t4[2], e3.ax(t4[1]))), a3 = (i4.z + e3.Q.length([i4.x - o3[0], i4.y - o3[1], i4.z - o3[2] * s4])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(a3), this._centerAltitude = i4.toAltitude(), this._center = this.coordinateLocation(i4), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t3 = false) {
            if (!this._elevation)
              return;
            const i3 = this._elevation, o3 = e3.bo(1, this._center.lat) * this.worldSize, r4 = this._computeCameraPosition(o3), s4 = i3.getAtPointOrZero(new e3.O(...r4)), n3 = this.pixelsPerMeter / this.worldSize * s4, a3 = this._minimumHeightOverTerrain(), l3 = r4[2] - n3;
            if (l3 <= a3)
              if (l3 < 0 || t3) {
                const t4 = this.locationCoordinate(this._center, this._centerAltitude), i4 = [r4[0], r4[1], t4.z - r4[2]], o4 = e3.Q.length(i4);
                i4[2] -= (a3 - l3) / this._pixelsPerMercatorPixel;
                const s5 = e3.Q.length(i4);
                if (0 === s5)
                  return;
                e3.Q.scale(i4, i4, o4 / s5 * this._pixelsPerMercatorPixel), this._camera.position = [r4[0], r4[1], t4.z * this._pixelsPerMercatorPixel - i4[2]], this._updateStateFromCamera();
              } else
                this._isCameraConstrained = true;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            this._constraining = true;
            const t3 = "globe" === this.projection.name || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t3) {
              const i4 = this.center;
              return i4.lat = e3.ad(i4.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t3) && (i4.lng = e3.ad(i4.lng, this.minLng, this.maxLng)), this.center = i4, void (this._constraining = false);
            }
            const i3 = this._unmodified, { x: o3, y: r4 } = this.point;
            let s4 = 0, n3 = o3, a3 = r4;
            const l3 = this.width / 2, c3 = this.height / 2, h2 = this.worldMinY * this.scale, u3 = this.worldMaxY * this.scale;
            if (r4 - c3 < h2 && (a3 = h2 + c3), r4 + c3 > u3 && (a3 = u3 - c3), u3 - h2 < this.height && (s4 = Math.max(s4, this.height / (u3 - h2)), a3 = (u3 + h2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const e4 = this.worldMinX * this.scale, t4 = this.worldMaxX * this.scale, i4 = this.worldSize / 2 - (e4 + t4) / 2;
              n3 = (o3 + i4 + this.worldSize) % this.worldSize - i4, n3 - l3 < e4 && (n3 = e4 + l3), n3 + l3 > t4 && (n3 = t4 - l3), t4 - e4 < this.width && (s4 = Math.max(s4, this.width / (t4 - e4)), n3 = (t4 + e4) / 2);
            }
            n3 === o3 && a3 === r4 || (this.center = this.unproject(new e3.P(n3, a3))), s4 && (this.zoom += this.scaleZoom(s4)), this._constrainCamera(), this._unmodified = i3, this._constraining = false;
          }
          _minZoomForBounds() {
            let e4 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (e4 = Math.max(e4, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e4;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const t3 = this.centerOffset, i3 = "globe" === this.projection.name, o3 = this.pixelsPerMeter;
            "globe" === this.projection.name && (this._mercatorScaleRatio = e3.bo(1, this.center.lat) / e3.bo(1, e3.bL));
            const r4 = e3.bD(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r4), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const s4 = "meters" === this.projection.zAxisUnit ? o3 : 1, n3 = this._camera.getWorldToCamera(this.worldSize, s4);
            let a3;
            const l3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            if (l3[8] = 2 * -t3.x / this.width, l3[9] = 2 * t3.y / this.height, this.isOrthographic) {
              let e4 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), i4 = e4 * this.aspect, o4 = -i4, r5 = -e4;
              i4 -= t3.x, o4 -= t3.x, e4 += t3.y, r5 += t3.y, a3 = this._camera.getCameraToClipOrthographic(o4, i4, r5, e4, this._nearZ, this._farZ), ((e5, t4, i5, o5) => {
                for (let r6 = 0; r6 < 16; r6++)
                  e5[r6] = uo(t4[r6], i5[r6], o5);
              })(a3, a3, l3, _o(this.pitch >= 15 ? 1 : this.pitch / 15));
            } else
              a3 = l3;
            const c3 = e3.a9.mul([], l3, n3);
            let h2 = e3.a9.mul([], a3, n3);
            if (this.projection.isReprojectedInTileSpace) {
              const t4 = this.locationCoordinate(this.center), i4 = e3.a9.identity([]);
              e3.a9.translate(i4, i4, [t4.x * this.worldSize, t4.y * this.worldSize, 0]), e3.a9.multiply(i4, i4, e3.bE(this)), e3.a9.translate(i4, i4, [-t4.x * this.worldSize, -t4.y * this.worldSize, 0]), e3.a9.multiply(h2, h2, i4), e3.a9.multiply(c3, c3, i4), this.inverseAdjustmentMatrix = e3.bF(this);
            } else
              this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            if (this.mercatorMatrix = e3.a9.scale([], h2, [this.worldSize, this.worldSize, this.worldSize / s4, 1]), this.projMatrix = h2, this.invProjMatrix = e3.a9.invert(new Float64Array(16), this.projMatrix), i3) {
              const i4 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
              i4[8] = 2 * -t3.x / this.width, i4[9] = 2 * t3.y / this.height, this.expandedFarZProjMatrix = e3.a9.mul([], i4, n3);
            } else
              this.expandedFarZProjMatrix = this.projMatrix;
            const u3 = e3.a9.invert([], a3);
            this.frustumCorners = e3.bG.fromInvProjectionMatrix(u3, this.horizonLineFromTop(), this.height), this.cameraFrustum = e3.bt.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i3);
            const d2 = new Float32Array(16);
            e3.a9.identity(d2), e3.a9.scale(d2, d2, [1, -1, 1]), e3.a9.rotateX(d2, d2, this._pitch), e3.a9.rotateZ(d2, d2, this.angle);
            const _3 = e3.a9.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
            this.starsProjMatrix = e3.a9.clone(_3);
            const p3 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            _3[8] = 2 * -t3.x / this.width, _3[9] = 2 * (t3.y + p3) / this.height, this.skyboxMatrix = e3.a9.multiply(d2, _3, d2);
            const f2 = this.point, m2 = f2.x, g3 = f2.y, v3 = this.width % 2 / 2, x3 = this.height % 2 / 2, y3 = Math.cos(this.angle), b2 = Math.sin(this.angle), w2 = m2 - Math.round(m2) + y3 * v3 + b2 * x3, T2 = g3 - Math.round(g3) + y3 * x3 + b2 * v3, E2 = new Float64Array(h2);
            if (e3.a9.translate(E2, E2, [w2 > 0.5 ? w2 - 1 : w2, T2 > 0.5 ? T2 - 1 : T2, 0]), this.alignedProjMatrix = E2, h2 = e3.a9.create(), e3.a9.scale(h2, h2, [this.width / 2, -this.height / 2, 1]), e3.a9.translate(h2, h2, [1, -1, 0]), this.labelPlaneMatrix = h2, h2 = e3.a9.create(), e3.a9.scale(h2, h2, [1, -1, 1]), e3.a9.translate(h2, h2, [-1, -1, 0]), e3.a9.scale(h2, h2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h2, this.pixelMatrix = e3.a9.multiply(new Float64Array(16), this.labelPlaneMatrix, c3), this._calcFogMatrices(), this._distanceTileDataCache = {}, h2 = e3.a9.invert(new Float64Array(16), this.pixelMatrix), !h2)
              throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = h2, "globe" === this.projection.name || this.mercatorFromTransition) {
              this.globeMatrix = e3.bH(this);
              const t4 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = e3.Q.transformMat4(t4, t4, n3), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else
              this.globeMatrix = h2;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t3 = this.cameraWorldSizeForFog, i3 = this.cameraPixelsPerMeter, o3 = this._camera.position, r4 = 1 / this.height / this._pixelsPerMercatorPixel, s4 = [t3, t3, i3];
            e3.Q.scale(s4, s4, r4), e3.Q.scale(o3, o3, -1), e3.Q.multiply(o3, o3, s4);
            const n3 = e3.a9.create();
            e3.a9.translate(n3, n3, o3), e3.a9.scale(n3, n3, s4), this.mercatorFogMatrix = n3, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t3, i3, r4);
          }
          _computeCameraPosition(e4) {
            const t3 = (e4 = e4 || this.pixelsPerMeter) / this.pixelsPerMeter, i3 = this._camera.forward(), o3 = this.point, r4 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t3 - e4 / this.worldSize * this._centerAltitude;
            return [o3.x / this.worldSize - i3[0] * r4, o3.y / this.worldSize - i3[1] * r4, e4 / this.worldSize * this._centerAltitude - i3[2] * r4];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t3) {
            const i3 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o3 = this._camera.position[2], r4 = t3[2];
            let s4 = 1;
            this.projection.wrap && (this.center = this.center.wrap()), r4 > 0 && (s4 = Math.min((i3 - o3) / r4, 1)), this._camera.position = e3.Q.scaleAndAdd([], this._camera.position, t3, s4), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t3 = this._camera.position, i3 = this._camera.forward(), { pitch: o3, bearing: r4 } = this._camera.getPitchBearing(), s4 = e3.bo(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n3 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e3.bm(this._maxPitch)), a3 = Math.max((t3[2] - s4) / Math.cos(o3), n3), l3 = this._zoomFromMercatorZ(a3);
            e3.Q.scaleAndAdd(t3, t3, i3, a3), this._pitch = e3.ad(o3, e3.bm(this.minPitch), e3.bm(this.maxPitch)), this.angle = e3.bk(r4, -Math.PI, Math.PI), this._setZoom(e3.ad(l3, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e3.O(t3[0], t3[1], t3[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(e4) {
            return Math.pow(2, e4) * this.tileSize;
          }
          _mercatorZfromZoom(e4) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(e4);
          }
          _minimumHeightOverTerrain() {
            const e4 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
            return this._mercatorZfromZoom(e4);
          }
          _zoomFromMercatorZ(e4) {
            return this.scaleZoom(this.cameraToCenterDistance / (e4 * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t3) {
            let i3 = 0, o3 = e3.bA, r4 = 0, s4 = 1 / 0;
            for (; o3 - i3 > 1e-6 && o3 > i3; ) {
              const e4 = i3 + 0.5 * (o3 - i3), n3 = this.tileSize * Math.pow(2, e4), a3 = this.getCameraToCenterDistance(this.projection, e4, n3), l3 = this.scaleZoom(a3 / (t3 * this.tileSize)), c3 = Math.abs(e4 - l3);
              c3 < s4 && (s4 = c3, r4 = e4), e4 < l3 ? i3 = e4 : o3 = e4;
            }
            return r4;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (e3.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t3, i3) {
            const o3 = Math.min(t3.x, i3.x), r4 = Math.max(t3.x, i3.x), s4 = Math.min(t3.y, i3.y), n3 = Math.max(t3.y, i3.y);
            if (s4 < this.horizonLineFromTop(false))
              return true;
            if ("mercator" !== this.projection.name)
              return false;
            const a3 = [new e3.P(o3, s4), new e3.P(r4, n3), new e3.P(o3, n3), new e3.P(r4, s4)], l3 = this.renderWorldCopies ? -3 : 0, c3 = this.renderWorldCopies ? 4 : 1;
            for (const e4 of a3) {
              const t4 = this.pointRayIntersection(e4);
              if (t4.t < 0)
                return true;
              const i4 = this.rayIntersectionCoordinate(t4);
              if (i4.x < l3 || i4.y < 0 || i4.x > c3 || i4.y > 1)
                return true;
            }
            return false;
          }
          isHorizonVisible() {
            return this.pitch + e3.bI(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e3.P(0, 0), new e3.P(this.width, this.height));
          }
          zoomDeltaToMovement(t3, i3) {
            const o3 = e3.Q.length(e3.Q.sub([], this._camera.position, t3)), r4 = this._zoomFromMercatorZ(o3) + i3;
            return o3 - this._mercatorZfromZoom(r4);
          }
          getCameraPoint() {
            if ("globe" === this.projection.name) {
              const t3 = function([t4, i3, o3], r4) {
                const s4 = [t4, i3, o3, 1];
                e3.aa.transformMat4(s4, s4, r4);
                const n3 = s4[3] = Math.max(s4[3], 1e-6);
                return s4[0] /= n3, s4[1] /= n3, s4[2] /= n3, s4;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new e3.P(t3[0], t3[1]);
            }
            {
              const t3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new e3.P(0, t3));
            }
          }
          getCameraToCenterDistance(t3, i3 = this.zoom, o3 = this.worldSize) {
            const r4 = e3.bD(t3, i3, this.width, this.height, 1024), s4 = t3.pixelSpaceConversion(this.center.lat, o3, r4);
            let n3 = 0.5 / Math.tan(0.5 * this._fov) * this.height * s4;
            return this.isOrthographic && (n3 = uo(1, n3, _o(this.pitch >= 15 ? 1 : this.pitch / 15))), n3;
          }
          getWorldToCameraMatrix() {
            const t3 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
            return "globe" === this.projection.name && e3.a9.multiply(t3, t3, this.globeMatrix), t3;
          }
          getFrustum(t3) {
            return e3.bt.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t3, "meters" === this.projection.zAxisUnit);
          }
        }
        const fo = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, ShadowMap0: 10 }, mo = (t3, i3) => {
          if (i3 > 0 && t3.terrain && e3.w("Cutoff is currently disabled on terrain"), i3 <= 0 || t3.terrain)
            return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
          const o3 = t3.transform, r4 = Math.max(Math.abs(o3._zoom - (t3.minCutoffZoom - 1)), 1), s4 = o3.isLODDisabled(false) ? e3.S(60, 45, o3.pitch) : e3.S(30, 15, o3.pitch), n3 = o3._farZ - o3._nearZ, a3 = i3 * o3.height, l3 = ((1 - (c3 = s4)) * o3.cameraToCenterDistance + c3 * (o3._farZ + a3)) * r4;
          var c3;
          return { shouldRenderCutoff: s4 < 1, uniformValues: { u_cutoff_params: [o3._nearZ, o3._farZ, (l3 - o3._nearZ) / n3, (l3 - a3 - o3._nearZ) / n3] } };
        }, go = { cascadeCount: 2, shadowMapResolution: 2048 };
        class vo {
          constructor(e4, t3) {
            this.aabb = e4, this.lastCascade = t3;
          }
        }
        class xo {
          add(e4, t3) {
            const i3 = this.receivers[e4.key];
            void 0 !== i3 ? (i3.aabb.min[0] = Math.min(i3.aabb.min[0], t3.min[0]), i3.aabb.min[1] = Math.min(i3.aabb.min[1], t3.min[1]), i3.aabb.min[2] = Math.min(i3.aabb.min[2], t3.min[2]), i3.aabb.max[0] = Math.max(i3.aabb.max[0], t3.max[0]), i3.aabb.max[1] = Math.max(i3.aabb.max[1], t3.max[1]), i3.aabb.max[2] = Math.max(i3.aabb.max[2], t3.max[2])) : this.receivers[e4.key] = new vo(t3, null);
          }
          clear() {
            this.receivers = {};
          }
          get(e4) {
            return this.receivers[e4.key];
          }
          computeRequiredCascades(t3, i3, o3) {
            const r4 = e3.bV.fromPoints(t3.points);
            let s4 = 0;
            for (const t4 in this.receivers) {
              const n3 = this.receivers[t4];
              if (!n3)
                continue;
              if (!r4.intersectsAabb(n3.aabb))
                continue;
              n3.aabb.min = r4.closestPoint(n3.aabb.min), n3.aabb.max = r4.closestPoint(n3.aabb.max);
              const a3 = n3.aabb.getCorners();
              for (let t5 = 0; t5 < o3.length; t5++) {
                let r5 = true;
                for (const s5 of a3) {
                  const n4 = [s5[0] * i3, s5[1] * i3, s5[2]];
                  if (e3.Q.transformMat4(n4, n4, o3[t5].matrix), n4[0] < -1 || n4[0] > 1 || n4[1] < -1 || n4[1] > 1) {
                    r5 = false;
                    break;
                  }
                }
                if (n3.lastCascade = t5, s4 = Math.max(s4, t5), r5)
                  break;
              }
            }
            return s4 + 1;
          }
        }
        class yo {
          constructor(e4) {
            this.painter = e4, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new xo(), this._depthMode = new Ct(e4.context.gl.LEQUAL, Ct.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = false, this.useNormalOffset = false, e4.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
              this.painter.style.map.triggerRepaint();
            }), e4.tp.registerParameter(go, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), e4.tp.registerParameter(go, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), e4.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: true, label: "numCascadesToRender" });
          }
          destroy() {
            for (const e4 of this._cascades)
              e4.texture.destroy(), e4.framebuffer.destroy();
            this._cascades = [];
          }
          updateShadowParameters(t3, i3) {
            const o3 = this.painter;
            if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !i3 || !i3.properties)
              return;
            const r4 = i3.properties.get("shadow-intensity");
            if (!i3.shadowsEnabled() || r4 <= 0)
              return;
            if (this._shadowLayerCount = o3.style.order.reduce((e4, i4) => {
              const r5 = o3.style._mergedLayers[i4];
              return e4 + (r5.hasShadowPass() && !r5.isHidden(t3.zoom) ? 1 : 0);
            }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled)
              return;
            const s4 = o3.context, n3 = go.shadowMapResolution, a3 = go.shadowMapResolution;
            if (0 === this._cascades.length || go.shadowMapResolution !== this._cascades[0].texture.size[0]) {
              this._cascades = [];
              for (let t4 = 0; t4 < go.cascadeCount; ++t4) {
                const t5 = o3._shadowMapDebug, i4 = s4.gl, r5 = s4.createFramebuffer(n3, a3, t5, "texture"), l4 = new e3.T(s4, { width: n3, height: a3, data: null }, i4.DEPTH_COMPONENT);
                if (r5.depthAttachment.set(l4.texture), t5) {
                  const t6 = new e3.T(s4, { width: n3, height: a3, data: null }, i4.RGBA);
                  r5.colorAttachment.set(t6.texture);
                }
                this._cascades.push({ framebuffer: r5, texture: l4, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e3.bt(), scale: 0 });
              }
            }
            this.shadowDirection = wo(i3);
            let l3 = 0;
            if (t3.elevation) {
              const e4 = t3.elevation, i4 = [1e4, -1e4];
              e4.visibleDemTiles.filter((e5) => e5.dem).forEach((e5) => {
                const t4 = e5.dem.tree;
                i4[0] = Math.min(i4[0], t4.minimums[0]), i4[1] = Math.max(i4[1], t4.maximums[0]);
              }), 1e4 !== i4[0] && (l3 = (i4[1] - i4[0]) * e4.exaggeration());
            }
            const c3 = 1.5 * t3.cameraToCenterDistance, h2 = 3 * c3, u3 = new Float64Array(16);
            for (let i4 = 0; i4 < this._cascades.length; ++i4) {
              const o4 = this._cascades[i4];
              let r5 = t3.height / 50, s5 = 1;
              1 === go.cascadeCount ? s5 = h2 : 0 === i4 ? s5 = c3 : (r5 = c3, s5 = h2);
              const [n4, a4] = Eo(t3, this.shadowDirection, r5, s5, go.shadowMapResolution, l3);
              o4.scale = t3.scale, o4.matrix = n4, o4.boundingSphereRadius = a4, e3.a9.invert(u3, o4.matrix), o4.frustum = e3.bt.fromInvProjectionMatrix(u3, 1, 0, true), o4.far = s5;
            }
            const d2 = this._cascades.length - 1;
            this._uniformValues.u_fade_range = [0.75 * this._cascades[d2].far, this._cascades[d2].far], this._uniformValues.u_shadow_intensity = r4, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / go.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = go.shadowMapResolution, this._uniformValues.u_shadowmap_0 = fo.ShadowMap0, this._uniformValues.u_shadowmap_1 = fo.ShadowMap0 + 1, this._groundShadowTiles = o3.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
            const _3 = o3.transform.elevation;
            for (const e4 of this._groundShadowTiles) {
              let t4 = { min: 0, max: 0 };
              if (_3) {
                const i4 = _3.getMinMaxForTile(e4);
                i4 && (t4 = i4);
              }
              this.addShadowReceiver(e4.toUnwrapped(), t4.min, t4.max);
            }
          }
          get enabled() {
            return this._enabled && !this._forceDisable;
          }
          set enabled(e4) {
            this._enabled = e4;
          }
          drawShadowPass(t3, i3) {
            if (!this.enabled)
              return;
            const o3 = this.painter, r4 = o3.context;
            this._numCascadesToRender = this._receivers.computeRequiredCascades(o3.transform.getFrustum(0), o3.transform.worldSize, this._cascades), r4.viewport.set([0, 0, go.shadowMapResolution, go.shadowMapResolution]);
            for (let s4 = 0; s4 < this._numCascadesToRender; ++s4) {
              o3.currentShadowCascade = s4, r4.bindFramebuffer.set(this._cascades[s4].framebuffer.framebuffer), r4.clear({ color: e3.aA.white, depth: 1 });
              for (const e4 of t3.order) {
                const r5 = t3._mergedLayers[e4];
                if (!r5.hasShadowPass() || r5.isHidden(o3.transform.zoom))
                  continue;
                const s5 = t3.getLayerSourceCache(r5), n3 = s5 ? i3[s5.id] : void 0;
                ("model" === r5.type || n3 && n3.length) && o3.renderLayer(o3, s5, r5, n3);
              }
            }
            o3.currentShadowCascade = 0;
          }
          drawGroundShadows() {
            if (!this.enabled)
              return;
            const e4 = this.painter, t3 = e4.style, i3 = e4.context, o3 = t3.directionalLight, r4 = t3.ambientLight;
            if (!o3 || !r4)
              return;
            const s4 = [], n3 = mo(e4, e4.longestCutoffRange);
            n3.shouldRenderCutoff && s4.push("RENDER_CUTOFF");
            const a3 = To(o3, r4), l3 = new Ct(i3.gl.LEQUAL, Ct.ReadOnly, e4.depthRangeFor3D);
            for (const t4 of this._groundShadowTiles) {
              const o4 = t4.toUnwrapped(), r5 = e4.isTileAffectedByFog(t4), c3 = e4.getOrCreateProgram("groundShadow", { defines: s4, overrideFog: r5 });
              this.setupShadows(o4, c3), e4.uploadCommonUniforms(i3, c3, o4, null, n3);
              const h2 = { u_matrix: e4.transform.calculateProjMatrix(o4), u_ground_shadow_factor: a3 };
              c3.draw(e4, i3.gl.TRIANGLES, l3, Dt.disabled, At.multiply, Mt.disabled, h2, "ground_shadow", e4.tileExtentBuffer, e4.quadTriangleIndexBuffer, e4.tileExtentSegments, {}, e4.transform.zoom, null, null);
            }
          }
          getShadowPassColorMode() {
            return this.painter._shadowMapDebug ? At.unblended : At.disabled;
          }
          getShadowPassDepthMode() {
            return this._depthMode;
          }
          getShadowCastingLayerCount() {
            return this._shadowLayerCount;
          }
          calculateShadowPassMatrixFromTile(t3) {
            const i3 = this.painter.transform, o3 = i3.calculatePosMatrix(t3, i3.worldSize);
            return e3.a9.multiply(o3, this._cascades[this.painter.currentShadowCascade].matrix, o3), Float32Array.from(o3);
          }
          calculateShadowPassMatrixFromMatrix(t3) {
            return e3.a9.multiply(t3, this._cascades[this.painter.currentShadowCascade].matrix, t3), Float32Array.from(t3);
          }
          setupShadows(t3, i3, o3, r4 = 0) {
            if (!this.enabled)
              return;
            const s4 = this.painter.transform, n3 = this.painter.context, a3 = n3.gl, l3 = this._uniformValues, c3 = new Float64Array(16), h2 = s4.calculatePosMatrix(t3, s4.worldSize);
            for (let t4 = 0; t4 < this._cascades.length; t4++)
              e3.a9.multiply(c3, this._cascades[t4].matrix, h2), l3[0 === t4 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c3), n3.activeTexture.set(a3.TEXTURE0 + fo.ShadowMap0 + t4), this._cascades[t4].texture.bind(a3.NEAREST, a3.CLAMP_TO_EDGE);
            if (this.useNormalOffset = !!o3, this.useNormalOffset) {
              const i4 = e3.bU(t3.canonical), n4 = 2 / s4.tileSize * e3.Y / go.shadowMapResolution, a4 = n4 * this._cascades[0].boundingSphereRadius, c4 = n4 * this._cascades[this._cascades.length - 1].boundingSphereRadius, h3 = ("vector-tile" === o3 ? 1 : 3) / Math.pow(2, r4 - t3.canonical.z - (1 - s4.zoom + Math.floor(s4.zoom)));
              l3.u_shadow_normal_offset = [i4, a4 * h3, c4 * h3], l3.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else
              l3.u_shadow_bias = [36e-5, 12e-4, 0.012];
            i3.setShadowUniformValues(n3, l3);
          }
          setupShadowsFromMatrix(t3, i3, o3 = false) {
            if (!this.enabled)
              return;
            const r4 = this.painter.context, s4 = r4.gl, n3 = this._uniformValues, a3 = new Float64Array(16);
            for (let i4 = 0; i4 < go.cascadeCount; i4++)
              e3.a9.multiply(a3, this._cascades[i4].matrix, t3), n3[0 === i4 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a3), r4.activeTexture.set(s4.TEXTURE0 + fo.ShadowMap0 + i4), this._cascades[i4].texture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE);
            if (this.useNormalOffset = o3, o3) {
              const e4 = 5;
              n3.u_shadow_normal_offset = [1, e4, e4], n3.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else
              n3.u_shadow_bias = [36e-5, 12e-4, 0.012];
            i3.setShadowUniformValues(r4, n3);
          }
          getShadowUniformValues() {
            return this._uniformValues;
          }
          getCurrentCascadeFrustum() {
            return this._cascades[this.painter.currentShadowCascade].frustum;
          }
          computeSimplifiedTileShadowVolume(t3, i3, o3, r4) {
            if (r4[2] >= 0)
              return {};
            const s4 = function(t4, i4, o4) {
              const r5 = o4 / (1 << t4.canonical.z);
              return new e3.bV([t4.canonical.x * r5 + t4.wrap * o4, t4.canonical.y * r5 + t4.wrap * o4, 0], [(t4.canonical.x + 1) * r5 + t4.wrap * o4, (t4.canonical.y + 1) * r5 + t4.wrap * o4, i4]);
            }(t3, i3, o3).getCorners(), n3 = i3 / -r4[2];
            r4[0] < 0 ? (e3.Q.add(s4[0], s4[0], [r4[0] * n3, 0, 0]), e3.Q.add(s4[3], s4[3], [r4[0] * n3, 0, 0])) : r4[0] > 0 && (e3.Q.add(s4[1], s4[1], [r4[0] * n3, 0, 0]), e3.Q.add(s4[2], s4[2], [r4[0] * n3, 0, 0])), r4[1] < 0 ? (e3.Q.add(s4[0], s4[0], [0, r4[1] * n3, 0]), e3.Q.add(s4[1], s4[1], [0, r4[1] * n3, 0])) : r4[1] > 0 && (e3.Q.add(s4[2], s4[2], [0, r4[1] * n3, 0]), e3.Q.add(s4[3], s4[3], [0, r4[1] * n3, 0]));
            const a3 = {};
            return a3.vertices = s4, a3.planes = [bo(s4[1], s4[0], s4[4]), bo(s4[2], s4[1], s4[5]), bo(s4[3], s4[2], s4[6]), bo(s4[0], s4[3], s4[7])], a3;
          }
          addShadowReceiver(t3, i3, o3) {
            this._receivers.add(t3, e3.bV.fromTileIdAndHeight(t3, i3, o3));
          }
          getMaxCascadeForTile(e4) {
            const t3 = this._receivers.get(e4);
            return t3 && t3.lastCascade ? t3.lastCascade : 0;
          }
        }
        function bo(t3, i3, o3) {
          const r4 = e3.Q.sub([], o3, i3), s4 = e3.Q.sub([], t3, i3), n3 = e3.Q.cross([], r4, s4), a3 = e3.Q.length(n3);
          return 0 === a3 ? [0, 0, 1, 0] : (e3.Q.scale(n3, n3, 1 / a3), [n3[0], n3[1], n3[2], -e3.Q.dot(n3, i3)]);
        }
        function wo(t3) {
          const i3 = t3.properties.get("direction"), o3 = e3.bT(i3.x, i3.y, i3.z);
          o3[2] = e3.ad(o3[2], 0, 75);
          const r4 = e3.bW([o3[0], o3[1], o3[2]]);
          return e3.Q.fromValues(r4.x, r4.y, r4.z);
        }
        function To(t3, i3) {
          const o3 = t3.properties.get("color"), r4 = t3.properties.get("intensity"), s4 = t3.properties.get("direction"), n3 = [s4.x, s4.y, s4.z], a3 = i3.properties.get("color"), l3 = i3.properties.get("intensity"), c3 = Math.max(e3.Q.dot([0, 0, 1], n3), 0), h2 = [0, 0, 0];
          e3.Q.scale(h2, a3.toArray01Linear().slice(0, 3), l3);
          const u3 = [0, 0, 0];
          return e3.Q.scale(u3, o3.toArray01Linear().slice(0, 3), c3 * r4), e3.bX([h2[0] > 0 ? h2[0] / (h2[0] + u3[0]) : 0, h2[1] > 0 ? h2[1] / (h2[1] + u3[1]) : 0, h2[2] > 0 ? h2[2] / (h2[2] + u3[2]) : 0]);
        }
        function Eo(t3, i3, o3, r4, s4, n3) {
          const a3 = t3.zoom, l3 = t3.scale, c3 = t3.worldSize, h2 = 1 / c3, u3 = t3.aspect, d2 = Math.sqrt(1 + u3 * u3) * Math.tan(0.5 * t3.fovX), _3 = d2 * d2, p3 = r4 - o3, f2 = r4 + o3;
          let m2, g3;
          _3 > p3 / f2 ? (m2 = r4, g3 = r4 * d2) : (m2 = 0.5 * f2 * (1 + _3), g3 = 0.5 * Math.sqrt(p3 * p3 + 2 * (r4 * r4 + o3 * o3) * _3 + f2 * f2 * _3 * _3));
          const v3 = t3.projection.pixelsPerMeter(t3.center.lat, c3), x3 = t3._camera.getCameraToWorldMercator(), y3 = [0, 0, -m2 * h2];
          e3.Q.transformMat4(y3, y3, x3);
          let b2 = g3 * h2;
          const w2 = t3._edgeInsets;
          if (!(0 === w2.left && 0 === w2.top && 0 === w2.right && 0 === w2.bottom || w2.left === w2.right && w2.top === w2.bottom)) {
            const i4 = t3._camera.getWorldToCamera(t3.worldSize, "meters" === t3.projection.zAxisUnit ? v3 : 1), s5 = t3._camera.getCameraToClipPerspective(t3._fov, t3.width / t3.height, o3, r4);
            s5[8] = 2 * -t3.centerOffset.x / t3.width, s5[9] = 2 * t3.centerOffset.y / t3.height;
            const n4 = new Float64Array(16);
            e3.a9.mul(n4, s5, i4);
            const h3 = new Float64Array(16);
            e3.a9.invert(h3, n4);
            const u4 = e3.bt.fromInvProjectionMatrix(h3, c3, a3, true);
            for (const i5 of u4.points) {
              const o4 = ((T2 = i5)[0] /= l3, T2[1] /= l3, T2[2] = e3.bo(T2[2], t3._center.lat), T2);
              b2 = Math.max(b2, e3.Q.len(e3.Q.subtract([], y3, o4)));
            }
          }
          var T2;
          b2 *= s4 / (s4 - 1);
          const E2 = Math.acos(i3[2]), S2 = Math.atan2(-i3[0], -i3[1]), C2 = new ho();
          C2.position = y3, C2.setPitchBearing(E2, S2);
          const I2 = C2.getWorldToCamera(c3, v3), D2 = b2 * c3, R3 = Math.min(t3._mercatorZfromZoom(17) * c3 * -2, -2 * D2), A2 = C2.getCameraToClipOrthographic(-D2, D2, -D2, D2, R3, (D2 + n3 * v3) / i3[2]), P2 = new Float64Array(16);
          e3.a9.multiply(P2, A2, I2);
          const L2 = e3.Q.fromValues(Math.floor(1e6 * y3[0]) / 1e6 * c3, Math.floor(1e6 * y3[1]) / 1e6 * c3, 0), M3 = 0.5 * s4, z3 = [0, 0, 0];
          e3.Q.transformMat4(z3, L2, P2), e3.Q.scale(z3, z3, M3);
          const O2 = [Math.floor(z3[0]), Math.floor(z3[1]), Math.floor(z3[2])], F2 = [0, 0, 0];
          e3.Q.sub(F2, z3, O2), e3.Q.scale(F2, F2, -1 / M3);
          const B2 = new Float64Array(16);
          return e3.a9.identity(B2), e3.a9.translate(B2, B2, F2), e3.a9.multiply(P2, B2, P2), [P2, D2];
        }
        const So = (e4, t3) => ne(e4, t3 && t3.filter((e5) => "source.canvas" !== e5.identifier)), Co = e3.af(ti, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), Io = e3.af(ti, ["setCenter", "setZoom", "setBearing", "setPitch"]), Do = { version: 8, layers: [], sources: {} }, Ro = { duration: 300, delay: 0 };
        class Ao extends e3.E {
          constructor(t3, i3 = {}) {
            super(), this.map = t3, this.scope = i3.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i3.importDepth || 0, this.importsCache = i3.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i3.resolvedImports || /* @__PURE__ */ new Set(), this.transition = e3.e({}, Ro), this._buildingIndex = new Jt(this), this.crossTileSymbolIndex = new ro(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = i3.styleChanges || new v2(), this.dispatcher = i3.dispatcher ? i3.dispatcher : new e3.bZ(e3.b_(), this), i3.imageManager ? this.imageManager = i3.imageManager : (this.imageManager = new w(), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i3.glyphManager ? i3.glyphManager : new e3.b$(t3._requestManager, i3.localFontFamily ? e3.c0.all : i3.localIdeographFontFamily ? e3.c0.ideographs : e3.c0.none, i3.localFontFamily || i3.localIdeographFontFamily), i3.modelManager ? this.modelManager = i3.modelManager : (this.modelManager = new x2(t3._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._order = [], this._markersNeedUpdate = false, this.options = i3.configOptions ? i3.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i3.configDependentLayers ? i3.configDependentLayers : /* @__PURE__ */ new Set(), this._config = i3.config, this._initialConfig = i3.initialConfig, this.dispatcher.broadcast("setReferrer", e3.c1());
            const o3 = this;
            this._rtlTextPluginCallback = Ao.registerForPluginStateChange((t4) => {
              o3.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t4.pluginStatus, pluginURL: t4.pluginURL }, (t5, i4) => {
                if (e3.c2(t5), i4 && i4.every((e4) => e4))
                  for (const e4 in o3._sourceCaches) {
                    const t6 = o3._sourceCaches[e4], i5 = t6.getSource().type;
                    "vector" !== i5 && "geojson" !== i5 || t6.reload();
                  }
              });
            }), this.on("data", (e4) => {
              if ("source" !== e4.dataType || "metadata" !== e4.sourceDataType)
                return;
              const t4 = this.getOwnSource(e4.sourceId);
              if (t4 && t4.vectorLayerIds)
                for (const e5 in this._layers) {
                  const i4 = this._layers[e5];
                  i4.source === t4.id && this._validateLayer(i4);
                }
            });
          }
          load(e4) {
            return e4 ? ("string" == typeof e4 ? this.loadURL(e4) : this.loadJSON(e4), this) : this;
          }
          _getGlobalId(t3) {
            if (!t3)
              return null;
            if ("string" == typeof t3) {
              if (e3.c3(t3))
                return t3;
              const i3 = e3.c4(t3);
              if (!i3.startsWith("http"))
                try {
                  return new URL(i3, location.href).toString();
                } catch (e4) {
                  return i3;
                }
              return i3;
            }
            return `json://${e3.c5(JSON.stringify(t3))}`;
          }
          _diffStyle(t3, i3, o3) {
            this.globalId = this._getGlobalId(t3);
            const r4 = (e4, t4) => {
              try {
                t4(null, this.setState(e4, o3));
              } catch (e5) {
                t4(e5, false);
              }
            };
            if ("string" == typeof t3) {
              const o4 = this.map._requestManager.normalizeStyleURL(t3), s4 = this.map._requestManager.transformRequest(o4, e3.R.Style);
              e3.g(s4, (t4, o5) => {
                t4 ? this.fire(new e3.a(t4)) : o5 && r4(o5, i3);
              });
            } else
              "object" == typeof t3 && r4(t3, i3);
          }
          loadURL(t3, i3 = {}) {
            this.fire(new e3.b("dataloading", { dataType: "style" }));
            const o3 = "boolean" == typeof i3.validate ? i3.validate : !e3.c3(t3);
            this.globalId = this._getGlobalId(t3), t3 = this.map._requestManager.normalizeStyleURL(t3, i3.accessToken), this.resolvedImports.add(t3);
            const r4 = this.importsCache.get(t3);
            if (r4)
              return this._load(r4, o3);
            const s4 = this.map._requestManager.transformRequest(t3, e3.R.Style);
            this._request = e3.g(s4, (i4, r5) => {
              if (this._request = null, i4)
                this.fire(new e3.a(i4));
              else if (r5)
                return this.importsCache.set(t3, r5), this._load(r5, o3);
            });
          }
          loadJSON(t3, i3 = {}) {
            this.fire(new e3.b("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t3), this._request = e3.f.frame(() => {
              this._request = null, this._load(t3, false !== i3.validate);
            });
          }
          loadEmpty() {
            this.fire(new e3.b("dataloading", { dataType: "style" })), this._load(Do, false);
          }
          _loadImports(t3, i3, o3) {
            if (this.importDepth >= 4)
              return e3.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
            const r4 = [];
            for (const e4 of t3) {
              const t4 = this._createFragmentStyle(e4), s4 = new Promise((e5) => {
                t4.once("style.import.load", e5), t4.once("error", e5);
              }).then(() => this.mergeAll());
              if (r4.push(s4), this.resolvedImports.has(e4.url)) {
                t4.loadEmpty();
                continue;
              }
              const n3 = e4.data || this.importsCache.get(e4.url);
              n3 ? (t4.loadJSON(n3, { validate: i3 }), this._isInternalStyle(n3) && (t4.globalId = null)) : e4.url ? t4.loadURL(e4.url, { validate: i3 }) : t4.loadEmpty();
              const a3 = { style: t4, id: e4.id, config: e4.config };
              if (o3) {
                const e5 = this.fragments.findIndex(({ id: e6 }) => e6 === o3);
                this.fragments = this.fragments.slice(0, e5).concat(a3).concat(this.fragments.slice(e5));
              } else
                this.fragments.push(a3);
            }
            return Promise.allSettled(r4);
          }
          getImportGlobalIds(e4 = this, t3 = /* @__PURE__ */ new Set()) {
            for (const i3 of e4.fragments)
              i3.style.globalId && t3.add(i3.style.globalId), this.getImportGlobalIds(i3.style, t3);
            return [...t3.values()];
          }
          _createFragmentStyle(t3) {
            const i3 = this.scope ? e3.aj(t3.id, this.scope) : t3.id;
            let o3;
            const r4 = this._initialConfig && this._initialConfig[i3];
            (t3.config || r4) && (o3 = e3.e({}, t3.config, r4));
            const s4 = new Ao(this.map, { scope: i3, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: o3, configOptions: this.options, configDependentLayers: this._configDependentLayers });
            return s4.setEventedParent(this.map, { style: s4 }), s4;
          }
          _reloadImports() {
            this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.isRootStyle();
          }
          _isInternalStyle(e4) {
            return this.isRootStyle() && (e4.fragment || !!e4.schema && false !== e4.fragment);
          }
          _load(t3, i3) {
            const o3 = t3.schema;
            if (this._isInternalStyle(t3)) {
              const o4 = e3.e({}, Do, { imports: [{ id: "basemap", data: t3, url: "" }] });
              return void this._load(o4, i3);
            }
            if (this.updateConfig(this._config, o3), i3 && So(this, Q(t3)))
              return;
            this._loaded = true, this.stylesheet = e3.c6(t3);
            for (const e4 in t3.sources)
              this.addSource(e4, t3.sources[e4], { validate: false, isInitialLoad: true });
            t3.sprite ? this._loadSprite(t3.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.glyphManager.setURL(t3.glyphs, this.scope);
            const r4 = ei(this.stylesheet.layers);
            if (this._order = r4.map((e4) => e4.id), this.stylesheet.light && e3.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
              if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                const e4 = this.stylesheet.lights[0];
                this.light = new le(e4.properties, e4.id);
              } else
                this.setLights(this.stylesheet.lights);
            this.light || (this.light = new le(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};
            for (const t4 of r4) {
              const i4 = e3.c7(t4, this.scope, this.options);
              i4.isConfigDependent && this._configDependentLayers.add(i4.fqid), i4.setEventedParent(this, { layer: { id: i4.id } }), this._layers[i4.id] = i4, this._serializedLayers[i4.id] = i4.serialize();
              const o4 = this.getOwnLayerSourceCache(i4), r5 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              o4 && i4.canCastShadows() && r5 && (o4.castsShadows = true);
            }
            this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
            const s4 = this.stylesheet.terrain;
            s4 && (void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e3.f.hasCanvasFingerprintNoise()), this.disableElevatedTerrain ? e3.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).") : this.terrainSetForDrapingOnly() || this._createTerrain(s4, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e3.b("data", { dataType: "style" }));
            const n3 = this.isRootStyle();
            t3.imports ? this._loadImports(t3.imports, i3).then(() => {
              this._reloadImports(), this.fire(new e3.b(n3 ? "style.load" : "style.import.load"));
            }) : (this._reloadImports(), this.fire(new e3.b(n3 ? "style.load" : "style.import.load")));
          }
          isRootStyle() {
            return 0 === this.importDepth;
          }
          mergeAll() {
            let t3, i3, o3, r4, s4, n3, a3, l3;
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e4) => {
              if (e4.stylesheet) {
                if (null != e4.light && (t3 = e4.light), e4.stylesheet.lights)
                  for (const t4 of e4.stylesheet.lights)
                    "ambient" === t4.type && null != e4.ambientLight && (i3 = e4.ambientLight), "directional" === t4.type && null != e4.directionalLight && (o3 = e4.directionalLight);
                r4 = this._prioritizeTerrain(r4, e4.terrain, e4.stylesheet.terrain), e4.stylesheet.fog && null != e4.fog && (s4 = e4.fog), null != e4.stylesheet.camera && (l3 = e4.stylesheet.camera), null != e4.stylesheet.projection && (n3 = e4.stylesheet.projection), null != e4.stylesheet.transition && (a3 = e4.stylesheet.transition);
              }
            }), this.light = t3, this.ambientLight = i3, this.directionalLight = o3, this.fog = s4, null === r4 ? delete this.terrain : this.terrain = r4, this.camera = l3 || { "camera-projection": "perspective" }, this.projection = n3 || { name: "mercator" }, this.transition = e3.e({}, Ro, a3), this.mergeSources(), this.mergeLayers();
          }
          forEachFragmentStyle(e4) {
            const t3 = (i3) => {
              for (const e5 of i3.fragments)
                t3(e5.style);
              e4(i3);
            };
            t3(this);
          }
          _prioritizeTerrain(e4, t3, i3) {
            const o3 = e4 && 0 === e4.drapeRenderMode;
            return null === i3 ? t3 && 0 === t3.drapeRenderMode ? t3 : o3 ? e4 : null : null != t3 && (!e4 || o3 || t3 && 1 === t3.drapeRenderMode) ? t3 : e4;
          }
          mergeTerrain() {
            let e4;
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t3) => {
              e4 = this._prioritizeTerrain(e4, t3.terrain, t3.stylesheet.terrain);
            }), null === e4 ? delete this.terrain : this.terrain = e4;
          }
          mergeProjection() {
            let e4;
            this.forEachFragmentStyle((t3) => {
              null != t3.stylesheet.projection && (e4 = t3.stylesheet.projection);
            }), this.projection = e4 || { name: "mercator" };
          }
          mergeSources() {
            const t3 = {}, i3 = {}, o3 = {};
            this.forEachFragmentStyle((r4) => {
              for (const i4 in r4._sourceCaches) {
                const o4 = e3.aj(i4, r4.scope);
                t3[o4] = r4._sourceCaches[i4];
              }
              for (const t4 in r4._otherSourceCaches) {
                const o4 = e3.aj(t4, r4.scope);
                i3[o4] = r4._otherSourceCaches[t4];
              }
              for (const t4 in r4._symbolSourceCaches) {
                const i4 = e3.aj(t4, r4.scope);
                o3[i4] = r4._symbolSourceCaches[t4];
              }
            }), this._mergedSourceCaches = t3, this._mergedOtherSourceCaches = i3, this._mergedSymbolSourceCaches = o3;
          }
          mergeLayers() {
            const t3 = {}, i3 = [], o3 = {};
            this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o4) => {
              for (const r5 of o4._order) {
                const s4 = o4._layers[r5];
                if ("slot" === s4.type) {
                  const i4 = e3.c8(r5);
                  if (t3[i4])
                    continue;
                  t3[i4] = [];
                }
                s4.slot && t3[s4.slot] ? t3[s4.slot].push(s4) : i3.push(s4);
              }
            }), this._mergedOrder = [];
            const r4 = (i4 = []) => {
              for (const s4 of i4)
                if ("slot" === s4.type) {
                  const i5 = e3.c8(s4.id);
                  t3[i5] && r4(t3[i5]);
                } else {
                  const t4 = e3.aj(s4.id, s4.scope);
                  this._mergedOrder.push(t4), o3[t4] = s4, s4.is3D() && (this._has3DLayers = true), "circle" === s4.type && (this._hasCircleLayers = true), "symbol" === s4.type && (this._hasSymbolLayers = true);
                }
            };
            r4(i3), this._mergedLayers = o3, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && 0 === this.terrain.drapeRenderMode;
          }
          getCamera() {
            return this.stylesheet.camera;
          }
          setCamera(t3) {
            return this.stylesheet.camera = e3.e({}, this.stylesheet.camera, t3), this.camera = this.stylesheet.camera, this;
          }
          setProjection(e4) {
            e4 ? this.stylesheet.projection = e4 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
          }
          _updateMapProjection() {
            this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
          }
          _loadSprite(t3) {
            this._spriteRequest = function(t4, i3, o3) {
              let r4, s4, n3;
              const a3 = e3.f.devicePixelRatio > 1 ? "@2x" : "";
              let l3 = e3.g(i3.transformRequest(i3.normalizeSpriteURL(t4, a3, ".json"), e3.R.SpriteJSON), (e4, t5) => {
                l3 = null, n3 || (n3 = e4, r4 = t5, h2());
              }), c3 = e3.d(i3.transformRequest(i3.normalizeSpriteURL(t4, a3, ".png"), e3.R.SpriteImage), (e4, t5) => {
                c3 = null, n3 || (n3 = e4, s4 = t5, h2());
              });
              function h2() {
                if (n3)
                  o3(n3);
                else if (r4 && s4) {
                  const t5 = e3.f.getImageData(s4), i4 = {};
                  for (const o4 in r4) {
                    const { width: s5, height: n4, x: a4, y: l4, sdf: c4, pixelRatio: h3, stretchX: u3, stretchY: d2, content: _3 } = r4[o4], p3 = new e3.h({ width: s5, height: n4 });
                    e3.h.copy(t5, p3, { x: a4, y: l4 }, { x: 0, y: 0 }, { width: s5, height: n4 }), i4[o4] = { data: p3, pixelRatio: h3, sdf: c4, stretchX: u3, stretchY: d2, content: _3 };
                  }
                  o3(null, i4);
                }
              }
              return { cancel() {
                l3 && (l3.cancel(), l3 = null), c3 && (c3.cancel(), c3 = null);
              } };
            }(t3, this.map._requestManager, (t4, i3) => {
              if (this._spriteRequest = null, t4)
                this.fire(new e3.a(t4));
              else if (i3)
                for (const e4 in i3)
                  this.imageManager.addImage(e4, this.scope, i3[e4]);
              this.imageManager.setLoaded(true, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e3.b("data", { dataType: "style" }));
            });
          }
          _validateLayer(t3) {
            const i3 = this.getOwnSource(t3.source);
            if (!i3)
              return;
            const o3 = t3.sourceLayer;
            o3 && ("geojson" === i3.type || i3.vectorLayerIds && -1 === i3.vectorLayerIds.indexOf(o3)) && this.fire(new e3.a(new Error(`Source layer "${o3}" does not exist on source "${i3.id}" as specified by style layer "${t3.id}"`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._changes.getUpdatedSourceCaches()).length)
              return false;
            for (const e4 in this._sourceCaches)
              if (!this._sourceCaches[e4].loaded())
                return false;
            if (!this.imageManager.isLoaded())
              return false;
            if (!this.modelManager.isLoaded())
              return false;
            for (const { style: e4 } of this.fragments)
              if (!e4.loaded())
                return false;
            return true;
          }
          _serializeImports() {
            if (this.stylesheet.imports)
              return this.stylesheet.imports.map((e4, t3) => {
                const i3 = this.fragments[t3];
                return i3 && i3.style && (e4.data = i3.style.serialize()), e4;
              });
          }
          _serializeSources() {
            const e4 = {};
            for (const t3 in this._sourceCaches) {
              const i3 = this._sourceCaches[t3].getSource();
              e4[i3.id] || (e4[i3.id] = i3.serialize());
            }
            return e4;
          }
          _serializeLayers(e4) {
            const t3 = [];
            for (const i3 of e4) {
              const e5 = this._layers[i3];
              e5 && "custom" !== e5.type && t3.push(e5.serialize());
            }
            return t3;
          }
          hasLightTransitions() {
            return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
          }
          hasFogTransition() {
            return !!this.fog && this.fog.hasTransition();
          }
          hasTransitions() {
            if (this.hasLightTransitions())
              return true;
            if (this.hasFogTransition())
              return true;
            for (const e4 in this._sourceCaches)
              if (this._sourceCaches[e4].hasTransition())
                return true;
            for (const e4 in this._layers)
              if (this._layers[e4].hasTransition())
                return true;
            return false;
          }
          get order() {
            return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
          }
          isLayerDraped(e4) {
            return !!this.terrain && e4.isDraped(this.getLayerSourceCache(e4));
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading");
          }
          _checkLayer(t3) {
            const i3 = this.getOwnLayer(t3);
            if (i3)
              return i3;
            this.fire(new e3.a(new Error(`The layer '${t3}' does not exist in the map's style.`)));
          }
          _checkSource(t3) {
            const i3 = this.getOwnSource(t3);
            if (i3)
              return i3;
            this.fire(new e3.a(new Error(`The source '${t3}' does not exist in the map's style.`)));
          }
          update(t3) {
            if (!this._loaded)
              return;
            this.ambientLight && this.ambientLight.recalculate(t3), this.directionalLight && this.directionalLight.recalculate(t3);
            const i3 = this.calculateLightsBrightness();
            t3.brightness = i3 || 0, i3 !== this._brightness && (this._brightness = i3, this.dispatcher.broadcast("setBrightness", i3));
            const o3 = this._changes.isDirty();
            if (this._changes.isDirty()) {
              const e4 = this._changes.getLayerUpdatesByScope();
              for (const t4 in e4) {
                const { updatedIds: i4, removedIds: o4 } = e4[t4];
                (i4 || o4) && this._updateWorkerLayers(t4, i4, o4);
              }
              this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t3), this.light && this.light.updateTransitions(t3), this.ambientLight && this.ambientLight.updateTransitions(t3), this.directionalLight && this.directionalLight.updateTransitions(t3), this.fog && this.fog.updateTransitions(t3), this._changes.reset();
            }
            const r4 = {};
            for (const e4 in this._mergedSourceCaches) {
              const t4 = this._mergedSourceCaches[e4];
              r4[e4] = t4.used, t4.used = false, t4.tileCoverLift = 0;
            }
            for (const e4 of this._mergedOrder) {
              const i4 = this._mergedLayers[e4];
              if (i4.recalculate(t3, this._availableImages), !i4.isHidden(t3.zoom)) {
                const e5 = this.getLayerSourceCache(i4);
                e5 && (e5.used = true, e5.tileCoverLift = Math.max(e5.tileCoverLift, i4.tileCoverLift()));
              }
              if (!this._precompileDone && this._shouldPrecompile)
                for (let e5 = i4.minzoom || 0; e5 < (i4.maxzoom || 25.5); e5++) {
                  const e6 = this.map.painter;
                  if (e6) {
                    const o4 = i4.getProgramIds();
                    if (!o4)
                      continue;
                    for (const r5 of o4) {
                      const o5 = i4.getDefaultProgramParams(r5, t3.zoom);
                      o5 && (e6.style = this, this.fog && (e6._fogVisible = true, o5.overrideFog = true, e6.getOrCreateProgram(r5, o5)), e6._fogVisible = false, o5.overrideFog = false, e6.getOrCreateProgram(r5, o5), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o5.overrideRtt = true, e6.getOrCreateProgram(r5, o5)));
                    }
                  }
                }
            }
            this._shouldPrecompile && (this._precompileDone = true);
            for (const t4 in r4) {
              const i4 = this._mergedSourceCaches[t4];
              r4[t4] !== i4.used && i4.getSource().fire(new e3.b("data", { sourceDataType: "visibility", dataType: "source", sourceId: i4.getSource().id }));
            }
            this.light && this.light.recalculate(t3), this.terrain && this.terrain.recalculate(t3), this.fog && this.fog.recalculate(t3), this.z = t3.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), o3 && this.fire(new e3.b("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e4 = this._changes.getUpdatedImages();
            if (e4.length) {
              for (const t3 in this._sourceCaches)
                this._sourceCaches[t3].reloadTilesForDependencies(["icons", "patterns"], e4);
              this._changes.resetUpdatedImages();
            }
          }
          _updateWorkerLayers(e4, t3, i3) {
            const o3 = this.getFragmentStyle(e4);
            o3 && this.dispatcher.broadcast("updateLayers", { layers: t3 ? o3._serializeLayers(t3) : [], scope: e4, removedIds: i3 || [], options: o3.options });
          }
          setState(i3, o3) {
            if (this._checkLoaded(), So(this, Q(i3)))
              return false;
            (i3 = e3.c6(i3)).layers = ei(i3.layers);
            const r4 = function(e4, i4) {
              if (!e4)
                return [{ command: ti.setStyle, args: [i4] }];
              let o4 = [];
              try {
                if (!t2(e4.version, i4.version))
                  return [{ command: ti.setStyle, args: [i4] }];
                t2(e4.center, i4.center) || o4.push({ command: ti.setCenter, args: [i4.center] }), t2(e4.zoom, i4.zoom) || o4.push({ command: ti.setZoom, args: [i4.zoom] }), t2(e4.bearing, i4.bearing) || o4.push({ command: ti.setBearing, args: [i4.bearing] }), t2(e4.pitch, i4.pitch) || o4.push({ command: ti.setPitch, args: [i4.pitch] }), t2(e4.sprite, i4.sprite) || o4.push({ command: ti.setSprite, args: [i4.sprite] }), t2(e4.glyphs, i4.glyphs) || o4.push({ command: ti.setGlyphs, args: [i4.glyphs] }), t2(e4.imports, i4.imports) || function(e5 = [], i5 = [], o5) {
                  i5 = i5 || [];
                  const r6 = (e5 = e5 || []).map(ai), s6 = i5.map(ai), n5 = e5.reduce(li, {}), a4 = i5.reduce(li, {}), l3 = r6.slice();
                  let c3, h2, u3, d2;
                  for (c3 = 0, h2 = 0; c3 < r6.length; c3++)
                    u3 = r6[c3], a4.hasOwnProperty(u3) ? h2++ : (o5.push({ command: ti.removeImport, args: [u3] }), l3.splice(l3.indexOf(u3, h2), 1));
                  for (c3 = 0, h2 = 0; c3 < s6.length; c3++)
                    u3 = s6[s6.length - 1 - c3], l3[l3.length - 1 - c3] !== u3 && (n5.hasOwnProperty(u3) ? (o5.push({ command: ti.removeImport, args: [u3] }), l3.splice(l3.lastIndexOf(u3, l3.length - h2), 1)) : h2++, d2 = l3[l3.length - c3], o5.push({ command: ti.addImport, args: [a4[u3], d2] }), l3.splice(l3.length - c3, 0, u3));
                  for (const e6 of i5) {
                    const i6 = n5[e6.id];
                    i6 && !t2(i6, e6) && o5.push({ command: ti.updateImport, args: [e6.id, e6] });
                  }
                }(e4.imports, i4.imports, o4), t2(e4.transition, i4.transition) || o4.push({ command: ti.setTransition, args: [i4.transition] }), t2(e4.light, i4.light) || o4.push({ command: ti.setLight, args: [i4.light] }), t2(e4.fog, i4.fog) || o4.push({ command: ti.setFog, args: [i4.fog] }), t2(e4.projection, i4.projection) || o4.push({ command: ti.setProjection, args: [i4.projection] }), t2(e4.lights, i4.lights) || o4.push({ command: ti.setLights, args: [i4.lights] }), t2(e4.camera, i4.camera) || o4.push({ command: ti.setCamera, args: [i4.camera] });
                const r5 = {}, s5 = [];
                !function(e5, i5, o5, r6) {
                  let s6;
                  for (s6 in i5 = i5 || {}, e5 = e5 || {})
                    e5.hasOwnProperty(s6) && (i5.hasOwnProperty(s6) || oi(s6, o5, r6));
                  for (s6 in i5) {
                    if (!i5.hasOwnProperty(s6))
                      continue;
                    const n5 = i5[s6];
                    e5.hasOwnProperty(s6) ? t2(e5[s6], n5) || ("geojson" === e5[s6].type && "geojson" === n5.type && si(e5, i5, s6) ? o5.push({ command: ti.setGeoJSONSourceData, args: [s6, n5.data] }) : ri(s6, i5, o5, r6)) : ii(s6, i5, o5);
                  }
                }(e4.sources, i4.sources, s5, r5);
                const n4 = [];
                e4.layers && e4.layers.forEach((e5) => {
                  e5.source && r5[e5.source] ? o4.push({ command: ti.removeLayer, args: [e5.id] }) : n4.push(e5);
                });
                let a3 = e4.terrain;
                a3 && r5[a3.source] && (o4.push({ command: ti.setTerrain, args: [void 0] }), a3 = void 0), o4 = o4.concat(s5), t2(a3, i4.terrain) || o4.push({ command: ti.setTerrain, args: [i4.terrain] }), function(e5, i5, o5) {
                  i5 = i5 || [];
                  const r6 = (e5 = e5 || []).map(ai), s6 = i5.map(ai), n5 = e5.reduce(li, {}), a4 = i5.reduce(li, {}), l3 = r6.slice(), c3 = /* @__PURE__ */ Object.create(null);
                  let h2, u3, d2, _3, p3, f2, m2;
                  for (h2 = 0, u3 = 0; h2 < r6.length; h2++)
                    d2 = r6[h2], a4.hasOwnProperty(d2) ? u3++ : (o5.push({ command: ti.removeLayer, args: [d2] }), l3.splice(l3.indexOf(d2, u3), 1));
                  for (h2 = 0, u3 = 0; h2 < s6.length; h2++)
                    d2 = s6[s6.length - 1 - h2], l3[l3.length - 1 - h2] !== d2 && (n5.hasOwnProperty(d2) ? (o5.push({ command: ti.removeLayer, args: [d2] }), l3.splice(l3.lastIndexOf(d2, l3.length - u3), 1)) : u3++, f2 = l3[l3.length - h2], o5.push({ command: ti.addLayer, args: [a4[d2], f2] }), l3.splice(l3.length - h2, 0, d2), c3[d2] = true);
                  for (h2 = 0; h2 < s6.length; h2++)
                    if (d2 = s6[h2], _3 = n5[d2], p3 = a4[d2], !c3[d2] && !t2(_3, p3))
                      if (t2(_3.source, p3.source) && t2(_3["source-layer"], p3["source-layer"]) && t2(_3.type, p3.type)) {
                        for (m2 in ni(_3.layout, p3.layout, o5, d2, null, ti.setLayoutProperty), ni(_3.paint, p3.paint, o5, d2, null, ti.setPaintProperty), t2(_3.slot, p3.slot) || o5.push({ command: ti.setSlot, args: [d2, p3.slot] }), t2(_3.filter, p3.filter) || o5.push({ command: ti.setFilter, args: [d2, p3.filter] }), t2(_3.minzoom, p3.minzoom) && t2(_3.maxzoom, p3.maxzoom) || o5.push({ command: ti.setLayerZoomRange, args: [d2, p3.minzoom, p3.maxzoom] }), _3)
                          _3.hasOwnProperty(m2) && "layout" !== m2 && "paint" !== m2 && "filter" !== m2 && "metadata" !== m2 && "minzoom" !== m2 && "maxzoom" !== m2 && "slot" !== m2 && (0 === m2.indexOf("paint.") ? ni(_3[m2], p3[m2], o5, d2, m2.slice(6), ti.setPaintProperty) : t2(_3[m2], p3[m2]) || o5.push({ command: ti.setLayerProperty, args: [d2, m2, p3[m2]] }));
                        for (m2 in p3)
                          p3.hasOwnProperty(m2) && !_3.hasOwnProperty(m2) && "layout" !== m2 && "paint" !== m2 && "filter" !== m2 && "metadata" !== m2 && "minzoom" !== m2 && "maxzoom" !== m2 && "slot" !== m2 && (0 === m2.indexOf("paint.") ? ni(_3[m2], p3[m2], o5, d2, m2.slice(6), ti.setPaintProperty) : t2(_3[m2], p3[m2]) || o5.push({ command: ti.setLayerProperty, args: [d2, m2, p3[m2]] }));
                      } else
                        o5.push({ command: ti.removeLayer, args: [d2] }), f2 = l3[l3.lastIndexOf(d2) + 1], o5.push({ command: ti.addLayer, args: [p3, f2] });
                }(n4, i4.layers, o4);
              } catch (e5) {
                console.warn("Unable to compute style diff:", e5), o4 = [{ command: ti.setStyle, args: [i4] }];
              }
              return o4;
            }(this.serialize(), i3).filter((e4) => !(e4.command in Io));
            if (0 === r4.length)
              return false;
            const s4 = r4.filter((e4) => !(e4.command in Co));
            if (s4.length > 0)
              throw new Error(`Unimplemented: ${s4.map((e4) => e4.command).join(", ")}.`);
            const n3 = [];
            return r4.forEach((e4) => {
              n3.push(this[e4.command].apply(this, e4.args));
            }), o3 && Promise.all(n3).then(o3), this.stylesheet = i3, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
          }
          addImage(t3, i3) {
            return this.getImage(t3) ? this.fire(new e3.a(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t3, this.scope, i3), this._afterImageUpdated(t3), this);
          }
          updateImage(e4, t3) {
            this.imageManager.updateImage(e4, this.scope, t3);
          }
          getImage(e4) {
            return this.imageManager.getImage(e4, this.scope);
          }
          removeImage(t3) {
            return this.getImage(t3) ? (this.imageManager.removeImage(t3, this.scope), this._afterImageUpdated(t3), this) : this.fire(new e3.a(new Error("No image with this name exists.")));
          }
          _afterImageUpdated(t3) {
            this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t3), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new e3.b("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addModel(e4, t3, i3 = {}) {
            return this._checkLoaded(), this._validate(re, `models.${e4}`, t3, null, i3) || (this.modelManager.addModel(e4, t3, this.scope), this._changes.setDirty()), this;
          }
          hasModel(e4) {
            return this.modelManager.hasModel(e4, this.scope);
          }
          removeModel(t3) {
            return this.hasModel(t3) ? (this.modelManager.removeModel(t3, this.scope), this) : this.fire(new e3.a(new Error("No model with this ID exists.")));
          }
          listModels() {
            return this._checkLoaded(), this.modelManager.listModels(this.scope);
          }
          addSource(t3, i3, o3 = {}) {
            if (this._checkLoaded(), void 0 !== this.getOwnSource(t3))
              throw new Error(`There is already a source with ID "${t3}".`);
            if (!i3.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i3).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate($, `sources.${t3}`, i3, null, o3))
              return;
            this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
            const r4 = Gt(t3, i3, this.dispatcher, this);
            r4.scope = this.scope, r4.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(r4.id), source: r4.serialize(), sourceId: r4.id }));
            const s4 = (t4) => {
              const i4 = (t4 ? "symbol:" : "other:") + r4.id, o4 = e3.aj(i4, this.scope), s5 = this._sourceCaches[i4] = new Qt(o4, r4, t4);
              (t4 ? this._symbolSourceCaches : this._otherSourceCaches)[r4.id] = s5, s5.onAdd(this.map);
            };
            s4(false), "vector" !== i3.type && "geojson" !== i3.type || s4(true), r4.onAdd && r4.onAdd(this.map), o3.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
          }
          removeSource(t3) {
            this._checkLoaded();
            const i3 = this.getOwnSource(t3);
            if (!i3)
              throw new Error("There is no source with this ID");
            for (const i4 in this._layers)
              if (this._layers[i4].source === t3)
                return this.fire(new e3.a(new Error(`Source "${t3}" cannot be removed while layer "${i4}" is using it.`)));
            if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t3)
              return this.fire(new e3.a(new Error(`Source "${t3}" cannot be removed while terrain is using it.`)));
            const o3 = this.getOwnSourceCaches(t3);
            for (const t4 of o3) {
              const i4 = e3.c8(t4.id);
              delete this._sourceCaches[i4], this._changes.discardSourceCacheUpdate(t4.id), t4.fire(new e3.b("data", { sourceDataType: "metadata", dataType: "source", sourceId: t4.getSource().id })), t4.setEventedParent(null), t4.clearTiles();
            }
            return delete this._otherSourceCaches[t3], delete this._symbolSourceCaches[t3], this.mergeSources(), i3.setEventedParent(null), i3.onRemove && i3.onRemove(this.map), this._changes.setDirty(), this;
          }
          setGeoJSONSourceData(e4, t3) {
            this._checkLoaded(), this.getOwnSource(e4).setData(t3), this._changes.setDirty();
          }
          getOwnSource(e4) {
            const t3 = this.getOwnSourceCache(e4);
            return t3 && t3.getSource();
          }
          getOwnSources() {
            const e4 = [];
            for (const t3 in this._otherSourceCaches) {
              const i3 = this.getOwnSourceCache(t3);
              i3 && e4.push(i3.getSource());
            }
            return e4;
          }
          areTilesLoaded() {
            const e4 = this._mergedSourceCaches;
            for (const t3 in e4) {
              const i3 = e4[t3]._tiles;
              for (const e5 in i3) {
                const t4 = i3[e5];
                if ("loaded" !== t4.state && "errored" !== t4.state)
                  return false;
              }
            }
            return true;
          }
          setLights(t3) {
            if (this._checkLoaded(), !t3)
              return delete this.ambientLight, void delete this.directionalLight;
            const i3 = this._getTransitionParameters();
            for (const e4 of t3) {
              if (this._validate(Y, "lights", e4))
                return;
              switch (e4.type) {
                case "ambient":
                  if (this.ambientLight) {
                    const t4 = this.ambientLight;
                    t4.set(e4), t4.updateTransitions(i3);
                  } else
                    this.ambientLight = new ye(e4, be, this.scope, this.options);
                  break;
                case "directional":
                  if (this.directionalLight) {
                    const t4 = this.directionalLight;
                    t4.set(e4), t4.updateTransitions(i3);
                  } else
                    this.directionalLight = new ye(e4, we, this.scope, this.options);
              }
            }
            const o3 = new e3.N(this.z || 0, i3);
            this.ambientLight && this.ambientLight.recalculate(o3), this.directionalLight && this.directionalLight.recalculate(o3), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
          }
          calculateLightsBrightness() {
            const t3 = this.directionalLight, i3 = this.ambientLight;
            if (!t3 || !i3)
              return;
            const o3 = (e4) => 0.2126 * (e4[0] <= 0.03928 ? e4[0] / 12.92 : Math.pow((e4[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e4[1] <= 0.03928 ? e4[1] / 12.92 : Math.pow((e4[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e4[2] <= 0.03928 ? e4[2] / 12.92 : Math.pow((e4[2] + 0.055) / 1.055, 2.4)), r4 = t3.properties.get("color").toArray01(), s4 = t3.properties.get("intensity"), n3 = t3.properties.get("direction"), a3 = 1 - e3.bT(n3.x, n3.y, n3.z)[2] / 90, l3 = o3(r4) * s4 * a3, c3 = i3.properties.get("color").toArray01(), h2 = i3.properties.get("intensity");
            return (l3 + o3(c3) * h2) / 2;
          }
          getBrightness() {
            return this._brightness;
          }
          getLights() {
            if (!this.enable3dLights())
              return null;
            const e4 = [];
            return this.directionalLight && e4.push(this.directionalLight.get()), this.ambientLight && e4.push(this.ambientLight.get()), e4;
          }
          enable3dLights() {
            return !!this.ambientLight && !!this.directionalLight;
          }
          getFragmentStyle(t3) {
            if (!t3)
              return this;
            if (e3.c9(t3)) {
              const i3 = e3.ca(t3), o3 = this.fragments.find(({ id: e4 }) => e4 === i3);
              if (!o3)
                throw new Error(`Style import not found: ${t3}`);
              const r4 = e3.c8(t3);
              return o3.style.getFragmentStyle(r4);
            }
            {
              const e4 = this.fragments.find(({ id: e5 }) => e5 === t3);
              if (!e4)
                throw new Error(`Style import not found: ${t3}`);
              return e4.style;
            }
          }
          getConfigProperty(t3, i3) {
            const o3 = this.getFragmentStyle(t3);
            if (!o3)
              return null;
            const r4 = e3.aj(i3, o3.scope), s4 = o3.options.get(r4), n3 = s4 ? s4.value || s4.default : null;
            return n3 ? n3.serialize() : null;
          }
          setConfigProperty(t3, i3, o3) {
            const r4 = this.getFragmentStyle(t3);
            if (!r4)
              return;
            const s4 = r4.stylesheet.schema;
            if (!s4 || !s4[i3])
              return;
            const n3 = e3.t(o3);
            if ("success" !== n3.result)
              return void So(this, n3.value);
            const a3 = n3.value.expression, l3 = e3.aj(i3, r4.scope), c3 = r4.options.get(l3);
            if (!c3)
              return;
            let h2;
            const { minValue: u3, maxValue: d2, stepValue: _3, type: p3, values: f2 } = s4[i3], m2 = e3.t(s4[i3].default);
            "success" === m2.result && (h2 = m2.value.expression), h2 ? (this.options.set(l3, { ...c3, value: a3, default: h2, minValue: u3, maxValue: d2, stepValue: _3, type: p3, values: f2 }), this.updateConfigDependencies()) : this.fire(new e3.a(new Error(`No schema defined for the config option "${i3}" in the "${t3}" fragment.`)));
          }
          getConfig(t3) {
            const i3 = this.getFragmentStyle(t3);
            if (!i3)
              return null;
            const o3 = i3.stylesheet.schema;
            if (!o3)
              return null;
            const r4 = {};
            for (const t4 in o3) {
              const o4 = e3.aj(t4, i3.scope), s4 = i3.options.get(o4), n3 = s4 ? s4.value || s4.default : null;
              r4[t4] = n3 ? n3.serialize() : null;
            }
            return r4;
          }
          setConfig(e4, t3) {
            const i3 = this.getFragmentStyle(e4);
            i3 && (i3.updateConfig(t3, i3.stylesheet.schema), this.updateConfigDependencies());
          }
          getSchema(e4) {
            const t3 = this.getFragmentStyle(e4);
            return t3 ? t3.stylesheet.schema : null;
          }
          setSchema(e4, t3) {
            const i3 = this.getFragmentStyle(e4);
            i3 && (i3.stylesheet.schema = t3, i3.updateConfig(i3._config, t3), this.updateConfigDependencies());
          }
          updateConfig(t3, i3) {
            if (this._config = t3, t3 || i3)
              if (i3)
                for (const o3 in i3) {
                  let r4, s4;
                  const n3 = e3.t(i3[o3].default);
                  if ("success" === n3.result && (r4 = n3.value.expression), t3 && void 0 !== t3[o3]) {
                    const i4 = e3.t(t3[o3]);
                    "success" === i4.result && (s4 = i4.value.expression);
                  }
                  const { minValue: a3, maxValue: l3, stepValue: c3, type: h2, values: u3 } = i3[o3];
                  if (r4) {
                    const t4 = e3.aj(o3, this.scope);
                    this.options.set(t4, { default: r4, value: s4, minValue: a3, maxValue: l3, stepValue: c3, type: h2, values: u3 });
                  } else
                    this.fire(new e3.a(new Error(`No schema defined for config option "${o3}".`)));
                }
              else
                this.fire(new e3.a(new Error("Attempting to set config for a style without schema.")));
          }
          updateConfigDependencies() {
            for (const e4 of this._configDependentLayers) {
              const t3 = this.getLayer(e4);
              t3 && (t3.possiblyEvaluateVisibility(), this._updateLayer(t3));
            }
            this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this._changes.setDirty();
          }
          addLayer(t3, i3, o3 = {}) {
            this._checkLoaded();
            const r4 = t3.id;
            if (this._layers[r4])
              return void this.fire(new e3.a(new Error(`Layer with id "${r4}" already exists on this map`)));
            let s4;
            if ("custom" === t3.type) {
              if (So(this, e3.cb(t3)))
                return;
              s4 = e3.c7(t3, this.scope, this.options);
            } else {
              if ("object" == typeof t3.source && (this.addSource(r4, t3.source), t3 = e3.c6(t3), t3 = e3.e(t3, { source: r4 })), this._validate(ee, `layers.${r4}`, t3, { arrayIndex: -1 }, o3))
                return;
              s4 = e3.c7(t3, this.scope, this.options), this._validateLayer(s4), s4.setEventedParent(this, { layer: { id: r4 } }), this._serializedLayers[s4.id] = s4.serialize();
            }
            s4.isConfigDependent && this._configDependentLayers.add(s4.fqid);
            let n3 = this._order.length;
            if (i3) {
              const t4 = this._order.indexOf(i3);
              if (-1 === t4)
                return void this.fire(new e3.a(new Error(`Layer with id "${i3}" does not exist on this map.`)));
              s4.slot === this._layers[i3].slot ? n3 = t4 : e3.w(`Layer with id "${i3}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(n3, 0, r4), this._layerOrderChanged = true, this._layers[r4] = s4;
            const a3 = this.getOwnLayerSourceCache(s4), l3 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            a3 && s4.canCastShadows() && l3 && (a3.castsShadows = true);
            const c3 = this._changes.getRemovedLayer(s4);
            if (c3 && s4.source && a3 && "custom" !== s4.type) {
              this._changes.discardLayerRemoval(s4);
              const t4 = e3.aj(s4.source, s4.scope);
              c3.type !== s4.type ? this._changes.updateSourceCache(t4, "clear") : (this._changes.updateSourceCache(t4, "reload"), a3.pause());
            }
            this._updateLayer(s4), s4.onAdd && s4.onAdd(this.map), s4.scope = this.scope, this.mergeLayers();
          }
          moveLayer(t3, i3) {
            this._checkLoaded();
            const o3 = this._checkLayer(t3);
            if (!o3)
              return;
            if (t3 === i3)
              return;
            const r4 = this._order.indexOf(t3);
            this._order.splice(r4, 1);
            let s4 = this._order.length;
            if (i3) {
              const t4 = this._order.indexOf(i3);
              if (-1 === t4)
                return void this.fire(new e3.a(new Error(`Layer with id "${i3}" does not exist on this map.`)));
              o3.slot === this._layers[i3].slot ? s4 = t4 : e3.w(`Layer with id "${i3}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(s4, 0, t3), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
          }
          removeLayer(e4) {
            this._checkLoaded();
            const t3 = this._checkLayer(e4);
            if (!t3)
              return;
            t3.setEventedParent(null);
            const i3 = this._order.indexOf(e4);
            this._order.splice(i3, 1), delete this._layers[e4], delete this._serializedLayers[e4], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t3.fqid), this._changes.removeLayer(t3);
            const o3 = this.getOwnLayerSourceCache(t3);
            if (o3 && o3.castsShadows) {
              let e5 = false;
              for (const i4 in this._layers)
                if (this._layers[i4].source === t3.source && this._layers[i4].canCastShadows()) {
                  e5 = true;
                  break;
                }
              o3.castsShadows = e5;
            }
            t3.onRemove && t3.onRemove(this.map), this.mergeLayers();
          }
          getOwnLayer(e4) {
            return this._layers[e4];
          }
          hasLayer(e4) {
            return e4 in this._mergedLayers;
          }
          hasLayerType(e4) {
            for (const t3 in this._layers)
              if (this._layers[t3].type === e4)
                return true;
            return false;
          }
          setLayerZoomRange(e4, t3, i3) {
            this._checkLoaded();
            const o3 = this._checkLayer(e4);
            o3 && (o3.minzoom === t3 && o3.maxzoom === i3 || (null != t3 && (o3.minzoom = t3), null != i3 && (o3.maxzoom = i3), this._updateLayer(o3)));
          }
          setSlot(e4, t3) {
            this._checkLoaded();
            const i3 = this._checkLayer(e4);
            i3 && i3.slot !== t3 && (i3.slot = t3, this._updateLayer(i3));
          }
          setFilter(i3, o3, r4 = {}) {
            this._checkLoaded();
            const s4 = this._checkLayer(i3);
            if (s4 && !t2(s4.filter, o3))
              return null == o3 ? (s4.filter = void 0, void this._updateLayer(s4)) : void (this._validate(te, `layers.${s4.id}.filter`, o3, { layerType: s4.type }, r4) || (s4.filter = e3.c6(o3), this._updateLayer(s4)));
          }
          getFilter(t3) {
            const i3 = this._checkLayer(t3);
            if (i3)
              return e3.c6(i3.filter);
          }
          setLayoutProperty(i3, o3, r4, s4 = {}) {
            this._checkLoaded();
            const n3 = this._checkLayer(i3);
            if (n3 && !t2(n3.getLayoutProperty(o3), r4)) {
              if (null != r4 && (!s4 || false !== s4.validate) && So(n3, oe.call(Q, { key: `layers.${i3}.layout.${o3}`, layerType: n3.type, objectKey: o3, value: r4, styleSpec: e3.G, style: { glyphs: true, sprite: true } })))
                return;
              n3.setLayoutProperty(o3, r4), n3.isConfigDependent && this._configDependentLayers.add(n3.fqid), this._updateLayer(n3);
            }
          }
          getLayoutProperty(e4, t3) {
            const i3 = this._checkLayer(e4);
            if (i3)
              return i3.getLayoutProperty(t3);
          }
          setPaintProperty(i3, o3, r4, s4 = {}) {
            this._checkLoaded();
            const n3 = this._checkLayer(i3);
            if (!n3)
              return;
            if (t2(n3.getPaintProperty(o3), r4))
              return;
            if (null != r4 && (!s4 || false !== s4.validate) && So(n3, ie2.call(Q, { key: `layers.${i3}.paint.${o3}`, layerType: n3.type, objectKey: o3, value: r4, styleSpec: e3.G })))
              return;
            const a3 = n3.setPaintProperty(o3, r4);
            n3.isConfigDependent && this._configDependentLayers.add(n3.fqid), a3 && this._updateLayer(n3), this._changes.updatePaintProperties(n3);
          }
          getPaintProperty(e4, t3) {
            const i3 = this._checkLayer(e4);
            if (i3)
              return i3.getPaintProperty(t3);
          }
          setFeatureState(t3, i3) {
            this._checkLoaded();
            const o3 = t3.source, r4 = t3.sourceLayer, s4 = this._checkSource(o3);
            if (!s4)
              return;
            const n3 = s4.type;
            if ("geojson" === n3 && r4)
              return void this.fire(new e3.a(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if ("vector" === n3 && !r4)
              return void this.fire(new e3.a(new Error("The sourceLayer parameter must be provided for vector source types.")));
            void 0 === t3.id && this.fire(new e3.a(new Error("The feature id parameter must be provided.")));
            const a3 = this.getOwnSourceCaches(o3);
            for (const e4 of a3)
              e4.setFeatureState(r4, t3.id, i3);
          }
          removeFeatureState(t3, i3) {
            this._checkLoaded();
            const o3 = t3.source, r4 = this._checkSource(o3);
            if (!r4)
              return;
            const s4 = r4.type, n3 = "vector" === s4 ? t3.sourceLayer : void 0;
            if ("vector" === s4 && !n3)
              return void this.fire(new e3.a(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (i3 && "string" != typeof t3.id && "number" != typeof t3.id)
              return void this.fire(new e3.a(new Error("A feature id is required to remove its specific state property.")));
            const a3 = this.getOwnSourceCaches(o3);
            for (const e4 of a3)
              e4.removeFeatureState(n3, t3.id, i3);
          }
          getFeatureState(t3) {
            this._checkLoaded();
            const i3 = t3.source, o3 = t3.sourceLayer, r4 = this._checkSource(i3);
            if (r4) {
              if ("vector" !== r4.type || o3)
                return void 0 === t3.id && this.fire(new e3.a(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i3)[0].getFeatureState(o3, t3.id);
              this.fire(new e3.a(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
          }
          setTransition(t3) {
            return this.stylesheet.transition = e3.e({}, this.stylesheet.transition, t3), this.transition = this.stylesheet.transition, this;
          }
          getTransition() {
            return e3.e({}, this.stylesheet.transition);
          }
          serialize() {
            this._checkLoaded();
            const t3 = this.getTerrain(), i3 = t3 && this.terrain && this.terrain.scope === this.scope ? t3 : this.stylesheet.terrain;
            return e3.cc({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i3, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e4) => void 0 !== e4);
          }
          _updateLayer(t3) {
            this._changes.updateLayer(t3);
            const i3 = this.getLayerSourceCache(t3), o3 = e3.aj(t3.source, t3.scope), r4 = this._changes.getUpdatedSourceCaches();
            t3.source && !r4[o3] && i3 && "raster" !== i3.getSource().type && (this._changes.updateSourceCache(o3, "reload"), i3.pause()), t3.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(e4) {
            const t3 = (e5) => "fill-extrusion" === this._mergedLayers[e5].type || "model" === this._mergedLayers[e5].type, i3 = this.order, o3 = {}, r4 = [];
            for (let s5 = i3.length - 1; s5 >= 0; s5--) {
              const n3 = i3[s5];
              if (t3(n3)) {
                o3[n3] = s5;
                for (const t4 of e4) {
                  const e5 = t4[n3];
                  if (e5)
                    for (const t5 of e5)
                      r4.push(t5);
                }
              }
            }
            r4.sort((e5, t4) => t4.intersectionZ - e5.intersectionZ);
            const s4 = [];
            for (let n3 = i3.length - 1; n3 >= 0; n3--) {
              const a3 = i3[n3];
              if (t3(a3))
                for (let e5 = r4.length - 1; e5 >= 0; e5--) {
                  const t4 = r4[e5].feature;
                  if (o3[t4.layer.id] < n3)
                    break;
                  s4.push(t4), r4.pop();
                }
              else
                for (const t4 of e4) {
                  const e5 = t4[a3];
                  if (e5)
                    for (const t5 of e5)
                      s4.push(t5.feature);
                }
            }
            return s4;
          }
          queryRenderedFeatures(t3, i3, o3) {
            i3 && i3.filter && this._validate(te, "queryRenderedFeatures.filter", i3.filter, null, i3), i3.scope = this.scope, i3.availableImages = this._availableImages, i3.serializedLayers = this._serializedLayers;
            const r4 = {};
            if (i3 && i3.layers) {
              if (!Array.isArray(i3.layers))
                return this.fire(new e3.a(new Error("parameters.layers must be an Array."))), [];
              for (const t4 of i3.layers) {
                const i4 = this._mergedLayers[t4];
                if (!i4)
                  return this.fire(new e3.a(new Error(`The layer '${t4}' does not exist in the map's style and cannot be queried for features.`))), [];
                r4[i4.source] = true;
              }
            }
            const s4 = [], n3 = i3.serializedLayers || {}, a3 = i3 && i3.layers ? i3.layers.some((e4) => {
              const t4 = this.getLayer(e4);
              return t4 && t4.is3D();
            }) : this.has3DLayers(), l3 = Te.createFromScreenPoints(t3, o3);
            for (const e4 in this._mergedSourceCaches) {
              const t4 = this._mergedSourceCaches[e4].getSource();
              if (!t4 || t4.scope !== i3.scope)
                continue;
              const c3 = this._mergedSourceCaches[e4].getSource().id;
              i3.layers && !r4[c3] || s4.push(Vt(this._mergedSourceCaches[e4], this._mergedLayers, n3, l3, i3, o3, a3, !!this.map._showQueryGeometry));
            }
            return this.placement && s4.push(function(e4, t4, i4, o4, r5, s5, n4) {
              const a4 = {}, l4 = s5.queryRenderedSymbols(o4), c3 = [];
              for (const e5 of Object.keys(l4).map(Number))
                c3.push(n4[e5]);
              c3.sort(Wt);
              for (const i5 of c3) {
                const o5 = i5.featureIndex.lookupSymbolFeatures(l4[i5.bucketInstanceId], t4, i5.bucketIndex, i5.sourceLayerIndex, r5.filter, r5.layers, r5.availableImages, e4);
                for (const e5 in o5) {
                  const t5 = a4[e5] = a4[e5] || [], r6 = o5[e5];
                  r6.sort((e6, t6) => {
                    const o6 = i5.featureSortOrder;
                    if (o6) {
                      const i6 = o6.indexOf(e6.featureIndex);
                      return o6.indexOf(t6.featureIndex) - i6;
                    }
                    return t6.featureIndex - e6.featureIndex;
                  });
                  for (const e6 of r6)
                    t5.push(e6);
                }
              }
              for (const t5 in a4)
                a4[t5].forEach((o5) => {
                  const r6 = o5.feature, s6 = i4(e4[t5]);
                  if (!s6)
                    return;
                  const n5 = s6.getFeatureState(r6.layer["source-layer"], r6.id);
                  r6.source = r6.layer.source, r6.layer["source-layer"] && (r6.sourceLayer = r6.layer["source-layer"]), r6.state = n5;
                });
              return a4;
            }(this._mergedLayers, n3, this.getLayerSourceCache.bind(this), l3.screenGeometry, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s4);
          }
          querySourceFeatures(e4, t3) {
            t3 && t3.filter && this._validate(te, "querySourceFeatures.filter", t3.filter, null, t3);
            const i3 = this.getOwnSourceCaches(e4);
            let o3 = [];
            for (const e5 of i3)
              o3 = o3.concat(Zt(e5, t3));
            return o3;
          }
          addSourceType(e4, t3, i3) {
            return Ao.getSourceType(e4) ? i3(new Error(`A source type called "${e4}" already exists.`)) : (Ao.setSourceType(e4, t3), t3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e4, url: t3.workerSourceURL }, i3) : i3(null, null));
          }
          getFlatLight() {
            return this.light.getLight();
          }
          setFlatLight(e4, i3, o3 = {}) {
            this._checkLoaded();
            const r4 = this.light.getLight();
            let s4 = false;
            for (const i4 in e4)
              if (!t2(e4[i4], r4[i4])) {
                s4 = true;
                break;
              }
            if (!s4)
              return;
            const n3 = this._getTransitionParameters();
            this.light.setLight(e4, i3, o3), this.light.updateTransitions(n3);
          }
          getTerrain() {
            return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          setTerrain(i3, o3 = 1) {
            if (this._checkLoaded(), !i3)
              return this.terrainSetForDrapingOnly() && 0 !== o3 || delete this.terrain, null === i3 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
            let r4 = i3;
            const s4 = null == i3.source;
            if (1 === o3) {
              if ("object" == typeof r4.source) {
                const t4 = "terrain-dem-src";
                this.addSource(t4, r4.source), r4 = e3.c6(r4), r4 = e3.e(r4, { source: t4 });
              }
              const t3 = e3.e({}, r4), i4 = {};
              if (this.terrain && s4) {
                t3.source = this.terrain.get().source;
                const e4 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                e4 && (i4.style = e4.serialize());
              }
              if (this._validate(J, "terrain", t3, i4))
                return;
            }
            if (!this.terrain || this.terrain.scope !== this.scope && !s4 || this.terrain && o3 !== this.terrain.drapeRenderMode) {
              if (!r4)
                return;
              this._createTerrain(r4, o3), this.fire(new e3.b("data", { dataType: "style" }));
            } else {
              const o4 = this.terrain, s5 = o4.get();
              for (const t3 of Object.keys(e3.G.terrain))
                !r4.hasOwnProperty(t3) && e3.G.terrain[t3].default && (r4[t3] = e3.G.terrain[t3].default);
              for (const r5 in i3)
                if (!t2(i3[r5], s5[r5])) {
                  o4.set(i3, this.options), this.stylesheet.terrain = i3;
                  const t3 = this._getTransitionParameters({ duration: 0 });
                  o4.updateTransitions(t3), this.fire(new e3.b("data", { dataType: "style" }));
                  break;
                }
            }
            this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
          _createFog(e4) {
            const t3 = this.fog = new xe(e4, this.map.transform, this.scope, this.options);
            this.stylesheet.fog = t3.get();
            const i3 = this._getTransitionParameters({ duration: 0 });
            t3.updateTransitions(i3);
          }
          _updateMarkersOpacity() {
            0 !== this.map._markers.length && this.map._requestDomTask(() => {
              for (const e4 of this.map._markers)
                e4._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(e4) {
            if (this._checkLoaded(), !e4)
              return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
            if (this.fog) {
              const i3 = this.fog;
              if (!t2(i3.get(), e4)) {
                i3.set(e4, this.options), this.stylesheet.fog = i3.get();
                const t3 = this._getTransitionParameters({ duration: 0 });
                i3.updateTransitions(t3);
              }
            } else
              this._createFog(e4);
            this._markersNeedUpdate = true;
          }
          _getTransitionParameters(t3) {
            return { now: e3.f.now(), transition: e3.e(this.transition, t3) };
          }
          updateDrapeFirstLayers() {
            if (!this.terrain)
              return;
            const e4 = [], t3 = [];
            for (const i3 in this._mergedLayers)
              this.isLayerDraped(this._mergedLayers[i3]) ? e4.push(i3) : t3.push(i3);
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e4), this._drapedFirstOrder.push(...t3);
          }
          _createTerrain(e4, t3) {
            const i3 = this.terrain = new he(e4, t3, this.scope, this.options);
            1 === t3 && (this.stylesheet.terrain = e4), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
            const o3 = this._getTransitionParameters({ duration: 0 });
            i3.updateTransitions(o3);
          }
          _force3DLayerUpdate() {
            for (const e4 in this._layers) {
              const t3 = this._layers[e4];
              "fill-extrusion" === t3.type && this._updateLayer(t3);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const e4 in this._layers) {
              const t3 = this._layers[e4];
              "symbol" === t3.type && this._updateLayer(t3);
            }
          }
          _validate(t3, i3, o3, r4, s4 = {}) {
            if (s4 && false === s4.validate)
              return false;
            const n3 = e3.e({}, this.serialize());
            return So(this, t3.call(Q, e3.e({ key: i3, style: n3, value: o3, styleSpec: e3.G }, r4)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e3.cd.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const e4 in this._mergedLayers)
              this._mergedLayers[e4].setEventedParent(null);
            for (const e4 in this._mergedSourceCaches)
              this._mergedSourceCaches[e4].clearTiles(), this._mergedSourceCaches[e4].setEventedParent(null);
            this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
          }
          clearSource(e4) {
            const t3 = this.getSourceCaches(e4);
            for (const e5 of t3)
              e5.clearTiles();
          }
          clearSources() {
            for (const e4 in this._mergedSourceCaches)
              this._mergedSourceCaches[e4].clearTiles();
          }
          reloadSource(e4) {
            const t3 = this.getSourceCaches(e4);
            for (const e5 of t3)
              e5.resume(), e5.reload();
          }
          reloadSources() {
            for (const e4 of this.getSources())
              e4.reload && e4.reload();
          }
          updateSources(e4) {
            let t3;
            this.directionalLight && (t3 = wo(this.directionalLight));
            for (const i3 in this._mergedSourceCaches)
              this._mergedSourceCaches[i3].update(e4, void 0, void 0, t3);
          }
          _generateCollisionBoxes() {
            for (const e4 in this._sourceCaches) {
              const t3 = this._sourceCaches[e4];
              t3.resume(), t3.reload();
            }
          }
          _updatePlacement(t3, i3, o3, r4, s4 = false) {
            let n3 = false, a3 = false;
            const l3 = {}, c3 = {};
            for (const i4 of this._mergedOrder) {
              const o4 = this._mergedLayers[i4];
              if ("symbol" !== o4.type)
                continue;
              const r5 = e3.aj(o4.source, o4.scope);
              let s5 = l3[r5];
              if (!s5) {
                const e4 = this.getLayerSourceCache(o4);
                if (!e4)
                  continue;
                const t4 = e4.getRenderableIds(true).map((t5) => e4.getTileByID(t5));
                c3[r5] = t4.slice(), s5 = l3[r5] = t4.sort((e5, t5) => t5.tileID.overscaledZ - e5.tileID.overscaledZ || (e5.tileID.isLessThan(t5.tileID) ? -1 : 1));
              }
              const a4 = this.crossTileSymbolIndex.addLayer(o4, s5, t3.center.lng, t3.projection);
              n3 = n3 || a4;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), s4 = s4 || this._layerOrderChanged || 0 === o3, this._layerOrderChanged && this.fire(new e3.b("neworder")), (s4 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e3.f.now(), t3.zoom)) && (this.pauseablePlacement = new Ki(t3, this._mergedOrder, s4, i3, o3, r4, this.placement, this.fog && t3.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, l3, c3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e3.f.now()), a3 = true), n3 && this.pauseablePlacement.placement.setStale()), a3 || n3) {
              this._buildingIndex.onNewFrame(t3.zoom);
              for (const t4 of this._mergedOrder) {
                const i4 = this._mergedLayers[t4];
                "symbol" === i4.type && this.placement.updateLayerOpacities(i4, l3[e3.aj(i4.source, i4.scope)]);
              }
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e3.f.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e4 in this._sourceCaches)
              this._sourceCaches[e4].releaseSymbolFadeTiles();
          }
          addImport(t3, i3) {
            this._checkLoaded();
            const o3 = this.stylesheet.imports = this.stylesheet.imports || [];
            if (-1 !== o3.findIndex(({ id: e4 }) => e4 === t3.id))
              return void this.fire(new e3.a(new Error(`Import with id '${t3.id}' already exists in the map's style.`)));
            if (!i3)
              return o3.push(t3), this._loadImports([t3], true);
            const r4 = o3.findIndex(({ id: e4 }) => e4 === i3);
            return -1 === r4 && this.fire(new e3.a(new Error(`Import with id "${i3}" does not exist on this map.`))), this.stylesheet.imports = o3.slice(0, r4).concat(t3).concat(o3.slice(r4)), this._loadImports([t3], true, i3);
          }
          updateImport(e4, i3) {
            this._checkLoaded();
            const o3 = this.stylesheet.imports || [], r4 = this.getImportIndex(e4);
            return -1 === r4 ? this : "string" == typeof i3 ? (this.setImportUrl(e4, i3), this) : (i3.url && i3.url !== o3[r4].url && this.setImportUrl(e4, i3.url), t2(i3.config, o3[r4].config) || this.setImportConfig(e4, i3.config), t2(i3.data, o3[r4].data) || this.setImportData(e4, i3.data), this);
          }
          moveImport(e4, t3) {
            this._checkLoaded();
            let i3 = this.stylesheet.imports || [];
            const o3 = this.getImportIndex(e4);
            if (-1 === o3)
              return this;
            const r4 = this.getImportIndex(t3);
            if (-1 === r4)
              return this;
            const s4 = i3[o3], n3 = this.fragments[o3];
            return i3 = i3.filter(({ id: t4 }) => t4 !== e4), this.fragments = this.fragments.filter(({ id: t4 }) => t4 !== e4), this.stylesheet.imports = i3.slice(0, r4).concat(s4).concat(i3.slice(r4)), this.fragments = this.fragments.slice(0, r4).concat(n3).concat(this.fragments.slice(r4)), this.mergeLayers(), this;
          }
          setImportUrl(e4, t3) {
            this._checkLoaded();
            const i3 = this.stylesheet.imports || [], o3 = this.getImportIndex(e4);
            if (-1 === o3)
              return this;
            i3[o3].url = t3;
            const r4 = this.fragments[o3];
            return r4.style = this._createFragmentStyle(i3[o3]), r4.style.on("style.import.load", () => this.mergeAll()), r4.style.loadURL(t3), this;
          }
          setImportData(e4, t3) {
            this._checkLoaded();
            const i3 = this.getImportIndex(e4), o3 = this.stylesheet.imports || [];
            return -1 === i3 ? this : t3 ? (this.fragments[i3].style.setState(t3), this._reloadImports(), this) : (delete o3[i3].data, this.setImportUrl(e4, o3[i3].url));
          }
          setImportConfig(e4, t3) {
            this._checkLoaded();
            const i3 = this.getImportIndex(e4), o3 = this.stylesheet.imports || [];
            if (-1 === i3)
              return this;
            t3 ? o3[i3].config = t3 : delete o3[i3].config;
            const r4 = this.fragments[i3], s4 = r4.style.stylesheet && r4.style.stylesheet.schema;
            return r4.config = t3, r4.style.updateConfig(t3, s4), this.updateConfigDependencies(), this;
          }
          removeImport(e4) {
            this._checkLoaded();
            const t3 = this.stylesheet.imports || [], i3 = this.getImportIndex(e4);
            -1 !== i3 && (t3.splice(i3, 1), this.fragments[i3].style._remove(), this.fragments.splice(i3, 1), this._reloadImports());
          }
          getImportIndex(t3) {
            const i3 = (this.stylesheet.imports || []).findIndex((e4) => e4.id === t3);
            return -1 === i3 && this.fire(new e3.a(new Error(`Import '${t3}' does not exist in the map's style and cannot be updated.`))), i3;
          }
          getLayer(e4) {
            return this._mergedLayers[e4];
          }
          getSources() {
            const e4 = [];
            for (const t3 in this._mergedOtherSourceCaches) {
              const i3 = this._mergedOtherSourceCaches[t3];
              i3 && e4.push(i3.getSource());
            }
            return e4;
          }
          getSource(e4, t3) {
            const i3 = this.getSourceCache(e4, t3);
            return i3 && i3.getSource();
          }
          getLayerSource(e4) {
            const t3 = this.getLayerSourceCache(e4);
            return t3 && t3.getSource();
          }
          getSourceCache(t3, i3) {
            const o3 = e3.aj(t3, i3);
            return this._mergedOtherSourceCaches[o3];
          }
          getLayerSourceCache(t3) {
            const i3 = e3.aj(t3.source, t3.scope);
            return "symbol" === t3.type ? this._mergedSymbolSourceCaches[i3] : this._mergedOtherSourceCaches[i3];
          }
          getSourceCaches(e4) {
            if (null == e4)
              return Object.values(this._mergedSourceCaches);
            const t3 = [];
            return this._mergedOtherSourceCaches[e4] && t3.push(this._mergedOtherSourceCaches[e4]), this._mergedSymbolSourceCaches[e4] && t3.push(this._mergedSymbolSourceCaches[e4]), t3;
          }
          updateSourceCaches() {
            const e4 = this._changes.getUpdatedSourceCaches();
            for (const t3 in e4) {
              const i3 = e4[t3];
              "reload" === i3 ? this.reloadSource(t3) : "clear" === i3 && this.clearSource(t3);
            }
          }
          updateLayers(e4) {
            const t3 = this._changes.getUpdatedPaintProperties();
            for (const i3 of t3) {
              const t4 = this.getLayer(i3);
              t4 && t4.updateTransitions(e4);
            }
          }
          getImages(e4, t3, i3) {
            this.imageManager.getImages(t3.icons, t3.scope, i3), this._updateTilesForChangedImages();
            const o3 = (e5) => {
              e5 && e5.setDependencies(t3.tileID.key, t3.type, t3.icons);
            };
            o3(this._otherSourceCaches[t3.source]), o3(this._symbolSourceCaches[t3.source]);
          }
          getGlyphs(e4, t3, i3) {
            this.glyphManager.getGlyphs(t3.stacks, t3.scope, i3);
          }
          getResource(t3, i3, o3) {
            return e3.ce(i3, o3);
          }
          getOwnSourceCache(e4) {
            return this._otherSourceCaches[e4];
          }
          getOwnLayerSourceCache(e4) {
            return "symbol" === e4.type ? this._symbolSourceCaches[e4.source] : this._otherSourceCaches[e4.source];
          }
          getOwnSourceCaches(e4) {
            const t3 = [];
            return this._otherSourceCaches[e4] && t3.push(this._otherSourceCaches[e4]), this._symbolSourceCaches[e4] && t3.push(this._symbolSourceCaches[e4]), t3;
          }
          _isSourceCacheLoaded(t3) {
            const i3 = this.getOwnSourceCaches(t3);
            return 0 === i3.length ? (this.fire(new e3.a(new Error(`There is no source with ID '${t3}'`))), false) : i3.every((e4) => e4.loaded());
          }
          has3DLayers() {
            return this._has3DLayers;
          }
          hasSymbolLayers() {
            return this._hasSymbolLayers;
          }
          hasCircleLayers() {
            return this._hasCircleLayers;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.fragments.forEach((e4) => {
              e4.style._remove();
            }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Ao.getSourceType = function(e4) {
          return Ut[e4];
        }, Ao.setSourceType = function(e4, t3) {
          Ut[e4] = t3;
        }, Ao.registerForPluginStateChange = e3.bY;
        var Po = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Lo = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,vec2 pos,vec2 lod_coord) {vec2 size=vec2(textureSize(image,0));vec2 dx=dFdx(lod_coord.xy*size);vec2 dy=dFdy(lod_coord.xy*size);float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}", Mo = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", zo = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Oo = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture(u_depth,uv-df.xz)),unpack_depth(texture(u_depth,uv+df.xz)),unpack_depth(texture(u_depth,uv-df.zy)),unpack_depth(texture(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", Fo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Bo = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", ko = "#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", No = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec4 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=vec2(u_data_offset+dot(t.rg,u_data_scale.yx),-(u_data_offset+dot(t.ba,u_data_scale.yx)));velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Uo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", Go = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
        const jo = [];
        Qo(Po, jo), Qo(Mo, jo), Qo(Lo, jo);
        const Vo = { "_prelude_fog.vertex.glsl": Fo, "_prelude_terrain.vertex.glsl": Oo, "_prelude_shadow.vertex.glsl": Uo, "_prelude_fog.fragment.glsl": Bo, "_prelude_shadow.fragment.glsl": Go, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": ko, "_prelude_raster_particle.glsl": No }, Zo = {};
        $o("", Oo), $o(Bo, Fo), $o(Go, Uo), $o(ko, ""), $o(No, "");
        const Wo = $o(Lo, Mo), Ho = Po;
        var qo = { background: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), circle: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: $o("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: $o('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: $o("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: $o("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: $o("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: $o("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), fill: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutline: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nuniform float u_emissive_strength;in float v_height;void main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=max(0.01,cutoff_opacity(u_cutoff_params,ground.z));if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff < 0.01 && centroid_pos.x !=0.0));gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: $o("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: $o('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: $o("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: $o("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    \nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), linePattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform mediump float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float pattern_x=v_linesofar/pattern_size.x*aspect;float x=mod(pattern_x,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {color=vec4(0,0,0,0);}}\n#endif\n#ifdef LINE_JOIN_NONE\nfloat pattern_len=pattern_size.x/aspect;float segment_phase=pattern_len-mod((v_linesofar-v_pattern_data.x),pattern_len);float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin vec2 a_pattern_data;out vec2 v_pattern_data;\n#endif\nuniform mat4 u_matrix;uniform mediump float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef LINE_JOIN_NONE\nv_width+=ANTIALIASING;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5/u_tile_units_to_pixels;v_linesofar+=line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), raster: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), rasterParticle: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'), rasterParticleDraw: $o("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-vec2(1.0),0.0,1.0);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'), rasterParticleTexture: $o("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: $o('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp float speed=velocity==INVALID_VELOCITY ? 0.0 : length(velocity);highp float reset_rate_bump=speed*u_reset_rate;highp vec2 particle_pos_min=-u_particle_pos_offset;highp vec2 particle_pos_max=vec2(1.0)+u_particle_pos_offset;highp vec2 pos_drop_rate=vec2(1.0)-step(particle_pos_min,pos)+step(particle_pos_max,pos);highp float drop_rate=max(u_reset_rate+reset_rate_bump,length(pos_drop_rate));highp float drop=step(1.0-drop_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbolIcon: $o('#include "_prelude_lighting.glsl"\nuniform sampler2D u_texture;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\nin float v_fade_opacity;in vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\nout_color*=alpha;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nv_tex_a=a_tex/u_texsize;\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\nv_fade_opacity=out_fade_opacity;}'), symbolSDF: $o('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}'), symbolTextAndIcon: $o('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}'), terrainRaster: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'), terrainDepth: $o("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: $o('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', zo), skyboxGradient: $o('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', zo), skyboxCapture: $o("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: $o('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture(u_depthTexture,coord));return v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nreturn vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: $o("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: $o("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}") };
        function Qo(e4, t3) {
          const i3 = e4.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
          for (let e5 of i3)
            if (e5 = e5.trim(), "#" === e5[0] && e5.includes("if") && !e5.includes("endif")) {
              e5 = e5.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
              const i4 = e5.split(" ");
              for (const e6 of i4)
                t3.includes(e6) || t3.push(e6);
            }
        }
        function $o(e4, t3) {
          const i3 = /#include\s+"([^"]+)"/g, o3 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
          let r4 = t3.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
          r4 && (r4 = r4.map((e5) => {
            const t4 = e5.split(" ");
            return t4[t4.length - 1];
          }), r4 = [...new Set(r4)]);
          const s4 = {}, n3 = [], a3 = [];
          if (e4 = e4.replace(i3, (e5, t4) => (a3.push(t4), "")), (t3 = t3.replace(i3, (e5, t4) => (n3.push(t4), ""))).includes("flat out"))
            return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
          let l3 = [...jo];
          Qo(e4, l3), Qo(t3, l3);
          for (const e5 of [...n3, ...a3])
            Vo[e5] || console.error(`Undefined include: ${e5}`), Zo[e5] || (Zo[e5] = [], Qo(Vo[e5], Zo[e5])), l3 = [...l3, ...Zo[e5]];
          return { fragmentSource: e4 = e4.replace(o3, (e5, t4, i4, o4, r5) => (s4[r5] = true, "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${r5}
in ${i4} ${o4} ${r5};
#else
uniform ${i4} ${o4} u_${r5};
#endif
` : "initialize" === t4 ? `
#ifdef HAS_UNIFORM_u_${r5}
    ${i4} ${o4} ${r5} = u_${r5};
#endif
` : "define-attribute" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    in ${i4} ${o4} ${r5};
#endif
` : "initialize-attribute" === t4 ? "" : void 0)), vertexSource: t3 = t3.replace(o3, (e5, t4, i4, o4, r5) => {
            const n4 = "float" === o4 ? "vec2" : o4, a4 = r5.match(/color/) ? "color" : n4;
            return "define-attribute-vertex-shader-only" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
in ${i4} ${o4} a_${r5};
#endif
` : s4[r5] ? "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${r5}
uniform lowp float u_${r5}_t;
in ${i4} ${n4} a_${r5};
out ${i4} ${o4} ${r5};
#else
uniform ${i4} ${o4} u_${r5};
#endif
` : "initialize" === t4 ? "vec4" === a4 ? `
#ifndef HAS_UNIFORM_u_${r5}
    ${r5} = a_${r5};
#else
    ${i4} ${o4} ${r5} = u_${r5};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r5}
    ${r5} = unpack_mix_${a4}(a_${r5}, u_${r5}_t);
#else
    ${i4} ${o4} ${r5} = u_${r5};
#endif
` : "define-attribute" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    in ${i4} ${o4} a_${r5};
    out ${i4} ${o4} ${r5};
#endif
` : "initialize-attribute" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    ${r5} = a_${r5};
#endif
` : void 0 : "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${r5}
uniform lowp float u_${r5}_t;
in ${i4} ${n4} a_${r5};
#else
uniform ${i4} ${o4} u_${r5};
#endif
` : "define-instanced" === t4 ? "mat4" === a4 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${r5}0;
in vec4 a_${r5}1;
in vec4 a_${r5}2;
in vec4 a_${r5}3;
#else
uniform ${i4} ${o4} u_${r5};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${i4} ${n4} a_${r5};
#else
uniform ${i4} ${o4} u_${r5};
#endif
` : "initialize-attribute-custom" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    ${i4} ${o4} ${r5} = a_${r5};
#endif
` : "vec4" === a4 ? `
#ifndef HAS_UNIFORM_u_${r5}
    ${i4} ${o4} ${r5} = a_${r5};
#else
    ${i4} ${o4} ${r5} = u_${r5};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r5}
    ${i4} ${o4} ${r5} = unpack_mix_${a4}(a_${r5}, u_${r5}_t);
#else
    ${i4} ${o4} ${r5} = u_${r5};
#endif
`;
          }), staticAttributes: r4, usedDefines: l3, vertexIncludes: n3, fragmentIncludes: a3 };
        }
        class Xo {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(e4, t3, i3, o3, r4, s4, n3, a3) {
            this.context = e4;
            let l3 = this.boundPaintVertexBuffers.length !== o3.length;
            for (let e5 = 0; !l3 && e5 < o3.length; e5++)
              this.boundPaintVertexBuffers[e5] !== o3[e5] && (l3 = true);
            let c3 = this.boundDynamicVertexBuffers.length !== n3.length;
            for (let e5 = 0; !c3 && e5 < n3.length; e5++)
              this.boundDynamicVertexBuffers[e5] !== n3[e5] && (c3 = true);
            if (!this.vao || this.boundProgram !== t3 || this.boundLayoutVertexBuffer !== i3 || l3 || c3 || this.boundIndexBuffer !== r4 || this.boundVertexOffset !== s4)
              this.freshBind(t3, i3, o3, r4, s4, n3, a3);
            else {
              e4.bindVertexArrayOES.set(this.vao);
              for (const i4 of n3)
                i4 && (i4.bind(), a3 && i4.instanceCount && i4.setVertexAttribDivisor(e4.gl, t3, a3));
              r4 && r4.dynamicDraw && r4.bind();
            }
          }
          freshBind(e4, t3, i3, o3, r4, s4, n3) {
            const a3 = e4.numAttributes, l3 = this.context, c3 = l3.gl;
            this.vao && this.destroy(), this.vao = l3.gl.createVertexArray(), l3.bindVertexArrayOES.set(this.vao), this.boundProgram = e4, this.boundLayoutVertexBuffer = t3, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = o3, this.boundVertexOffset = r4, this.boundDynamicVertexBuffers = s4, t3.enableAttributes(c3, e4), t3.bind(), t3.setVertexAttribPointers(c3, e4, r4);
            for (const t4 of i3)
              t4.enableAttributes(c3, e4), t4.bind(), t4.setVertexAttribPointers(c3, e4, r4);
            for (const t4 of s4)
              t4 && (t4.enableAttributes(c3, e4), t4.bind(), t4.setVertexAttribPointers(c3, e4, r4), n3 && t4.instanceCount && t4.setVertexAttribDivisor(c3, e4, n3));
            o3 && o3.bind(), l3.currentNumAttributes = a3;
          }
          destroy() {
            this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function Yo(t3, i3) {
          const o3 = Math.pow(2, i3.canonical.z), r4 = i3.canonical.y;
          return [new e3.O(0, r4 / o3).toLngLat().lat, new e3.O(0, (r4 + 1) / o3).toLngLat().lat];
        }
        function Jo(t3, i3, o3, r4, s4, n3, a3) {
          const l3 = t3.context, c3 = l3.gl, h2 = o3.hillshadeFBO;
          if (!h2)
            return;
          t3.prepareDrawTile();
          const u3 = t3.isTileAffectedByFog(i3), d2 = t3.getOrCreateProgram("hillshade", { overrideFog: u3 });
          l3.activeTexture.set(c3.TEXTURE0), c3.bindTexture(c3.TEXTURE_2D, h2.colorAttachment.get());
          const _3 = ((t4, i4, o4, r5) => {
            const s5 = o4.paint.get("hillshade-shadow-color"), n4 = o4.paint.get("hillshade-highlight-color"), a4 = o4.paint.get("hillshade-accent-color"), l4 = o4.paint.get("hillshade-emissive-strength");
            let c4 = e3.bm(o4.paint.get("hillshade-illumination-direction"));
            if ("viewport" === o4.paint.get("hillshade-illumination-anchor"))
              c4 -= t4.transform.angle;
            else if (t4.style && t4.style.enable3dLights() && t4.style.directionalLight) {
              const i5 = t4.style.directionalLight.properties.get("direction"), o5 = e3.bT(i5.x, i5.y, i5.z);
              c4 = e3.bm(o5[1]);
            }
            const h3 = !t4.options.moving;
            return { u_matrix: r5 || t4.transform.calculateProjMatrix(i4.tileID.toUnwrapped(), h3), u_image: 0, u_latrange: Yo(0, i4.tileID), u_light: [o4.paint.get("hillshade-exaggeration"), c4], u_shadow: s5, u_highlight: n4, u_emissive_strength: l4, u_accent: a4 };
          })(t3, o3, r4, t3.terrain ? i3.projMatrix : null);
          t3.uploadCommonUniforms(l3, d2, i3.toUnwrapped());
          const { tileBoundsBuffer: p3, tileBoundsIndexBuffer: f2, tileBoundsSegments: m2 } = t3.getTileBoundsBuffers(o3);
          d2.draw(t3, c3.TRIANGLES, s4, n3, a3, Mt.disabled, _3, r4.id, p3, f2, m2);
        }
        function Ko(t3, i3, o3) {
          if (!i3.needsDEMTextureUpload)
            return;
          const r4 = t3.context, s4 = r4.gl;
          r4.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || t3.getTileTexture(o3.stride);
          const n3 = o3.getPixels();
          i3.demTexture ? i3.demTexture.update(n3, { premultiply: false }) : i3.demTexture = new e3.T(r4, n3, s4.R32F, { premultiply: false }), i3.needsDEMTextureUpload = false;
        }
        function er(t3, i3, o3) {
          const r4 = t3.context, s4 = r4.gl;
          if (!i3.dem)
            return;
          const n3 = i3.dem;
          if (r4.activeTexture.set(s4.TEXTURE1), Ko(t3, i3, n3), !i3.demTexture)
            return;
          i3.demTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE);
          const a3 = n3.dim;
          r4.activeTexture.set(s4.TEXTURE0);
          let l3 = i3.hillshadeFBO;
          if (!l3) {
            const t4 = new e3.T(r4, { width: a3, height: a3, data: null }, s4.RGBA);
            t4.bind(s4.LINEAR, s4.CLAMP_TO_EDGE), l3 = i3.hillshadeFBO = r4.createFramebuffer(a3, a3, true, "renderbuffer"), l3.colorAttachment.set(t4.texture);
          }
          r4.bindFramebuffer.set(l3.framebuffer), r4.viewport.set([0, 0, a3, a3]);
          const { tileBoundsBuffer: c3, tileBoundsIndexBuffer: h2, tileBoundsSegments: u3 } = t3.getMercatorTileBoundsBuffers(), d2 = [];
          t3.linearFloatFilteringSupported() && d2.push("TERRAIN_DEM_FLOAT_FORMAT"), t3.getOrCreateProgram("hillshadePrepare", { defines: d2 }).draw(t3, s4.TRIANGLES, Ct.disabled, Dt.disabled, At.unblended, Mt.disabled, ((t4, i4) => {
            const o4 = i4.stride, r5 = e3.a9.create();
            return e3.a9.ortho(r5, 0, e3.Y, -e3.Y, 0, 0, 1), e3.a9.translate(r5, r5, [0, -e3.Y, 0]), { u_matrix: r5, u_image: 1, u_dimension: [o4, o4], u_zoom: t4.overscaledZ };
          })(i3.tileID, n3), o3.id, c3, h2, u3), i3.needsHillshadePrepare = false;
        }
        const tr = (t3) => ({ u_matrix: new e3.bN(t3), u_image0: new e3.bR(t3), u_skirt_height: new e3.bQ(t3), u_ground_shadow_factor: new e3.bP(t3) }), ir = (e4, t3, i3) => ({ u_matrix: e4, u_image0: 0, u_skirt_height: t3, u_ground_shadow_factor: i3 }), or = (e4, t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2) => ({ u_proj_matrix: Float32Array.from(e4), u_globe_matrix: t3, u_normalize_matrix: Float32Array.from(o3), u_merc_matrix: i3, u_zoom_transition: r4, u_merc_center: s4, u_image0: 0, u_frustum_tl: n3, u_frustum_tr: a3, u_frustum_br: l3, u_frustum_bl: c3, u_globe_pos: h2, u_globe_radius: u3, u_viewport: d2, u_grid_matrix: f2 ? Float32Array.from(f2) : new Float32Array(9), u_skirt_height: _3, u_far_z_cutoff: p3 });
        function rr(e4, t3) {
          return null != e4 && null != t3 && !(!e4.hasData() || !t3.hasData()) && null != e4.demTexture && null != t3.demTexture && e4.tileID.key !== t3.tileID.key;
        }
        const sr = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e4, t3, i3, o3, r4) {
            if (e4 in this.operations) {
              const t4 = this.operations[e4];
              t4.to.tileID.key !== i3.tileID.key && (t4.queued = i3);
            } else
              this.operations[e4] = { startTime: o3, phase: 0, duration: r4, from: t3, to: i3, queued: null };
          }
          getMorphValuesForProxy(e4) {
            if (!(e4 in this.operations))
              return null;
            const t3 = this.operations[e4];
            return { from: t3.from, to: t3.to, phase: t3.phase };
          }
          update(e4) {
            for (const t3 in this.operations) {
              const i3 = this.operations[t3];
              for (i3.phase = (e4 - i3.startTime) / i3.duration; i3.phase >= 1 || !this._validOp(i3); )
                if (!this._nextOp(i3, e4)) {
                  delete this.operations[t3];
                  break;
                }
            }
          }
          _nextOp(e4, t3) {
            return !!e4.queued && (e4.from = e4.to, e4.to = e4.queued, e4.queued = null, e4.phase = 0, e4.startTime = t3, true);
          }
          _validOp(e4) {
            return e4.from.hasData() && e4.to.hasData();
          }
        }(), nr = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
        function ar(e4, t3, i3) {
          if (0 === t3)
            return 0;
          const o3 = t3 < 1 && 514 === i3 ? 0.25 / t3 : 1;
          return 6 * Math.pow(1.5, 22 - e4) * Math.max(t3, 1) * o3;
        }
        function lr(e4, t3) {
          const i3 = 1 << e4.z;
          return !t3 && (0 === e4.x || e4.x === i3 - 1) || 0 === e4.y || e4.y === i3 - 1;
        }
        const cr = (e4) => ({ u_matrix: e4 });
        function hr(t3, i3, o3, r4, s4) {
          if (s4 > 0) {
            const n3 = e3.f.now(), a3 = (n3 - t3.timeAdded) / s4, l3 = i3 ? (n3 - i3.timeAdded) / s4 : -1, c3 = o3.getSource(), h2 = r4.coveringZoomLevel({ tileSize: c3.tileSize, roundZoom: c3.roundZoom }), u3 = !i3 || Math.abs(i3.tileID.overscaledZ - h2) > Math.abs(t3.tileID.overscaledZ - h2), d2 = u3 && t3.refreshedUponExpiration ? 1 : e3.ad(u3 ? a3 : 1 - l3, 0, 1);
            return t3.refreshedUponExpiration && a3 >= 1 && (t3.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class ur extends Qt {
          constructor(t3) {
            const i3 = { type: "raster-dem", maxzoom: t3.transform.maxZoom }, o3 = new e3.bZ(e3.b_(), null), r4 = Gt("mock-dem", i3, o3, t3.style);
            super("mock-dem", r4, false), r4.setEventedParent(this), this._sourceLoaded = true;
          }
          _loadTile(e4, t3) {
            e4.state = "loaded", t3(null);
          }
        }
        class dr extends Qt {
          constructor(t3) {
            const i3 = Gt("proxy", { type: "geojson", maxzoom: t3.transform.maxZoom }, new e3.bZ(e3.b_(), null), t3.style);
            super("proxy", i3, false), i3.setEventedParent(this), this.map = this.getSource().map = t3, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(e4, t3, i3) {
            if (e4.freezeTileCoverage)
              return;
            this.transform = e4;
            const o3 = e4.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t4, i4) => {
              if (t4[i4.key] = "", !this._tiles[i4.key]) {
                const t5 = new Nt(i4, this._source.tileSize * i4.overscaleFactor(), e4.tileZoom);
                t5.state = "loaded", this._tiles[i4.key] = t5;
              }
              return t4;
            }, {});
            for (const e5 in this._tiles)
              e5 in o3 || (this.freeFBO(e5), this._tiles[e5].unloadVectorData(), delete this._tiles[e5]);
          }
          freeFBO(e4) {
            const t3 = this.proxyCachedFBO[e4];
            if (void 0 !== t3) {
              const i3 = Object.values(t3);
              this.renderCachePool.push(...i3), delete this.proxyCachedFBO[e4];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((e4) => e4.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class _r extends e3.ap {
          constructor(e4, t3, i3) {
            super(e4.overscaledZ, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y), this.proxyTileKey = t3, this.projMatrix = i3;
          }
        }
        class pr extends e3.cp {
          constructor(t3, i3) {
            super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, t3.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
              this._style.map.triggerRepaint();
            }), t3.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
              this._style.map.triggerRepaint();
            }), t3.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
              this.invalidateRenderCache = true, this._style.map.triggerRepaint();
            }), this.painter = t3, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [o3, r4, s4] = function(t4) {
              const i4 = new e3.aQ(), o4 = new e3.az(), r5 = 131;
              i4.reserve(17161), o4.reserve(33800);
              const s5 = e3.Y / 128, n4 = e3.Y + s5 / 2, a4 = n4 + s5;
              for (let t5 = -s5; t5 < a4; t5 += s5)
                for (let o5 = -s5; o5 < a4; o5 += s5) {
                  const r6 = o5 < 0 || o5 > n4 || t5 < 0 || t5 > n4 ? 24575 : 0, s6 = e3.ad(Math.round(o5), 0, e3.Y), a5 = e3.ad(Math.round(t5), 0, e3.Y);
                  i4.emplaceBack(s6 + r6, a5);
                }
              const l3 = (e4, t5) => {
                const i5 = t5 * r5 + e4;
                o4.emplaceBack(i5 + 1, i5, i5 + r5), o4.emplaceBack(i5 + r5, i5 + r5 + 1, i5 + 1);
              };
              for (let e4 = 1; e4 < 129; e4++)
                for (let t5 = 1; t5 < 129; t5++)
                  l3(t5, e4);
              return [0, 129].forEach((e4) => {
                for (let t5 = 0; t5 < 130; t5++)
                  l3(t5, e4), l3(e4, t5);
              }), [i4, o4, 32768];
            }(), n3 = t3.context;
            this.gridBuffer = n3.createVertexBuffer(o3, e3.aS.members), this.gridIndexBuffer = n3.createIndexBuffer(r4), this.gridSegments = e3.aE.simpleSegment(0, 0, o3.length, r4.length), this.gridNoSkirtSegments = e3.aE.simpleSegment(0, 0, o3.length, s4), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new dr(i3.map), this.orthoMatrix = e3.a9.create(), e3.a9.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e3.Y, 0, e3.Y, 0, 1);
            const a3 = n3.gl;
            this._overlapStencilMode = new Dt({ func: a3.GEQUAL, mask: 255 }, 0, 255, a3.KEEP, a3.KEEP, a3.REPLACE), this._previousZoom = t3.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i3, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new ur(i3.map), this._pendingGroundEffectLayers = [];
          }
          set style(e4) {
            e4.on("data", this._onStyleDataEvent.bind(this)), this._style = e4, this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t3, i3, o3) {
            if (t3 && t3.terrain) {
              this._style !== t3 && (this.style = t3, this._evaluationZoom = void 0);
              const r4 = t3.terrain.properties, s4 = 0 === t3.terrain.drapeRenderMode, n3 = t3.terrain.isZoomDependent();
              this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e3.f.now();
              const a3 = t3.terrain && t3.terrain.scope, l3 = r4.get("source"), c3 = s4 ? this._mockSourceCache : t3.getSourceCache(l3, a3);
              if (!c3)
                return void e3.w(`Couldn't find terrain source "${l3}".`);
              if (this.sourceCache = c3, this._exaggeration = n3 ? this.calculateExaggeration(i3) : r4.get("exaggeration"), !i3.projection.requiresDraping && n3 && 0 === this._exaggeration)
                return void this._disable();
              this.enabled = true;
              const h2 = () => {
                this.sourceCache.used && e3.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const t4 = this.getScaledDemTileSize();
                this.sourceCache.update(i3, t4, true), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h2(), this._initializing = true), h2(), i3.updateElevation(true, o3), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i3), this._emptyDEMTextureDirty = true, this._previousZoom = i3.zoom;
            } else
              this._disable();
          }
          calculateExaggeration(t3) {
            const i3 = this._previousCameraAltitude, o3 = t3.getFreeCameraOptions().position.z / t3.pixelsPerMeter * t3.worldSize;
            this._previousCameraAltitude = o3;
            const r4 = null != i3 ? o3 - i3 : Number.MAX_VALUE;
            if (Math.abs(r4) < 2)
              return this._exaggeration;
            const s4 = t3.zoom, n3 = this._style.terrain;
            if (!this._previousUpdateTimestamp)
              return n3.getExaggeration(s4);
            let a3 = s4 - this._previousZoom;
            const l3 = this._previousUpdateTimestamp;
            let c3 = s4;
            null != this._evaluationZoom && (c3 = this._evaluationZoom, Math.abs(s4 - c3) > 0.5 && (a3 = 0.5 * (s4 - c3 + a3)), a3 * r4 < 0 && (c3 += a3)), this._evaluationZoom = c3;
            const h2 = n3.getExaggeration(c3), u3 = h2 === n3.getExaggeration(Math.max(0, c3 - 0.1));
            if (u3 && Math.abs(h2 - this._exaggeration) < 0.01)
              return h2;
            let d2 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l3));
            return (u3 || h2 < 0.1 || Math.abs(a3) < 1e-4) && (d2 = Math.min(0.2, 4 * d2)), e3.X(this._exaggeration, h2, d2);
          }
          resetTileLookupCache(e4) {
            this._findCoveringTileCache[e4] = {};
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _onStyleDataEvent(e4) {
            e4.coord && "source" === e4.dataType ? this._clearRenderCacheForTile(e4.sourceCacheId, e4.coord) : "style" === e4.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
          }
          _disable() {
            if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
              for (const e4 in this._style._mergedSourceCaches)
                this._style._mergedSourceCaches[e4].usedForTerrain = false;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e4) => e4.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this._exaggeration;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const e4 = 2 * this.proxySourceCache.getSource().tileSize;
            return [e4, e4];
          }
          set useVertexMorphing(e4) {
            this._useVertexMorphing = e4;
          }
          updateTileBinding(t3) {
            if (!this.enabled)
              return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const i3 = this.proxySourceCache, o3 = this.painter.transform;
            this._initializing && (this._initializing = 0 === o3._centerAltitude && -1 === this.getAtPointOrZero(e3.O.fromLngLat(o3.center), -1), this._emptyDEMTextureDirty = !this._initializing);
            const r4 = this.proxyCoords = i3.getIds().map((e4) => {
              const t4 = i3.getTileByID(e4).tileID;
              return t4.projMatrix = o3.calculateProjMatrix(t4.toUnwrapped()), t4;
            });
            !function(t4, i4) {
              const o4 = i4.transform.pointCoordinate(i4.transform.getCameraPoint()), r5 = new e3.P(o4.x, o4.y);
              t4.sort((t5, i5) => {
                if (i5.overscaledZ - t5.overscaledZ)
                  return i5.overscaledZ - t5.overscaledZ;
                const o5 = new e3.P(t5.canonical.x + (1 << t5.canonical.z) * t5.wrap, t5.canonical.y), s5 = new e3.P(i5.canonical.x + (1 << i5.canonical.z) * i5.wrap, i5.canonical.y), n4 = r5.mult(1 << t5.canonical.z);
                return n4.x -= 0.5, n4.y -= 0.5, n4.distSqr(o5) - n4.distSqr(s5);
              });
            }(r4, this.painter);
            const s4 = this.proxyToSource || {};
            this.proxyToSource = {}, r4.forEach((e4) => {
              this.proxyToSource[e4.key] = {};
            }), this.terrainTileForTile = {};
            const n3 = this._style._mergedSourceCaches;
            for (const e4 in n3) {
              const i4 = n3[e4];
              if (!i4.used)
                continue;
              if (i4 !== this.sourceCache && this.resetTileLookupCache(i4.id), this._setupProxiedCoordsForOrtho(i4, t3[e4], s4), i4.usedForTerrain)
                continue;
              const o4 = t3[e4];
              i4.getSource().reparseOverscaled && this._assignTerrainTiles(o4);
            }
            this.proxiedCoords[i3.id] = r4.map((e4) => new _r(e4, e4.key, this.orthoMatrix)), this._assignTerrainTiles(r4), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(s4), this.renderingToTexture = false;
            const a3 = {};
            this._visibleDemTiles = [];
            for (const e4 of this.proxyCoords) {
              const t4 = this.terrainTileForTile[e4.key];
              if (!t4)
                continue;
              const i4 = t4.tileID.key;
              i4 in a3 || (this._visibleDemTiles.push(t4), a3[i4] = i4);
            }
          }
          _assignTerrainTiles(e4) {
            this._initializing || e4.forEach((e5) => {
              if (this.terrainTileForTile[e5.key])
                return;
              const t3 = this._findTileCoveringTileID(e5, this.sourceCache);
              t3 && (this.terrainTileForTile[e5.key] = t3);
            });
          }
          _prepareDEMTextures() {
            const e4 = this.painter.context, t3 = e4.gl;
            for (const i3 in this.terrainTileForTile) {
              const o3 = this.terrainTileForTile[i3], r4 = o3.dem;
              !r4 || o3.demTexture && !o3.needsDEMTextureUpload || (e4.activeTexture.set(t3.TEXTURE1), Ko(this.painter, o3, r4));
            }
          }
          _prepareDemTileUniforms(e4, t3, i3, o3) {
            if (!t3 || null == t3.demTexture)
              return false;
            const r4 = e4.tileID.canonical, s4 = Math.pow(2, t3.tileID.canonical.z - r4.z), n3 = o3 || "";
            return i3[`u_dem_tl${n3}`] = [r4.x * s4 % 1, r4.y * s4 % 1], i3[`u_dem_scale${n3}`] = s4, true;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          get emptyDepthBufferTexture() {
            const t3 = this.painter.context, i3 = t3.gl;
            if (!this._emptyDepthBufferTexture) {
              const o3 = new e3.h({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
              this._emptyDepthBufferTexture = new e3.T(t3, o3, i3.RGBA, { premultiply: false });
            }
            return this._emptyDepthBufferTexture;
          }
          _getLoadedAreaMinimum() {
            let e4 = 0;
            const t3 = this._visibleDemTiles.reduce((t4, i3) => {
              if (!i3.dem)
                return t4;
              const o3 = i3.dem.tree.minimums[0];
              return o3 > 0 && e4++, t4 + o3;
            }, 0);
            return e4 ? t3 / e4 : 0;
          }
          _updateEmptyDEMTexture() {
            const t3 = this.painter.context, i3 = t3.gl;
            t3.activeTexture.set(i3.TEXTURE2);
            const o3 = this._getLoadedAreaMinimum(), [r4, s4] = (() => {
              const t4 = new e3.cr({ width: 1, height: 1 }, new Float32Array([o3]));
              return [i3.R32F, t4];
            })();
            this._emptyDEMTextureDirty = false;
            let n3 = this._emptyDEMTexture;
            return n3 ? n3.update(s4, { premultiply: false }) : n3 = this._emptyDEMTexture = new e3.T(t3, s4, r4, { premultiply: false }), n3;
          }
          setupElevationDraw(t3, i3, o3) {
            const r4 = this.painter.context, s4 = r4.gl, n3 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 };
            n3.u_exaggeration = this.exaggeration();
            let a3 = null, l3 = null, c3 = 1;
            if (o3 && o3.morphing && this._useVertexMorphing) {
              const e4 = o3.morphing.srcDemTile, i4 = o3.morphing.dstDemTile;
              c3 = o3.morphing.phase, e4 && i4 && (this._prepareDemTileUniforms(t3, e4, n3, "_prev") && (l3 = e4), this._prepareDemTileUniforms(t3, i4, n3) && (a3 = i4));
            }
            const h2 = (e4) => e4 && e4.demTexture && this.painter.linearFloatFilteringSupported() ? s4.LINEAR : s4.NEAREST, u3 = (e4) => {
              n3.u_dem_size = 1 === e4.size[0] ? 1 : e4.size[0] - 2;
            };
            if (l3 && a3)
              r4.activeTexture.set(s4.TEXTURE2), a3.demTexture.bind(h2(a3), s4.CLAMP_TO_EDGE), r4.activeTexture.set(s4.TEXTURE4), l3.demTexture.bind(h2(l3), s4.CLAMP_TO_EDGE), a3.demTexture && u3(a3.demTexture), n3.u_dem_lerp = c3;
            else {
              a3 = this.terrainTileForTile[t3.tileID.key], r4.activeTexture.set(s4.TEXTURE2);
              const e4 = this._prepareDemTileUniforms(t3, a3, n3) ? a3.demTexture : this.emptyDEMTexture;
              e4.bind(h2(a3), s4.CLAMP_TO_EDGE), u3(e4);
            }
            if (r4.activeTexture.set(s4.TEXTURE3), o3 && o3.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE), this._depthFBO && (n3.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE), n3.u_depth_size_inv = [1, 1]), o3 && o3.useMeterToDem && a3) {
              const t4 = (1 << a3.tileID.canonical.z) * e3.bo(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              n3.u_meter_to_dem = t4;
            }
            if (o3 && o3.labelPlaneMatrixInv && (n3.u_label_plane_matrix_inv = o3.labelPlaneMatrixInv), i3.setTerrainUniformValues(r4, n3), "globe" === this.painter.transform.projection.name) {
              const e4 = this.globeUniformValues(this.painter.transform, t3.tileID.canonical, o3 && o3.useDenormalizedUpVectorScale);
              i3.setGlobeUniformValues(r4, e4);
            }
          }
          globeUniformValues(t3, i3, o3) {
            const r4 = t3.projection;
            return { u_tile_tl_up: r4.upVector(i3, 0, 0), u_tile_tr_up: r4.upVector(i3, e3.Y, 0), u_tile_br_up: r4.upVector(i3, e3.Y, e3.Y), u_tile_bl_up: r4.upVector(i3, 0, e3.Y), u_tile_up_scale: o3 ? e3.cq(1) : r4.upVectorScale(i3, t3.center.lat, t3.worldSize).metersToTile };
          }
          renderToBackBuffer(t3) {
            const i3 = this.painter, o3 = this.painter.context;
            0 !== t3.length && (o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, i3.width, i3.height]), i3.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t4, i4, o4, r4, s4) {
              if ("globe" === t4.transform.projection.name)
                !function(t5, i5, o5, r5, s5) {
                  const n3 = t5.context, a3 = n3.gl;
                  let l3, c3;
                  const h2 = t5.transform, u3 = e3.ci(t5, n3, h2), d2 = (e4, i6) => {
                    if (c3 === i6)
                      return;
                    const o6 = [nr[i6], "PROJECTION_GLOBE_VIEW"];
                    u3 && o6.push("CUSTOM_ANTIALIASING");
                    const r6 = t5.isTileAffectedByFog(e4);
                    l3 = t5.getOrCreateProgram("globeRaster", { defines: o6, overrideFog: r6 }), c3 = i6;
                  }, _3 = t5.colorModeForRenderPass(), p3 = new Ct(a3.LEQUAL, Ct.ReadWrite, t5.depthRangeFor3D);
                  sr.update(s5);
                  const f2 = e3.cj(h2), m2 = [e3.a8(h2.center.lng), e3.ah(h2.center.lat)], g3 = t5.globeSharedBuffers, v3 = [h2.width * e3.f.devicePixelRatio, h2.height * e3.f.devicePixelRatio], x3 = Float32Array.from(h2.globeMatrix), y3 = { useDenormalizedUpVectorScale: true };
                  {
                    const h3 = t5.transform, u4 = ar(h3.zoom, i5.exaggeration(), i5.sourceCache._source.tileSize);
                    c3 = -1;
                    const b2 = a3.TRIANGLES;
                    for (const c4 of r5) {
                      const r6 = o5.getTile(c4), w2 = Dt.disabled, T2 = i5.prevTerrainTileForTile[c4.key], E2 = i5.terrainTileForTile[c4.key];
                      rr(T2, E2) && sr.newMorphing(c4.key, T2, E2, s5, 250), n3.activeTexture.set(a3.TEXTURE0), r6.texture && r6.texture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
                      const S2 = sr.getMorphValuesForProxy(c4.key), C2 = S2 ? 1 : 0;
                      S2 && e3.k(y3, { morphing: { srcDemTile: S2.from, dstDemTile: S2.to, phase: e3.ch(S2.phase) } });
                      const I2 = e3.ck(c4.canonical), D2 = e3.cl(I2.getCenter().lat), R3 = e3.cm(c4.canonical, I2, D2, h3.worldSize / h3._pixelsPerMercatorPixel), A2 = e3.aW(e3.cn(c4.canonical)), P2 = or(h3.expandedFarZProjMatrix, x3, f2, A2, e3.W(h3.zoom), m2, h3.frustumCorners.TL, h3.frustumCorners.TR, h3.frustumCorners.BR, h3.frustumCorners.BL, h3.globeCenterInViewSpace, h3.globeRadius, v3, u4, h3._farZ, R3);
                      if (d2(c4, C2), l3 && (i5.setupElevationDraw(r6, l3, y3), t5.uploadCommonUniforms(n3, l3, c4.toUnwrapped()), g3)) {
                        const [e4, i6, o6] = g3.getGridBuffers(D2, 0 !== u4);
                        l3.draw(t5, b2, p3, w2, _3, Mt.backCCW, P2, "globe_raster", e4, i6, o6);
                      }
                    }
                  }
                  if (g3 && (t5.renderDefaultNorthPole || t5.renderDefaultSouthPole)) {
                    const s6 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                    u3 && s6.push("CUSTOM_ANTIALIASING"), l3 = t5.getOrCreateProgram("globeRaster", { defines: s6 });
                    for (const s7 of r5) {
                      const { x: r6, y: c4, z: u4 } = s7.canonical, d3 = 0 === c4, f3 = c4 === (1 << u4) - 1, [x4, b2, w2, T2] = g3.getPoleBuffers(u4, false);
                      if (T2 && (d3 || f3)) {
                        const c5 = o5.getTile(s7);
                        n3.activeTexture.set(a3.TEXTURE0), c5.texture && c5.texture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
                        let g4 = e3.co(u4, r6, h2);
                        const E2 = e3.aW(e3.cn(s7.canonical)), S2 = (e4, i6) => e4.draw(t5, a3.TRIANGLES, p3, Dt.disabled, _3, Mt.disabled, or(h2.expandedFarZProjMatrix, g4, g4, E2, 0, m2, h2.frustumCorners.TL, h2.frustumCorners.TR, h2.frustumCorners.BR, h2.frustumCorners.BL, h2.globeCenterInViewSpace, h2.globeRadius, v3, 0, h2._farZ), "globe_pole_raster", i6, w2, T2);
                        i5.setupElevationDraw(c5, l3, y3), t5.uploadCommonUniforms(n3, l3, s7.toUnwrapped()), d3 && t5.renderDefaultNorthPole && S2(l3, x4), f3 && t5.renderDefaultSouthPole && (g4 = e3.a9.scale(e3.a9.create(), g4, [1, -1, 1]), S2(l3, b2));
                      }
                    }
                  }
                }(t4, i4, o4, r4, s4);
              else {
                const n3 = t4.context, a3 = n3.gl;
                let l3, c3;
                const h2 = t4.shadowRenderer, u3 = mo(t4, t4.longestCutoffRange), d2 = (e4) => {
                  if (c3 === e4)
                    return;
                  const i5 = [];
                  i5.push(nr[e4]), u3.shouldRenderCutoff && i5.push("RENDER_CUTOFF"), l3 = t4.getOrCreateProgram("terrainRaster", { defines: i5 }), c3 = e4;
                }, _3 = t4.colorModeForRenderPass(), p3 = new Ct(a3.LEQUAL, Ct.ReadWrite, t4.depthRangeFor3D);
                sr.update(s4);
                const f2 = t4.transform, m2 = ar(f2.zoom, i4.exaggeration(), i4.sourceCache._source.tileSize);
                let g3 = [0, 0, 0];
                if (h2) {
                  const e4 = t4.style.directionalLight, i5 = t4.style.ambientLight;
                  e4 && i5 && (g3 = To(e4, i5));
                }
                {
                  c3 = -1;
                  const v3 = a3.TRIANGLES, [x3, y3] = [i4.gridIndexBuffer, i4.gridSegments];
                  for (const c4 of r4) {
                    const r5 = o4.getTile(c4), b2 = Dt.disabled, w2 = i4.prevTerrainTileForTile[c4.key], T2 = i4.terrainTileForTile[c4.key];
                    rr(w2, T2) && sr.newMorphing(c4.key, w2, T2, s4, 250), n3.activeTexture.set(a3.TEXTURE0), r5.texture && r5.texture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
                    const E2 = sr.getMorphValuesForProxy(c4.key), S2 = E2 ? 1 : 0;
                    let C2;
                    E2 && (C2 = { morphing: { srcDemTile: E2.from, dstDemTile: E2.to, phase: e3.ch(E2.phase) } });
                    const I2 = ir(c4.projMatrix, lr(c4.canonical, f2.renderWorldCopies) ? m2 / 10 : m2, g3);
                    if (d2(S2), !l3)
                      continue;
                    i4.setupElevationDraw(r5, l3, C2);
                    const D2 = c4.toUnwrapped();
                    h2 && h2.setupShadows(D2, l3), t4.uploadCommonUniforms(n3, l3, D2, null, u3), l3.draw(t4, v3, p3, b2, _3, Mt.backCCW, I2, "terrain_raster", i4.gridBuffer, x3, y3);
                  }
                }
              }
            }(i3, this, this.proxySourceCache, t3, this._updateTimestamp), this.renderingToTexture = true, i3.gpuTimingDeferredRenderEnd(), t3.splice(0, t3.length));
          }
          renderBatch(t3) {
            if (0 === this._drapedRenderBatches.length)
              return t3 + 1;
            this.renderingToTexture = true;
            const i3 = this.painter, o3 = this.painter.context, r4 = this.proxySourceCache, s4 = this.proxiedCoords[r4.id], n3 = this._drapedRenderBatches.shift(), a3 = i3.style.order, l3 = [];
            let c3 = 0;
            for (const h2 of s4) {
              const s5 = r4.getTileByID(h2.proxyTileKey), u3 = r4.proxyCachedFBO[h2.key] ? r4.proxyCachedFBO[h2.key][t3] : void 0, d2 = void 0 !== u3 ? r4.renderCache[u3] : this.pool[c3++], _3 = void 0 !== u3;
              if (s5.texture = d2.tex, _3 && !d2.dirty) {
                l3.push(s5.tileID);
                continue;
              }
              let p3;
              o3.bindFramebuffer.set(d2.fb.framebuffer), this.renderedToTile = false, d2.dirty && (o3.clear({ color: e3.aA.transparent, stencil: 0 }), d2.dirty = false);
              for (let e4 = n3.start; e4 <= n3.end; ++e4) {
                const t4 = i3.style._mergedLayers[a3[e4]];
                if (t4.isHidden(i3.transform.zoom))
                  continue;
                const r5 = i3.style.getLayerSourceCache(t4), s6 = r5 ? this.proxyToSource[h2.key][r5.id] : [h2];
                if (!s6)
                  continue;
                const n4 = s6;
                o3.viewport.set([0, 0, d2.fb.width, d2.fb.height]), p3 !== (r5 ? r5.id : null) && (this._setupStencil(d2, s6, t4, r5), p3 = r5 ? r5.id : null), i3.renderLayer(i3, r5, t4, n4);
              }
              if (0 === this._drapedRenderBatches.length)
                for (const e4 of this._pendingGroundEffectLayers) {
                  const t4 = i3.style._mergedLayers[a3[e4]];
                  if (t4.isHidden(i3.transform.zoom))
                    continue;
                  const r5 = i3.style.getLayerSourceCache(t4), s6 = r5 ? this.proxyToSource[h2.key][r5.id] : [h2];
                  if (!s6)
                    continue;
                  const n4 = s6;
                  o3.viewport.set([0, 0, d2.fb.width, d2.fb.height]), p3 !== (r5 ? r5.id : null) && (this._setupStencil(d2, s6, t4, r5), p3 = r5 ? r5.id : null), i3.renderLayer(i3, r5, t4, n4);
                }
              this.renderedToTile ? (d2.dirty = true, l3.push(s5.tileID)) : _3 || --c3, 5 === c3 && (c3 = 0, this.renderToBackBuffer(l3));
            }
            return this.renderToBackBuffer(l3), this.renderingToTexture = false, o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, i3.width, i3.height]), n3.end + 1;
          }
          postRender() {
          }
          isLayerOrderingCorrect(e4) {
            const t3 = e4.order.length;
            let i3 = -1, o3 = t3;
            for (let r4 = 0; r4 < t3; ++r4)
              this._style.isLayerDraped(e4._mergedLayers[e4.order[r4]]) ? i3 = Math.max(i3, r4) : o3 = Math.min(o3, r4);
            return o3 > i3;
          }
          getMinElevationBelowMSL() {
            let e4 = 0;
            return this._visibleDemTiles.filter((e5) => e5.dem).forEach((t3) => {
              e4 = Math.min(e4, t3.dem.tree.minimums[0]);
            }), 0 === e4 ? e4 : (e4 - 30) * this._exaggeration;
          }
          raycast(e4, t3, i3) {
            if (!this._visibleDemTiles)
              return null;
            const o3 = this._visibleDemTiles.filter((e5) => e5.dem).map((o4) => {
              const r4 = o4.tileID, s4 = 1 << r4.overscaledZ, { x: n3, y: a3 } = r4.canonical, l3 = n3 / s4, c3 = (n3 + 1) / s4, h2 = a3 / s4, u3 = (a3 + 1) / s4;
              return { minx: l3, miny: h2, maxx: c3, maxy: u3, t: o4.dem.tree.raycastRoot(l3, h2, c3, u3, e4, t3, i3), tile: o4 };
            });
            o3.sort((e5, t4) => (null !== e5.t ? e5.t : Number.MAX_VALUE) - (null !== t4.t ? t4.t : Number.MAX_VALUE));
            for (const r4 of o3) {
              if (null == r4.t)
                return null;
              const o4 = r4.tile.dem.tree.raycast(r4.minx, r4.miny, r4.maxx, r4.maxy, e4, t3, i3);
              if (null != o4)
                return o4;
            }
            return null;
          }
          _createFBO() {
            const t3 = this.painter.context, i3 = t3.gl, o3 = this.drapeBufferSize;
            t3.activeTexture.set(i3.TEXTURE0);
            const r4 = new e3.T(t3, { width: o3[0], height: o3[1], data: null }, i3.RGBA);
            r4.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
            const s4 = t3.createFramebuffer(o3[0], o3[1], true, null);
            return s4.colorAttachment.set(r4.texture), s4.depthAttachment = new Et(t3, s4.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t3.createRenderbuffer(t3.gl.DEPTH_STENCIL, o3[0], o3[1]), this._stencilRef = 0, s4.depthAttachment.set(this._sharedDepthStencil), t3.clear({ stencil: 0 })) : s4.depthAttachment.set(this._sharedDepthStencil), t3.extTextureFilterAnisotropic && i3.texParameterf(i3.TEXTURE_2D, t3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t3.extTextureFilterAnisotropicMax), { fb: s4, tex: r4, dirty: false };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
              this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._debugParams.disableRenderCache)
              return true;
            if (this._style.hasLightTransitions())
              return true;
            for (const e4 in this._style._mergedSourceCaches)
              if (this._style._mergedSourceCaches[e4].hasTransition())
                return true;
            return this._style.order.some((e4) => {
              const t3 = this._style._mergedLayers[e4], i3 = t3.isHidden(this.painter.transform.zoom);
              return "custom" === t3.type ? !i3 && t3.shouldRedrape() : !i3 && t3.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t3 = false;
            for (const e4 of this._style.getSources())
              if (e4 instanceof Re) {
                t3 = true;
                break;
              }
            if (!t3)
              return;
            const i3 = {};
            for (let t4 = 0; t4 < this._style.order.length; ++t4) {
              const o3 = this._style._mergedLayers[this._style.order[t4]], r4 = this._style.getLayerSourceCache(o3);
              if (r4 && !i3[r4.id] && !o3.isHidden(this.painter.transform.zoom) && "line" === o3.type && o3.widthExpression() instanceof e3.Z) {
                i3[r4.id] = true;
                for (const e4 of this.proxyCoords) {
                  const t5 = this.proxyToSource[e4.key][r4.id];
                  if (t5)
                    for (const e5 of t5)
                      this._clearRenderCacheForTile(r4.id, e5);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let e4 = false;
            for (const t4 in this._style._mergedSourceCaches)
              if (this._style._mergedSourceCaches[t4]._source instanceof Ae) {
                e4 = true;
                break;
              }
            if (!e4)
              return;
            const t3 = {};
            for (let e5 = 0; e5 < this._style.order.length; ++e5) {
              const i3 = this._style._mergedLayers[this._style.order[e5]], o3 = this._style.getLayerSourceCache(i3);
              if (!o3 || t3[o3.id])
                continue;
              if (i3.isHidden(this.painter.transform.zoom) || "raster" !== i3.type)
                continue;
              const r4 = i3.paint.get("raster-fade-duration");
              for (const e6 of this.proxyCoords) {
                const t4 = this.proxyToSource[e6.key][o3.id];
                if (t4)
                  for (const e7 of t4) {
                    const t5 = hr(o3.getTile(e7), o3.findLoadedParent(e7, 0), o3, this.painter.transform, r4);
                    (1 !== t5.opacity || 0 !== t5.mix) && this._clearRenderCacheForTile(o3.id, e7);
                  }
              }
            }
          }
          _setupDrapedRenderBatches() {
            const t3 = this._style.order, i3 = t3.length;
            if (0 === i3)
              return;
            const o3 = [];
            this._pendingGroundEffectLayers = [];
            let r4, s4 = 0, n3 = this._style._mergedLayers[t3[s4]];
            for (; !this._style.isLayerDraped(n3) && n3.isHidden(this.painter.transform.zoom) && ++s4 < i3; )
              n3 = this._style._mergedLayers[t3[s4]];
            for (; s4 < i3; ++s4) {
              const e4 = this._style._mergedLayers[t3[s4]];
              e4.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e4) ? void 0 === r4 && (r4 = s4) : ("fill-extrusion" === e4.type && this._pendingGroundEffectLayers.push(s4), void 0 !== r4 && (o3.push({ start: r4, end: s4 - 1 }), r4 = void 0)));
            }
            if (void 0 !== r4 && o3.push({ start: r4, end: s4 - 1 }), 0 !== o3.length) {
              const t4 = o3[o3.length - 1];
              this._pendingGroundEffectLayers.every((e4) => e4 > t4.end) || e3.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
            }
            this._drapedRenderBatches = o3;
          }
          _setupRenderCache(e4) {
            const t3 = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
              if (this.invalidateRenderCache = false, t3.renderCache.length > t3.renderCachePool.length) {
                const e5 = Object.values(t3.proxyCachedFBO);
                t3.proxyCachedFBO = {};
                for (let i4 = 0; i4 < e5.length; ++i4) {
                  const o4 = Object.values(e5[i4]);
                  t3.renderCachePool.push(...o4);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const i3 = this.proxyCoords, o3 = this._tilesDirty;
            for (let r5 = i3.length - 1; r5 >= 0; r5--) {
              const s4 = i3[r5];
              if (t3.getTileByID(s4.key), void 0 !== t3.proxyCachedFBO[s4.key]) {
                const i4 = e4[s4.key], r6 = this.proxyToSource[s4.key];
                let n3 = 0;
                for (const e5 in r6) {
                  const t4 = r6[e5], s5 = i4[e5];
                  if (!s5 || s5.length !== t4.length || t4.some((t5, i5) => t5 !== s5[i5] || o3[e5] && o3[e5].hasOwnProperty(t5.key))) {
                    n3 = -1;
                    break;
                  }
                  ++n3;
                }
                for (const e5 in t3.proxyCachedFBO[s4.key])
                  t3.renderCache[t3.proxyCachedFBO[s4.key][e5]].dirty = n3 < 0 || n3 !== Object.values(i4).length;
              }
            }
            const r4 = [...this._drapedRenderBatches];
            r4.sort((e5, t4) => t4.end - t4.start - (e5.end - e5.start));
            for (const e5 of r4)
              for (const o4 of i3) {
                if (t3.proxyCachedFBO[o4.key])
                  continue;
                let i4 = t3.renderCachePool.pop();
                void 0 === i4 && t3.renderCache.length < 50 && (i4 = t3.renderCache.length, t3.renderCache.push(this._createFBO())), void 0 !== i4 && (t3.proxyCachedFBO[o4.key] = {}, t3.proxyCachedFBO[o4.key][e5.start] = i4, t3.renderCache[i4].dirty = true);
              }
            this._tilesDirty = {};
          }
          _setupStencil(e4, t3, i3, o3) {
            if (!o3 || !this._sourceTilesOverlap[o3.id])
              return void (this._overlapStencilType && (this._overlapStencilType = false));
            const r4 = this.painter.context, s4 = r4.gl;
            if (t3.length <= 1)
              return void (this._overlapStencilType = false);
            let n3;
            if (i3.isTileClipped())
              n3 = t3.length, this._overlapStencilMode.test = { func: s4.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(t3[0].overscaledZ > t3[t3.length - 1].overscaledZ))
                return void (this._overlapStencilType = false);
              n3 = 1, this._overlapStencilMode.test = { func: s4.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + n3 > 255 && (r4.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n3, this._overlapStencilMode.ref = this._stencilRef, i3.isTileClipped() && this._renderTileClippingMasks(t3, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
          }
          stencilModeForRTTOverlap(e4) {
            return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e4.key]), this._overlapStencilMode) : Dt.disabled;
          }
          _renderTileClippingMasks(e4, t3) {
            const i3 = this.painter, o3 = this.painter.context, r4 = o3.gl;
            i3._tileClippingMaskIDs = {}, o3.setColorMode(At.disabled), o3.setDepthMode(Ct.disabled);
            const s4 = i3.getOrCreateProgram("clippingMask");
            for (const o4 of e4) {
              const e5 = i3._tileClippingMaskIDs[o4.key] = --t3;
              s4.draw(i3, r4.TRIANGLES, Ct.disabled, new Dt({ func: r4.ALWAYS, mask: 0 }, e5, 255, r4.KEEP, r4.KEEP, r4.REPLACE), At.disabled, Mt.disabled, cr(o4.projMatrix), "$clipping", i3.tileExtentBuffer, i3.quadTriangleIndexBuffer, i3.tileExtentSegments);
            }
          }
          pointCoordinate(t3) {
            const i3 = this.painter.transform;
            if (t3.x < 0 || t3.x > i3.width || t3.y < 0 || t3.y > i3.height)
              return null;
            const o3 = [t3.x, t3.y, 1, 1];
            e3.aa.transformMat4(o3, o3, i3.pixelMatrixInverse), e3.aa.scale(o3, o3, 1 / o3[3]), o3[0] /= i3.worldSize, o3[1] /= i3.worldSize;
            const r4 = i3._camera.position, s4 = e3.bo(1, i3.center.lat), n3 = [r4[0], r4[1], r4[2] / s4, 0], a3 = e3.Q.subtract([], o3.slice(0, 3), n3);
            e3.Q.normalize(a3, a3);
            const l3 = this.raycast(n3, a3, this._exaggeration);
            return null !== l3 && l3 ? (e3.Q.scaleAndAdd(n3, n3, a3, l3), n3[3] = n3[2], n3[2] *= s4, n3) : null;
          }
          drawDepth() {
            const t3 = this.painter, i3 = t3.context, o3 = this.proxySourceCache, r4 = Math.ceil(t3.width), s4 = Math.ceil(t3.height);
            if (!this._depthFBO || this._depthFBO.width === r4 && this._depthFBO.height === s4 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
              const t4 = i3.gl, o4 = i3.createFramebuffer(r4, s4, true, "renderbuffer");
              i3.activeTexture.set(t4.TEXTURE0);
              const n3 = new e3.T(i3, { width: r4, height: s4, data: null }, t4.RGBA);
              n3.bind(t4.NEAREST, t4.CLAMP_TO_EDGE), o4.colorAttachment.set(n3.texture);
              const a3 = i3.createRenderbuffer(i3.gl.DEPTH_COMPONENT16, r4, s4);
              o4.depthAttachment.set(a3), this._depthFBO = o4, this._depthTexture = n3;
            }
            i3.bindFramebuffer.set(this._depthFBO.framebuffer), i3.viewport.set([0, 0, r4, s4]), function(e4, t4, i4, o4) {
              if ("globe" === e4.transform.projection.name)
                return;
              const r5 = e4.context, s5 = r5.gl;
              r5.clear({ depth: 1 });
              const n3 = e4.getOrCreateProgram("terrainDepth"), a3 = new Ct(s5.LESS, Ct.ReadWrite, e4.depthRangeFor3D);
              for (const r6 of o4) {
                const o5 = i4.getTile(r6), l3 = ir(r6.projMatrix, 0, [0, 0, 0]);
                t4.setupElevationDraw(o5, n3), n3.draw(e4, s5.TRIANGLES, a3, Dt.disabled, At.unblended, Mt.backCCW, l3, "terrain_depth", t4.gridBuffer, t4.gridIndexBuffer, t4.gridNoSkirtSegments);
              }
            }(t3, this, o3, this.proxyCoords);
          }
          _setupProxiedCoordsForOrtho(t3, i3, o3) {
            if (t3.getSource() instanceof e3.as)
              return this._setupProxiedCoordsForImageSource(t3, i3, o3);
            this._findCoveringTileCache[t3.id] = this._findCoveringTileCache[t3.id] || {};
            const r4 = this.proxiedCoords[t3.id] = [], s4 = this.proxyCoords;
            for (let e4 = 0; e4 < s4.length; e4++) {
              const i4 = s4[e4], n4 = this._findTileCoveringTileID(i4, t3);
              if (n4) {
                const e5 = this._createProxiedId(i4, n4, o3[i4.key] && o3[i4.key][t3.id]);
                r4.push(e5), this.proxyToSource[i4.key][t3.id] = [e5];
              }
            }
            let n3 = false;
            const a3 = /* @__PURE__ */ new Set();
            for (let e4 = 0; e4 < i3.length; e4++) {
              const s5 = t3.getTile(i3[e4]);
              if (!s5 || !s5.hasData())
                continue;
              const l3 = this._findTileCoveringTileID(s5.tileID, this.proxySourceCache);
              if (l3 && l3.tileID.canonical.z !== s5.tileID.canonical.z) {
                const e5 = this.proxyToSource[l3.tileID.key][t3.id], i4 = this._createProxiedId(l3.tileID, s5, o3[l3.tileID.key] && o3[l3.tileID.key][t3.id]);
                e5 ? e5.splice(e5.length - 1, 0, i4) : this.proxyToSource[l3.tileID.key][t3.id] = [i4];
                const c3 = this.proxyToSource[l3.tileID.key][t3.id];
                a3.has(c3) || a3.add(c3), r4.push(i4), n3 = true;
              }
            }
            if (this._sourceTilesOverlap[t3.id] = n3, n3 && this._debugParams.sortTilesHiZFirst)
              for (const e4 of a3)
                e4.sort((e5, t4) => t4.overscaledZ - e5.overscaledZ);
          }
          _setupProxiedCoordsForImageSource(t3, i3, o3) {
            if (!t3.getSource().loaded())
              return;
            const r4 = this.proxiedCoords[t3.id] = [], s4 = this.proxyCoords, n3 = t3.getSource(), a3 = n3.tileID;
            if (!a3)
              return;
            const l3 = new e3.P(a3.x, a3.y)._div(1 << a3.z), c3 = n3.coordinates.map(e3.O.fromLngLat).reduce((e4, t4) => (e4.min.x = Math.min(e4.min.x, t4.x - l3.x), e4.min.y = Math.min(e4.min.y, t4.y - l3.y), e4.max.x = Math.max(e4.max.x, t4.x - l3.x), e4.max.y = Math.max(e4.max.y, t4.y - l3.y), e4), { min: new e3.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e3.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h2 = (t4, i4) => {
              const o4 = t4.wrap + t4.canonical.x / (1 << t4.canonical.z), r5 = t4.canonical.y / (1 << t4.canonical.z), s5 = e3.Y / (1 << t4.canonical.z), n4 = i4.wrap + i4.canonical.x / (1 << i4.canonical.z), a4 = i4.canonical.y / (1 << i4.canonical.z);
              return o4 + s5 < n4 + c3.min.x || o4 > n4 + c3.max.x || r5 + s5 < a4 + c3.min.y || r5 > a4 + c3.max.y;
            };
            for (let e4 = 0; e4 < s4.length; e4++) {
              const n4 = s4[e4];
              for (let e5 = 0; e5 < i3.length; e5++) {
                const s5 = t3.getTile(i3[e5]);
                if (!s5 || !s5.hasData())
                  continue;
                if (h2(n4, s5.tileID))
                  continue;
                const a4 = this._createProxiedId(n4, s5, o3[n4.key] && o3[n4.key][t3.id]), l4 = this.proxyToSource[n4.key][t3.id];
                l4 ? l4.push(a4) : this.proxyToSource[n4.key][t3.id] = [a4], r4.push(a4);
              }
            }
          }
          _createProxiedId(t3, i3, o3) {
            let r4 = this.orthoMatrix;
            if (o3) {
              const e4 = o3.find((e5) => e5.key === i3.tileID.key);
              if (e4)
                return e4;
            }
            if (i3.tileID.key !== t3.key) {
              const o4 = t3.canonical.z - i3.tileID.canonical.z;
              let s4, n3, a3;
              r4 = e3.a9.create();
              const l3 = i3.tileID.wrap - t3.wrap << t3.overscaledZ;
              o4 > 0 ? (s4 = e3.Y >> o4, n3 = s4 * ((i3.tileID.canonical.x << o4) - t3.canonical.x + l3), a3 = s4 * ((i3.tileID.canonical.y << o4) - t3.canonical.y)) : (s4 = e3.Y << -o4, n3 = e3.Y * (i3.tileID.canonical.x - (t3.canonical.x + l3 << -o4)), a3 = e3.Y * (i3.tileID.canonical.y - (t3.canonical.y << -o4))), e3.a9.ortho(r4, 0, s4, 0, s4, 0, 1), e3.a9.translate(r4, r4, [n3, a3, 0]);
            }
            return new _r(i3.tileID, t3.key, r4);
          }
          _findTileCoveringTileID(t3, i3) {
            let o3 = i3.getTile(t3);
            if (o3 && o3.hasData())
              return o3;
            const r4 = this._findCoveringTileCache[i3.id], s4 = r4[t3.key];
            if (o3 = s4 ? i3.getTileByID(s4) : null, o3 && o3.hasData() || null === s4)
              return o3;
            let n3 = o3 ? o3.tileID : t3, a3 = n3.overscaledZ;
            const l3 = i3.getSource().minzoom, c3 = [];
            if (!s4) {
              const r5 = i3.getSource().maxzoom;
              if (t3.canonical.z >= r5) {
                const o4 = t3.canonical.z - r5;
                i3.getSource().reparseOverscaled ? (a3 = Math.max(t3.canonical.z + 2, i3.transform.tileZoom), n3 = new e3.ap(a3, t3.wrap, r5, t3.canonical.x >> o4, t3.canonical.y >> o4)) : 0 !== o4 && (a3 = r5, n3 = new e3.ap(a3, t3.wrap, r5, t3.canonical.x >> o4, t3.canonical.y >> o4));
              }
              n3.key !== t3.key && (c3.push(n3.key), o3 = i3.getTile(n3));
            }
            const h2 = (e4) => {
              c3.forEach((t4) => {
                r4[t4] = e4;
              }), c3.length = 0;
            };
            for (a3 -= 1; a3 >= l3 && (!o3 || !o3.hasData()); a3--) {
              o3 && h2(o3.tileID.key);
              const e4 = n3.calculateScaledKey(a3);
              if (o3 = i3.getTileByID(e4), o3 && o3.hasData())
                break;
              const t4 = r4[e4];
              if (null === t4)
                break;
              void 0 === t4 ? c3.push(e4) : o3 = i3.getTileByID(t4);
            }
            return h2(o3 ? o3.tileID.key : null), o3 && o3.hasData() ? o3 : null;
          }
          findDEMTileFor(e4) {
            return this.enabled ? this._findTileCoveringTileID(e4, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = true;
          }
          _clearRenderCacheForTile(e4, t3) {
            let i3 = this._tilesDirty[e4];
            i3 || (i3 = this._tilesDirty[e4] = {}), i3[t3.key] = true;
          }
        }
        function fr(t3, i3, o3) {
          const r4 = function(t4, i4, o4) {
            const r5 = e3.Q.dot(i4, t4), s5 = e3.Q.dot(o4, [0.2126, 0.7152, 0.0722]), n4 = (e4, t5, i5) => (1 - i5) * e4 + i5 * t5, a4 = n4(1 - 0.3 * Math.min(s5, 1), 1, Math.min(r5 + 1, 1));
            return n4(0.92, 1, Math.asin(e3.ad(i4[2], -1, 1)) / Math.PI + 0.5) * a4;
          }(t3, [0, 0, 1], i3), s4 = [0, 0, 0];
          e3.Q.scale(s4, o3.slice(0, 3), r4);
          const n3 = [0, 0, 0];
          e3.Q.scale(n3, i3.slice(0, 3), t3[2]);
          const a3 = [0, 0, 0];
          return e3.Q.add(a3, s4, n3), e3.bX(a3);
        }
        const mr = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], gr = ["stars", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbolSDF", "symbolIcon", "symbolTextAndIcon"];
        class vr {
          static cacheKey(e4, t3, i3, o3) {
            let r4 = `${t3}${o3 ? o3.cacheKey : ""}`;
            for (const t4 of i3)
              e4.usedDefines.includes(t4) && (r4 += `/${t4}`);
            return r4;
          }
          constructor(t3, i3, o3, r4, s4, n3) {
            const a3 = t3.gl;
            this.program = a3.createProgram(), this.configuration = r4, this.name = i3, this.fixedDefines = [...n3];
            const l3 = r4 ? r4.getBinderAttributes() : [], c3 = (o3.staticAttributes || []).concat(l3);
            let h2 = r4 ? r4.defines() : [];
            h2 = h2.concat(n3.map((e4) => `#define ${e4}`));
            const u3 = "#version 300 es\n";
            let d2 = u3 + h2.concat("precision mediump float;", Ho, Wo.fragmentSource).join("\n");
            for (const e4 of o3.fragmentIncludes)
              d2 += `
${Vo[e4]}`;
            d2 += `
${o3.fragmentSource}`;
            let _3 = u3 + h2.concat("precision highp float;", Ho, Wo.vertexSource).join("\n");
            for (const e4 of o3.vertexIncludes)
              _3 += `
${Vo[e4]}`;
            _3 += `
${o3.vertexSource}`;
            const p3 = a3.createShader(a3.FRAGMENT_SHADER);
            if (a3.isContextLost())
              return void (this.failedToCreate = true);
            a3.shaderSource(p3, d2), a3.compileShader(p3), a3.attachShader(this.program, p3);
            const f2 = a3.createShader(a3.VERTEX_SHADER);
            if (a3.isContextLost())
              this.failedToCreate = true;
            else {
              a3.shaderSource(f2, _3), a3.compileShader(f2), a3.attachShader(this.program, f2), this.attributes = {}, this.numAttributes = c3.length;
              for (let e4 = 0; e4 < this.numAttributes; e4++)
                if (c3[e4]) {
                  const t4 = c3[e4].startsWith("a_") ? c3[e4] : `a_${c3[e4]}`;
                  a3.bindAttribLocation(this.program, e4, t4), this.attributes[t4] = e4;
                }
              a3.linkProgram(this.program), a3.deleteShader(f2), a3.deleteShader(p3), this.fixedUniforms = s4(t3), this.binderUniforms = r4 ? r4.getUniforms(t3) : [], n3.includes("TERRAIN") && (this.terrainUniforms = ((t4) => ({ u_dem: new e3.bR(t4), u_dem_prev: new e3.bR(t4), u_dem_tl: new e3.bO(t4), u_dem_scale: new e3.bQ(t4), u_dem_tl_prev: new e3.bO(t4), u_dem_scale_prev: new e3.bQ(t4), u_dem_size: new e3.bQ(t4), u_dem_lerp: new e3.bQ(t4), u_exaggeration: new e3.bQ(t4), u_depth: new e3.bR(t4), u_depth_size_inv: new e3.bO(t4), u_meter_to_dem: new e3.bQ(t4), u_label_plane_matrix_inv: new e3.bN(t4) }))(t3)), n3.includes("GLOBE") && (this.globeUniforms = ((t4) => ({ u_tile_tl_up: new e3.bP(t4), u_tile_tr_up: new e3.bP(t4), u_tile_br_up: new e3.bP(t4), u_tile_bl_up: new e3.bP(t4), u_tile_up_scale: new e3.bQ(t4) }))(t3)), n3.includes("FOG") && (this.fogUniforms = ((t4) => ({ u_fog_matrix: new e3.bN(t4), u_fog_range: new e3.bO(t4), u_fog_color: new e3.bS(t4), u_fog_horizon_blend: new e3.bQ(t4), u_fog_vertical_limit: new e3.bO(t4), u_fog_temporal_offset: new e3.bQ(t4), u_frustum_tl: new e3.bP(t4), u_frustum_tr: new e3.bP(t4), u_frustum_br: new e3.bP(t4), u_frustum_bl: new e3.bP(t4), u_globe_pos: new e3.bP(t4), u_globe_radius: new e3.bQ(t4), u_globe_transition: new e3.bQ(t4), u_is_globe: new e3.bR(t4), u_viewport: new e3.bO(t4) }))(t3)), n3.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t4) => ({ u_cutoff_params: new e3.bS(t4) }))(t3)), n3.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t4) => ({ u_lighting_ambient_color: new e3.bP(t4), u_lighting_directional_dir: new e3.bP(t4), u_lighting_directional_color: new e3.bP(t4), u_ground_radiance: new e3.bP(t4) }))(t3)), n3.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t4) => ({ u_light_matrix_0: new e3.bN(t4), u_light_matrix_1: new e3.bN(t4), u_fade_range: new e3.bO(t4), u_shadow_normal_offset: new e3.bP(t4), u_shadow_intensity: new e3.bQ(t4), u_shadow_texel_size: new e3.bQ(t4), u_shadow_map_resolution: new e3.bQ(t4), u_shadow_direction: new e3.bP(t4), u_shadow_bias: new e3.bP(t4), u_shadowmap_0: new e3.bR(t4), u_shadowmap_1: new e3.bR(t4) }))(t3));
            }
          }
          setTerrainUniformValues(e4, t3) {
            if (!this.terrainUniforms)
              return;
            const i3 = this.terrainUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t3)
                i3[e5] && i3[e5].set(this.program, e5, t3[e5]);
            }
          }
          setGlobeUniformValues(e4, t3) {
            if (!this.globeUniforms)
              return;
            const i3 = this.globeUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t3)
                i3[e5] && i3[e5].set(this.program, e5, t3[e5]);
            }
          }
          setFogUniformValues(e4, t3) {
            if (!this.fogUniforms)
              return;
            const i3 = this.fogUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t3)
                i3[e5].set(this.program, e5, t3[e5]);
            }
          }
          setCutoffUniformValues(e4, t3) {
            if (!this.cutoffUniforms)
              return;
            const i3 = this.cutoffUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t3)
                i3[e5].set(this.program, e5, t3[e5]);
            }
          }
          setLightsUniformValues(e4, t3) {
            if (!this.lightsUniforms)
              return;
            const i3 = this.lightsUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t3)
                i3[e5].set(this.program, e5, t3[e5]);
            }
          }
          setShadowUniformValues(e4, t3) {
            if (this.failedToCreate || !this.shadowUniforms)
              return;
            const i3 = this.shadowUniforms;
            e4.program.set(this.program);
            for (const e5 in t3)
              i3[e5].set(this.program, e5, t3[e5]);
          }
          _drawDebugWireframe(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2) {
            const u3 = t3.options.wireframe;
            if (false === u3.terrain && false === u3.layers2D && false === u3.layers3D)
              return;
            const d2 = t3.context;
            if (!(() => !(!u3.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!u3.layers2D || t3._terrain && t3._terrain.renderingToTexture || !mr.includes(this.name)) || !(!u3.layers3D || !gr.includes(this.name)))())
              return;
            const _3 = d2.gl, p3 = t3.wireframeDebugCache.getLinesFromTrianglesBuffer(t3.frameCounter, s4, d2);
            if (!p3)
              return;
            const f2 = [...this.fixedDefines];
            f2.push("DEBUG_WIREFRAME");
            const m2 = t3.getOrCreateProgram(this.name, { config: this.configuration, defines: f2 });
            d2.program.set(m2.program);
            const g3 = (e4, t4, i4) => {
              if (t4[e4] && i4[e4])
                for (const o4 in t4[e4])
                  i4[e4][o4] && i4[e4][o4].set(i4.program, o4, t4[e4][o4].current);
            };
            c3 && c3.setUniforms(m2.program, d2, m2.binderUniforms, a3, { zoom: l3 }), g3("fixedUniforms", this, m2), g3("terrainUniforms", this, m2), g3("globeUniforms", this, m2), g3("fogUniforms", this, m2), g3("lightsUniforms", this, m2), g3("shadowUniforms", this, m2), p3.bind(), d2.setColorMode(new At([_3.ONE, _3.ONE_MINUS_SRC_ALPHA, _3.ZERO, _3.ONE], e3.aA.transparent, [true, true, true, false])), d2.setDepthMode(new Ct(i3.func === _3.LESS ? _3.LEQUAL : i3.func, Ct.ReadOnly, i3.range)), d2.setStencilMode(Dt.disabled);
            const v3 = 3 * n3.primitiveLength * 2, x3 = 3 * n3.primitiveOffset * 2 * 2;
            h2 && h2 > 1 ? _3.drawElementsInstanced(_3.LINES, v3, _3.UNSIGNED_SHORT, x3, h2) : _3.drawElements(_3.LINES, v3, _3.UNSIGNED_SHORT, x3), s4.bind(), d2.program.set(this.program), d2.setDepthMode(i3), d2.setStencilMode(o3), d2.setColorMode(r4);
          }
          draw(e4, t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2) {
            const m2 = e4.context, g3 = m2.gl;
            if (this.failedToCreate)
              return;
            m2.program.set(this.program), m2.setDepthMode(i3), m2.setStencilMode(o3), m2.setColorMode(r4), m2.setCullFace(s4);
            for (const e5 of Object.keys(this.fixedUniforms))
              this.fixedUniforms[e5].set(this.program, e5, n3[e5]);
            _3 && _3.setUniforms(this.program, m2, this.binderUniforms, u3, { zoom: d2 });
            const v3 = { [g3.POINTS]: 1, [g3.LINES]: 2, [g3.TRIANGLES]: 3, [g3.LINE_STRIP]: 1 }[t3], x3 = f2 && f2 > 0 ? 1 : void 0;
            for (const s5 of h2.get()) {
              const n4 = s5.vaos || (s5.vaos = {});
              (n4[a3] || (n4[a3] = new Xo())).bind(m2, this, l3, _3 ? _3.getPaintVertexBuffers() : [], c3, s5.vertexOffset, p3 || [], x3), f2 && f2 > 1 ? g3.drawElementsInstanced(t3, s5.primitiveLength * v3, g3.UNSIGNED_SHORT, s5.primitiveOffset * v3 * 2, f2) : c3 ? g3.drawElements(t3, s5.primitiveLength * v3, g3.UNSIGNED_SHORT, s5.primitiveOffset * v3 * 2) : g3.drawArrays(t3, s5.vertexOffset, s5.vertexLength), t3 === g3.TRIANGLES && c3 && this._drawDebugWireframe(e4, i3, o3, r4, c3, s5, u3, d2, _3, f2);
            }
          }
        }
        function xr(t3, i3) {
          const o3 = Math.pow(2, i3.tileID.overscaledZ), r4 = i3.tileSize * Math.pow(2, t3.transform.tileZoom) / o3, s4 = r4 * (i3.tileID.canonical.x + i3.tileID.wrap * o3), n3 = r4 * i3.tileID.canonical.y;
          return { u_image: 0, u_texsize: i3.imageAtlasTexture ? i3.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e3.a6(i3, 1, t3.transform.tileZoom), u_pixel_coord_upper: [s4 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & s4, 65535 & n3] };
        }
        const yr = e3.a9.create(), br = (t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2) => {
          const g3 = i3.style.light, v3 = g3.properties.get("position"), x3 = [v3.x, v3.y, v3.z], y3 = e3.ct.create();
          "viewport" === g3.properties.get("anchor") && (e3.ct.fromRotation(y3, -i3.transform.angle), e3.Q.transformMat3(x3, x3, y3));
          const b2 = g3.properties.get("color"), w2 = i3.transform, T2 = { u_matrix: t3, u_lightpos: x3, u_lightintensity: g3.properties.get("intensity"), u_lightcolor: [b2.r, b2.g, b2.b], u_vertical_gradient: +o3, u_opacity: r4, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: yr, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: s4, u_edge_radius: n3, u_flood_light_color: d2, u_vertical_scale: _3, u_flood_light_intensity: p3, u_ground_shadow_factor: f2, u_emissive_strength: m2 };
          return "globe" === w2.projection.name && (T2.u_tile_id = [a3.canonical.x, a3.canonical.y, 1 << a3.canonical.z], T2.u_zoom_transition = c3, T2.u_inv_rot_matrix = u3, T2.u_merc_center = h2, T2.u_up_dir = w2.projection.upVector(new e3.bv(0, 0, 0), h2[0] * e3.Y, h2[1] * e3.Y), T2.u_height_lift = l3), T2;
        }, wr = (e4, t3, i3) => ({ u_matrix: e4, u_edge_radius: t3, u_vertical_scale: i3 }), Tr = (t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3) => {
          const f2 = br(t3, i3, o3, r4, s4, n3, a3, c3, h2, u3, d2, _3, p3, 1, [0, 0, 0], 0), m2 = { u_height_factor: -Math.pow(2, a3.overscaledZ) / l3.tileSize / 8 };
          return e3.e(f2, xr(i3, l3), m2);
        }, Er = (e4, t3) => ({ u_matrix: e4, u_emissive_strength: t3 }), Sr = (t3, i3, o3, r4) => e3.e(Er(t3, i3), xr(o3, r4)), Cr = (e4, t3, i3) => ({ u_matrix: e4, u_world: i3, u_emissive_strength: t3 }), Ir = (t3, i3, o3, r4, s4) => e3.e(Sr(t3, i3, o3, r4), { u_world: s4 }), Dr = (t3, i3, o3, r4) => {
          const s4 = e3.Y / o3.tileSize;
          return { u_matrix: t3, u_camera_to_center_distance: i3.getCameraToCenterDistance(r4), u_extrude_scale: [i3.pixelsToGLUnits[0] / s4, i3.pixelsToGLUnits[1] / s4] };
        }, Rr = (e4, t3, i3 = 1) => ({ u_matrix: e4, u_color: t3, u_overlay: 0, u_overlay_scale: i3 }), Ar = e3.a9.create(), Pr = (t3, i3, o3, r4, s4, n3, a3) => {
          const l3 = t3.transform, c3 = "globe" === l3.projection.name, h2 = c3 ? e3.cu(l3.zoom, i3.canonical) * l3._pixelsPerMercatorPixel : e3.a6(o3, 1, n3), u3 = { u_matrix: i3.projMatrix, u_extrude_scale: h2, u_intensity: a3, u_inv_rot_matrix: Ar, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (c3) {
            u3.u_inv_rot_matrix = r4, u3.u_merc_center = s4, u3.u_tile_id = [i3.canonical.x, i3.canonical.y, 1 << i3.canonical.z], u3.u_zoom_transition = e3.W(l3.zoom);
            const t4 = s4[0] * e3.Y, o4 = s4[1] * e3.Y;
            u3.u_up_dir = l3.projection.upVector(new e3.bv(0, 0, 0), t4, o4);
          }
          return u3;
        };
        function Lr(e4, [t3, i3, o3, r4], [s4, n3]) {
          if (s4 === n3)
            return [0, 0, 0, 0];
          const a3 = 255 * (e4 - 1) / (e4 * (n3 - s4));
          return [t3 * a3, i3 * a3, o3 * a3, r4 * a3];
        }
        function Mr(e4, t3, [i3, o3]) {
          return i3 === o3 ? 0 : 0.5 / e4 + (t3 - i3) * (e4 - 1) / (e4 * (o3 - i3));
        }
        const zr = (t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2, g3, v3, x3, y3, b2) => ({ u_matrix: t3, u_normalize_matrix: i3, u_globe_matrix: o3, u_merc_matrix: r4, u_grid_matrix: s4, u_tl_parent: n3, u_scale_parent: h2, u_fade_t: u3.mix, u_opacity: u3.opacity * d2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d2.paint.get("raster-brightness-min"), u_brightness_high: d2.paint.get("raster-brightness-max"), u_saturation_factor: e3.cv(d2.paint.get("raster-saturation")), u_contrast_factor: e3.cw(d2.paint.get("raster-contrast")), u_spin_weights: Or(d2.paint.get("raster-hue-rotate")), u_perspective_transform: _3, u_raster_elevation: p3, u_zoom_transition: a3, u_merc_center: l3, u_cutoff_params: c3, u_colorization_mix: Lr(e3.cx, m2, v3), u_colorization_offset: Mr(e3.cx, g3, v3), u_color_ramp: f2, u_texture_offset: [y3 / (x3 + 2 * y3), x3 / (x3 + 2 * y3)], u_texture_res: [x3 + 2 * y3, x3 + 2 * y3], u_emissive_strength: b2 });
        function Or(e4) {
          e4 *= Math.PI / 180;
          const t3 = Math.sin(e4), i3 = Math.cos(e4);
          return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * t3 - i3 + 1) / 3, (Math.sqrt(3) * t3 - i3 + 1) / 3];
        }
        const Fr = (e4, t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3) => ({ u_matrix: e4, u_normalize_matrix: t3, u_globe_matrix: i3, u_merc_matrix: o3, u_grid_matrix: r4, u_tl_parent: s4, u_scale_parent: c3, u_fade_t: h2.mix, u_opacity: h2.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: u3, u_zoom_transition: n3, u_merc_center: a3, u_cutoff_params: l3 }), Br = (e4, t3, i3, o3, r4, s4, n3, a3, l3, c3) => ({ u_particle_texture: e4, u_particle_texture_side_len: t3, u_tile_offset: i3, u_velocity: o3, u_color_ramp: s4, u_velocity_res: r4, u_max_speed: n3, u_uv_offset: a3, u_data_scale: l3, u_data_offset: c3, u_particle_pos_scale: 1.3, u_particle_pos_offset: [Ft, Ft] }), kr = (e4, t3, i3, o3, r4, s4, n3, a3, l3, c3) => ({ u_particle_texture: e4, u_particle_texture_side_len: t3, u_velocity: i3, u_velocity_res: o3, u_max_speed: r4, u_speed_factor: s4, u_reset_rate: n3, u_rand_seed: Math.random(), u_uv_offset: a3, u_data_scale: l3, u_data_offset: c3, u_particle_pos_scale: 1.3, u_particle_pos_offset: [Ft, Ft] }), Nr = e3.a9.create(), Ur = (t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2, g3, v3) => {
          const x3 = s4.transform, y3 = { u_is_size_zoom_constant: +("constant" === t3 || "source" === t3), u_is_size_feature_constant: +("constant" === t3 || "camera" === t3), u_size_t: i3 ? i3.uSizeT : 0, u_size: i3 ? i3.uSize : 0, u_camera_to_center_distance: x3.getCameraToCenterDistance(m2), u_rotate_symbol: +o3, u_aspect_ratio: x3.width / x3.height, u_fade_change: s4.options.fadeDuration ? s4.symbolFadeChange : 1, u_matrix: n3, u_label_plane_matrix: a3, u_coord_matrix: l3, u_is_text: +c3, u_pitch_with_map: +r4, u_texsize: h2, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Nr, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: Nr, u_up_vector: [0, -1, 0], u_color_adj_mat: g3, u_icon_transition: v3 || 0 };
          return "globe" === m2.name && (y3.u_tile_id = [u3.canonical.x, u3.canonical.y, 1 << u3.canonical.z], y3.u_zoom_transition = d2, y3.u_inv_rot_matrix = p3, y3.u_merc_center = _3, y3.u_camera_forward = x3._camera.forward(), y3.u_ecef_origin = e3.cy(x3.globeMatrix, u3.toUnwrapped()), y3.u_tile_matrix = Float32Array.from(x3.globeMatrix), y3.u_up_vector = f2), y3;
        }, Gr = (t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2, g3) => e3.e(Ur(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, d2, _3, p3, f2, m2, g3), { u_gamma_scale: r4 ? s4.transform.getCameraToCenterDistance(g3) * Math.cos(s4.terrain ? 0 : s4.transform._pitch) : 1, u_device_pixel_ratio: e3.f.devicePixelRatio, u_is_halo: +u3, undefined: void 0 }), jr = (t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2) => e3.e(Gr(t3, i3, o3, r4, s4, n3, a3, l3, true, c3, true, u3, d2, _3, p3, f2, m2), { u_texsize_icon: h2, u_texture_icon: 1 }), Vr = (e4, t3, i3, o3) => ({ u_matrix: e4, u_emissive_strength: t3, u_opacity: i3, u_color: o3 }), Zr = (t3, i3, o3, r4, s4, n3, a3) => e3.e(function(t4, i4, o4, r5) {
          const s5 = o4.imageManager.getPattern(t4.toString(), i4), { width: n4, height: a4 } = o4.imageManager.getPixelSize(i4), l3 = Math.pow(2, r5.tileID.overscaledZ), c3 = r5.tileSize * Math.pow(2, o4.transform.tileZoom) / l3, h2 = c3 * (r5.tileID.canonical.x + r5.tileID.wrap * l3), u3 = c3 * r5.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: s5.tl, u_pattern_br: s5.br, u_texsize: [n4, a4], u_pattern_size: s5.displaySize, u_tile_units_to_pixels: 1 / e3.a6(r5, 1, o4.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, u3 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & u3] };
        }(s4, n3, r4, a3), { u_matrix: t3, u_emissive_strength: i3, u_opacity: o3 }), Wr = new Float32Array(e3.a9.identity([])), Hr = (t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3 = [0, 0, 0], f2) => {
          const m2 = s4.style.light, g3 = m2.properties.get("position"), v3 = [-g3.x, -g3.y, g3.z], x3 = e3.ct.create();
          "viewport" === m2.properties.get("anchor") && (e3.ct.fromRotation(x3, -s4.transform.angle), e3.Q.transformMat3(v3, v3, x3));
          const y3 = "MASK" === u3.alphaMode, b2 = m2.properties.get("color"), w2 = _3.paint.get("model-ambient-occlusion-intensity"), T2 = _3.paint.get("model-color").constantOr(e3.aA.white), E2 = _3.paint.get("model-color-mix-intensity").constantOr(0);
          return { u_matrix: t3, u_lighting_matrix: i3, u_normal_matrix: o3, u_node_matrix: r4 || Wr, u_lightpos: v3, u_lightintensity: m2.properties.get("intensity"), u_lightcolor: [b2.r, b2.g, b2.b], u_camera_pos: p3, u_opacity: n3, u_baseTextureIsAlpha: 0, u_alphaMask: +y3, u_alphaCutoff: u3.alphaCutoff, u_baseColorFactor: [a3.r, a3.g, a3.b, a3.a], u_emissiveFactor: [l3[0], l3[1], l3[2], 1], u_metallicFactor: c3, u_roughnessFactor: h2, u_baseColorTexture: fo.BaseColor, u_metallicRoughnessTexture: fo.MetallicRoughness, u_normalTexture: fo.Normal, u_occlusionTexture: fo.Occlusion, u_emissionTexture: fo.Emission, u_color_mix: [T2.r, T2.g, T2.b, E2], u_aoIntensity: w2, u_emissive_strength: d2, u_occlusionTextureTransform: f2 || [0, 0, 0, 0] };
        }, qr = (e4, t3 = Wr, i3 = Wr) => ({ u_matrix: e4, u_instance: t3, u_node_matrix: i3 }), Qr = { fillExtrusion: (t3) => ({ u_matrix: new e3.bN(t3), u_lightpos: new e3.bP(t3), u_lightintensity: new e3.bQ(t3), u_lightcolor: new e3.bP(t3), u_vertical_gradient: new e3.bQ(t3), u_opacity: new e3.bQ(t3), u_edge_radius: new e3.bQ(t3), u_ao: new e3.bO(t3), u_tile_id: new e3.bP(t3), u_zoom_transition: new e3.bQ(t3), u_inv_rot_matrix: new e3.bN(t3), u_merc_center: new e3.bO(t3), u_up_dir: new e3.bP(t3), u_height_lift: new e3.bQ(t3), u_flood_light_color: new e3.bP(t3), u_vertical_scale: new e3.bQ(t3), u_flood_light_intensity: new e3.bQ(t3), u_ground_shadow_factor: new e3.bP(t3), u_emissive_strength: new e3.bQ(t3) }), fillExtrusionDepth: (t3) => ({ u_matrix: new e3.bN(t3), u_edge_radius: new e3.bQ(t3), u_vertical_scale: new e3.bQ(t3) }), fillExtrusionPattern: (t3) => ({ u_matrix: new e3.bN(t3), u_lightpos: new e3.bP(t3), u_lightintensity: new e3.bQ(t3), u_lightcolor: new e3.bP(t3), u_vertical_gradient: new e3.bQ(t3), u_height_factor: new e3.bQ(t3), u_edge_radius: new e3.bQ(t3), u_ao: new e3.bO(t3), u_tile_id: new e3.bP(t3), u_zoom_transition: new e3.bQ(t3), u_inv_rot_matrix: new e3.bN(t3), u_merc_center: new e3.bO(t3), u_up_dir: new e3.bP(t3), u_height_lift: new e3.bQ(t3), u_image: new e3.bR(t3), u_texsize: new e3.bO(t3), u_pixel_coord_upper: new e3.bO(t3), u_pixel_coord_lower: new e3.bO(t3), u_tile_units_to_pixels: new e3.bQ(t3), u_opacity: new e3.bQ(t3) }), fillExtrusionGroundEffect: (t3) => ({ u_matrix: new e3.bN(t3), u_opacity: new e3.bQ(t3), u_ao_pass: new e3.bQ(t3), u_meter_to_tile: new e3.bQ(t3), u_ao: new e3.bO(t3), u_flood_light_intensity: new e3.bQ(t3), u_flood_light_color: new e3.bP(t3), u_attenuation: new e3.bQ(t3), u_edge_radius: new e3.bQ(t3), u_fb: new e3.bR(t3), u_fb_size: new e3.bQ(t3) }), fill: (t3) => ({ u_matrix: new e3.bN(t3), u_emissive_strength: new e3.bQ(t3) }), fillPattern: (t3) => ({ u_matrix: new e3.bN(t3), u_emissive_strength: new e3.bQ(t3), u_image: new e3.bR(t3), u_texsize: new e3.bO(t3), u_pixel_coord_upper: new e3.bO(t3), u_pixel_coord_lower: new e3.bO(t3), u_tile_units_to_pixels: new e3.bQ(t3) }), fillOutline: (t3) => ({ u_matrix: new e3.bN(t3), u_emissive_strength: new e3.bQ(t3), u_world: new e3.bO(t3) }), fillOutlinePattern: (t3) => ({ u_matrix: new e3.bN(t3), u_emissive_strength: new e3.bQ(t3), u_world: new e3.bO(t3), u_image: new e3.bR(t3), u_texsize: new e3.bO(t3), u_pixel_coord_upper: new e3.bO(t3), u_pixel_coord_lower: new e3.bO(t3), u_tile_units_to_pixels: new e3.bQ(t3) }), circle: e3.cz, collisionBox: (t3) => ({ u_matrix: new e3.bN(t3), u_camera_to_center_distance: new e3.bQ(t3), u_extrude_scale: new e3.bO(t3) }), collisionCircle: (t3) => ({ u_matrix: new e3.bN(t3), u_inv_matrix: new e3.bN(t3), u_camera_to_center_distance: new e3.bQ(t3), u_viewport_size: new e3.bO(t3) }), debug: (t3) => ({ u_color: new e3.cf(t3), u_matrix: new e3.bN(t3), u_overlay: new e3.bR(t3), u_overlay_scale: new e3.bQ(t3) }), clippingMask: (t3) => ({ u_matrix: new e3.bN(t3) }), heatmap: (t3) => ({ u_extrude_scale: new e3.bQ(t3), u_intensity: new e3.bQ(t3), u_matrix: new e3.bN(t3), u_inv_rot_matrix: new e3.bN(t3), u_merc_center: new e3.bO(t3), u_tile_id: new e3.bP(t3), u_zoom_transition: new e3.bQ(t3), u_up_dir: new e3.bP(t3) }), heatmapTexture: (t3) => ({ u_image: new e3.bR(t3), u_color_ramp: new e3.bR(t3), u_opacity: new e3.bQ(t3) }), hillshade: (t3) => ({ u_matrix: new e3.bN(t3), u_image: new e3.bR(t3), u_latrange: new e3.bO(t3), u_light: new e3.bO(t3), u_shadow: new e3.cf(t3), u_highlight: new e3.cf(t3), u_emissive_strength: new e3.bQ(t3), u_accent: new e3.cf(t3) }), hillshadePrepare: (t3) => ({ u_matrix: new e3.bN(t3), u_image: new e3.bR(t3), u_dimension: new e3.bO(t3), u_zoom: new e3.bQ(t3) }), line: e3.cA, linePattern: e3.cB, raster: (t3) => ({ u_matrix: new e3.bN(t3), u_normalize_matrix: new e3.bN(t3), u_globe_matrix: new e3.bN(t3), u_merc_matrix: new e3.bN(t3), u_grid_matrix: new e3.cg(t3), u_tl_parent: new e3.bO(t3), u_scale_parent: new e3.bQ(t3), u_fade_t: new e3.bQ(t3), u_opacity: new e3.bQ(t3), u_image0: new e3.bR(t3), u_image1: new e3.bR(t3), u_brightness_low: new e3.bQ(t3), u_brightness_high: new e3.bQ(t3), u_saturation_factor: new e3.bQ(t3), u_contrast_factor: new e3.bQ(t3), u_spin_weights: new e3.bP(t3), u_perspective_transform: new e3.bO(t3), u_raster_elevation: new e3.bQ(t3), u_zoom_transition: new e3.bQ(t3), u_merc_center: new e3.bO(t3), u_cutoff_params: new e3.bS(t3), u_colorization_mix: new e3.bS(t3), u_colorization_offset: new e3.bQ(t3), u_color_ramp: new e3.bR(t3), u_texture_offset: new e3.bO(t3), u_texture_res: new e3.bO(t3), u_emissive_strength: new e3.bQ(t3) }), rasterParticle: (t3) => ({ u_matrix: new e3.bN(t3), u_normalize_matrix: new e3.bN(t3), u_globe_matrix: new e3.bN(t3), u_merc_matrix: new e3.bN(t3), u_grid_matrix: new e3.cg(t3), u_tl_parent: new e3.bO(t3), u_scale_parent: new e3.bQ(t3), u_fade_t: new e3.bQ(t3), u_opacity: new e3.bQ(t3), u_image0: new e3.bR(t3), u_image1: new e3.bR(t3), u_raster_elevation: new e3.bQ(t3), u_zoom_transition: new e3.bQ(t3), u_merc_center: new e3.bO(t3), u_cutoff_params: new e3.bS(t3) }), rasterParticleTexture: (t3) => ({ u_texture: new e3.bR(t3), u_opacity: new e3.bQ(t3) }), rasterParticleDraw: (t3) => ({ u_particle_texture: new e3.bR(t3), u_particle_texture_side_len: new e3.bQ(t3), u_tile_offset: new e3.bO(t3), u_velocity: new e3.bR(t3), u_color_ramp: new e3.bR(t3), u_velocity_res: new e3.bO(t3), u_max_speed: new e3.bQ(t3), u_uv_offset: new e3.bO(t3), u_data_scale: new e3.bS(t3), u_data_offset: new e3.bQ(t3), u_particle_pos_scale: new e3.bQ(t3), u_particle_pos_offset: new e3.bO(t3) }), rasterParticleUpdate: (t3) => ({ u_particle_texture: new e3.bR(t3), u_particle_texture_side_len: new e3.bQ(t3), u_velocity: new e3.bR(t3), u_velocity_res: new e3.bO(t3), u_max_speed: new e3.bQ(t3), u_speed_factor: new e3.bQ(t3), u_reset_rate: new e3.bQ(t3), u_rand_seed: new e3.bQ(t3), u_uv_offset: new e3.bO(t3), u_data_scale: new e3.bS(t3), u_data_offset: new e3.bQ(t3), u_particle_pos_scale: new e3.bQ(t3), u_particle_pos_offset: new e3.bO(t3) }), symbolIcon: (t3) => ({ u_is_size_zoom_constant: new e3.bR(t3), u_is_size_feature_constant: new e3.bR(t3), u_size_t: new e3.bQ(t3), u_size: new e3.bQ(t3), u_camera_to_center_distance: new e3.bQ(t3), u_rotate_symbol: new e3.bR(t3), u_aspect_ratio: new e3.bQ(t3), u_fade_change: new e3.bQ(t3), u_matrix: new e3.bN(t3), u_label_plane_matrix: new e3.bN(t3), u_coord_matrix: new e3.bN(t3), u_is_text: new e3.bR(t3), u_pitch_with_map: new e3.bR(t3), u_texsize: new e3.bO(t3), u_tile_id: new e3.bP(t3), u_zoom_transition: new e3.bQ(t3), u_inv_rot_matrix: new e3.bN(t3), u_merc_center: new e3.bO(t3), u_camera_forward: new e3.bP(t3), u_tile_matrix: new e3.bN(t3), u_up_vector: new e3.bP(t3), u_ecef_origin: new e3.bP(t3), u_texture: new e3.bR(t3), u_icon_transition: new e3.bQ(t3), u_color_adj_mat: new e3.bN(t3) }), symbolSDF: (t3) => ({ u_is_size_zoom_constant: new e3.bR(t3), u_is_size_feature_constant: new e3.bR(t3), u_size_t: new e3.bQ(t3), u_size: new e3.bQ(t3), u_camera_to_center_distance: new e3.bQ(t3), u_rotate_symbol: new e3.bR(t3), u_aspect_ratio: new e3.bQ(t3), u_fade_change: new e3.bQ(t3), u_matrix: new e3.bN(t3), u_label_plane_matrix: new e3.bN(t3), u_coord_matrix: new e3.bN(t3), u_is_text: new e3.bR(t3), u_pitch_with_map: new e3.bR(t3), u_texsize: new e3.bO(t3), u_texture: new e3.bR(t3), u_gamma_scale: new e3.bQ(t3), u_device_pixel_ratio: new e3.bQ(t3), u_tile_id: new e3.bP(t3), u_zoom_transition: new e3.bQ(t3), u_inv_rot_matrix: new e3.bN(t3), u_merc_center: new e3.bO(t3), u_camera_forward: new e3.bP(t3), u_tile_matrix: new e3.bN(t3), u_up_vector: new e3.bP(t3), u_ecef_origin: new e3.bP(t3), u_is_halo: new e3.bR(t3) }), symbolTextAndIcon: (t3) => ({ u_is_size_zoom_constant: new e3.bR(t3), u_is_size_feature_constant: new e3.bR(t3), u_size_t: new e3.bQ(t3), u_size: new e3.bQ(t3), u_camera_to_center_distance: new e3.bQ(t3), u_rotate_symbol: new e3.bR(t3), u_aspect_ratio: new e3.bQ(t3), u_fade_change: new e3.bQ(t3), u_matrix: new e3.bN(t3), u_label_plane_matrix: new e3.bN(t3), u_coord_matrix: new e3.bN(t3), u_is_text: new e3.bR(t3), u_pitch_with_map: new e3.bR(t3), u_texsize: new e3.bO(t3), u_texsize_icon: new e3.bO(t3), u_texture: new e3.bR(t3), u_texture_icon: new e3.bR(t3), u_gamma_scale: new e3.bQ(t3), u_device_pixel_ratio: new e3.bQ(t3), u_is_halo: new e3.bR(t3) }), background: (t3) => ({ u_matrix: new e3.bN(t3), u_emissive_strength: new e3.bQ(t3), u_opacity: new e3.bQ(t3), u_color: new e3.cf(t3) }), backgroundPattern: (t3) => ({ u_matrix: new e3.bN(t3), u_emissive_strength: new e3.bQ(t3), u_opacity: new e3.bQ(t3), u_image: new e3.bR(t3), u_pattern_tl: new e3.bO(t3), u_pattern_br: new e3.bO(t3), u_texsize: new e3.bO(t3), u_pattern_size: new e3.bO(t3), u_pixel_coord_upper: new e3.bO(t3), u_pixel_coord_lower: new e3.bO(t3), u_tile_units_to_pixels: new e3.bQ(t3) }), terrainRaster: tr, terrainDepth: tr, skybox: (t3) => ({ u_matrix: new e3.bN(t3), u_sun_direction: new e3.bP(t3), u_cubemap: new e3.bR(t3), u_opacity: new e3.bQ(t3), u_temporal_offset: new e3.bQ(t3) }), skyboxGradient: (t3) => ({ u_matrix: new e3.bN(t3), u_color_ramp: new e3.bR(t3), u_center_direction: new e3.bP(t3), u_radius: new e3.bQ(t3), u_opacity: new e3.bQ(t3), u_temporal_offset: new e3.bQ(t3) }), skyboxCapture: (t3) => ({ u_matrix_3f: new e3.cg(t3), u_sun_direction: new e3.bP(t3), u_sun_intensity: new e3.bQ(t3), u_color_tint_r: new e3.bS(t3), u_color_tint_m: new e3.bS(t3), u_luminance: new e3.bQ(t3) }), globeRaster: (t3) => ({ u_proj_matrix: new e3.bN(t3), u_globe_matrix: new e3.bN(t3), u_normalize_matrix: new e3.bN(t3), u_merc_matrix: new e3.bN(t3), u_zoom_transition: new e3.bQ(t3), u_merc_center: new e3.bO(t3), u_image0: new e3.bR(t3), u_grid_matrix: new e3.cg(t3), u_skirt_height: new e3.bQ(t3), u_far_z_cutoff: new e3.bQ(t3), u_frustum_tl: new e3.bP(t3), u_frustum_tr: new e3.bP(t3), u_frustum_br: new e3.bP(t3), u_frustum_bl: new e3.bP(t3), u_globe_pos: new e3.bP(t3), u_globe_radius: new e3.bQ(t3), u_viewport: new e3.bO(t3) }), globeAtmosphere: (t3) => ({ u_frustum_tl: new e3.bP(t3), u_frustum_tr: new e3.bP(t3), u_frustum_br: new e3.bP(t3), u_frustum_bl: new e3.bP(t3), u_horizon: new e3.bQ(t3), u_transition: new e3.bQ(t3), u_fadeout_range: new e3.bQ(t3), u_color: new e3.bS(t3), u_high_color: new e3.bS(t3), u_space_color: new e3.bS(t3), u_temporal_offset: new e3.bQ(t3), u_horizon_angle: new e3.bQ(t3) }), model: (t3) => ({ u_matrix: new e3.bN(t3), u_lighting_matrix: new e3.bN(t3), u_normal_matrix: new e3.bN(t3), u_node_matrix: new e3.bN(t3), u_lightpos: new e3.bP(t3), u_lightintensity: new e3.bQ(t3), u_lightcolor: new e3.bP(t3), u_camera_pos: new e3.bP(t3), u_opacity: new e3.bQ(t3), u_baseColorFactor: new e3.bS(t3), u_emissiveFactor: new e3.bS(t3), u_metallicFactor: new e3.bQ(t3), u_roughnessFactor: new e3.bQ(t3), u_baseTextureIsAlpha: new e3.bR(t3), u_alphaMask: new e3.bR(t3), u_alphaCutoff: new e3.bQ(t3), u_baseColorTexture: new e3.bR(t3), u_metallicRoughnessTexture: new e3.bR(t3), u_normalTexture: new e3.bR(t3), u_occlusionTexture: new e3.bR(t3), u_emissionTexture: new e3.bR(t3), u_color_mix: new e3.bS(t3), u_aoIntensity: new e3.bQ(t3), u_emissive_strength: new e3.bQ(t3), u_occlusionTextureTransform: new e3.bS(t3) }), modelDepth: (t3) => ({ u_matrix: new e3.bN(t3), u_instance: new e3.bN(t3), u_node_matrix: new e3.bN(t3) }), groundShadow: (t3) => ({ u_matrix: new e3.bN(t3), u_ground_shadow_factor: new e3.bP(t3) }), stars: (t3) => ({ u_matrix: new e3.bN(t3), u_up: new e3.bP(t3), u_right: new e3.bP(t3), u_intensity_multiplier: new e3.bQ(t3) }) };
        let $r;
        function Xr(t3, i3, o3, r4, s4, n3, a3) {
          const l3 = t3.context, c3 = l3.gl, h2 = t3.transform, u3 = t3.getOrCreateProgram("collisionBox"), d2 = [];
          let _3 = 0, p3 = 0;
          for (let l4 = 0; l4 < r4.length; l4++) {
            const f3 = r4[l4], m3 = i3.getTile(f3), g4 = m3.getBucket(o3);
            if (!g4)
              continue;
            const v4 = Pi(f3, g4, h2);
            let x4 = v4;
            0 === s4[0] && 0 === s4[1] || (x4 = t3.translatePosMatrix(v4, m3, s4, n3));
            const y4 = a3 ? g4.textCollisionBox : g4.iconCollisionBox, b2 = g4.collisionCircleArray;
            if (b2.length > 0) {
              const t4 = e3.a9.create(), i4 = x4;
              e3.a9.mul(t4, g4.placementInvProjMatrix, h2.glCoordMatrix), e3.a9.mul(t4, t4, g4.placementViewportMatrix), d2.push({ circleArray: b2, circleOffset: p3, transform: i4, invTransform: t4, projection: g4.getProjection() }), _3 += b2.length / 4, p3 = _3;
            }
            y4 && (t3.terrain && t3.terrain.setupElevationDraw(m3, u3), u3.draw(t3, c3.LINES, Ct.disabled, Dt.disabled, t3.colorModeForRenderPass(), Mt.disabled, Dr(x4, h2, m3, g4.getProjection()), o3.id, y4.layoutVertexBuffer, y4.indexBuffer, y4.segments, null, h2.zoom, null, [y4.collisionVertexBuffer, y4.collisionVertexBufferExt]));
          }
          if (!a3 || !d2.length)
            return;
          const f2 = t3.getOrCreateProgram("collisionCircle"), m2 = new e3.cC();
          m2.resize(4 * _3), m2._trim();
          let g3 = 0;
          for (const e4 of d2)
            for (let t4 = 0; t4 < e4.circleArray.length / 4; t4++) {
              const i4 = 4 * t4, o4 = e4.circleArray[i4 + 0], r5 = e4.circleArray[i4 + 1], s5 = e4.circleArray[i4 + 2], n4 = e4.circleArray[i4 + 3];
              m2.emplace(g3++, o4, r5, s5, n4, 0), m2.emplace(g3++, o4, r5, s5, n4, 1), m2.emplace(g3++, o4, r5, s5, n4, 2), m2.emplace(g3++, o4, r5, s5, n4, 3);
            }
          (!$r || $r.length < 2 * _3) && ($r = function(t4) {
            const i4 = 2 * t4, o4 = new e3.az();
            o4.resize(i4), o4._trim();
            for (let e4 = 0; e4 < i4; e4++) {
              const t5 = 6 * e4;
              o4.uint16[t5 + 0] = 4 * e4 + 0, o4.uint16[t5 + 1] = 4 * e4 + 1, o4.uint16[t5 + 2] = 4 * e4 + 2, o4.uint16[t5 + 3] = 4 * e4 + 2, o4.uint16[t5 + 4] = 4 * e4 + 3, o4.uint16[t5 + 5] = 4 * e4 + 0;
            }
            return o4;
          }(_3));
          const v3 = l3.createIndexBuffer($r, true), x3 = l3.createVertexBuffer(m2, e3.cD.members, true);
          for (const i4 of d2) {
            const r5 = { u_matrix: i4.transform, u_inv_matrix: i4.invTransform, u_camera_to_center_distance: (y3 = h2).getCameraToCenterDistance(i4.projection), u_viewport_size: [y3.width, y3.height] };
            f2.draw(t3, c3.TRIANGLES, Ct.disabled, Dt.disabled, t3.colorModeForRenderPass(), Mt.disabled, r5, o3.id, x3, v3, e3.aE.simpleSegment(0, 2 * i4.circleOffset, i4.circleArray.length, i4.circleArray.length / 2), null, h2.zoom);
          }
          var y3;
          x3.destroy(), v3.destroy();
        }
        const Yr = e3.a9.create();
        function Jr(t3) {
          const i3 = t3._camera.getWorldToCamera(t3.worldSize, 1), o3 = e3.a9.multiply([], i3, t3.globeMatrix);
          e3.a9.invert(o3, o3);
          const r4 = [0, 0, 0], s4 = [0, 1, 0, 0];
          return e3.aa.transformMat4(s4, s4, o3), r4[0] = s4[0], r4[1] = s4[1], r4[2] = s4[2], e3.Q.normalize(r4, r4), r4;
        }
        function Kr({ width: t3, height: i3, anchor: o3, textOffset: r4, textScale: s4 }, n3) {
          const { horizontalAlign: a3, verticalAlign: l3 } = e3.bi(o3), c3 = -(a3 - 0.5) * t3, h2 = -(l3 - 0.5) * i3, u3 = e3.bh(o3, r4);
          return new e3.P((c3 / s4 + u3[0]) * n3, (h2 / s4 + u3[1]) * n3);
        }
        function es(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3) {
          const d2 = t3.text.placedSymbolArray, _3 = t3.text.dynamicLayoutVertexArray, p3 = t3.icon.dynamicLayoutVertexArray, f2 = {}, m2 = t3.getProjection(), g3 = Li(l3, m2, n3), v3 = n3.elevation, x3 = m2.upVectorScale(l3.canonical, n3.center.lat, n3.worldSize).metersToTile;
          _3.clear();
          for (let p4 = 0; p4 < d2.length; p4++) {
            const y3 = d2.get(p4), { tileAnchorX: b2, tileAnchorY: w2, numGlyphs: T2 } = y3, E2 = y3.hidden || !y3.crossTileID || t3.allowVerticalPlacement && !y3.placedOrientation ? null : r4[y3.crossTileID];
            if (E2) {
              let r5 = 0, d3 = 0, p5 = 0;
              if (v3) {
                const e4 = v3 ? v3.getAtTileOffset(l3, b2, w2) : 0, [t4, i4, o4] = m2.upVector(l3.canonical, b2, w2);
                r5 = e4 * t4 * x3, d3 = e4 * i4 * x3, p5 = e4 * o4 * x3;
              }
              let [S2, C2, I2, D2] = mi(y3.projectedAnchorX + r5, y3.projectedAnchorY + d3, y3.projectedAnchorZ + p5, o3 ? g3 : a3);
              const R3 = gi(n3.getCameraToCenterDistance(m2), D2);
              let A2 = s4.evaluateSizeForFeature(t3.textSizeData, h2, y3) * R3 / e3.bf;
              o3 && (A2 *= t3.tilePixelRatio / c3);
              const P2 = Kr(E2, A2);
              o3 ? ({ x: S2, y: C2, z: I2 } = m2.projectTilePoint(b2 + P2.x, w2 + P2.y, l3.canonical), [S2, C2, I2] = mi(S2 + r5, C2 + d3, I2 + p5, a3)) : (i3 && P2._rotate(-n3.angle), S2 += P2.x, C2 += P2.y, I2 = 0);
              const L2 = t3.allowVerticalPlacement && y3.placedOrientation === e3.b9.vertical ? Math.PI / 2 : 0;
              for (let t4 = 0; t4 < T2; t4++)
                e3.bc(_3, S2, C2, I2, L2);
              u3 && y3.associatedIconIndex >= 0 && (f2[y3.associatedIconIndex] = { x: S2, y: C2, z: I2, angle: L2 });
            } else
              Ci(T2, _3);
          }
          if (u3) {
            p3.clear();
            const i4 = t3.icon.placedSymbolArray;
            for (let t4 = 0; t4 < i4.length; t4++) {
              const o4 = i4.get(t4), { numGlyphs: r5 } = o4, s5 = f2[t4];
              if (o4.hidden || !s5)
                Ci(r5, p3);
              else {
                const { x: t5, y: i5, z: o5, angle: n4 } = s5;
                for (let s6 = 0; s6 < r5; s6++)
                  e3.bc(p3, t5, i5, o5, n4);
              }
            }
            t3.icon.dynamicLayoutVertexBuffer.updateData(p3);
          }
          t3.text.dynamicLayoutVertexBuffer.updateData(_3);
        }
        function ts(t3, i3, o3, r4, s4, n3, a3 = {}) {
          const l3 = o3.paint.get("icon-translate"), c3 = o3.paint.get("text-translate"), h2 = o3.paint.get("icon-translate-anchor"), u3 = o3.paint.get("text-translate-anchor"), d2 = o3.layout.get("icon-rotation-alignment"), _3 = o3.layout.get("text-rotation-alignment"), p3 = o3.layout.get("icon-pitch-alignment"), f2 = o3.layout.get("text-pitch-alignment"), m2 = o3.layout.get("icon-keep-upright"), g3 = o3.layout.get("text-keep-upright"), v3 = o3.paint.get("icon-color-saturation"), x3 = o3.paint.get("icon-color-contrast"), y3 = o3.paint.get("icon-color-brightness-min"), b2 = o3.paint.get("icon-color-brightness-max"), w2 = t3.context, T2 = w2.gl, E2 = t3.transform, S2 = "map" === d2, C2 = "map" === _3, I2 = "map" === p3, D2 = "map" === f2, R3 = void 0 !== o3.layout.get("symbol-sort-key").constantOr(1);
          let A2 = false;
          const P2 = t3.depthModeForSublayer(0, Ct.ReadOnly), L2 = [e3.a8(E2.center.lng), e3.ah(E2.center.lat)], M3 = o3.layout.get("text-variable-anchor"), z3 = "globe" === E2.projection.name, O2 = [], F2 = [0, -1, 0];
          for (const s5 of r4) {
            const r5 = i3.getTile(s5), n4 = r5.getBucket(o3);
            if (!n4)
              continue;
            if ("mercator" === n4.projection.name && z3)
              continue;
            if (n4.fullyClipped)
              continue;
            const d3 = "globe" === n4.projection.name, _4 = d3 ? e3.W(E2.zoom) : 0, p4 = Li(s5, n4.getProjection(), E2), f3 = E2.calculatePixelsToTileUnitsMatrix(r5), w3 = M3 && n4.hasTextData(), P3 = n4.hasIconTextFit() && w3 && n4.hasIconData(), B2 = n4.getProjection().createInversionMatrix(E2, s5.canonical), k2 = () => {
              const i4 = S2 && "point" !== o3.layout.get("symbol-placement"), a4 = [], c4 = i4 || P3, u4 = o3.paint.get("icon-image-cross-fade").constantOr(0);
              t3.terrainRenderModeElevated() && I2 && a4.push("PITCH_WITH_MAP_TERRAIN"), d3 && (a4.push("PROJECTION_GLOBE_VIEW"), c4 && a4.push("PROJECTED_POS_ON_VIEWPORT")), u4 > 0 && a4.push("ICON_TRANSITION"), n4.icon.zOffsetVertexBuffer && a4.push("Z_OFFSET"), 0 === v3 && 0 === x3 && 0 === y3 && 1 === b2 || a4.push("COLOR_ADJUSTMENT");
              const g4 = n4.icon.programConfigurations.get(o3.id), w4 = t3.getOrCreateProgram(n4.sdfIcons ? "symbolSDF" : "symbolIcon", { config: g4, defines: a4 });
              let C3;
              const D3 = r5.imageAtlasTexture ? r5.imageAtlasTexture.size : [0, 0], R4 = n4.iconSizeData, A3 = e3.b8(R4, E2.zoom), M4 = I2 || 0 !== E2.pitch, O3 = _i(p4, r5.tileID.canonical, I2, S2, E2, n4.getProjection(), f3), k3 = fi(p4, r5.tileID.canonical, I2, S2, E2, n4.getProjection(), f3), N3 = t3.translatePosMatrix(k3, r5, l3, h2, true), U3 = t3.translatePosMatrix(p4, r5, l3, h2), G3 = c4 ? Yr : O3, j4 = S2 && !I2 && !i4;
              let V3 = F2;
              !z3 && !E2.mercatorFromTransition || S2 || (V3 = Jr(E2));
              const Z4 = d3 ? V3 : F2;
              if (n4.sdfIcons && !n4.iconsInText)
                C3 = Gr(R4.kind, A3, j4, I2, t3, U3, G3, N3, false, D3, true, s5, _4, L2, B2, Z4, n4.getProjection());
              else {
                const e4 = o3.getColorAdjustmentMatrix(v3, x3, y3, b2);
                C3 = Ur(R4.kind, A3, j4, I2, t3, U3, G3, N3, false, D3, s5, _4, L2, B2, Z4, n4.getProjection(), e4, u4);
              }
              const W3 = r5.imageAtlasTexture ? r5.imageAtlasTexture : null, H2 = 1 !== o3.layout.get("icon-size").constantOr(0) || n4.iconsNeedLinear, q3 = n4.sdfIcons || t3.options.rotating || t3.options.zooming || H2 || M4 ? T2.LINEAR : T2.NEAREST, Q2 = n4.sdfIcons && 0 !== o3.paint.get("icon-halo-width").constantOr(1), $2 = t3.terrain && I2 && i4 ? e3.a9.invert(e3.a9.create(), O3) : Yr;
              if (i4 && n4.icon) {
                const e4 = E2.elevation, i5 = e4 ? e4.getAtTileOffsetFunc(s5, E2.center.lat, E2.worldSize, n4.getProjection()) : null, o4 = pi(p4, r5.tileID.canonical, I2, S2, E2, n4.getProjection(), f3);
                xi(n4, p4, t3, false, o4, k3, I2, m2, i5, s5);
              }
              return { program: w4, buffers: n4.icon, uniformValues: C3, atlasTexture: W3, atlasTextureIcon: null, atlasInterpolation: q3, atlasInterpolationIcon: null, isSDF: n4.sdfIcons, hasHalo: Q2, tile: r5, labelPlaneMatrixInv: $2 };
            }, N2 = () => {
              const i4 = C2 && "point" !== o3.layout.get("symbol-placement"), a4 = [], l4 = i4 || M3 || P3;
              t3.terrainRenderModeElevated() && D2 && a4.push("PITCH_WITH_MAP_TERRAIN"), d3 && (a4.push("PROJECTION_GLOBE_VIEW"), l4 && a4.push("PROJECTED_POS_ON_VIEWPORT")), n4.text.zOffsetVertexBuffer && a4.push("Z_OFFSET");
              const h3 = n4.text.programConfigurations.get(o3.id), m3 = t3.getOrCreateProgram(n4.iconsInText ? "symbolTextAndIcon" : "symbolSDF", { config: h3, defines: a4 });
              let v4, x4 = [0, 0], y4 = null;
              const b3 = n4.textSizeData;
              n4.iconsInText && (x4 = r5.imageAtlasTexture ? r5.imageAtlasTexture.size : [0, 0], y4 = r5.imageAtlasTexture ? r5.imageAtlasTexture : null, v4 = D2 || 0 !== E2.pitch || t3.options.rotating || t3.options.zooming || "composite" === b3.kind || "camera" === b3.kind ? T2.LINEAR : T2.NEAREST);
              const w4 = r5.glyphAtlasTexture ? r5.glyphAtlasTexture.size : [0, 0], S3 = e3.b8(b3, E2.zoom), I3 = _i(p4, r5.tileID.canonical, D2, C2, E2, n4.getProjection(), f3), R4 = fi(p4, r5.tileID.canonical, D2, C2, E2, n4.getProjection(), f3), A3 = t3.translatePosMatrix(R4, r5, c3, u3, true), O3 = t3.translatePosMatrix(p4, r5, c3, u3), k3 = l4 ? Yr : I3, N3 = C2 && !D2 && !i4;
              let U3 = F2;
              !z3 && !E2.mercatorFromTransition || C2 || (U3 = Jr(E2));
              const G3 = d3 ? U3 : F2;
              let j4;
              j4 = n4.iconsInText ? jr(b3.kind, S3, N3, D2, t3, O3, k3, A3, w4, x4, s5, _4, L2, B2, G3, n4.getProjection()) : Gr(b3.kind, S3, N3, D2, t3, O3, k3, A3, true, w4, true, s5, _4, L2, B2, G3, n4.getProjection());
              const V3 = r5.glyphAtlasTexture ? r5.glyphAtlasTexture : null, Z4 = T2.LINEAR, W3 = 0 !== o3.paint.get("text-halo-width").constantOr(1), H2 = t3.terrain && D2 && i4 ? e3.a9.invert(e3.a9.create(), I3) : Yr;
              if (i4 && n4.text) {
                const e4 = E2.elevation, i5 = e4 ? e4.getAtTileOffsetFunc(s5, E2.center.lat, E2.worldSize, n4.getProjection()) : null, o4 = pi(p4, r5.tileID.canonical, D2, C2, E2, n4.getProjection(), f3);
                xi(n4, p4, t3, true, o4, R4, D2, g3, i5, s5);
              }
              return { program: m3, buffers: n4.text, uniformValues: j4, atlasTexture: V3, atlasTextureIcon: y4, atlasInterpolation: Z4, atlasInterpolationIcon: v4, isSDF: true, hasHalo: W3, tile: r5, labelPlaneMatrixInv: H2 };
            }, U2 = n4.icon.segments.get().length, G2 = n4.text.segments.get().length, j3 = U2 && !a3.onlyText ? k2() : null, V2 = G2 && !a3.onlyIcons ? N2() : null, Z3 = o3.paint.get("icon-opacity").constantOr(1), W2 = o3.paint.get("text-opacity").constantOr(1);
            if (R3 && n4.canOverlap) {
              A2 = true;
              const t4 = Z3 && !a3.onlyText ? n4.icon.segments.get() : [], i4 = W2 && !a3.onlyIcons ? n4.text.segments.get() : [];
              for (const i5 of t4)
                O2.push({ segments: new e3.aE([i5]), sortKey: i5.sortKey, state: j3 });
              for (const t5 of i4)
                O2.push({ segments: new e3.aE([t5]), sortKey: t5.sortKey, state: V2 });
            } else
              a3.onlyText || O2.push({ segments: Z3 ? n4.icon.segments : new e3.aE([]), sortKey: 0, state: j3 }), a3.onlyIcons || O2.push({ segments: W2 ? n4.text.segments : new e3.aE([]), sortKey: 0, state: V2 });
          }
          A2 && O2.sort((e4, t4) => e4.sortKey - t4.sortKey);
          for (const e4 of O2) {
            const i4 = e4.state;
            if (i4)
              if (t3.terrain && t3.terrain.setupElevationDraw(i4.tile, i4.program, { useDepthForOcclusion: E2.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i4.labelPlaneMatrixInv }), w2.activeTexture.set(T2.TEXTURE0), i4.atlasTexture && i4.atlasTexture.bind(i4.atlasInterpolation, T2.CLAMP_TO_EDGE, true), i4.atlasTextureIcon && (w2.activeTexture.set(T2.TEXTURE1), i4.atlasTextureIcon && i4.atlasTextureIcon.bind(i4.atlasInterpolationIcon, T2.CLAMP_TO_EDGE, true)), t3.uploadCommonLightUniforms(t3.context, i4.program), i4.hasHalo) {
                const r5 = i4.uniformValues;
                r5.u_is_halo = 1, is(i4.buffers, e4.segments, o3, t3, i4.program, P2, s4, n3, r5, 2), r5.u_is_halo = 0;
              } else {
                if (i4.isSDF) {
                  const r5 = i4.uniformValues;
                  i4.hasHalo && (r5.u_is_halo = 1, is(i4.buffers, e4.segments, o3, t3, i4.program, P2, s4, n3, r5, 1)), r5.u_is_halo = 0;
                }
                is(i4.buffers, e4.segments, o3, t3, i4.program, P2, s4, n3, i4.uniformValues, 1);
              }
          }
        }
        function is(e4, t3, i3, o3, r4, s4, n3, a3, l3, c3) {
          const h2 = [e4.dynamicLayoutVertexBuffer, e4.opacityVertexBuffer, e4.iconTransitioningVertexBuffer, e4.globeExtVertexBuffer, e4.zOffsetVertexBuffer];
          r4.draw(o3, o3.context.gl.TRIANGLES, s4, n3, a3, Mt.disabled, l3, i3.id, e4.layoutVertexBuffer, e4.indexBuffer, t3, i3.paint, o3.transform.zoom, e4.programConfigurations.get(i3.id), h2, c3);
        }
        function os(e4, t3, i3, o3, r4, s4, n3) {
          const a3 = e4.context.gl, l3 = i3.paint.get("fill-pattern"), c3 = l3 && l3.constantOr(1);
          let h2, u3, d2, _3, p3;
          n3 ? (u3 = c3 && !i3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", h2 = a3.LINES) : (u3 = c3 ? "fillPattern" : "fill", h2 = a3.TRIANGLES);
          for (const f2 of o3) {
            const o4 = t3.getTile(f2);
            if (c3 && !o4.patternsLoaded())
              continue;
            const m2 = o4.getBucket(i3);
            if (!m2)
              continue;
            e4.prepareDrawTile();
            const g3 = m2.programConfigurations.get(i3.id), v3 = e4.isTileAffectedByFog(f2), x3 = e4.getOrCreateProgram(u3, { config: g3, overrideFog: v3 });
            c3 && (e4.context.activeTexture.set(a3.TEXTURE0), o4.imageAtlasTexture && o4.imageAtlasTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), g3.updatePaintBuffers());
            const y3 = l3.constantOr(null);
            if (y3 && o4.imageAtlas) {
              const e5 = o4.imageAtlas.patternPositions[y3.toString()];
              e5 && g3.setConstantPatternPositions(e5);
            }
            const b2 = e4.translatePosMatrix(f2.projMatrix, o4, i3.paint.get("fill-translate"), i3.paint.get("fill-translate-anchor")), w2 = i3.paint.get("fill-emissive-strength");
            if (n3) {
              _3 = m2.indexBuffer2, p3 = m2.segments2;
              const t4 = e4.terrain && e4.terrain.renderingToTexture ? e4.terrain.drapeBufferSize : [a3.drawingBufferWidth, a3.drawingBufferHeight];
              d2 = "fillOutlinePattern" === u3 && c3 ? Ir(b2, w2, e4, o4, t4) : Cr(b2, w2, t4);
            } else
              _3 = m2.indexBuffer, p3 = m2.segments, d2 = c3 ? Sr(b2, w2, e4, o4) : Er(b2, w2);
            e4.uploadCommonUniforms(e4.context, x3, f2.toUnwrapped()), x3.draw(e4, h2, r4, e4.stencilModeForClipping(f2), s4, Mt.disabled, d2, i3.id, m2.layoutVertexBuffer, _3, p3, i3.paint, e4.transform.zoom, g3, void 0);
          }
        }
        function rs(t3, i3, o3, r4, s4, n3, a3, l3) {
          o3.resetLayerRenderingStats(t3);
          const c3 = t3.context, h2 = c3.gl, u3 = t3.transform, d2 = o3.paint.get("fill-extrusion-pattern"), _3 = d2.constantOr(1), p3 = o3.paint.get("fill-extrusion-opacity"), f2 = t3.style.enable3dLights(), m2 = o3.paint.get(f2 && !_3 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), g3 = [o3.paint.get("fill-extrusion-ambient-occlusion-intensity"), m2], v3 = o3.layout.get("fill-extrusion-edge-radius"), x3 = v3 > 0 && !o3.paint.get("fill-extrusion-rounded-roof"), y3 = x3 ? 0 : v3, b2 = "globe" === u3.projection.name ? e3.cM() : 0, w2 = "globe" === u3.projection.name, T2 = w2 ? e3.W(u3.zoom) : 0, E2 = [e3.a8(u3.center.lng), e3.ah(u3.center.lat)], S2 = o3.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), C2 = o3.paint.get("fill-extrusion-flood-light-intensity"), I2 = o3.paint.get("fill-extrusion-vertical-scale"), D2 = mo(t3, o3.paint.get("fill-extrusion-cutoff-fade-range")), R3 = o3.paint.get("fill-extrusion-emissive-strength"), A2 = [];
          let P2;
          w2 && A2.push("PROJECTION_GLOBE_VIEW"), g3[0] > 0 && A2.push("FAUX_AO"), x3 && A2.push("ZERO_ROOF_RADIUS"), l3 && A2.push("HAS_CENTROID"), C2 > 0 && A2.push("FLOOD_LIGHT"), D2.shouldRenderCutoff && A2.push("RENDER_CUTOFF");
          const L2 = "shadow" === t3.renderPass, M3 = t3.shadowRenderer, z3 = L2 && !!M3;
          t3.shadowRenderer && (t3.shadowRenderer.useNormalOffset = true);
          let O2 = [0, 0, 0];
          if (M3) {
            const e4 = t3.style.directionalLight, i4 = t3.style.ambientLight;
            e4 && i4 && (O2 = To(e4, i4)), P2 = A2.concat(["SHADOWS_SINGLE_CASCADE"]);
          }
          const F2 = z3 ? "fillExtrusionDepth" : _3 ? "fillExtrusionPattern" : "fillExtrusion", B2 = o3.getLayerRenderingStats();
          for (const e4 of r4) {
            const r5 = i3.getTile(e4), f3 = r5.getBucket(o3);
            if (!f3 || f3.projection.name !== u3.projection.name)
              continue;
            let m3 = false;
            M3 && (m3 = 0 === M3.getMaxCascadeForTile(e4.toUnwrapped()));
            const v4 = t3.isTileAffectedByFog(e4), x4 = f3.programConfigurations.get(o3.id), z4 = t3.getOrCreateProgram(F2, { config: x4, defines: m3 ? P2 : A2, overrideFog: v4 });
            if (t3.terrain && t3.terrain.setupElevationDraw(r5, z4, { useMeterToDem: true }), !f3.centroidVertexBuffer) {
              const e5 = z4.attributes.a_centroid_pos;
              void 0 !== e5 && h2.vertexAttrib2f(e5, 0, 0);
            }
            !L2 && M3 && M3.setupShadows(r5.tileID.toUnwrapped(), z4, "vector-tile", r5.tileID.overscaledZ), _3 && (t3.context.activeTexture.set(h2.TEXTURE0), r5.imageAtlasTexture && r5.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), x4.updatePaintBuffers());
            const k2 = d2.constantOr(null);
            if (k2 && r5.imageAtlas) {
              const e5 = r5.imageAtlas.patternPositions[k2.toString()];
              e5 && x4.setConstantPatternPositions(e5);
            }
            const N2 = o3.paint.get("fill-extrusion-vertical-gradient");
            let U2;
            if (L2 && M3) {
              if (hs(r5.tileID, f3, t3))
                continue;
              const e5 = M3.calculateShadowPassMatrixFromTile(r5.tileID.toUnwrapped());
              U2 = wr(e5, y3, I2);
            } else {
              const i4 = t3.translatePosMatrix(e4.expandedProjMatrix, r5, o3.paint.get("fill-extrusion-translate"), o3.paint.get("fill-extrusion-translate-anchor")), s5 = u3.projection.createInversionMatrix(u3, e4.canonical);
              U2 = _3 ? Tr(i4, t3, N2, p3, g3, y3, e4, r5, b2, T2, E2, s5, S2, I2) : br(i4, t3, N2, p3, g3, y3, e4, b2, T2, E2, s5, S2, I2, C2, O2, R3);
            }
            t3.uploadCommonUniforms(c3, z4, e4.toUnwrapped(), null, D2);
            let G2 = f3.segments;
            if ("mercator" === u3.projection.name && !L2 && (G2 = f3.getVisibleSegments(r5.tileID, t3.terrain, t3.transform.getFrustum(0)), !G2.get().length))
              continue;
            if (B2)
              if (L2)
                for (const e5 of G2.get())
                  B2.numRenderedVerticesInShadowPass += e5.primitiveLength;
              else
                for (const e5 of G2.get())
                  B2.numRenderedVerticesInTransparentPass += e5.primitiveLength;
            const j3 = [];
            (t3.terrain || l3) && j3.push(f3.centroidVertexBuffer), w2 && j3.push(f3.layoutVertexExtBuffer), z4.draw(t3, c3.gl.TRIANGLES, s4, n3, a3, Mt.backCCW, U2, o3.id, f3.layoutVertexBuffer, f3.indexBuffer, G2, o3.paint, t3.transform.zoom, x4, j3);
          }
          t3.shadowRenderer && (t3.shadowRenderer.useNormalOffset = false);
        }
        function ss(t3, i3, o3, r4, s4, n3, a3, l3, c3, h2, u3, d2, _3, p3, f2, m2, g3, v3, x3) {
          const y3 = t3.context, b2 = y3.gl, w2 = t3.transform, T2 = t3.transform.zoom, E2 = [], S2 = mo(t3, o3.paint.get("fill-extrusion-cutoff-fade-range"));
          "clear" === h2 ? (E2.push("CLEAR_SUBPASS"), x3 && (E2.push("CLEAR_FROM_TEXTURE"), y3.activeTexture.set(b2.TEXTURE0), x3.bind(b2.LINEAR, b2.CLAMP_TO_EDGE))) : "sdf" === h2 && E2.push("SDF_SUBPASS"), g3 && E2.push("HAS_CENTROID"), S2.shouldRenderCutoff && E2.push("RENDER_CUTOFF");
          const C2 = o3.layout.get("fill-extrusion-edge-radius"), I2 = (e4, i4, r5, h3, v4) => {
            const b3 = i4.programConfigurations.get(o3.id), w3 = t3.isTileAffectedByFog(e4), I3 = t3.getOrCreateProgram("fillExtrusionGroundEffect", { config: b3, defines: E2, overrideFog: w3 }), D2 = /* @__PURE__ */ ((e5, t4, i5, o4, r6, s5, n4, a4, l4, c4, h4) => ({ u_matrix: t4, u_opacity: i5, u_ao_pass: o4 ? 1 : 0, u_meter_to_tile: r6, u_ao: s5, u_flood_light_intensity: n4, u_flood_light_color: a4, u_attenuation: l4, u_edge_radius: c4, u_fb: 0, u_fb_size: h4 }))(0, h3, u3, c3, v4, [d2, _3 * v4], p3, f2, m2, T2 >= 17 ? 0 : C2 * v4, x3 ? x3.size[0] : 0), R3 = [];
            g3 && R3.push(i4.hiddenByLandmarkVertexBuffer), t3.uploadCommonUniforms(y3, I3, e4.toUnwrapped(), null, S2), I3.draw(t3, y3.gl.TRIANGLES, s4, n3, a3, l3, D2, o3.id, i4.vertexBuffer, i4.indexBuffer, r5, o3.paint, T2, b3, R3);
          };
          for (const s5 of r4) {
            const r5 = i3.getTile(s5), n4 = r5.getBucket(o3);
            if (!n4 || n4.projection.name !== w2.projection.name || !n4.groundEffect || n4.groundEffect && !n4.groundEffect.hasData())
              continue;
            const a4 = n4.groundEffect, l4 = 1 / n4.tileToMeter;
            {
              const e4 = t3.translatePosMatrix(s5.projMatrix, r5, o3.paint.get("fill-extrusion-translate"), o3.paint.get("fill-extrusion-translate-anchor")), i4 = a4.getDefaultSegment();
              I2(s5, a4, i4, e4, l4);
            }
            if (v3)
              for (let n5 = 0; n5 < 4; n5++) {
                const a5 = e3.cN[n5](s5), c4 = i3.getTile(a5);
                if (!c4)
                  continue;
                const h3 = c4.getBucket(o3);
                if (!h3 || h3.projection.name !== w2.projection.name || !h3.groundEffect || h3.groundEffect && !h3.groundEffect.hasData())
                  continue;
                const u4 = h3.groundEffect;
                let d3, _4;
                0 === n5 ? (d3 = [-e3.Y, 0, 0], _4 = 1) : 1 === n5 ? (d3 = [e3.Y, 0, 0], _4 = 0) : 2 === n5 ? (d3 = [0, -e3.Y, 0], _4 = 3) : (d3 = [0, e3.Y, 0], _4 = 2);
                const p4 = u4.regionSegments[_4];
                if (!p4)
                  continue;
                const f3 = new Float32Array(16);
                e3.a9.translate(f3, s5.projMatrix, d3), I2(s5, u4, p4, t3.translatePosMatrix(f3, r5, o3.paint.get("fill-extrusion-translate"), o3.paint.get("fill-extrusion-translate-anchor")), l4);
              }
          }
        }
        function ns(t3, i3, o3, r4, s4, n3, a3) {
          0 === r4.centroidVertexArray.length && r4.createCentroidsBuffer();
          const l3 = n3 ? n3.findDEMTileFor(o3) : null;
          if (!(l3 && l3.dem || a3))
            return;
          const c3 = (t4) => new e3.P(Math.ceil((t4 + e3.cQ) * e3.cR), 0), h2 = (e4) => {
            const t4 = i3.getSource().minzoom, o4 = (e5) => {
              const t5 = i3.getTileByID(e5);
              if (t5 && t5.hasData())
                return t5.getBucket(s4);
            }, r5 = [0, -1, 1];
            for (const i4 of r5) {
              if (e4.overscaledZ + i4 < t4)
                continue;
              const r6 = o4(e4.calculateScaledKey(e4.overscaledZ + i4));
              if (r6)
                return r6;
            }
          }, u3 = [0, 0, 0], d2 = (t4, i4) => (u3[0] = Math.min(t4.min.y, i4.min.y), u3[1] = Math.max(t4.max.y, i4.max.y), u3[2] = e3.Y - i4.min.x > t4.max.x ? i4.min.x - e3.Y : t4.max.x, u3), _3 = (t4, i4) => (u3[0] = Math.min(t4.min.x, i4.min.x), u3[1] = Math.max(t4.max.x, i4.max.x), u3[2] = e3.Y - i4.min.y > t4.max.y ? i4.min.y - e3.Y : t4.max.y, u3), p3 = [(e4, t4) => d2(e4, t4), (e4, t4) => d2(t4, e4), (e4, t4) => _3(e4, t4), (e4, t4) => _3(t4, e4)], f2 = (t4, i4, r5, s5, a4, c4, h3) => {
            if (!n3)
              return 0;
            const u4 = [[c4 ? r5 : t4, c4 ? t4 : r5, 0], [c4 ? r5 : i4, c4 ? i4 : r5, 0]], d3 = h3 < 0 ? e3.Y + h3 : h3, _4 = [c4 ? d3 : (t4 + i4) / 2, c4 ? (t4 + i4) / 2 : d3, 0];
            return 0 === r5 && h3 < 0 || 0 !== r5 && h3 > 0 ? n3.getForTilePoints(a4, [_4], true, s5) : u4.push(_4), n3.getForTilePoints(o3, u4, true, l3), Math.max(u4[0][2], u4[1][2], _4[2]) / n3.exaggeration();
          };
          for (let t4 = 0; t4 < 4; t4++) {
            const i4 = r4.borderFeatureIndices[t4];
            if (0 === i4.length)
              continue;
            const s5 = e3.cN[t4](o3), l4 = h2(s5);
            if (!(l4 && l4 instanceof e3.cO))
              continue;
            if (r4.borderDoneWithNeighborZ[t4] === l4.canonical.z)
              continue;
            0 === l4.centroidVertexArray.length && l4.createCentroidsBuffer();
            const u4 = n3 ? n3.findDEMTileFor(s5) : null;
            if (!(u4 && u4.dem || a3))
              continue;
            const d3 = (t4 < 2 ? 1 : 5) - t4, _4 = l4.borderDoneWithNeighborZ[d3] !== r4.canonical.z, v3 = l4.borderFeatureIndices[d3];
            let x3 = 0;
            if (r4.canonical.z !== l4.canonical.z) {
              for (const e4 of i4)
                r4.showCentroid(r4.featuresOnBorder[e4]);
              if (_4)
                for (const e4 of v3)
                  l4.showCentroid(l4.featuresOnBorder[e4]);
              r4.borderDoneWithNeighborZ[t4] = l4.canonical.z, l4.borderDoneWithNeighborZ[d3] = r4.canonical.z;
            }
            for (const o4 of i4) {
              const i5 = r4.featuresOnBorder[o4], n4 = r4.centroidData[i5.centroidDataIndex], h3 = i5.borders[t4];
              let _5;
              for (; x3 < v3.length; ) {
                _5 = l4.featuresOnBorder[v3[x3]];
                const e4 = _5.borders[d3];
                if (e4[1] > h3[0] + 3 || e4[0] > h3[0] - 3)
                  break;
                l4.showCentroid(_5), x3++;
              }
              if (_5 && x3 < v3.length) {
                const o5 = x3;
                let y3 = 0;
                for (; !(_5.borders[d3][0] > h3[1] - 3) && (y3++, ++x3 !== v3.length); )
                  _5 = l4.featuresOnBorder[v3[x3]];
                if (_5 = l4.featuresOnBorder[v3[o5]], y3 > 1) {
                  const e4 = _5.borders[d3];
                  Math.abs(h3[0] - e4[0]) < 3 && Math.abs(h3[1] - e4[1]) < 3 && (y3 = 1, x3 = o5 + 1);
                } else if (0 === y3) {
                  r4.showCentroid(i5);
                  continue;
                }
                const b2 = l4.centroidData[_5.centroidDataIndex];
                a3 && 1 === y3 && (((m2 = n4).flags | (g3 = b2).flags) & e3.cP ? (m2.flags |= e3.cP, g3.flags |= e3.cP) : (m2.flags &= ~e3.cP, g3.flags &= ~e3.cP));
                const w2 = i5.intersectsCount() > 1 || _5.intersectsCount() > 1;
                if (y3 > 1)
                  x3 = o5, n4.centroidXY = b2.centroidXY = new e3.P(0, 0);
                else if (u4 && u4.dem && !w2) {
                  const i6 = p3[t4](n4, b2), o6 = t4 % 2 ? e3.Y - 1 : 0, r5 = f2(i6[0], Math.min(e3.Y - 1, i6[1]), o6, u4, s5, t4 < 2, i6[2]);
                  n4.centroidXY = b2.centroidXY = c3(r5);
                } else
                  w2 ? n4.centroidXY = b2.centroidXY = new e3.P(0, 0) : (n4.centroidXY = r4.encodeBorderCentroid(i5), b2.centroidXY = l4.encodeBorderCentroid(_5));
                r4.writeCentroidToBuffer(n4), l4.writeCentroidToBuffer(b2);
              } else
                r4.showCentroid(i5);
            }
            r4.borderDoneWithNeighborZ[t4] = l4.canonical.z, l4.borderDoneWithNeighborZ[d3] = r4.canonical.z;
          }
          var m2, g3;
          (r4.needsCentroidUpdate || !r4.centroidVertexBuffer && 0 !== r4.centroidVertexArray.length) && r4.uploadCentroid(t3);
        }
        const as = [1, 0, 0], ls = [0, 1, 0], cs = [0, 0, 1];
        function hs(t3, i3, o3) {
          const r4 = o3.transform, s4 = o3.shadowRenderer;
          if (!s4)
            return true;
          const n3 = t3.toUnwrapped(), a3 = r4.tileSize * s4._cascades[o3.currentShadowCascade].scale;
          let l3 = i3.maxHeight;
          if (r4.elevation) {
            const e4 = r4.elevation.getMinMaxForTile(t3);
            e4 && (l3 += e4.max);
          }
          const c3 = [...s4.shadowDirection];
          c3[2] = -c3[2];
          const h2 = s4.computeSimplifiedTileShadowVolume(n3, l3, a3, c3);
          if (!h2)
            return false;
          const u3 = [as, ls, cs, c3, [c3[0], 0, c3[2]], [0, c3[1], c3[2]]], d2 = "globe" === r4.projection.name, _3 = r4.scaleZoom(a3), p3 = e3.bt.fromInvProjectionMatrix(r4.invProjMatrix, r4.worldSize, _3, !d2), f2 = s4.getCurrentCascadeFrustum();
          return 0 === p3.intersectsPrecise(h2.vertices, h2.planes, u3) || 0 === f2.intersectsPrecise(h2.vertices, h2.planes, u3);
        }
        function us(t3) {
          return [t3[0] * e3.cS, t3[1] * e3.cS, t3[2] * e3.cS, 0];
        }
        function ds(t3, i3, o3, r4, s4, n3, a3, l3, c3) {
          const h2 = r4.getSource(), u3 = o3.globeSharedBuffers;
          if (!u3)
            return;
          let d2, _3, p3;
          if (i3 && (d2 = r4.getTile(i3)), h2 instanceof e3.as ? (_3 = h2.texture, p3 = e3.co(0, 0, o3.transform)) : d2 && i3 && (_3 = d2.texture, p3 = e3.co(i3.canonical.z, i3.canonical.x, o3.transform)), !_3 || !p3)
            return;
          t3 || (p3 = e3.a9.scale(e3.a9.create(), p3, [1, -1, 1]));
          const f2 = o3.context, m2 = f2.gl, g3 = "nearest" === s4.paint.get("raster-resampling") ? m2.NEAREST : m2.LINEAR, v3 = o3.colorModeForDrapableLayerRenderPass(n3), x3 = a3.defines;
          x3.push("GLOBE_POLES");
          const y3 = new Ct(m2.LEQUAL, Ct.ReadWrite, o3.depthRangeFor3D), b2 = Float32Array.from(o3.transform.expandedFarZProjMatrix), w2 = Float32Array.from(e3.aW(e3.cn(new e3.bv(0, 0, 0))));
          o3.terrain && o3.terrain.prepareDrawTile(), f2.activeTexture.set(m2.TEXTURE0), _3.bind(g3, m2.CLAMP_TO_EDGE), f2.activeTexture.set(m2.TEXTURE1), _3.bind(g3, m2.CLAMP_TO_EDGE), _3.useMipmap && f2.extTextureFilterAnisotropic && o3.transform.pitch > 20 && m2.texParameterf(m2.TEXTURE_2D, f2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f2.extTextureFilterAnisotropicMax);
          const [T2, E2, S2, C2] = i3 ? u3.getPoleBuffers(i3.canonical.z, false) : u3.getPoleBuffers(0, true), I2 = s4.paint.get("raster-elevation");
          let D2;
          t3 ? (D2 = T2, o3.renderDefaultNorthPole = 0 !== I2) : (D2 = E2, o3.renderDefaultSouthPole = 0 !== I2);
          const R3 = us(a3.mix), A2 = ((e4, t4, i4, o4, r5, s5, n4, a4, l4, c4, h3, u4, d3) => zr(e4, t4, i4, new Float32Array(16), new Float32Array(9), [0, 0], o4, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, s5, [0, 0], a4, 2, c4, h3, u4, 1, 0, d3))(b2, w2, p3, e3.W(o3.transform.zoom), 0, s4, 0, I2, 0, R3, a3.offset, a3.range, n3), P2 = o3.getOrCreateProgram("raster", { defines: x3 });
          o3.uploadCommonUniforms(f2, P2, null), P2.draw(o3, m2.TRIANGLES, y3, c3, v3, l3, A2, s4.id, D2, S2, C2);
        }
        function _s(e4) {
          const t3 = e4._nearZ, i3 = e4.projection.farthestPixelDistance(e4), o3 = i3 - t3, r4 = 0.2 * e4.height, s4 = t3 + r4;
          return [t3, i3, (s4 - r4 - t3) / o3, (s4 - t3) / o3];
        }
        function ps(e4, t3, i3, o3) {
          if (e4)
            return t3 instanceof Pe && e4 instanceof Ht ? t3.getTextureDescriptor(e4, i3, true) : { texture: e4.texture, mix: us(o3.mix), offset: o3.offset, buffer: 0, tileSize: 1 };
        }
        function fs(t3, i3, o3) {
          if (!t3)
            return null;
          const r4 = i3.getTextureDescriptor(t3, o3, true);
          if (!r4)
            return null;
          let { texture: s4, mix: n3, offset: a3, tileSize: l3, buffer: c3, format: h2 } = r4;
          if (!s4 || !h2)
            return null;
          let u3 = false;
          return "uint32" === h2 && (u3 = true, n3[3] = 0, n3 = Lr(e3.cT, n3, [0, o3.paint.get("raster-particle-max-speed")]), a3 = Mr(e3.cT, a3, [0, o3.paint.get("raster-particle-max-speed")])), { texture: s4, textureOffset: [c3 / (l3 + 2 * c3), l3 / (l3 + 2 * c3)], tileSize: l3, scalarData: u3, scale: n3, offset: a3, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[h2]] };
        }
        function ms(e4) {
          const t3 = e4._nearZ, i3 = e4.projection.farthestPixelDistance(e4), o3 = i3 - t3, r4 = 0.2 * e4.height, s4 = t3 + r4;
          return [t3, i3, (s4 - r4 - t3) / o3, (s4 - t3) / o3];
        }
        const gs = new e3.aA(1, 0, 0, 1), vs = new e3.aA(0, 1, 0, 1), xs = new e3.aA(0, 0, 1, 1), ys = new e3.aA(1, 0, 1, 1), bs = new e3.aA(0, 1, 1, 1);
        function ws(t3, i3, o3, r4, s4, n3, a3) {
          const l3 = t3.context, c3 = t3.transform, h2 = l3.gl, u3 = "globe" === c3.projection.name, d2 = u3 ? ["PROJECTION_GLOBE_VIEW"] : [];
          let _3 = e3.a9.clone(o3.projMatrix);
          if (u3 && e3.W(c3.zoom) > 0) {
            const t4 = e3.aV(o3.canonical, c3), i4 = e3.cU(t4);
            _3 = e3.a9.multiply(new Float32Array(16), c3.globeMatrix, i4), e3.a9.multiply(_3, c3.projMatrix, _3);
          }
          const p3 = e3.a9.create();
          p3[12] += 2 * s4 / (e3.f.devicePixelRatio * c3.width), p3[13] += 2 * n3 / (e3.f.devicePixelRatio * c3.height), e3.a9.multiply(_3, p3, _3);
          const f2 = t3.getOrCreateProgram("debug", { defines: d2 }), m2 = i3.getTileByID(o3.key);
          t3.terrain && t3.terrain.setupElevationDraw(m2, f2);
          const g3 = Ct.disabled, v3 = Dt.disabled, x3 = t3.colorModeForRenderPass(), y3 = "$debug";
          l3.activeTexture.set(h2.TEXTURE0), t3.emptyTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), u3 ? m2._makeGlobeTileDebugBuffers(t3.context, c3) : m2._makeDebugTileBoundsBuffers(t3.context, c3.projection);
          const b2 = m2._tileDebugBuffer || t3.debugBuffer, w2 = m2._tileDebugIndexBuffer || t3.debugIndexBuffer, T2 = m2._tileDebugSegments || t3.debugSegments;
          if (f2.draw(t3, h2.LINE_STRIP, g3, v3, x3, Mt.disabled, Rr(_3, r4), y3, b2, w2, T2, null, null, null, [m2._globeTileDebugBorderBuffer]), a3) {
            const e4 = m2.latestRawTileData, i4 = Math.floor((e4 && e4.byteLength || 0) / 1024);
            let r5 = o3.canonical.toString();
            o3.overscaledZ !== o3.canonical.z && (r5 += ` => ${o3.overscaledZ}`), r5 += ` ${m2.state}`, r5 += ` ${i4}kb`, function(e5, t4) {
              e5.initDebugOverlayCanvas();
              const i5 = e5.debugOverlayCanvas, o4 = e5.context.gl, r6 = e5.debugOverlayCanvas.getContext("2d");
              r6.clearRect(0, 0, i5.width, i5.height), r6.shadowColor = "white", r6.shadowBlur = 2, r6.lineWidth = 1.5, r6.strokeStyle = "white", r6.textBaseline = "top", r6.font = "bold 36px Open Sans, sans-serif", r6.fillText(t4, 5, 5), r6.strokeText(t4, 5, 5), e5.debugOverlayTexture.update(i5), e5.debugOverlayTexture.bind(o4.LINEAR, o4.CLAMP_TO_EDGE);
            }(t3, r5);
          }
          const E2 = i3.getTile(o3).tileSize, S2 = 512 / Math.min(E2, 512) * (o3.overscaledZ / c3.zoom) * 0.5, C2 = m2._tileDebugTextBuffer || t3.debugBuffer, I2 = m2._tileDebugTextIndexBuffer || t3.quadTriangleIndexBuffer, D2 = m2._tileDebugTextSegments || t3.debugSegments;
          f2.draw(t3, h2.TRIANGLES, g3, v3, At.alphaBlended, Mt.disabled, Rr(_3, e3.aA.transparent, S2), y3, C2, I2, D2, null, null, null, [m2._globeTileDebugTextBuffer]);
        }
        function Ts(e4, t3, i3, o3) {
          Ss(e4, 0, t3 + i3 / 2, e4.transform.width, i3, o3);
        }
        function Es(e4, t3, i3, o3) {
          Ss(e4, t3 - i3 / 2, 0, i3, e4.transform.height, o3);
        }
        function Ss(t3, i3, o3, r4, s4, n3) {
          const a3 = t3.context, l3 = a3.gl;
          l3.enable(l3.SCISSOR_TEST), l3.scissor(i3 * e3.f.devicePixelRatio, o3 * e3.f.devicePixelRatio, r4 * e3.f.devicePixelRatio, s4 * e3.f.devicePixelRatio), a3.clear({ color: n3 }), l3.disable(l3.SCISSOR_TEST);
        }
        const Cs = e3.aB([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Is } = Cs;
        function Ds(e4, t3, i3, o3) {
          e4.emplaceBack(t3, i3, o3);
        }
        class Rs {
          constructor(t3) {
            this.vertexArray = new e3.cV(), this.indices = new e3.az(), Ds(this.vertexArray, -1, -1, 1), Ds(this.vertexArray, 1, -1, 1), Ds(this.vertexArray, -1, 1, 1), Ds(this.vertexArray, 1, 1, 1), Ds(this.vertexArray, -1, -1, -1), Ds(this.vertexArray, 1, -1, -1), Ds(this.vertexArray, -1, 1, -1), Ds(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t3.createVertexBuffer(this.vertexArray, Is), this.indexBuffer = t3.createIndexBuffer(this.indices), this.segment = e3.aE.simpleSegment(0, 0, 36, 12);
          }
        }
        function As(t3, i3, o3, r4, s4, n3) {
          const a3 = t3.context.gl, l3 = i3.paint.get("sky-atmosphere-color"), c3 = i3.paint.get("sky-atmosphere-halo-color"), h2 = i3.paint.get("sky-atmosphere-sun-intensity"), u3 = ((e4, t4, i4, o4, r5) => ({ u_matrix_3f: e4, u_sun_direction: t4, u_sun_intensity: i4, u_color_tint_r: [o4.r, o4.g, o4.b, o4.a], u_color_tint_m: [r5.r, r5.g, r5.b, r5.a], u_luminance: 5e-5 }))(e3.ct.fromMat4(e3.ct.create(), r4), s4, h2, l3, c3);
          a3.framebufferTexture2D(a3.FRAMEBUFFER, a3.COLOR_ATTACHMENT0, a3.TEXTURE_CUBE_MAP_POSITIVE_X + n3, i3.skyboxTexture, 0), o3.draw(t3, a3.TRIANGLES, Ct.disabled, Dt.disabled, At.unblended, Mt.frontCW, u3, "skyboxCapture", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }
        const Ps = e3.aB([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class Ls {
          constructor(t3) {
            const i3 = new e3.cW();
            i3.emplaceBack(-1, 1, 1, 0, 0), i3.emplaceBack(1, 1, 1, 1, 0), i3.emplaceBack(1, -1, 1, 1, 1), i3.emplaceBack(-1, -1, 1, 0, 1);
            const o3 = new e3.az();
            o3.emplaceBack(0, 1, 2), o3.emplaceBack(2, 3, 0), this.vertexBuffer = t3.createVertexBuffer(i3, Ps.members), this.indexBuffer = t3.createIndexBuffer(o3), this.segments = e3.aE.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const Ms = e3.aB([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
        class zs {
          constructor() {
            this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
          }
        }
        class Os {
          constructor(t3) {
            this.colorModeAlphaBlendedWriteRGB = new At([1, Rt, 1, Rt], e3.aA.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new At([1, 0, 1, 0], e3.aA.transparent, [false, false, false, true]), this.params = new zs(), this.updateNeeded = true, t3.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
              this.updateNeeded = true;
            }), t3.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t3.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = true;
            }), t3.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = true;
            });
          }
          update(t3) {
            const i3 = t3.context;
            if (!this.atmosphereBuffer || this.updateNeeded) {
              this.updateNeeded = false, this.atmosphereBuffer = new Ls(i3);
              const t4 = this.params.sizeRange, o3 = this.params.intensityRange, r4 = function(t5) {
                const i4 = e3.aC(30), o4 = [];
                for (let r5 = 0; r5 < t5; ++r5) {
                  const t6 = 2 * Math.PI * i4(), r6 = Math.acos(1 - 2 * i4()) - 0.5 * Math.PI;
                  o4.push(e3.Q.fromValues(Math.cos(r6) * Math.cos(t6), Math.cos(r6) * Math.sin(t6), Math.sin(r6)));
                }
                return o4;
              }(this.params.starsCount), s4 = e3.aC(300), n3 = new e3.cX(), a3 = new e3.az();
              let l3 = 0;
              for (let i4 = 0; i4 < r4.length; ++i4) {
                const c3 = e3.Q.scale([], r4[i4], 200), h2 = Math.max(0, 1 + 0.01 * t4 * (1 * s4() - 0.5)), u3 = Math.max(0, 1 + 0.01 * o3 * (1 * s4() - 0.5));
                n3.emplaceBack(c3[0], c3[1], c3[2], -1, -1, h2, u3), n3.emplaceBack(c3[0], c3[1], c3[2], 1, -1, h2, u3), n3.emplaceBack(c3[0], c3[1], c3[2], 1, 1, h2, u3), n3.emplaceBack(c3[0], c3[1], c3[2], -1, 1, h2, u3), a3.emplaceBack(l3 + 0, l3 + 1, l3 + 2), a3.emplaceBack(l3 + 0, l3 + 2, l3 + 3), l3 += 4;
              }
              this.starsVx = i3.createVertexBuffer(n3, Ms.members), this.starsIdx = i3.createIndexBuffer(a3), this.starsSegments = e3.aE.simpleSegment(0, 0, n3.length, a3.length);
            }
          }
          destroy() {
            this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
          }
          drawAtmosphereGlow(t3, i3) {
            const o3 = t3.context, r4 = o3.gl, s4 = t3.transform, n3 = new Ct(r4.LEQUAL, Ct.ReadOnly, [0, 1]), a3 = e3.W(s4.zoom), l3 = i3.properties.get("color").toArray01(), c3 = i3.properties.get("high-color").toArray01(), h2 = i3.properties.get("space-color").toArray01PremultipliedAlpha(), u3 = 5e-4, d2 = e3.cY(i3.properties.get("horizon-blend"), 0, 1, u3, 0.25), _3 = e3.ci(t3, o3, s4) && d2 === u3 ? s4.worldSize / (2 * Math.PI * 1.025) - 1 : s4.globeRadius, p3 = t3.frameCounter / 1e3 % 1, f2 = e3.Q.length(s4.globeCenterInViewSpace), m2 = Math.sqrt(Math.pow(f2, 2) - Math.pow(_3, 2)), g3 = Math.acos(m2 / f2), v3 = (e4) => {
              const i4 = "globe" === s4.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
              e4 && i4.push("ALPHA_PASS");
              const u4 = t3.getOrCreateProgram("globeAtmosphere", { defines: i4 }), _4 = /* @__PURE__ */ ((e5, t4, i5, o4, r5, s5, n4, a4, l4, c4, h3, u5) => ({ u_frustum_tl: e5, u_frustum_tr: t4, u_frustum_br: i5, u_frustum_bl: o4, u_horizon: r5, u_transition: s5, u_fadeout_range: n4, u_color: a4, u_high_color: l4, u_space_color: c4, u_temporal_offset: h3, u_horizon_angle: u5 }))(s4.frustumCorners.TL, s4.frustumCorners.TR, s4.frustumCorners.BR, s4.frustumCorners.BL, s4.frustumCorners.horizon, a3, d2, l3, c3, h2, p3, g3);
              t3.uploadCommonUniforms(o3, u4);
              const f3 = this.atmosphereBuffer;
              f3 && u4.draw(t3, r4.TRIANGLES, n3, Dt.disabled, e4 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Mt.backCW, _4, e4 ? "atmosphere_glow_alpha" : "atmosphere_glow", f3.vertexBuffer, f3.indexBuffer, f3.segments);
            };
            v3(false), v3(true);
          }
          drawStars(t3, i3) {
            const o3 = e3.ad(i3.properties.get("star-intensity"), 0, 1);
            if (0 === o3)
              return;
            const r4 = t3.context, s4 = r4.gl, n3 = t3.transform, a3 = t3.getOrCreateProgram("stars"), l3 = e3.bl.identity([]);
            e3.bl.rotateX(l3, l3, -n3._pitch), e3.bl.rotateZ(l3, l3, -n3.angle), e3.bl.rotateX(l3, l3, e3.bm(n3._center.lat)), e3.bl.rotateY(l3, l3, -e3.bm(n3._center.lng));
            const c3 = e3.a9.fromQuat(new Float32Array(16), l3), h2 = e3.a9.multiply([], n3.starsProjMatrix, c3), u3 = e3.ct.fromMat4([], c3), d2 = e3.ct.invert([], u3), _3 = [0, 1, 0];
            e3.Q.transformMat3(_3, _3, d2), e3.Q.scale(_3, _3, this.params.sizeMultiplier);
            const p3 = [1, 0, 0];
            e3.Q.transformMat3(p3, p3, d2), e3.Q.scale(p3, p3, this.params.sizeMultiplier);
            const f2 = (m2 = _3, g3 = p3, v3 = o3, { u_matrix: Float32Array.from(h2), u_up: m2, u_right: g3, u_intensity_multiplier: v3 });
            var m2, g3, v3;
            t3.uploadCommonUniforms(r4, a3), this.starsVx && this.starsIdx && a3.draw(t3, s4.TRIANGLES, Ct.disabled, Dt.disabled, this.colorModeAlphaBlendedWriteRGB, Mt.disabled, f2, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
          }
        }
        function Fs(t3, i3) {
          const o3 = [...t3], r4 = i3.cameraWorldSizeForFog / i3.worldSize, s4 = e3.a9.identity([]);
          return e3.a9.scale(s4, s4, [r4, r4, 1]), e3.a9.multiply(o3, s4, o3), e3.a9.multiply(o3, i3.worldToFogMatrix, o3), o3;
        }
        function Bs(e4, t3, i3, o3) {
          const r4 = i3.material, s4 = o3.context, { baseColorTexture: n3, metallicRoughnessTexture: a3 } = r4.pbrMetallicRoughness, { normalTexture: l3, occlusionTexture: c3, emissionTexture: h2 } = r4;
          function u3(t4, i4, o4) {
            if (t4 && (e4.push(i4), s4.activeTexture.set(s4.gl.TEXTURE0 + o4), t4.gfxTexture)) {
              const { minFilter: e5, magFilter: i5, wrapS: o5, wrapT: r5 } = t4.sampler;
              t4.gfxTexture.bindExtraParam(e5, i5, o5, r5);
            }
          }
          u3(n3, "HAS_TEXTURE_u_baseColorTexture", fo.BaseColor), u3(a3, "HAS_TEXTURE_u_metallicRoughnessTexture", fo.MetallicRoughness), u3(l3, "HAS_TEXTURE_u_normalTexture", fo.Normal), u3(c3, "HAS_TEXTURE_u_occlusionTexture", fo.Occlusion), u3(h2, "HAS_TEXTURE_u_emissionTexture", fo.Emission), i3.texcoordBuffer && (e4.push("HAS_ATTRIBUTE_a_uv_2f"), t3.push(i3.texcoordBuffer)), i3.colorBuffer && (e4.push(12 === i3.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t3.push(i3.colorBuffer)), i3.normalBuffer && (e4.push("HAS_ATTRIBUTE_a_normal_3f"), t3.push(i3.normalBuffer)), i3.pbrBuffer && (e4.push("HAS_ATTRIBUTE_a_pbr"), e4.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t3.push(i3.pbrBuffer)), "OPAQUE" !== r4.alphaMode && "MASK" !== r4.alphaMode || e4.push("UNPREMULT_TEXTURE_IN_SHADER"), r4.defined || e4.push("DIFFUSE_SHADED"), e4.push("USE_STANDARD_DERIVATIVES");
        }
        function ks(t3, i3, o3, r4, s4, n3) {
          const a3 = o3.paint.get("model-opacity"), l3 = i3.context, c3 = new Ct(i3.context.gl.LEQUAL, Ct.ReadWrite, i3.depthRangeFor3D), h2 = i3.transform, u3 = t3.mesh, d2 = u3.material, _3 = d2.pbrMetallicRoughness, p3 = i3.style.fog;
          let f2;
          f2 = "pixels" === i3.transform.projection.zAxisUnit ? [...t3.nodeModelMatrix] : e3.a9.multiply([], r4.zScaleMatrix, t3.nodeModelMatrix), e3.a9.multiply(f2, r4.negCameraPosMatrix, f2);
          const m2 = e3.a9.invert([], f2);
          e3.a9.transpose(m2, m2);
          const g3 = o3.paint.get("model-emissive-strength").constantOr(0), v3 = Hr(new Float32Array(t3.worldViewProjection), new Float32Array(f2), new Float32Array(m2), null, i3, a3, _3.baseColorFactor, d2.emissiveFactor, _3.metallicFactor, _3.roughnessFactor, d2, g3, o3), x3 = { defines: [] }, y3 = [];
          Bs(x3.defines, y3, u3, i3);
          const b2 = i3.shadowRenderer;
          b2 && (b2.useNormalOffset = false);
          let w2 = null;
          if (p3) {
            const e4 = Fs(t3.nodeModelMatrix, i3.transform);
            if (w2 = new Float32Array(e4), "globe" !== h2.projection.name) {
              const t4 = u3.aabb.min, i4 = u3.aabb.max, [o4, r5] = p3.getOpacityForBounds(e4, t4[0], t4[1], i4[0], i4[1]);
              x3.overrideFog = o4 >= _e || r5 >= _e;
            }
          }
          const T2 = mo(i3, o3.paint.get("model-cutoff-fade-range"));
          T2.shouldRenderCutoff && x3.defines.push("RENDER_CUTOFF");
          const E2 = i3.getOrCreateProgram("model", x3);
          i3.uploadCommonUniforms(l3, E2, null, w2, T2), "shadow" !== i3.renderPass && b2 && b2.setupShadowsFromMatrix(t3.nodeModelMatrix, E2), E2.draw(i3, l3.gl.TRIANGLES, c3, s4, n3, u3.material.doubleSided ? Mt.disabled : Mt.backCCW, v3, o3.id, u3.vertexBuffer, u3.indexBuffer, u3.segments, o3.paint, i3.transform.zoom, void 0, y3);
        }
        function Ns(t3, i3, o3, r4, s4, n3, a3) {
          let l3;
          l3 = "globe" === t3.projection.name ? e3.c_(o3, t3) : [...o3], e3.a9.multiply(l3, l3, i3.matrix);
          const c3 = e3.a9.multiply([], r4, l3);
          if (i3.meshes)
            for (const t4 of i3.meshes) {
              if ("BLEND" !== t4.material.alphaMode) {
                a3.push({ mesh: t4, depth: 0, modelIndex: s4, worldViewProjection: c3, nodeModelMatrix: l3 });
                continue;
              }
              const i4 = e3.Q.transformMat4([], t4.centroid, c3);
              i4[2] > 0 && n3.push({ mesh: t4, depth: i4[2], modelIndex: s4, worldViewProjection: c3, nodeModelMatrix: l3 });
            }
          if (i3.children)
            for (const e4 of i3.children)
              Ns(t3, e4, o3, r4, s4, n3, a3);
        }
        function Us(e4, t3, i3, o3) {
          const r4 = i3.shadowRenderer;
          if (!r4)
            return;
          const s4 = r4.getShadowPassDepthMode(), n3 = r4.getShadowPassColorMode(), a3 = r4.calculateShadowPassMatrixFromMatrix(t3), l3 = qr(a3);
          i3.getOrCreateProgram("modelDepth", { defines: i3._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i3, i3.context.gl.TRIANGLES, s4, Dt.disabled, n3, Mt.backCCW, l3, o3.id, e4.vertexBuffer, e4.indexBuffer, e4.segments, o3.paint, i3.transform.zoom, void 0, void 0);
        }
        function Gs(t3, i3, o3) {
          const r4 = i3.updateZoomBasedPaintProperties(), s4 = function(t4, i4, o4) {
            let r5, s5, n3, a3 = t4.terrain ? t4.terrain.exaggeration() : 0;
            if (t4.terrain && a3 > 0) {
              const i5 = t4.terrain, s6 = i5.findDEMTileFor(o4);
              s6 && s6.dem ? r5 = e3.d0.create(i5, o4, s6) : a3 = 0;
            }
            if (0 === a3 && (i4.terrainElevationMin = 0, i4.terrainElevationMax = 0), a3 === i4.validForExaggeration && (0 === a3 || r5 && r5._demTile && r5._demTile.tileID === i4.validForDEMTile.id && r5._dem._timestamp === i4.validForDEMTile.timestamp))
              return false;
            for (const e4 in i4.instancesPerModel) {
              const t5 = i4.instancesPerModel[e4];
              for (let e5 = 0; e5 < t5.instancedDataArray.length; ++e5) {
                const o5 = (r5 ? a3 * r5.getElevationAt(0 | t5.instancedDataArray.float32[16 * e5], 0 | t5.instancedDataArray.float32[16 * e5 + 1], true, true) : 0) + t5.instancesEvaluatedElevation[e5];
                t5.instancedDataArray.float32[16 * e5 + 6] = o5, s5 = s5 ? Math.min(i4.terrainElevationMin, o5) : o5, n3 = n3 ? Math.max(i4.terrainElevationMax, o5) : o5;
              }
            }
            return i4.terrainElevationMin = s5 || 0, i4.terrainElevationMax = n3 || 0, i4.validForExaggeration = a3, i4.validForDEMTile = r5 && r5._demTile ? { id: r5._demTile.tileID, timestamp: r5._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
          }(t3, i3, o3);
          (r4 || s4) && (i3.uploaded = false, i3.upload(t3.context));
        }
        const js = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e3.bV([0, 0, 0], [e3.Y, e3.Y, 0]) };
        function Vs(t3, i3) {
          const o3 = 1 << t3.canonical.z, r4 = i3.getFreeCameraOptions().position, s4 = i3.elevation, n3 = t3.canonical.x / o3, a3 = (t3.canonical.x + 1) / o3, l3 = t3.canonical.y / o3, c3 = (t3.canonical.y + 1) / o3;
          let h2 = i3._centerAltitude;
          if (s4) {
            const e4 = s4.getMinMaxForTile(t3);
            e4 && e4.max > h2 && (h2 = e4.max);
          }
          const u3 = e3.ad(r4.x, n3, a3) - r4.x, d2 = e3.ad(r4.y, l3, c3) - r4.y, _3 = e3.bo(h2, i3.center.lat) - r4.z;
          return i3._zoomFromMercatorZ(Math.sqrt(u3 * u3 + d2 * d2 + _3 * _3));
        }
        function Zs(e4, t3, i3, o3, r4, s4, n3) {
          const a3 = e4.context, l3 = "shadow" === e4.renderPass, c3 = e4.shadowRenderer, h2 = l3 && c3 ? c3.getShadowPassDepthMode() : new Ct(a3.gl.LEQUAL, Ct.ReadWrite, e4.depthRangeFor3D), u3 = e4.isTileAffectedByFog(s4);
          if (i3.meshes)
            for (const d2 of i3.meshes) {
              const _3 = ["MODEL_POSITION_ON_GPU"], p3 = [];
              let f2, m2, g3;
              o3.instancedDataArray.length > 20 && _3.push("INSTANCED_ARRAYS");
              const v3 = mo(e4, t3.paint.get("model-cutoff-fade-range"));
              if (v3.shouldRenderCutoff && _3.push("RENDER_CUTOFF"), l3 && c3)
                f2 = e4.getOrCreateProgram("modelDepth", { defines: _3 }), m2 = qr(n3.shadowTileMatrix, n3.shadowTileMatrix, Float32Array.from(i3.matrix)), g3 = c3.getShadowPassColorMode();
              else {
                Bs(_3, p3, d2, e4), f2 = e4.getOrCreateProgram("model", { defines: _3, overrideFog: u3 });
                const o4 = d2.material, l4 = o4.pbrMetallicRoughness, h3 = t3.paint.get("model-opacity"), x4 = t3.paint.get("model-emissive-strength").constantOr(0);
                m2 = Hr(s4.expandedProjMatrix, Float32Array.from(i3.matrix), new Float32Array(16), null, e4, h3, l4.baseColorFactor, o4.emissiveFactor, l4.metallicFactor, l4.roughnessFactor, o4, x4, t3, r4), c3 && (n3.shadowUniformsInitialized ? f2.setShadowUniformValues(a3, c3.getShadowUniformValues()) : (c3.setupShadows(s4.toUnwrapped(), f2, "model-tile", s4.overscaledZ), n3.shadowUniformsInitialized = true)), g3 = v3.shouldRenderCutoff || h3 < 1 || "OPAQUE" !== o4.alphaMode ? At.alphaBlended : At.unblended;
              }
              e4.uploadCommonUniforms(a3, f2, s4.toUnwrapped(), null, v3);
              const x3 = d2.material.doubleSided ? Mt.disabled : Mt.backCCW;
              if (o3.instancedDataArray.length > 20)
                p3.push(o3.instancedDataBuffer), f2.draw(e4, a3.gl.TRIANGLES, h2, Dt.disabled, g3, x3, m2, t3.id, d2.vertexBuffer, d2.indexBuffer, d2.segments, t3.paint, e4.transform.zoom, void 0, p3, o3.instancedDataArray.length);
              else {
                const i4 = l3 ? "u_instance" : "u_normal_matrix";
                for (let r5 = 0; r5 < o3.instancedDataArray.length; ++r5)
                  m2[i4] = new Float32Array(o3.instancedDataArray.arrayBuffer, 64 * r5, 16), f2.draw(e4, a3.gl.TRIANGLES, h2, Dt.disabled, g3, x3, m2, t3.id, d2.vertexBuffer, d2.indexBuffer, d2.segments, t3.paint, e4.transform.zoom, void 0, p3);
              }
            }
          if (i3.children)
            for (const a4 of i3.children)
              Zs(e4, t3, a4, o3, r4, s4, n3);
        }
        const Ws = [1, -1, 1];
        function Hs(t3, i3, o3, r4) {
          if (!o3.modelManager)
            return true;
          const s4 = o3.modelManager;
          if (!o3.shadowRenderer)
            return true;
          const n3 = o3.shadowRenderer, a3 = i3.aabb;
          let l3 = true, c3 = t3.maxHeight;
          if (0 === c3) {
            let e4 = 0;
            for (const i4 in t3.instancesPerModel) {
              const t4 = s4.getModel(i4, r4);
              t4 ? e4 = Math.max(e4, Math.max(Math.max(t4.aabb.max[0], t4.aabb.max[1]), t4.aabb.max[2])) : l3 = false;
            }
            c3 = t3.maxScale * e4 * 1.41 + t3.maxVerticalOffset, l3 && (t3.maxHeight = c3);
          }
          a3.max[2] = c3, a3.min[2] += t3.terrainElevationMin, a3.max[2] += t3.terrainElevationMax, e3.Q.transformMat4(a3.min, a3.min, i3.tileMatrix), e3.Q.transformMat4(a3.max, a3.max, i3.tileMatrix);
          const h2 = a3.intersects(n3.getCurrentCascadeFrustum());
          return 0 === o3.currentShadowCascade && (t3.isInsideFirstShadowMapFrustum = 2 === h2), 0 === h2;
        }
        class qs {
        }
        class Qs {
          constructor() {
            this._storage = /* @__PURE__ */ new Map();
          }
          getLinesFromTrianglesBuffer(t3, i3, o3) {
            {
              const e4 = this._storage.get(i3.id);
              if (e4)
                return e4.lastUsedFrameIdx = t3, e4.buf;
            }
            const r4 = o3.gl, s4 = r4.getBufferParameter(r4.ELEMENT_ARRAY_BUFFER, r4.BUFFER_SIZE), n3 = new ArrayBuffer(s4), a3 = new Int16Array(n3);
            r4.getBufferSubData(r4.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n3));
            const l3 = new e3.d2();
            for (let e4 = 0; e4 < s4 / 2; e4 += 3) {
              const t4 = a3[e4], i4 = a3[e4 + 1], o4 = a3[e4 + 2];
              l3.emplaceBack(t4, i4), l3.emplaceBack(i4, o4), l3.emplaceBack(o4, t4);
            }
            const c3 = o3.bindVertexArrayOES.current, h2 = new qs();
            return h2.buf = new Ne(o3, l3), h2.lastUsedFrameIdx = t3, this._storage.set(i3.id, h2), o3.bindVertexArrayOES.set(c3), h2.buf;
          }
          update(e4) {
            for (const [t3, i3] of this._storage)
              e4 - i3.lastUsedFrameIdx > 30 && (i3.buf.destroy(), this._storage.delete(t3));
          }
          destroy() {
            for (const [e4, t3] of this._storage)
              t3.buf.destroy(), this._storage.delete(e4);
          }
        }
        const $s = { symbol: function(t3, i3, o3, r4, s4) {
          if ("translucent" !== t3.renderPass)
            return;
          const n3 = Dt.disabled, a3 = t3.colorModeForRenderPass();
          o3.layout.get("text-variable-anchor") && function(t4, i4, o4, r5, s5, n4, a4) {
            const l4 = i4.transform, c4 = "map" === s5, h2 = "map" === n4;
            for (const i5 of t4) {
              const t5 = r5.getTile(i5), s6 = t5.getBucket(o4);
              if (!s6 || !s6.text || !s6.text.segments.get().length)
                continue;
              const n5 = e3.b8(s6.textSizeData, l4.zoom), u3 = Li(i5, s6.getProjection(), l4), d2 = l4.calculatePixelsToTileUnitsMatrix(t5), _3 = _i(u3, t5.tileID.canonical, h2, c4, l4, s6.getProjection(), d2), p3 = s6.hasIconTextFit() && s6.hasIconData();
              if (n5) {
                const o5 = Math.pow(2, l4.zoom - t5.tileID.overscaledZ);
                es(s6, c4, h2, a4, e3.cE, l4, _3, i5, o5, n5, p3);
              }
            }
          }(r4, t3, o3, i3, o3.layout.get("text-rotation-alignment"), o3.layout.get("text-pitch-alignment"), s4);
          const l3 = 0 !== o3.paint.get("icon-opacity").constantOr(1), c3 = 0 !== o3.paint.get("text-opacity").constantOr(1);
          void 0 !== o3.layout.get("symbol-sort-key").constantOr(1) && (l3 || c3) ? ts(t3, i3, o3, r4, n3, a3) : (l3 && ts(t3, i3, o3, r4, n3, a3, { onlyIcons: true }), c3 && ts(t3, i3, o3, r4, n3, a3, { onlyText: true })), i3.map.showCollisionBoxes && (Xr(t3, i3, o3, r4, o3.paint.get("text-translate"), o3.paint.get("text-translate-anchor"), true), Xr(t3, i3, o3, r4, o3.paint.get("icon-translate"), o3.paint.get("icon-translate-anchor"), false));
        }, circle: function(t3, i3, o3, r4) {
          if ("translucent" !== t3.renderPass)
            return;
          const s4 = o3.paint.get("circle-opacity"), n3 = o3.paint.get("circle-stroke-width"), a3 = o3.paint.get("circle-stroke-opacity"), l3 = void 0 !== o3.layout.get("circle-sort-key").constantOr(1), c3 = o3.paint.get("circle-emissive-strength");
          if (0 === s4.constantOr(1) && (0 === n3.constantOr(1) || 0 === a3.constantOr(1)))
            return;
          const h2 = t3.context, u3 = h2.gl, d2 = t3.transform, _3 = t3.depthModeForSublayer(0, Ct.ReadOnly), p3 = Dt.disabled, f2 = t3.colorModeForDrapableLayerRenderPass(c3), m2 = "globe" === d2.projection.name, g3 = [e3.a8(d2.center.lng), e3.ah(d2.center.lat)], v3 = [];
          for (let s5 = 0; s5 < r4.length; s5++) {
            const n4 = r4[s5], a4 = i3.getTile(n4), c4 = a4.getBucket(o3);
            if (!c4 || c4.projection.name !== d2.projection.name)
              continue;
            const h3 = c4.programConfigurations.get(o3.id), u4 = e3.cF(o3), _4 = t3.isTileAffectedByFog(n4);
            m2 && u4.push("PROJECTION_GLOBE_VIEW");
            const p4 = t3.getOrCreateProgram("circle", { config: h3, defines: u4, overrideFog: _4 }), f3 = c4.layoutVertexBuffer, x4 = c4.globeExtVertexBuffer, y3 = c4.indexBuffer, b2 = d2.projection.createInversionMatrix(d2, n4.canonical), w2 = { programConfiguration: h3, program: p4, layoutVertexBuffer: f3, globeExtVertexBuffer: x4, indexBuffer: y3, uniformValues: e3.cG(t3, n4, a4, b2, g3, o3), tile: a4 };
            if (l3) {
              const t4 = c4.segments.get();
              for (const i4 of t4)
                v3.push({ segments: new e3.aE([i4]), sortKey: i4.sortKey, state: w2 });
            } else
              v3.push({ segments: c4.segments, sortKey: 0, state: w2 });
          }
          l3 && v3.sort((e4, t4) => e4.sortKey - t4.sortKey);
          const x3 = { useDepthForOcclusion: d2.depthOcclusionForSymbolsAndCircles };
          for (const e4 of v3) {
            const { programConfiguration: i4, program: r5, layoutVertexBuffer: s5, globeExtVertexBuffer: n4, indexBuffer: a4, uniformValues: l4, tile: c4 } = e4.state, m3 = e4.segments;
            t3.terrain && t3.terrain.setupElevationDraw(c4, r5, x3), t3.uploadCommonUniforms(h2, r5, c4.tileID.toUnwrapped()), r5.draw(t3, u3.TRIANGLES, _3, p3, f2, Mt.disabled, l4, o3.id, s5, a4, m3, o3.paint, d2.zoom, i4, [n4]);
          }
        }, heatmap: function(t3, i3, o3, r4) {
          if (0 !== o3.paint.get("heatmap-opacity"))
            if ("offscreen" === t3.renderPass) {
              const s4 = t3.context, n3 = s4.gl, a3 = Dt.disabled, l3 = new At([n3.ONE, n3.ONE, n3.ONE, n3.ONE], e3.aA.transparent, [true, true, true, true]);
              !function(e4, t4, i4, o4) {
                const r5 = e4.gl, s5 = t4.width * o4, n4 = t4.height * o4;
                e4.activeTexture.set(r5.TEXTURE1), e4.viewport.set([0, 0, s5, n4]);
                let a4 = i4.heatmapFbo;
                if (!a4 || a4 && (a4.width !== s5 || a4.height !== n4)) {
                  a4 && a4.destroy();
                  const t5 = r5.createTexture();
                  r5.bindTexture(r5.TEXTURE_2D, t5), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_WRAP_S, r5.CLAMP_TO_EDGE), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_WRAP_T, r5.CLAMP_TO_EDGE), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_MIN_FILTER, r5.LINEAR), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_MAG_FILTER, r5.LINEAR), a4 = i4.heatmapFbo = e4.createFramebuffer(s5, n4, true, null), function(e5, t6, i5, o5, r6, s6) {
                    const n5 = e5.gl;
                    n5.texImage2D(n5.TEXTURE_2D, 0, e5.extRenderToTextureHalfFloat ? n5.RGBA16F : n5.RGBA, r6, s6, 0, n5.RGBA, e5.extRenderToTextureHalfFloat ? n5.HALF_FLOAT : n5.UNSIGNED_BYTE, null), o5.colorAttachment.set(i5);
                  }(e4, 0, t5, a4, s5, n4);
                } else
                  r5.bindTexture(r5.TEXTURE_2D, a4.colorAttachment.get()), e4.bindFramebuffer.set(a4.framebuffer);
              }(s4, t3, o3, "globe" === t3.transform.projection.name ? 0.5 : 0.25), s4.clear({ color: e3.aA.transparent });
              const c3 = t3.transform, h2 = "globe" === c3.projection.name, u3 = h2 ? ["PROJECTION_GLOBE_VIEW"] : [], d2 = h2 ? Mt.frontCCW : Mt.disabled, _3 = [e3.a8(c3.center.lng), e3.ah(c3.center.lat)];
              for (let e4 = 0; e4 < r4.length; e4++) {
                const p3 = r4[e4];
                if (i3.hasRenderableParent(p3))
                  continue;
                const f2 = i3.getTile(p3), m2 = f2.getBucket(o3);
                if (!m2 || m2.projection.name !== c3.projection.name)
                  continue;
                const g3 = t3.isTileAffectedByFog(p3), v3 = m2.programConfigurations.get(o3.id), x3 = t3.getOrCreateProgram("heatmap", { config: v3, defines: u3, overrideFog: g3 }), { zoom: y3 } = t3.transform;
                t3.terrain && t3.terrain.setupElevationDraw(f2, x3), t3.uploadCommonUniforms(s4, x3, p3.toUnwrapped());
                const b2 = c3.projection.createInversionMatrix(c3, p3.canonical);
                x3.draw(t3, n3.TRIANGLES, Ct.disabled, a3, l3, d2, Pr(t3, p3, f2, b2, _3, y3, o3.paint.get("heatmap-intensity")), o3.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, o3.paint, t3.transform.zoom, v3, h2 ? [m2.globeExtVertexBuffer] : null);
              }
              s4.viewport.set([0, 0, t3.width, t3.height]);
            } else
              "translucent" === t3.renderPass && (t3.context.setColorMode(t3.colorModeForRenderPass()), function(t4, i4) {
                const o4 = t4.context, r5 = o4.gl, s4 = i4.heatmapFbo;
                if (!s4)
                  return;
                o4.activeTexture.set(r5.TEXTURE0), r5.bindTexture(r5.TEXTURE_2D, s4.colorAttachment.get()), o4.activeTexture.set(r5.TEXTURE1);
                let n3 = i4.colorRampTexture;
                n3 || (n3 = i4.colorRampTexture = new e3.T(o4, i4.colorRamp, r5.RGBA)), n3.bind(r5.LINEAR, r5.CLAMP_TO_EDGE), t4.getOrCreateProgram("heatmapTexture").draw(t4, r5.TRIANGLES, Ct.disabled, Dt.disabled, t4.colorModeForRenderPass(), Mt.disabled, ((e4, t5, i5, o5) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t5.paint.get("heatmap-opacity") }))(0, i4), i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i4.paint, t4.transform.zoom);
              }(t3, o3));
        }, line: function(t3, i3, o3, r4) {
          if ("translucent" !== t3.renderPass)
            return;
          const s4 = o3.paint.get("line-opacity"), n3 = o3.paint.get("line-width");
          if (0 === s4.constantOr(1) || 0 === n3.constantOr(1))
            return;
          const a3 = o3.paint.get("line-emissive-strength"), l3 = t3.depthModeForSublayer(0, Ct.ReadOnly), c3 = t3.colorModeForDrapableLayerRenderPass(a3), h2 = t3.terrain && t3.terrain.renderingToTexture ? 1 : e3.f.devicePixelRatio, u3 = o3.paint.get("line-dasharray"), d2 = u3.constantOr(1), _3 = o3.layout.get("line-cap"), p3 = o3.paint.get("line-pattern"), f2 = p3.constantOr(1), m2 = 1 !== o3.paint.get("line-opacity").constantOr(1);
          let g3 = !f2 && m2;
          const v3 = o3.paint.get("line-gradient"), x3 = f2 ? "linePattern" : "line", y3 = t3.context, b2 = y3.gl, w2 = e3.cH(o3);
          t3.terrain && t3.terrain.clipOrMaskOverlapStencilType() && (g3 = false);
          for (const s5 of r4) {
            const r5 = i3.getTile(s5);
            if (f2 && !r5.patternsLoaded())
              continue;
            const n4 = r5.getBucket(o3);
            if (!n4)
              continue;
            t3.prepareDrawTile();
            const a4 = n4.programConfigurations.get(o3.id), m3 = t3.isTileAffectedByFog(s5), T2 = t3.getOrCreateProgram(x3, { config: a4, defines: w2, overrideFog: m3 }), E2 = p3.constantOr(null);
            if (E2 && r5.imageAtlas) {
              const e4 = r5.imageAtlas.patternPositions[E2.toString()];
              e4 && a4.setConstantPatternPositions(e4);
            }
            const S2 = u3.constantOr(null), C2 = _3.constantOr(null);
            if (!f2 && S2 && C2 && r5.lineAtlas) {
              const e4 = r5.lineAtlas.getDash(S2, C2);
              e4 && a4.setConstantPatternPositions(e4);
            }
            let [I2, D2] = o3.paint.get("line-trim-offset");
            if ("round" === C2 || "square" === C2) {
              const e4 = 1;
              I2 !== D2 && (0 === I2 && (I2 -= e4), 1 === D2 && (D2 += e4));
            }
            const R3 = t3.terrain ? s5.projMatrix : null, A2 = f2 ? e3.cI(t3, r5, o3, R3, h2, [I2, D2]) : e3.cJ(t3, r5, o3, R3, n4.lineClipsArray.length, h2, [I2, D2]);
            if (v3) {
              const r6 = n4.gradients[o3.id];
              let a5 = r6.texture;
              if (o3.gradientVersion !== r6.version) {
                let l4 = 256;
                if (o3.stepInterpolant) {
                  const o4 = i3.getSource().maxzoom, r7 = s5.canonical.z === o4 ? Math.ceil(1 << t3.transform.maxZoom - s5.canonical.z) : 1;
                  l4 = e3.ad(e3.cK(n4.maxLineLength / e3.Y * 1024 * r7), 256, y3.maxTextureSize);
                }
                r6.gradient = e3.cL({ expression: o3.gradientExpression(), evaluationKey: "lineProgress", resolution: l4, image: r6.gradient || void 0, clips: n4.lineClipsArray }), r6.texture ? r6.texture.update(r6.gradient) : r6.texture = new e3.T(y3, r6.gradient, b2.RGBA), r6.version = o3.gradientVersion, a5 = r6.texture;
              }
              y3.activeTexture.set(b2.TEXTURE1), a5.bind(o3.stepInterpolant ? b2.NEAREST : b2.LINEAR, b2.CLAMP_TO_EDGE);
            }
            d2 && (y3.activeTexture.set(b2.TEXTURE0), r5.lineAtlasTexture && r5.lineAtlasTexture.bind(b2.LINEAR, b2.REPEAT), a4.updatePaintBuffers()), f2 && (y3.activeTexture.set(b2.TEXTURE0), r5.imageAtlasTexture && r5.imageAtlasTexture.bind(b2.LINEAR, b2.CLAMP_TO_EDGE), a4.updatePaintBuffers()), t3.uploadCommonUniforms(y3, T2, s5.toUnwrapped());
            const P2 = (e4) => {
              T2.draw(t3, b2.TRIANGLES, l3, e4, c3, Mt.disabled, A2, o3.id, n4.layoutVertexBuffer, n4.indexBuffer, n4.segments, o3.paint, t3.transform.zoom, a4, [n4.layoutVertexBuffer2, n4.patternVertexBuffer]);
            };
            if (g3) {
              const e4 = t3.stencilModeForClipping(s5).ref;
              0 === e4 && t3.terrain && y3.clear({ stencil: 0 });
              const i4 = { func: b2.EQUAL, mask: 255 };
              A2.u_alpha_discard_threshold = 0.8, P2(new Dt(i4, e4, 255, b2.KEEP, b2.KEEP, b2.INVERT)), A2.u_alpha_discard_threshold = 0, P2(new Dt(i4, e4, 255, b2.KEEP, b2.KEEP, b2.KEEP));
            } else
              P2(t3.stencilModeForClipping(s5));
          }
          g3 && (t3.resetStencilClippingMasks(), t3.terrain && y3.clear({ stencil: 0 }));
        }, fill: function(t3, i3, o3, r4) {
          const s4 = o3.paint.get("fill-color"), n3 = o3.paint.get("fill-opacity");
          if (0 === n3.constantOr(1))
            return;
          const a3 = o3.paint.get("fill-emissive-strength"), l3 = t3.colorModeForDrapableLayerRenderPass(a3), c3 = o3.paint.get("fill-pattern"), h2 = t3.opaquePassEnabledForLayer() && !c3.constantOr(1) && 1 === s4.constantOr(e3.aA.transparent).a && 1 === n3.constantOr(0) ? "opaque" : "translucent";
          if (t3.renderPass === h2) {
            const e4 = t3.depthModeForSublayer(1, "opaque" === t3.renderPass ? Ct.ReadWrite : Ct.ReadOnly);
            os(t3, i3, o3, r4, e4, l3, false);
          }
          if ("translucent" === t3.renderPass && o3.paint.get("fill-antialias")) {
            const e4 = t3.depthModeForSublayer(o3.getPaintProperty("fill-outline-color") ? 2 : 0, Ct.ReadOnly);
            os(t3, i3, o3, r4, e4, l3, true);
          }
        }, "fill-extrusion": function(t3, i3, o3, r4) {
          const s4 = o3.paint.get("fill-extrusion-opacity"), n3 = t3.context, a3 = n3.gl, l3 = t3.terrain, c3 = l3 && l3.renderingToTexture;
          if (0 === s4)
            return;
          const h2 = t3.conflationActive && t3.layerUsedInConflation(o3, i3.getSource());
          if (h2 && function(e4, t4, i4, o4) {
            for (const r5 of o4) {
              const o5 = t4.getTile(r5).getBucket(i4);
              o5 && (o5.updateReplacement(r5, e4.replacementSource), o5.uploadCentroid(e4.context));
            }
          }(t3, i3, o3, r4), l3 || h2)
            for (const e4 of r4) {
              const r5 = i3.getTile(e4).getBucket(o3);
              r5 && ns(t3.context, i3, e4, r5, o3, l3, h2);
            }
          if ("shadow" === t3.renderPass && t3.shadowRenderer) {
            const n4 = t3.shadowRenderer;
            if (l3 && s4 < 0.65 && o3._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e3.Z)
              return;
            const a4 = n4.getShadowPassDepthMode(), c4 = n4.getShadowPassColorMode();
            rs(t3, i3, o3, r4, a4, Dt.disabled, c4, h2);
          } else if ("translucent" === t3.renderPass) {
            const u3 = !o3.paint.get("fill-extrusion-pattern").constantOr(1), d2 = o3.paint.get("fill-extrusion-color").constantOr(e3.aA.white);
            if (!c3 && 0 !== d2.a) {
              const e4 = new Ct(t3.context.gl.LEQUAL, Ct.ReadWrite, t3.depthRangeFor3D);
              1 === s4 && u3 ? rs(t3, i3, o3, r4, e4, Dt.disabled, At.unblended, h2) : (rs(t3, i3, o3, r4, e4, Dt.disabled, At.disabled, h2), rs(t3, i3, o3, r4, e4, t3.stencilModeFor3D(), t3.colorModeForRenderPass(), h2), t3.resetStencilClippingMasks());
            }
            if (t3.style.enable3dLights() && u3 && (!l3 && "globe" !== t3.transform.projection.name || c3)) {
              const s5 = o3.paint.get("fill-extrusion-opacity"), u4 = o3.paint.get("fill-extrusion-ambient-occlusion-intensity"), d3 = o3.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _3 = o3.paint.get("fill-extrusion-flood-light-intensity"), p3 = o3.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), f2 = u4 > 0 && d3 > 0, m2 = _3 > 0, g3 = (e4, t4, i4) => (1 - i4) * e4 + i4 * t4, v3 = (n4) => {
                const l4 = t3.depthModeForSublayer(1, Ct.ReadOnly, a3.LEQUAL, true), c4 = o3.paint.get(n4 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), f3 = g3(0.1, 3, c4), m3 = t3._showOverdrawInspector;
                if (!m3) {
                  const c5 = new Dt({ func: a3.ALWAYS, mask: 255 }, 255, 255, a3.KEEP, a3.KEEP, a3.REPLACE), m4 = new At([a3.ONE, a3.ONE, a3.ONE, a3.ONE], e3.aA.transparent, [false, false, false, true], a3.MIN);
                  ss(t3, i3, o3, r4, l4, c5, m4, Mt.disabled, n4, "sdf", s5, u4, d3, _3, p3, f3, h2, false);
                }
                {
                  const c5 = m3 ? Dt.disabled : new Dt({ func: a3.EQUAL, mask: 255 }, 255, 255, a3.KEEP, a3.DECR, a3.DECR), g4 = m3 ? t3.colorModeForRenderPass() : new At([a3.ONE_MINUS_DST_ALPHA, a3.DST_ALPHA, a3.ONE, a3.ONE], e3.aA.transparent, [true, true, true, true]);
                  ss(t3, i3, o3, r4, l4, c5, g4, Mt.disabled, n4, "color", s5, u4, d3, _3, p3, f3, h2, false);
                }
              };
              if (c3) {
                const c4 = (n4, l4, c5) => {
                  const f3 = t3.depthModeForSublayer(1, Ct.ReadOnly, a3.LEQUAL, false), m3 = o3.paint.get(n4 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), v4 = g3(0.1, 3, m3);
                  {
                    const c6 = new At([a3.ONE, a3.ONE, a3.ONE, a3.ONE], e3.aA.transparent, [false, false, false, true]);
                    ss(t3, i3, o3, r4, f3, Dt.disabled, c6, Mt.disabled, n4, "clear", s5, u4, d3, _3, p3, v4, h2, l4);
                  }
                  {
                    const c6 = new Dt({ func: a3.ALWAYS, mask: 255 }, 255, 255, a3.KEEP, a3.KEEP, a3.REPLACE), m4 = new At([a3.ONE, a3.ONE, a3.ONE, a3.ONE], e3.aA.transparent, [false, false, false, true], a3.MIN);
                    ss(t3, i3, o3, r4, f3, c6, m4, Mt.disabled, n4, "sdf", s5, u4, d3, _3, p3, v4, h2, l4);
                  }
                  {
                    const c6 = n4 ? a3.ZERO : a3.ONE_MINUS_DST_ALPHA, m4 = new Dt({ func: a3.EQUAL, mask: 255 }, 255, 255, a3.KEEP, a3.DECR, a3.DECR), g4 = new At([c6, a3.DST_ALPHA, a3.ONE_MINUS_DST_ALPHA, a3.ZERO], e3.aA.transparent, [true, true, true, true]);
                    ss(t3, i3, o3, r4, f3, m4, g4, Mt.disabled, n4, "color", s5, u4, d3, _3, p3, v4, h2, l4);
                  }
                  {
                    const m4 = new At([a3.ONE, a3.ONE, a3.ONE, n4 ? a3.ZERO : a3.ONE], e3.aA.transparent, [false, false, false, true], n4 ? a3.FUNC_ADD : a3.MAX);
                    ss(t3, i3, o3, r4, f3, Dt.disabled, m4, Mt.disabled, n4, "clear", s5, u4, d3, _3, p3, v4, h2, l4, c5);
                  }
                };
                if (f2 || m2) {
                  let i4;
                  if (t3.prepareDrawTile(), l3) {
                    const t4 = l3.drapeBufferSize[0], o4 = l3.drapeBufferSize[1];
                    i4 = l3.framebufferCopyTexture, i4 && (!i4 || i4.size[0] === t4 && i4.size[1] === o4) || (i4 && i4.destroy(), i4 = l3.framebufferCopyTexture = new e3.T(n3, new e3.h({ width: t4, height: o4 }), a3.RGBA)), i4.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), a3.copyTexImage2D(a3.TEXTURE_2D, 0, a3.RGBA, 0, 0, t4, o4, 0);
                  }
                  f2 && c4(true, false, i4), m2 && c4(false, true, i4);
                }
              } else
                f2 && v3(true), m2 && v3(false);
            }
          }
        }, hillshade: function(e4, t3, i3, o3) {
          if ("offscreen" !== e4.renderPass && "translucent" !== e4.renderPass)
            return;
          if (e4.style.disableElevatedTerrain)
            return;
          const r4 = e4.context, s4 = e4.terrain && e4.terrain.renderingToTexture, [n3, a3] = "translucent" !== e4.renderPass || s4 ? [{}, o3] : e4.stencilConfigForOverlap(o3);
          for (const o4 of a3) {
            const r5 = t3.getTile(o4);
            if (r5.needsHillshadePrepare && "offscreen" === e4.renderPass)
              er(e4, r5, i3);
            else if ("translucent" === e4.renderPass) {
              const t4 = e4.depthModeForSublayer(0, Ct.ReadOnly), a4 = i3.paint.get("hillshade-emissive-strength"), l3 = e4.colorModeForDrapableLayerRenderPass(a4), c3 = s4 && e4.terrain ? e4.terrain.stencilModeForRTTOverlap(o4) : n3[o4.overscaledZ];
              Jo(e4, o4, r5, i3, t4, c3, l3);
            }
          }
          r4.viewport.set([0, 0, e4.width, e4.height]), e4.resetStencilClippingMasks();
        }, raster: function(t3, i3, o3, r4, s4, n3) {
          if ("translucent" !== t3.renderPass)
            return;
          if (0 === o3.paint.get("raster-opacity"))
            return;
          const a3 = "globe" === t3.transform.projection.name, l3 = 0 !== o3.paint.get("raster-elevation"), c3 = l3 && a3;
          if (t3.renderElevatedRasterBackface && !c3)
            return;
          const h2 = t3.context, u3 = h2.gl, d2 = i3.getSource(), _3 = function(t4, i4, o4, r5) {
            const s5 = i4.paint.get("raster-color"), n4 = "raster-array" === t4.type, a4 = [], l4 = i4.paint.get("raster-resampling"), c4 = i4.paint.get("raster-color-mix");
            let h3 = i4.paint.get("raster-color-range");
            const u4 = [c4[0], c4[1], c4[2], 0], d3 = c4[3];
            let _4 = "nearest" === l4 ? r5.NEAREST : r5.LINEAR;
            if (n4 && (a4.push("RASTER_ARRAY"), s5 || a4.push("RASTER_COLOR"), "linear" === l4 && a4.push("RASTER_ARRAY_LINEAR"), _4 = r5.NEAREST, !h3 && t4.rasterLayers)) {
              const e4 = t4.rasterLayers.find(({ id: e5 }) => e5 === i4.sourceLayer);
              e4 && e4.fields && e4.fields.range && (h3 = e4.fields.range);
            }
            if (h3 = h3 || [0, 1], s5) {
              a4.push("RASTER_COLOR"), o4.activeTexture.set(r5.TEXTURE2), i4.updateColorRamp(h3);
              let t5 = i4.colorRampTexture;
              t5 || (t5 = i4.colorRampTexture = new e3.T(o4, i4.colorRamp, r5.RGBA)), t5.bind(r5.LINEAR, r5.CLAMP_TO_EDGE);
            }
            return { mix: u4, range: h3, offset: d3, defines: a4, resampling: _4 };
          }(d2, o3, h2, u3);
          if (d2 instanceof e3.as && !r4.length && !a3)
            return;
          const p3 = o3.paint.get("raster-emissive-strength"), f2 = t3.colorModeForDrapableLayerRenderPass(p3), m2 = t3.terrain && t3.terrain.renderingToTexture, g3 = !t3.options.moving, v3 = "nearest" === o3.paint.get("raster-resampling") ? u3.NEAREST : u3.LINEAR;
          if (d2 instanceof e3.as && !r4.length && (d2.onNorthPole || d2.onSouthPole)) {
            const e4 = l3 ? t3.stencilModeFor3D() : Dt.disabled;
            return void ds(!!d2.onNorthPole, null, t3, i3, o3, p3, _3, Mt.disabled, e4);
          }
          if (!r4.length)
            return;
          const [x3, y3] = d2 instanceof e3.as || m2 ? [{}, r4] : t3.stencilConfigForOverlap(r4), b2 = y3[y3.length - 1].overscaledZ;
          c3 && _3.defines.push("PROJECTION_GLOBE_VIEW"), l3 && _3.defines.push("RENDER_CUTOFF");
          const w2 = (r5, s5, y4) => {
            for (const w3 of r5) {
              const r6 = w3.toUnwrapped(), T2 = i3.getTile(w3);
              if (m2 && (!T2 || !T2.hasData()))
                continue;
              h2.activeTexture.set(u3.TEXTURE0);
              const E2 = ps(T2, d2, o3, _3);
              if (!E2 || !E2.texture)
                continue;
              const { texture: S2, mix: C2, offset: I2, tileSize: D2, buffer: R3 } = E2;
              let A2, P2;
              m2 ? (A2 = Ct.disabled, P2 = w3.projMatrix) : l3 ? (A2 = new Ct(u3.LEQUAL, Ct.ReadWrite, t3.depthRangeFor3D), P2 = a3 ? Float32Array.from(t3.transform.expandedFarZProjMatrix) : t3.transform.calculateProjMatrix(r6, g3)) : (A2 = t3.depthModeForSublayer(w3.overscaledZ - b2, 1 === o3.paint.get("raster-opacity") ? Ct.ReadWrite : Ct.ReadOnly, u3.LESS), P2 = t3.transform.calculateProjMatrix(r6, g3));
              const L2 = t3.terrain && m2 ? t3.terrain.stencilModeForRTTOverlap(w3) : x3[w3.overscaledZ], M3 = n3 ? 0 : o3.paint.get("raster-fade-duration");
              T2.registerFadeDuration(M3);
              const z3 = i3.findLoadedParent(w3, 0), O2 = hr(T2, z3, i3, t3.transform, M3);
              let F2, B2;
              t3.terrain && t3.terrain.prepareDrawTile(), h2.activeTexture.set(u3.TEXTURE0), S2.bind(v3, u3.CLAMP_TO_EDGE), h2.activeTexture.set(u3.TEXTURE1), z3 ? (z3.texture && z3.texture.bind(v3, u3.CLAMP_TO_EDGE), F2 = Math.pow(2, z3.tileID.overscaledZ - T2.tileID.overscaledZ), B2 = [T2.tileID.canonical.x * F2 % 1, T2.tileID.canonical.y * F2 % 1]) : S2.bind(v3, u3.CLAMP_TO_EDGE), S2.useMipmap && h2.extTextureFilterAnisotropic && t3.transform.pitch > 20 && u3.texParameterf(u3.TEXTURE_2D, h2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h2.extTextureFilterAnisotropicMax);
              const k2 = t3.transform;
              let N2;
              const U2 = l3 ? _s(k2) : [0, 0, 0, 0];
              let G2, j3, V2, Z3, W2, H2 = 0;
              if (c3 && d2 instanceof e3.as && d2.coordinates.length > 3)
                G2 = Float32Array.from(e3.aW(e3.cn(new e3.bv(0, 0, 0)))), j3 = Float32Array.from(k2.globeMatrix), V2 = Float32Array.from(e3.cj(k2)), Z3 = [e3.a8(k2.center.lng), e3.ah(k2.center.lat)], N2 = d2.elevatedGlobePerspectiveTransform, W2 = d2.elevatedGlobeGridMatrix || new Float32Array(9);
              else if (c3) {
                const t4 = e3.ck(w3.canonical);
                H2 = e3.cl(t4.getCenter().lat), G2 = Float32Array.from(e3.aW(e3.cn(w3.canonical))), j3 = Float32Array.from(k2.globeMatrix), V2 = Float32Array.from(e3.cj(k2)), Z3 = [e3.a8(k2.center.lng), e3.ah(k2.center.lat)], N2 = [0, 0], W2 = Float32Array.from(e3.cm(w3.canonical, t4, H2, k2.worldSize / k2._pixelsPerMercatorPixel));
              } else
                N2 = d2 instanceof e3.as ? d2.perspectiveTransform : [0, 0], G2 = new Float32Array(16), j3 = new Float32Array(9), V2 = new Float32Array(16), Z3 = [0, 0], W2 = new Float32Array(9);
              const q3 = zr(P2, G2, j3, V2, W2, B2 || [0, 0], e3.W(t3.transform.zoom), Z3, U2, F2 || 1, O2, o3, N2, l3 ? o3.paint.get("raster-elevation") : 0, 2, C2, I2, _3.range, D2, R3, p3), Q2 = t3.isTileAffectedByFog(w3), $2 = t3.getOrCreateProgram("raster", { defines: _3.defines, overrideFog: Q2 });
              if (t3.uploadCommonUniforms(h2, $2, r6), d2 instanceof e3.as) {
                const i4 = d2.elevatedGlobeVertexBuffer, r7 = d2.elevatedGlobeIndexBuffer;
                if (m2 || !a3)
                  d2.boundsBuffer && d2.boundsSegments && $2.draw(t3, u3.TRIANGLES, A2, Dt.disabled, f2, Mt.disabled, q3, o3.id, d2.boundsBuffer, t3.quadTriangleIndexBuffer, d2.boundsSegments);
                else if (i4 && r7) {
                  const n4 = k2.zoom <= e3.bJ ? d2.elevatedGlobeSegments : d2.getSegmentsForLongitude(k2.center.lng);
                  n4 && $2.draw(t3, u3.TRIANGLES, A2, Dt.disabled, f2, s5, q3, o3.id, i4, r7, n4);
                }
              } else if (c3) {
                A2 = new Ct(u3.LEQUAL, Ct.ReadOnly, t3.depthRangeFor3D);
                const e4 = t3.globeSharedBuffers;
                if (e4) {
                  const [i4, r7, n4] = e4.getGridBuffers(H2, false);
                  $2.draw(t3, u3.TRIANGLES, A2, y4 || L2, t3.colorModeForRenderPass(), s5, q3, o3.id, i4, r7, n4);
                }
              } else {
                const { tileBoundsBuffer: e4, tileBoundsIndexBuffer: i4, tileBoundsSegments: r7 } = t3.getTileBoundsBuffers(T2);
                $2.draw(t3, u3.TRIANGLES, A2, L2, f2, Mt.disabled, q3, o3.id, e4, i4, r7);
              }
            }
            if (!(d2 instanceof e3.as) && c3)
              for (const e4 of r5) {
                const r6 = e4.canonical.y === (1 << e4.canonical.z) - 1;
                0 === e4.canonical.y && ds(true, e4, t3, i3, o3, p3, _3, s5, y4 || Dt.disabled), r6 && ds(false, e4, t3, i3, o3, p3, _3, s5 === Mt.frontCW ? Mt.backCW : Mt.frontCW, y4 || Dt.disabled);
              }
          };
          c3 ? w2(y3, t3.renderElevatedRasterBackface ? Mt.backCW : Mt.frontCW, t3.stencilModeFor3D()) : w2(y3, Mt.disabled, void 0), t3.resetStencilClippingMasks();
        }, "raster-particle": function(t3, i3, o3, r4, s4, n3) {
          "offscreen" === t3.renderPass && function(t4, i4, o4, r5) {
            if (!r5.length)
              return;
            const s5 = t4.context, n4 = s5.gl, a3 = i4.getSource();
            if (!(a3 instanceof Pe))
              return;
            const l3 = Math.ceil(Math.sqrt(o4.paint.get("raster-particle-count")));
            let c3 = o4.particleFramebuffer;
            c3 ? c3.width !== l3 && (c3.destroy(), c3 = o4.particleFramebuffer = s5.createFramebuffer(l3, l3, true, null)) : c3 = o4.particleFramebuffer = s5.createFramebuffer(l3, l3, true, null);
            const h2 = [];
            for (const e4 of r5) {
              const t5 = i4.getTile(e4);
              if (!(t5 instanceof Ht))
                continue;
              const r6 = fs(t5, a3, o4);
              if (!r6)
                continue;
              const n5 = [t5.tileSize, t5.tileSize];
              let c4 = o4.tileFramebuffer;
              c4 || (c4 = o4.tileFramebuffer = s5.createFramebuffer(n5[0], n5[1], true, null));
              let u4 = t5.rasterParticleState;
              u4 || (u4 = t5.rasterParticleState = new Bt(s5, e4, n5, l3));
              const d3 = u4.update(o4.lastInvalidatedAt);
              u4.particleTextureDimension !== l3 && u4.setParticleTextureDimension(e4, l3);
              const _3 = u4.targetColorTexture;
              u4.targetColorTexture = u4.backgroundColorTexture, u4.backgroundColorTexture = _3;
              const p3 = u4.particleTexture0;
              u4.particleTexture0 = u4.particleTexture1, u4.particleTexture1 = p3, h2.push([e4, r6, u4, d3]);
            }
            if (0 === h2.length)
              return;
            const u3 = e3.f.now(), d2 = o4.previousDrawTimestamp ? 1e-3 * (u3 - o4.previousDrawTimestamp) : 0.0167;
            if (o4.previousDrawTimestamp = u3, o4.hasColorMap()) {
              s5.activeTexture.set(n4.TEXTURE0 + 2);
              let t5 = o4.colorRampTexture;
              t5 || (t5 = o4.colorRampTexture = new e3.T(s5, o4.colorRamp, n4.RGBA)), t5.bind(n4.LINEAR, n4.CLAMP_TO_EDGE);
            }
            s5.bindFramebuffer.set(o4.tileFramebuffer.framebuffer), function(t5, i5, o5) {
              const r6 = t5.context, s6 = r6.gl, n5 = i5.tileFramebuffer;
              r6.activeTexture.set(s6.TEXTURE0);
              const a4 = { u_texture: 0, u_opacity: 1.05 * (c4 = i5.paint.get("raster-particle-fade-opacity-factor")) / (c4 + 0.05) }, l4 = t5.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: false });
              var c4;
              for (const c5 of o5) {
                const [, , o6, h3] = c5;
                n5.colorAttachment.set(o6.targetColorTexture.texture), r6.viewport.set([0, 0, n5.width, n5.height]), r6.clear({ color: e3.aA.transparent }), h3 && (o6.backgroundColorTexture.bind(s6.NEAREST, s6.CLAMP_TO_EDGE), l4.draw(t5, s6.TRIANGLES, Ct.disabled, Dt.disabled, At.alphaBlended, Mt.disabled, a4, i5.id, t5.viewportBuffer, t5.quadTriangleIndexBuffer, t5.viewportSegments));
              }
            }(t4, o4, h2), function(t5, i5, o5, r6) {
              const s6 = t5.context, n5 = s6.gl, a4 = o5.tileFramebuffer, l4 = "globe" === t5.transform.projection.name, c4 = o5.paint.get("raster-particle-max-speed");
              for (const h3 of r6) {
                const [r7, u4, d3] = h3;
                s6.activeTexture.set(n5.TEXTURE0 + 0), u4.texture.bind(n5.LINEAR, n5.CLAMP_TO_EDGE), a4.colorAttachment.set(d3.targetColorTexture.texture);
                const _3 = t5.getOrCreateProgram("rasterParticleDraw", { defines: u4.defines, overrideFog: false });
                s6.activeTexture.set(n5.TEXTURE0 + 1);
                const p3 = u4.scalarData ? [] : [0, 1, 2, 3].map((t6) => e3.cN[t6](r7));
                p3.push(r7);
                const f2 = r7.canonical.x, m2 = r7.canonical.y;
                for (const e4 of p3) {
                  const s7 = i5.getTile(l4 ? e4.wrapped() : e4);
                  if (!s7)
                    continue;
                  const a5 = s7.rasterParticleState;
                  if (!a5)
                    continue;
                  const h4 = e4.canonical.x + (1 << e4.canonical.z) * (e4.wrap - r7.wrap), d4 = e4.canonical.y;
                  a5.particleTexture0.bind(n5.NEAREST, n5.CLAMP_TO_EDGE);
                  const p4 = Br(1, a5.particleTexture0.size[0], [h4 - f2, d4 - m2], 0, u4.texture.size, 2, c4, u4.textureOffset, u4.scale, u4.offset);
                  _3.draw(t5, n5.POINTS, Ct.disabled, Dt.disabled, At.alphaBlended, Mt.disabled, p4, o5.id, a5.particleIndexBuffer, void 0, a5.particleSegment);
                }
              }
            }(t4, i4, o4, h2), s5.bindFramebuffer.set(o4.particleFramebuffer.framebuffer), function(t5, i5, o5, r6) {
              const s6 = t5.context, n5 = s6.gl, a4 = i5.paint.get("raster-particle-max-speed"), l4 = r6 * i5.paint.get("raster-particle-speed-factor") * 0.3, c4 = function(e4) {
                return Math.pow(e4, 6);
              }(0.01 + 1 * i5.paint.get("raster-particle-reset-rate-factor")), h3 = i5.particleFramebuffer;
              s6.viewport.set([0, 0, h3.width, h3.height]);
              for (const r7 of o5) {
                const [, o6, u4] = r7;
                s6.activeTexture.set(n5.TEXTURE0 + 0), o6.texture.bind(n5.LINEAR, n5.CLAMP_TO_EDGE), s6.activeTexture.set(n5.TEXTURE0 + 1);
                const d3 = u4.particleTexture0;
                d3.bind(n5.NEAREST, n5.CLAMP_TO_EDGE);
                const _3 = kr(1, d3.size[0], 0, o6.texture.size, a4, l4, c4, o6.textureOffset, o6.scale, o6.offset);
                h3.colorAttachment.set(u4.particleTexture1.texture), s6.clear({ color: e3.aA.transparent }), t5.getOrCreateProgram("rasterParticleUpdate", { defines: o6.defines }).draw(t5, n5.TRIANGLES, Ct.disabled, Dt.disabled, At.unblended, Mt.disabled, _3, i5.id, t5.viewportBuffer, t5.quadTriangleIndexBuffer, t5.viewportSegments);
              }
            }(t4, o4, h2, d2);
          }(t3, i3, o3, r4), "translucent" === t3.renderPass && (function(t4, i4, o4, r5, s5) {
            const n4 = t4.context, a3 = n4.gl, l3 = !t4.options.moving, c3 = "globe" === t4.transform.projection.name;
            if (!r5.length)
              return;
            const [h2, u3] = t4.stencilConfigForOverlap(r5), d2 = [];
            c3 && d2.push("PROJECTION_GLOBE_VIEW");
            const _3 = t4.stencilModeFor3D();
            for (const r6 of u3) {
              const s6 = r6.toUnwrapped(), u4 = i4.getTile(r6);
              if (!u4.rasterParticleState)
                continue;
              const p3 = u4.rasterParticleState, f2 = 100;
              u4.registerFadeDuration(f2);
              const m2 = i4.findLoadedParent(r6, 0), g3 = hr(u4, m2, i4, t4.transform, f2);
              let v3, x3;
              t4.terrain && t4.terrain.prepareDrawTile(), n4.activeTexture.set(a3.TEXTURE0), p3.targetColorTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), n4.activeTexture.set(a3.TEXTURE1), m2 && m2.rasterParticleState ? (m2.rasterParticleState.targetColorTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), v3 = Math.pow(2, m2.tileID.overscaledZ - u4.tileID.overscaledZ), x3 = [u4.tileID.canonical.x * v3 % 1, u4.tileID.canonical.y * v3 % 1]) : p3.targetColorTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
              const y3 = c3 ? Float32Array.from(t4.transform.expandedFarZProjMatrix) : t4.transform.calculateProjMatrix(s6, l3), b2 = t4.transform, w2 = ms(b2), T2 = e3.ck(r6.canonical), E2 = e3.cl(T2.getCenter().lat);
              let S2, C2, I2, D2, R3;
              c3 ? (S2 = Float32Array.from(e3.aW(e3.cn(r6.canonical))), C2 = Float32Array.from(b2.globeMatrix), I2 = Float32Array.from(e3.cj(b2)), D2 = [e3.a8(b2.center.lng), e3.ah(b2.center.lat)], R3 = Float32Array.from(e3.cm(r6.canonical, T2, E2, b2.worldSize / b2._pixelsPerMercatorPixel))) : (S2 = new Float32Array(16), C2 = new Float32Array(9), I2 = new Float32Array(16), D2 = [0, 0], R3 = new Float32Array(9));
              const A2 = Fr(y3, S2, C2, I2, R3, x3 || [0, 0], e3.W(t4.transform.zoom), D2, w2, v3 || 1, g3, 250), P2 = t4.isTileAffectedByFog(r6), L2 = t4.getOrCreateProgram("rasterParticle", { defines: d2, overrideFog: P2 });
              if (t4.uploadCommonUniforms(n4, L2, s6), c3) {
                const e4 = new Ct(a3.LEQUAL, Ct.ReadWrite, t4.depthRangeFor3D), i5 = 0, r7 = t4.globeSharedBuffers;
                if (r7) {
                  const [s7, n5, l4] = r7.getGridBuffers(E2, 0 !== i5);
                  L2.draw(t4, a3.TRIANGLES, e4, _3, At.alphaBlended, Mt.backCCW, A2, o4.id, s7, n5, l4);
                }
              } else {
                const e4 = t4.depthModeForSublayer(0, Ct.ReadOnly), i5 = h2[r6.overscaledZ], { tileBoundsBuffer: s7, tileBoundsIndexBuffer: n5, tileBoundsSegments: l4 } = t4.getTileBoundsBuffers(u4);
                L2.draw(t4, a3.TRIANGLES, e4, i5, At.alphaBlended, Mt.disabled, A2, o4.id, s7, n5, l4);
              }
            }
            t4.resetStencilClippingMasks();
          }(t3, i3, o3, r4), t3.style.map.triggerRepaint());
        }, background: function(e4, t3, i3, o3) {
          const r4 = i3.paint.get("background-color"), s4 = i3.paint.get("background-opacity"), n3 = i3.paint.get("background-emissive-strength");
          if (0 === s4)
            return;
          const a3 = e4.context, l3 = a3.gl, c3 = e4.transform, h2 = c3.tileSize, u3 = i3.paint.get("background-pattern");
          if (e4.isPatternMissing(u3, i3.scope))
            return;
          const d2 = !u3 && 1 === r4.a && 1 === s4 && e4.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (e4.renderPass !== d2)
            return;
          const _3 = Dt.disabled, p3 = e4.depthModeForSublayer(0, "opaque" === d2 ? Ct.ReadWrite : Ct.ReadOnly), f2 = e4.colorModeForDrapableLayerRenderPass(n3), m2 = u3 ? "backgroundPattern" : "background";
          let g3, v3 = o3;
          v3 || (g3 = e4.getBackgroundTiles(), v3 = Object.values(g3).map((e5) => e5.tileID)), u3 && (a3.activeTexture.set(l3.TEXTURE0), e4.imageManager.bind(e4.context, i3.scope));
          for (const d3 of v3) {
            const v4 = e4.isTileAffectedByFog(d3), x3 = e4.getOrCreateProgram(m2, { overrideFog: v4 }), y3 = d3.toUnwrapped(), b2 = o3 ? d3.projMatrix : e4.transform.calculateProjMatrix(y3);
            e4.prepareDrawTile();
            const w2 = t3 ? t3.getTile(d3) : g3 ? g3[d3.key] : new Nt(d3, h2, c3.zoom, e4), T2 = u3 ? Zr(b2, n3, s4, e4, u3, i3.scope, { tileID: d3, tileSize: h2 }) : Vr(b2, n3, s4, r4);
            e4.uploadCommonUniforms(a3, x3, y3);
            const { tileBoundsBuffer: E2, tileBoundsIndexBuffer: S2, tileBoundsSegments: C2 } = e4.getTileBoundsBuffers(w2);
            x3.draw(e4, l3.TRIANGLES, p3, _3, f2, Mt.disabled, T2, i3.id, E2, S2, C2);
          }
        }, sky: function(t3, i3, o3) {
          const r4 = t3._atmosphere ? e3.W(t3.transform.zoom) : 1, s4 = o3.paint.get("sky-opacity") * r4;
          if (0 === s4)
            return;
          const n3 = t3.context, a3 = o3.paint.get("sky-type"), l3 = new Ct(n3.gl.LEQUAL, Ct.ReadOnly, [0, 1]), c3 = t3.frameCounter / 1e3 % 1;
          "atmosphere" === a3 ? "offscreen" === t3.renderPass ? o3.needsSkyboxCapture(t3) && (function(t4, i4, o4, r5) {
            const s5 = t4.context, n4 = s5.gl;
            let a4 = i4.skyboxFbo;
            if (!a4) {
              a4 = i4.skyboxFbo = s5.createFramebuffer(32, 32, true, null), i4.skyboxGeometry = new Rs(s5), i4.skyboxTexture = s5.gl.createTexture(), n4.bindTexture(n4.TEXTURE_CUBE_MAP, i4.skyboxTexture), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_WRAP_S, n4.CLAMP_TO_EDGE), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_WRAP_T, n4.CLAMP_TO_EDGE), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_MIN_FILTER, n4.LINEAR), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_MAG_FILTER, n4.LINEAR);
              for (let e4 = 0; e4 < 6; ++e4)
                n4.texImage2D(n4.TEXTURE_CUBE_MAP_POSITIVE_X + e4, 0, n4.RGBA, 32, 32, 0, n4.RGBA, n4.UNSIGNED_BYTE, null);
            }
            s5.bindFramebuffer.set(a4.framebuffer), s5.viewport.set([0, 0, 32, 32]);
            const l4 = i4.getCenter(t4, true), c4 = t4.getOrCreateProgram("skyboxCapture"), h2 = new Float64Array(16);
            e3.a9.identity(h2), e3.a9.rotateY(h2, h2, 0.5 * -Math.PI), As(t4, i4, c4, h2, l4, 0), e3.a9.identity(h2), e3.a9.rotateY(h2, h2, 0.5 * Math.PI), As(t4, i4, c4, h2, l4, 1), e3.a9.identity(h2), e3.a9.rotateX(h2, h2, 0.5 * -Math.PI), As(t4, i4, c4, h2, l4, 2), e3.a9.identity(h2), e3.a9.rotateX(h2, h2, 0.5 * Math.PI), As(t4, i4, c4, h2, l4, 3), e3.a9.identity(h2), As(t4, i4, c4, h2, l4, 4), e3.a9.identity(h2), e3.a9.rotateY(h2, h2, Math.PI), As(t4, i4, c4, h2, l4, 5), s5.viewport.set([0, 0, t4.width, t4.height]);
          }(t3, o3), o3.markSkyboxValid(t3)) : "sky" === t3.renderPass && function(e4, t4, i4, o4, r5) {
            const s5 = e4.context, n4 = s5.gl, a4 = e4.transform, l4 = e4.getOrCreateProgram("skybox");
            s5.activeTexture.set(n4.TEXTURE0), n4.bindTexture(n4.TEXTURE_CUBE_MAP, t4.skyboxTexture);
            const c4 = /* @__PURE__ */ ((e5, t5, i5, o5, r6) => ({ u_matrix: e5, u_sun_direction: t5, u_cubemap: 0, u_opacity: o5, u_temporal_offset: r6 }))(a4.skyboxMatrix, t4.getCenter(e4, false), 0, o4, r5);
            e4.uploadCommonUniforms(s5, l4), l4.draw(e4, n4.TRIANGLES, i4, Dt.disabled, e4.colorModeForRenderPass(), Mt.backCW, c4, "skybox", t4.skyboxGeometry.vertexBuffer, t4.skyboxGeometry.indexBuffer, t4.skyboxGeometry.segment);
          }(t3, o3, l3, s4, c3) : "gradient" === a3 && "sky" === t3.renderPass && function(t4, i4, o4, r5, s5) {
            const n4 = t4.context, a4 = n4.gl, l4 = t4.transform, c4 = t4.getOrCreateProgram("skyboxGradient");
            i4.skyboxGeometry || (i4.skyboxGeometry = new Rs(n4)), n4.activeTexture.set(a4.TEXTURE0);
            let h2 = i4.colorRampTexture;
            h2 || (h2 = i4.colorRampTexture = new e3.T(n4, i4.colorRamp, a4.RGBA)), h2.bind(a4.LINEAR, a4.CLAMP_TO_EDGE);
            const u3 = ((t5, i5, o5, r6, s6) => ({ u_matrix: t5, u_color_ramp: 0, u_center_direction: i5, u_radius: e3.bm(o5), u_opacity: r6, u_temporal_offset: s6 }))(l4.skyboxMatrix, i4.getCenter(t4, false), i4.paint.get("sky-gradient-radius"), r5, s5);
            t4.uploadCommonUniforms(n4, c4), c4.draw(t4, a4.TRIANGLES, o4, Dt.disabled, t4.colorModeForRenderPass(), Mt.backCW, u3, "skyboxGradient", i4.skyboxGeometry.vertexBuffer, i4.skyboxGeometry.indexBuffer, i4.skyboxGeometry.segment);
          }(t3, o3, l3, s4, c3);
        }, debug: function(t3, i3, o3, r4, s4, n3) {
          for (let a3 = 0; a3 < o3.length; a3++)
            if (s4) {
              const s5 = 1, l3 = 0.8, c3 = new e3.aA(r4.r * l3, r4.g * l3, r4.b * l3, 1);
              ws(t3, i3, o3[a3], r4, -s5, -s5, n3), ws(t3, i3, o3[a3], r4, -s5, s5, n3), ws(t3, i3, o3[a3], r4, s5, s5, n3), ws(t3, i3, o3[a3], r4, s5, -s5, n3), ws(t3, i3, o3[a3], c3, 0, 0, n3);
            } else
              ws(t3, i3, o3[a3], r4, 0, 0, n3);
        }, custom: function(t3, i3, o3, r4) {
          const s4 = t3.context, n3 = o3.implementation;
          if (!t3.transform.projection.unsupportedLayers || !t3.transform.projection.unsupportedLayers.includes("custom") || t3.terrain && (t3.terrain.renderingToTexture || "offscreen" === t3.renderPass) && o3.isDraped(i3)) {
            if ("offscreen" === t3.renderPass) {
              const i4 = n3.prerender;
              if (i4) {
                if (t3.setCustomLayerDefaults(), s4.setColorMode(t3.colorModeForRenderPass()), "globe" === t3.transform.projection.name) {
                  const o4 = t3.transform.pointMerc;
                  i4.call(n3, s4.gl, t3.transform.customLayerMatrix(), t3.transform.getProjection(), t3.transform.globeToMercatorMatrix(), e3.W(t3.transform.zoom), [o4.x, o4.y], t3.transform.pixelsPerMeterRatio);
                } else
                  i4.call(n3, s4.gl, t3.transform.customLayerMatrix());
                s4.setDirty(), t3.setBaseState();
              }
            } else if ("translucent" === t3.renderPass) {
              if (t3.terrain && t3.terrain.renderingToTexture) {
                const i5 = n3.renderToTile;
                if (i5) {
                  const o4 = r4[0].canonical, a3 = new e3.O(o4.x + r4[0].wrap * (1 << o4.z), o4.y, o4.z);
                  s4.setDepthMode(Ct.disabled), s4.setStencilMode(Dt.disabled), s4.setColorMode(t3.colorModeForRenderPass()), t3.setCustomLayerDefaults(), i5.call(n3, s4.gl, a3), s4.setDirty(), t3.setBaseState();
                }
                return;
              }
              t3.setCustomLayerDefaults(), s4.setColorMode(t3.colorModeForRenderPass()), s4.setStencilMode(Dt.disabled);
              const i4 = "3d" === n3.renderingMode ? new Ct(t3.context.gl.LEQUAL, Ct.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Ct.ReadOnly);
              if (s4.setDepthMode(i4), "globe" === t3.transform.projection.name) {
                const i5 = t3.transform.pointMerc;
                n3.render(s4.gl, t3.transform.customLayerMatrix(), t3.transform.getProjection(), t3.transform.globeToMercatorMatrix(), e3.W(t3.transform.zoom), [i5.x, i5.y], t3.transform.pixelsPerMeterRatio);
              } else
                n3.render(s4.gl, t3.transform.customLayerMatrix());
              s4.setDirty(), t3.setBaseState(), s4.bindFramebuffer.set(null);
            }
          } else
            e3.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        }, model: function(t3, i3, o3, r4) {
          if ("opaque" === t3.renderPass)
            return;
          const s4 = o3.paint.get("model-opacity");
          if (0 === s4)
            return;
          const n3 = o3.paint.get("model-cast-shadows");
          if ("shadow" === t3.renderPass) {
            if (!n3)
              return;
            if (t3.terrain && s4 < 0.65 && o3._transitionablePaint._values["model-opacity"].value.expression instanceof e3.Z)
              return;
          }
          const a3 = t3.shadowRenderer, l3 = o3.paint.get("model-receive-shadows");
          a3 && (a3.useNormalOffset = true, l3 || (a3.enabled = false));
          const c3 = () => {
            a3 && (a3.useNormalOffset = true, l3 || (a3.enabled = true));
          }, h2 = i3.getSource();
          if ("light-beam" === t3.renderPass && "batched-model" !== h2.type)
            return;
          if ("vector" === h2.type || "geojson" === h2.type)
            return function(t4, i4, o4, r5, s5) {
              const n4 = t4.transform;
              if ("mercator" !== n4.projection.name)
                return void e3.w(`Drawing 3D models for ${n4.projection.name} projection is not yet implemented`);
              const a4 = n4.getFreeCameraOptions().position;
              if (!t4.modelManager)
                return;
              const l4 = t4.modelManager;
              o4.modelManager = l4;
              const c4 = t4.shadowRenderer;
              if (!o4._unevaluatedLayout._values.hasOwnProperty("model-id"))
                return;
              const h3 = o4._unevaluatedLayout._values["model-id"], u4 = { ...o4.layout.get("model-id").parameters };
              for (const d3 of r5) {
                const r6 = i4.getTile(d3).getBucket(o4);
                if (!r6 || r6.projection.name !== n4.projection.name)
                  continue;
                const _4 = r6.getModelUris();
                _4 && !r6.modelsRequested && (l4.addModelsFromBucket(_4, s5), r6.modelsRequested = true);
                const p4 = Vs(d3, n4);
                u4.zoom = p4;
                const f3 = h3.possiblyEvaluate(u4);
                if (Gs(t4, r6, d3), js.shadowUniformsInitialized = false, js.useSingleShadowCascade = !!c4 && 0 === c4.getMaxCascadeForTile(d3.toUnwrapped()), "shadow" === t4.renderPass && c4) {
                  if (1 === t4.currentShadowCascade && r6.isInsideFirstShadowMapFrustum)
                    continue;
                  const i5 = n4.calculatePosMatrix(d3.toUnwrapped(), n4.worldSize);
                  if (js.tileMatrix.set(i5), js.shadowTileMatrix = Float32Array.from(c4.calculateShadowPassMatrixFromMatrix(i5)), js.aabb.min.fill(0), js.aabb.max[0] = js.aabb.max[1] = e3.Y, js.aabb.max[2] = 0, Hs(r6, js, t4, o4.scope))
                    continue;
                }
                const m3 = 1 << d3.canonical.z, g4 = [((a4.x - d3.wrap) * m3 - d3.canonical.x) * e3.Y, (a4.y * m3 - d3.canonical.y) * e3.Y, a4.z * m3 * e3.Y];
                for (let e4 in r6.instancesPerModel) {
                  const i5 = r6.instancesPerModel[e4];
                  i5.features.length > 0 && (e4 = f3.evaluate(i5.features[0].feature, {}));
                  const n5 = l4.getModel(e4, s5);
                  if (n5 && n5.uploaded)
                    for (const e5 of n5.nodes)
                      Zs(t4, o4, e5, i5, g4, d3, js);
                }
              }
            }(t3, i3, o3, r4, "vector" === h2.type ? o3.scope : ""), void c3();
          if (!h2.loaded())
            return;
          if ("batched-model" === h2.type)
            return function(t4, i4, o4, r5) {
              o4.resetLayerRenderingStats(t4);
              const s5 = t4.context, n4 = t4.transform, a4 = t4.style.fog, l4 = t4.shadowRenderer;
              if ("mercator" !== n4.projection.name)
                return void e3.w(`Drawing 3D landmark models for ${n4.projection.name} projection is not yet implemented`);
              const c4 = t4.transform.getFreeCameraOptions().position, h3 = e3.Q.scale([], [c4.x, c4.y, c4.z], t4.transform.worldSize);
              e3.Q.negate(h3, h3);
              const u4 = e3.a9.identity([]), d3 = e3.cZ(n4.center.lat, n4.zoom), _4 = e3.a9.fromScaling([], [1, 1, 1 / d3]);
              e3.a9.translate(u4, u4, h3);
              const p4 = o4.paint.get("model-opacity"), f3 = new Ct(s5.gl.LEQUAL, Ct.ReadWrite, t4.depthRangeFor3D), m3 = new Ct(s5.gl.LEQUAL, Ct.ReadOnly, t4.depthRangeFor3D), g4 = new e3.bV([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), v3 = "shadow" === t4.renderPass, x3 = v3 && l4 ? l4.getCurrentCascadeFrustum() : n4.getFrustum(n4.scaleZoom(n4.worldSize)), y3 = o4.getLayerRenderingStats(), b2 = function(c5, h4) {
                for (const d4 of r5) {
                  const r6 = i4.getTile(d4).getBucket(o4);
                  if (!r6 || !r6.uploaded)
                    continue;
                  let b3 = false;
                  l4 && (b3 = 0 === l4.getMaxCascadeForTile(d4.toUnwrapped()));
                  const w2 = n4.calculatePosMatrix(d4.toUnwrapped(), n4.worldSize), T2 = r6.modelTraits;
                  for (const i5 of r6.getNodesInfo()) {
                    if (i5.hiddenByReplacement)
                      continue;
                    if (!i5.node.meshes)
                      continue;
                    const r7 = i5.evaluatedScale, d5 = i5.node;
                    let E2 = 0;
                    if (t4.terrain && d5.elevation && (E2 = d5.elevation * t4.terrain.exaggeration()), r7[0] <= 1 && r7[1] <= 1 && r7[2] <= 1 && 0 === (() => {
                      const t5 = i5.getLocalBounds();
                      return g4.min = [...t5.min], g4.max = [...t5.max], g4.min[2] += E2, g4.max[2] += E2, e3.Q.transformMat4(g4.min, g4.min, w2), e3.Q.transformMat4(g4.max, g4.max, w2), g4;
                    })().intersects(x3))
                      continue;
                    const S2 = [...w2];
                    e3.a9.translate(S2, S2, [(d5.anchor ? d5.anchor[0] : 0) * (r7[0] - 1), (d5.anchor ? d5.anchor[1] : 0) * (r7[1] - 1), E2]), e3.Q.exactEquals(r7, e3.c$) || e3.a9.scale(S2, S2, r7);
                    const C2 = e3.a9.multiply([], S2, d5.matrix);
                    let I2 = e3.a9.multiply([], _4, S2);
                    e3.a9.multiply(I2, u4, I2);
                    const D2 = e3.a9.invert([], I2);
                    e3.a9.transpose(D2, D2), e3.a9.scale(D2, D2, Ws), I2 = e3.a9.multiply(I2, I2, d5.matrix);
                    const R3 = "light-beam" === t4.renderPass, A2 = e3.a9.multiply([], n4.expandedFarZProjMatrix, C2), P2 = e3.a9.multiply([], n4.expandedFarZProjMatrix, S2), L2 = T2 & e3.d1.HasMapboxMeshFeatures, M3 = L2 ? 0 : i5.evaluatedRMEA[0][2];
                    for (let e4 = 0; e4 < d5.meshes.length; ++e4) {
                      const r8 = d5.meshes[e4], u5 = e4 === d5.lightMeshIndex;
                      let _5 = A2;
                      if (u5) {
                        if (!R3 && !t4.terrain && t4.shadowRenderer) {
                          t4.currentLayer < t4.firstLightBeamLayer && (t4.firstLightBeamLayer = t4.currentLayer);
                          continue;
                        }
                        _5 = P2;
                      } else if (R3)
                        continue;
                      const g5 = { defines: [] }, x4 = [];
                      if (Bs(g5.defines, x4, r8, t4), L2 || g5.defines.push("DIFFUSE_SHADED"), b3 && g5.defines.push("SHADOWS_SINGLE_CASCADE"), y3 && (v3 ? y3.numRenderedVerticesInShadowPass += r8.vertexArray.length : y3.numRenderedVerticesInTransparentPass += r8.vertexArray.length), v3) {
                        Us(r8, C2, t4, o4);
                        continue;
                      }
                      let w3 = null;
                      if (a4) {
                        const e5 = Fs(C2, t4.transform);
                        if (w3 = new Float32Array(e5), "globe" !== n4.projection.name) {
                          const t5 = r8.aabb.min, i6 = r8.aabb.max, [o5, s6] = a4.getOpacityForBounds(e5, t5[0], t5[1], i6[0], i6[1]);
                          g5.overrideFog = o5 >= _e || s6 >= _e;
                        }
                      }
                      const T3 = r8.material;
                      let E3;
                      T3.occlusionTexture && T3.occlusionTexture.offsetScale && (E3 = T3.occlusionTexture.offsetScale, g5.defines.push("OCCLUSION_TEXTURE_TRANSFORM")), !v3 && l4 && (l4.useNormalOffset = !!r8.normalBuffer);
                      const z3 = t4.getOrCreateProgram("model", g5);
                      !v3 && l4 && l4.setupShadowsFromMatrix(S2, z3, l4.useNormalOffset), t4.uploadCommonUniforms(s5, z3, null, w3);
                      const O2 = T3.pbrMetallicRoughness;
                      O2.metallicFactor = 0.9, O2.roughnessFactor = 0.5;
                      const F2 = Hr(new Float32Array(_5), new Float32Array(I2), new Float32Array(D2), new Float32Array(d5.matrix), t4, p4, O2.baseColorFactor, T3.emissiveFactor, O2.metallicFactor, O2.roughnessFactor, T3, M3, o4, [0, 0, 0], E3);
                      z3.draw(t4, s5.gl.TRIANGLES, h4 && !u5 ? f3 : m3, Dt.disabled, c5 ? u5 || p4 < 1 || i5.hasTranslucentParts ? At.alphaBlended : At.unblended : At.disabled, Mt.backCCW, F2, o4.id, r8.vertexBuffer, r8.indexBuffer, r8.segments, o4.paint, t4.transform.zoom, void 0, x4);
                    }
                  }
                }
              };
              (function(e4, t5, i5, o5) {
                const r6 = e4.terrain ? e4.terrain.exaggeration() : 0, s6 = e4.transform.zoom;
                for (const n5 of o5) {
                  const o6 = t5.getTile(n5).getBucket(i5);
                  o6 && (e4.conflationActive && o6.updateReplacement(n5, e4.replacementSource), o6.evaluateScale(e4, i5), e4.terrain && r6 > 0 && o6.elevationUpdate(e4.terrain, r6, n5, i5.source), o6.needsReEvaluation(e4, s6, i5) && o6.evaluate(i5));
                }
              })(t4, i4, o4, r5), 1 === p4 ? b2(true, true) : (b2(false, true), b2(true, false));
            }(t3, i3, o3, r4), void c3();
          const u3 = h2.getModels(), d2 = [], _3 = t3.transform.getFreeCameraOptions().position, p3 = e3.Q.scale([], [_3.x, _3.y, _3.z], t3.transform.worldSize);
          e3.Q.negate(p3, p3);
          const f2 = [], m2 = [];
          let g3 = 0;
          for (const i4 of u3) {
            const r5 = o3.paint.get("model-rotation").constantOr(null), s5 = o3.paint.get("model-scale").constantOr(null), n4 = o3.paint.get("model-translation").constantOr(null);
            i4.computeModelMatrix(t3, r5, s5, n4, true, true, false);
            const a4 = e3.a9.identity([]), l4 = e3.cZ(i4.position.lat, t3.transform.zoom), c4 = e3.a9.fromScaling([], [1, 1, 1 / l4]);
            e3.a9.translate(a4, a4, p3), d2.push({ zScaleMatrix: c4, negCameraPosMatrix: a4 });
            for (const e4 of i4.nodes)
              Ns(t3.transform, e4, i4.matrix, t3.transform.expandedFarZProjMatrix, g3, f2, m2);
            g3++;
          }
          if (f2.sort((e4, t4) => t4.depth - e4.depth), "shadow" !== t3.renderPass) {
            if (1 === s4)
              for (const e4 of m2)
                ks(e4, t3, o3, d2[e4.modelIndex], Dt.disabled, t3.colorModeForRenderPass());
            else {
              for (const e4 of m2)
                ks(e4, t3, o3, d2[e4.modelIndex], Dt.disabled, At.disabled);
              for (const e4 of m2)
                ks(e4, t3, o3, d2[e4.modelIndex], t3.stencilModeFor3D(), t3.colorModeForRenderPass());
              t3.resetStencilClippingMasks();
            }
            for (const e4 of f2)
              ks(e4, t3, o3, d2[e4.modelIndex], Dt.disabled, t3.colorModeForRenderPass());
            c3();
          } else {
            for (const e4 of m2)
              Us(e4.mesh, e4.nodeModelMatrix, t3, o3);
            for (const e4 of f2)
              Us(e4.mesh, e4.nodeModelMatrix, t3, o3);
            c3();
          }
        } }, Xs = { model: function(e4, t3, i3) {
          const o3 = t3.getSource();
          if (!o3.loaded())
            return;
          if ("vector" === o3.type || "geojson" === o3.type)
            return void (i3.modelManager && i3.modelManager.upload(i3, "vector" === o3.type ? e4.scope : ""));
          if ("batched-model" === o3.type)
            return;
          const r4 = o3.getModels();
          for (const e5 of r4)
            e5.upload(i3.context);
        }, raster: function(e4, t3, i3) {
          const o3 = t3.getSource();
          if (!(o3 instanceof Pe && o3.loaded()))
            return;
          const r4 = e4.sourceLayer || o3.rasterLayerIds && o3.rasterLayerIds[0];
          if (!r4)
            return;
          const s4 = e4.paint.get("raster-array-band") || o3.getInitialBand(r4);
          if (null == s4)
            return;
          const n3 = t3.getIds().map((e5) => t3.getTileByID(e5));
          for (const e5 of n3)
            e5.updateNeeded(r4, s4) && o3.prepareTile(e5, r4, s4);
        }, "raster-particle": function(e4, t3, i3) {
          const o3 = t3.getSource();
          if (!(o3 instanceof Pe && o3.loaded()))
            return;
          const r4 = e4.sourceLayer || o3.rasterLayerIds && o3.rasterLayerIds[0];
          if (!r4)
            return;
          const s4 = e4.paint.get("raster-particle-array-band") || o3.getInitialBand(r4);
          if (null == s4)
            return;
          const n3 = t3.getIds().map((e5) => t3.getTileByID(e5));
          for (const e5 of n3)
            e5.updateNeeded(r4, s4) && o3.prepareTile(e5, r4, s4);
        } };
        class Ys {
          constructor(t3, i3, o3, r4) {
            this.context = new zt(t3, i3), this.transform = o3, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r4, this._timeStamp = (/* @__PURE__ */ new Date()).getTime(), this._averageFPS = 0, this._fpsHistory = [], this._debugParams = { showTerrainProxyTiles: false, fpsWindow: 30, continousRedraw: false, enabledLayers: {} };
            const s4 = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
            for (const e4 of s4)
              this._debugParams.enabledLayers[e4] = true;
            r4.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
              this.style.map.triggerRepaint();
            }), r4.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), r4.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: true, label: "continuous redraw" }), r4.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "value" }), r4.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "graph", view: "graph", min: 0, max: 200 });
            for (const e4 of s4)
              r4.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], e4);
            this.setup(), this.numSublayers = Qt.maxUnderzooming + Qt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e3.d3(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new yo(this), this._wireframeDebugCache = new Qs(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true;
          }
          updateTerrain(e4, t3) {
            const i3 = !!e4 && !!e4.terrain && this.transform.projection.supportsTerrain;
            if (!(i3 || this._terrain && this._terrain.enabled))
              return;
            this._terrain || (this._terrain = new pr(this, e4));
            const o3 = this._terrain;
            this.transform.elevation = i3 ? o3 : null, o3.update(e4, this.transform, t3), this.transform.elevation && !o3.enabled && (this.transform.elevation = null);
          }
          _updateFog(e4) {
            const t3 = e4.fog;
            if (!t3 || "globe" === this.transform.projection.name || t3.getOpacity(this.transform.pitch) < 1 || t3.properties.get("horizon-blend") < 0.03)
              return void (this.transform.fogCullDistSq = null);
            const [i3, o3] = t3.getFovAdjustedRange(this.transform._fov);
            if (i3 > o3)
              return void (this.transform.fogCullDistSq = null);
            const r4 = i3 + 0.78 * (o3 - i3);
            this.transform.fogCullDistSq = r4 * r4;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
          }
          get shadowRenderer() {
            return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
          }
          get wireframeDebugCache() {
            return this._wireframeDebugCache;
          }
          resize(t3, i3) {
            if (this.width = t3 * e3.f.devicePixelRatio, this.height = i3 * e3.f.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const e4 of this.style.order)
                this.style._mergedLayers[e4].resize();
          }
          setup() {
            const t3 = this.context, i3 = new e3.aQ();
            i3.emplaceBack(0, 0), i3.emplaceBack(e3.Y, 0), i3.emplaceBack(0, e3.Y), i3.emplaceBack(e3.Y, e3.Y), this.tileExtentBuffer = t3.createVertexBuffer(i3, e3.aS.members), this.tileExtentSegments = e3.aE.simpleSegment(0, 0, 4, 2);
            const o3 = new e3.aQ();
            o3.emplaceBack(0, 0), o3.emplaceBack(e3.Y, 0), o3.emplaceBack(0, e3.Y), o3.emplaceBack(e3.Y, e3.Y), this.debugBuffer = t3.createVertexBuffer(o3, e3.aS.members), this.debugSegments = e3.aE.simpleSegment(0, 0, 4, 5);
            const r4 = new e3.aQ();
            r4.emplaceBack(-1, -1), r4.emplaceBack(1, -1), r4.emplaceBack(-1, 1), r4.emplaceBack(1, 1), this.viewportBuffer = t3.createVertexBuffer(r4, e3.aS.members), this.viewportSegments = e3.aE.simpleSegment(0, 0, 4, 2);
            const s4 = new e3.ay();
            s4.emplaceBack(0, 0, 0, 0), s4.emplaceBack(e3.Y, 0, e3.Y, 0), s4.emplaceBack(0, e3.Y, 0, e3.Y), s4.emplaceBack(e3.Y, e3.Y, e3.Y, e3.Y), this.mercatorBoundsBuffer = t3.createVertexBuffer(s4, e3.aU.members), this.mercatorBoundsSegments = e3.aE.simpleSegment(0, 0, 4, 2);
            const n3 = new e3.az();
            n3.emplaceBack(0, 1, 2), n3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t3.createIndexBuffer(n3);
            const a3 = new e3.aR();
            for (const e4 of [0, 1, 3, 2, 0])
              a3.emplaceBack(e4);
            this.debugIndexBuffer = t3.createIndexBuffer(a3), this.emptyTexture = new e3.T(t3, new e3.h({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t3.gl.RGBA), this.identityMat = e3.a9.create();
            const l3 = this.context.gl;
            this.stencilClearMode = new Dt({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO), this.loadTimeStamps.push(performance.now());
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(e4) {
            return e4._makeTileBoundsBuffers(this.context, this.transform.projection), e4._tileBoundsBuffer ? { tileBoundsBuffer: e4._tileBoundsBuffer, tileBoundsIndexBuffer: e4._tileBoundsIndexBuffer, tileBoundsSegments: e4._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const e4 = this.context.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e4.TRIANGLES, Ct.disabled, this.stencilClearMode, At.disabled, Mt.disabled, cr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(e4, t3, i3) {
            if (!t3 || this.currentStencilSource === t3.id || !e4.isTileClipped() || !i3 || 0 === i3.length)
              return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let e5 = false;
              for (const t4 of i3)
                if (void 0 === this._tileClippingMaskIDs[t4.key]) {
                  e5 = true;
                  break;
                }
              if (!e5)
                return;
            }
            this.currentStencilSource = t3.id;
            const o3 = this.context, r4 = o3.gl;
            this.nextStencilID + i3.length > 256 && this.clearStencil(), o3.setColorMode(At.disabled), o3.setDepthMode(Ct.disabled);
            const s4 = this.getOrCreateProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const e5 of i3) {
              const i4 = t3.getTile(e5), o4 = this._tileClippingMaskIDs[e5.key] = this.nextStencilID++, { tileBoundsBuffer: n3, tileBoundsIndexBuffer: a3, tileBoundsSegments: l3 } = this.getTileBoundsBuffers(i4);
              s4.draw(this, r4.TRIANGLES, Ct.disabled, new Dt({ func: r4.ALWAYS, mask: 0 }, o4, 255, r4.KEEP, r4.KEEP, r4.REPLACE), At.disabled, Mt.disabled, cr(e5.projMatrix), "$clipping", n3, a3, l3);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e4 = this.nextStencilID++, t3 = this.context.gl;
            return new Dt({ func: t3.NOTEQUAL, mask: 255 }, e4, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
          }
          stencilModeForClipping(e4) {
            if (this.terrain)
              return this.terrain.stencilModeForRTTOverlap(e4);
            const t3 = this.context.gl;
            return new Dt({ func: t3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e4.key], 0, t3.KEEP, t3.KEEP, t3.REPLACE);
          }
          stencilConfigForOverlap(e4) {
            const t3 = this.context.gl, i3 = e4.sort((e5, t4) => t4.overscaledZ - e5.overscaledZ), o3 = i3[i3.length - 1].overscaledZ, r4 = i3[0].overscaledZ - o3 + 1;
            if (r4 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + r4 > 256 && this.clearStencil();
              const e5 = {};
              for (let i4 = 0; i4 < r4; i4++)
                e5[i4 + o3] = new Dt({ func: t3.GEQUAL, mask: 255 }, i4 + this.nextStencilID, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
              return this.nextStencilID += r4, [e5, i3];
            }
            return [{ [o3]: Dt.disabled }, i3];
          }
          colorModeForRenderPass() {
            const t3 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i3 = 1 / 8;
              return new At([t3.CONSTANT_COLOR, t3.ONE, t3.CONSTANT_COLOR, t3.ONE], new e3.aA(i3, i3, i3, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? At.unblended : At.alphaBlended;
          }
          colorModeForDrapableLayerRenderPass(t3) {
            const i3 = this.context.gl;
            return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new At([i3.ONE, i3.ONE_MINUS_SRC_ALPHA, i3.CONSTANT_ALPHA, i3.ONE_MINUS_SRC_ALPHA], new e3.aA(0, 0, 0, void 0 === t3 ? 0 : t3), [true, true, true, true]) : this.colorModeForRenderPass();
          }
          depthModeForSublayer(e4, t3, i3, o3 = false) {
            if (!this.opaquePassEnabledForLayer() && !o3)
              return Ct.disabled;
            const r4 = 1 - ((1 + this.currentLayer) * this.numSublayers + e4) * this.depthEpsilon;
            return new Ct(i3 || this.context.gl.LEQUAL, t3, [r4, r4]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          updateAverageFPS() {
            const e4 = (/* @__PURE__ */ new Date()).getTime(), t3 = e4 - this._timeStamp;
            this._timeStamp = e4, this._fpsHistory.push(0 === t3 ? 0 : 1e3 / t3), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e5, t4) => e5 + t4 / this._fpsHistory.length, 0));
          }
          render(t3, i3) {
            this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t3.map.repaint, this.style = t3, this.options = i3;
            const o3 = this.style._mergedLayers, r4 = this.style.order.filter((e4) => {
              const t4 = o3[e4];
              return !(t4.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t4.type];
            }), s4 = r4.map((e4) => o3[e4]), n3 = this.style._mergedSourceCaches;
            this.imageManager = t3.imageManager, this.modelManager = t3.modelManager, this.symbolFadeChange = t3.placement.symbolFadeChange(e3.f.now()), this.imageManager.beginFrame();
            let a3 = 0, l3 = false;
            for (const e4 in n3) {
              const t4 = n3[e4];
              t4.used && (t4.prepare(this.context), t4.getSource().usedInConflation && ++a3);
            }
            for (const e4 of s4)
              e4.isHidden(this.transform.zoom) || this.prepareLayer(e4);
            const c3 = {}, h2 = {}, u3 = {}, d2 = {}, _3 = {};
            for (const e4 in n3) {
              const t4 = n3[e4];
              c3[e4] = t4.getVisibleCoordinates(), h2[e4] = c3[e4].slice().reverse(), u3[e4] = t4.getVisibleCoordinates(true).reverse(), d2[e4] = t4.getShadowCasterCoordinates(), _3[e4] = t4.sortCoordinatesByDistance(c3[e4]);
            }
            const p3 = (e4) => {
              const t4 = this.style.getLayerSourceCache(e4);
              return t4 && t4.used ? t4.getSource() : null;
            };
            if (a3) {
              const e4 = [];
              for (const t4 of s4)
                this.layerUsedInConflation(t4, p3(t4)) && e4.push(t4);
              if (e4 && e4.length > 1) {
                const t4 = [];
                for (const i4 of e4) {
                  const e5 = this.style.getLayerSourceCache(i4);
                  e5 && e5.used && e5.getSource().usedInConflation && t4.push({ layer: i4.fqid, cache: e5 });
                }
                this.replacementSource.setSources(t4), l3 = true;
              }
            }
            l3 || this.replacementSource.clear(), this.conflationActive = l3, this.minCutoffZoom = 0, this.longestCutoffRange = 0;
            for (const e4 of s4) {
              const t4 = e4.cutoffRange();
              if (this.longestCutoffRange = Math.max(t4, this.longestCutoffRange), t4 > 0) {
                const t5 = p3(e4);
                t5 && (this.minCutoffZoom = Math.max(t5.minzoom, this.minCutoffZoom)), e4.minzoom && (this.minCutoffZoom = Math.max(e4.minzoom, this.minCutoffZoom));
              }
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e4 = 0; e4 < s4.length; e4++)
              if (s4[e4].is3D()) {
                this.opaquePassCutoff = e4;
                break;
              }
            const f2 = this.style && this.style.fog;
            f2 ? (this._fogVisible = 0 !== f2.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = f2.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(u3), this.opaquePassCutoff = 0);
            const m2 = this._shadowRenderer;
            if (m2) {
              m2.updateShadowParameters(this.transform, this.style.directionalLight);
              for (const e4 in n3)
                for (const t4 of c3[e4]) {
                  let e5 = { min: 0, max: 0 };
                  this.terrain && (e5 = this.terrain.getMinMaxForTile(t4) || e5), m2.addShadowReceiver(t4.toUnwrapped(), e5.min, e5.max);
                }
            }
            if ("globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e3.d4(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Os(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !e3.d5(this.context.gl))
              return;
            this.renderPass = "offscreen";
            for (const e4 of s4) {
              const i4 = t3.getLayerSourceCache(e4);
              if (!e4.hasOffscreenPass() || e4.isHidden(this.transform.zoom))
                continue;
              const o4 = i4 ? h2[i4.id] : void 0;
              ("custom" === e4.type || "raster" === e4.type || "raster-particle" === e4.type || e4.isSky() || o4 && o4.length) && this.renderLayer(this, i4, e4, o4);
            }
            this.depthRangeFor3D = [0, 1 - (s4.length + 2) * this.numSublayers * this.depthEpsilon];
            const g3 = this.terrain;
            g3 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && !this.transform.isOrthographic && g3.drawDepth(), this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, d2)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
            const v3 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), x3 = (() => {
              if (i3.showOverdrawInspector)
                return e3.aA.black;
              if (this.style.fog && this.transform.projection.supportsFog && !v3) {
                const t4 = this.style.fog.properties.get("color").toArray01();
                return new e3.aA(...t4);
              }
              if (this.style.fog && this.transform.projection.supportsFog && v3) {
                const t4 = this.style.fog.properties.get("space-color").toArray01();
                return new e3.aA(...t4);
              }
              return e3.aA.transparent;
            })();
            if (this.context.clear({ color: x3, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v3 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
              for (this.currentLayer = r4.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e4 = s4[this.currentLayer], i4 = t3.getLayerSourceCache(e4);
                if (e4.isSky())
                  continue;
                const o4 = i4 ? (e4.is3D() ? _3 : h2)[i4.id] : void 0;
                this._renderTileClippingMasks(e4, i4, o4), this.renderLayer(this, i4, e4, o4);
              }
            if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v3 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e3.W(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible()))
              for (this.currentLayer = 0; this.currentLayer < r4.length; this.currentLayer++) {
                const e4 = s4[this.currentLayer], i4 = t3.getLayerSourceCache(e4);
                e4.isSky() && this.renderLayer(this, i4, e4, i4 ? h2[i4.id] : void 0);
              }
            function y3(e4, t4) {
              let i4;
              return t4 && (i4 = ("symbol" === e4.type ? u3 : e4.is3D() ? _3 : h2)[t4.id]), i4;
            }
            if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
              for (this.renderElevatedRasterBackface = true, this.currentLayer = 0; this.currentLayer < r4.length; ) {
                const e4 = s4[this.currentLayer];
                if ("raster" === e4.type) {
                  const i4 = t3.getLayerSourceCache(e4);
                  this.renderLayer(this, i4, e4, y3(e4, i4));
                }
                ++this.currentLayer;
              }
              this.renderElevatedRasterBackface = false;
            }
            this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
            let b2 = 0;
            for (m2 && (b2 = m2.getShadowCastingLayerCount()); this.currentLayer < r4.length; ) {
              const e4 = s4[this.currentLayer], i4 = t3.getLayerSourceCache(e4);
              if (e4.isSky())
                ++this.currentLayer;
              else if (g3 && this.style.isLayerDraped(e4)) {
                if (e4.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = g3.renderBatch(this.currentLayer);
              } else {
                if (this._renderTileClippingMasks(e4, i4, i4 ? c3[i4.id] : void 0), this.renderLayer(this, i4, e4, y3(e4, i4)), !g3 && m2 && b2 > 0 && e4.hasShadowPass() && 0 == --b2 && (m2.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                  const e5 = this.currentLayer;
                  for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e5; this.currentLayer++) {
                    const e6 = s4[this.currentLayer];
                    if (!e6.hasLightBeamPass())
                      continue;
                    const i5 = t3.getLayerSourceCache(e6);
                    this.renderLayer(this, i5, e6, i5 ? h2[i5.id] : void 0);
                  }
                  this.currentLayer = e5, this.renderPass = "translucent";
                }
                ++this.currentLayer;
              }
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let i4 = null;
              s4.forEach((e4) => {
                const o4 = t3.getLayerSourceCache(e4);
                o4 && !e4.isHidden(this.transform.zoom) && o4.getVisibleCoordinates().length && (!i4 || i4.getSource().maxzoom < o4.getSource().maxzoom) && (i4 = o4);
              }), i4 && this.options.showTileBoundaries && $s.debug(this, i4, i4.getVisibleCoordinates(), e3.aA.red, false, this.options.showParseStatus);
            }
            this.terrain && this._debugParams.showTerrainProxyTiles && $s.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e3.aA(1, 0.8, 0.1, 1), true, this.options.showParseStatus), this.options.showPadding && function(e4) {
              const t4 = e4.transform.padding;
              Ts(e4, e4.transform.height - (t4.top || 0), 3, gs), Ts(e4, t4.bottom || 0, 3, vs), Es(e4, t4.left || 0, 3, xs), Es(e4, e4.transform.width - (t4.right || 0), 3, ys);
              const i4 = e4.transform.centerPoint;
              !function(e5, t5, i5, o4) {
                Ss(e5, t5 - 1, i5 - 10, 2, 20, o4), Ss(e5, t5 - 10, i5 - 1, 20, 2, o4);
              }(e4, i4.x, e4.transform.height - i4.y, bs);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), l3 || (this.conflationActive = false);
          }
          prepareLayer(e4) {
            this.gpuTimingStart(e4);
            const { unsupportedLayers: t3 } = this.transform.projection, i3 = !t3 || !t3.includes(e4.type);
            if (Xs[e4.type] && (i3 || this.terrain && "custom" === e4.type)) {
              const t4 = this.style.getLayerSourceCache(e4);
              Xs[e4.type](e4, t4, this);
            }
            this.gpuTimingEnd();
          }
          renderLayer(e4, t3, i3, o3) {
            i3.isHidden(this.transform.zoom) || ("background" === i3.type || "sky" === i3.type || "custom" === i3.type || "model" === i3.type || "raster" === i3.type || "raster-particle" === i3.type || o3 && o3.length) && (this.id = i3.id, this.gpuTimingStart(i3), (!e4.transform.projection.unsupportedLayers || !e4.transform.projection.unsupportedLayers.includes(i3.type) || e4.terrain && "custom" === i3.type) && $s[i3.type](e4, t3, i3, o3, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(e4) {
            if (!this.options.gpuTiming)
              return;
            const t3 = this.context.extTimerQuery, i3 = this.context.gl;
            let o3 = this.gpuTimers[e4.id];
            o3 || (o3 = this.gpuTimers[e4.id] = { calls: 0, cpuTime: 0, query: i3.createQuery() }), o3.calls++, i3.beginQuery(t3.TIME_ELAPSED_EXT, o3.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const e4 = this.context.extTimerQuery, t3 = this.context.gl, i3 = t3.createQuery();
              this.deferredRenderGpuTimeQueries.push(i3), t3.beginQuery(e4.TIME_ELAPSED_EXT, i3);
            }
          }
          gpuTimingDeferredRenderEnd() {
            this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const e4 = this.gpuTimers;
            return this.gpuTimers = {}, e4;
          }
          collectDeferredRenderGpuQueries() {
            const e4 = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], e4;
          }
          queryGpuTimers(e4) {
            const t3 = {};
            for (const i3 in e4) {
              const o3 = e4[i3], r4 = this.context.extTimerQuery, s4 = r4.getQueryParameter(o3.query, this.context.gl.QUERY_RESULT) / 1e6;
              r4.deleteQueryEXT(o3.query), t3[i3] = s4;
            }
            return t3;
          }
          queryGpuTimeDeferredRender(e4) {
            if (!this.options.gpuTimingDeferredRender)
              return 0;
            const t3 = this.context.extTimerQuery, i3 = this.context.gl;
            let o3 = 0;
            for (const r4 of e4)
              o3 += t3.getQueryParameter(r4, i3.QUERY_RESULT) / 1e6, t3.deleteQueryEXT(r4);
            return o3;
          }
          translatePosMatrix(t3, i3, o3, r4, s4) {
            if (!o3[0] && !o3[1])
              return t3;
            const n3 = s4 ? "map" === r4 ? this.transform.angle : 0 : "viewport" === r4 ? -this.transform.angle : 0;
            if (n3) {
              const e4 = Math.sin(n3), t4 = Math.cos(n3);
              o3 = [o3[0] * t4 - o3[1] * e4, o3[0] * e4 + o3[1] * t4];
            }
            const a3 = [s4 ? o3[0] : e3.a6(i3, o3[0], this.transform.zoom), s4 ? o3[1] : e3.a6(i3, o3[1], this.transform.zoom), 0], l3 = new Float32Array(16);
            return e3.a9.translate(l3, t3, a3), l3;
          }
          saveTileTexture(e4) {
            const t3 = e4.size[0], i3 = this._tileTextures[t3];
            i3 ? i3.push(e4) : this._tileTextures[t3] = [e4];
          }
          getTileTexture(e4) {
            const t3 = this._tileTextures[e4];
            return t3 && t3.length > 0 ? t3.pop() : null;
          }
          isPatternMissing(e4, t3) {
            return null === e4 || void 0 !== e4 && !this.imageManager.getPattern(e4.toString(), t3);
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
          }
          linearFloatFilteringSupported() {
            return null != this.context.extTextureFloatLinear;
          }
          currentGlobalDefines(e4, t3, i3) {
            const o3 = void 0 === i3 ? this.terrain && this.terrain.renderingToTexture : i3, r4 = this.terrain && 0 === this.terrain.exaggeration(), s4 = [];
            return this.style && this.style.enable3dLights() && ("globeRaster" === e4 || "terrainRaster" === e4 ? (s4.push("LIGHTING_3D_MODE"), s4.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o3 || s4.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass ? this._shadowMapDebug || s4.push("DEPTH_TEXTURE") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? s4.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET") : s4.push("RENDER_SHADOWS", "DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s4.push("TERRAIN"), this.linearFloatFilteringSupported() && s4.push("TERRAIN_DEM_FLOAT_FORMAT"), r4 && s4.push("ZERO_EXAGGERATION")), "globe" === this.transform.projection.name && s4.push("GLOBE"), !this._fogVisible || o3 || void 0 !== t3 && !t3 || s4.push("FOG", "FOG_DITHERING"), o3 && s4.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s4.push("OVERDRAW_INSPECTOR"), s4;
          }
          getOrCreateProgram(e4, t3) {
            this.cache = this.cache || {};
            const i3 = t3 && t3.defines || [], o3 = t3 && t3.config, r4 = this.currentGlobalDefines(e4, t3 && t3.overrideFog, t3 && t3.overrideRtt).concat(i3), s4 = vr.cacheKey(qo[e4], e4, r4, o3);
            return this.cache[s4] || (this.cache[s4] = new vr(this.context, e4, qo[e4], o3, Qr[e4], r4)), this.cache[s4];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e4 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e4.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e3.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          uploadCommonLightUniforms(t3, i3) {
            if (this.style.enable3dLights()) {
              const o3 = this.style.directionalLight, r4 = this.style.ambientLight;
              if (o3 && r4) {
                const s4 = ((t4, i4) => {
                  const o4 = t4.properties.get("direction"), r5 = t4.properties.get("color").toArray01(), s5 = t4.properties.get("intensity"), n3 = i4.properties.get("color").toArray01(), a3 = i4.properties.get("intensity"), l3 = [o4.x, o4.y, o4.z], c3 = e3.cs(n3, a3), h2 = e3.cs(r5, s5);
                  return { u_lighting_ambient_color: c3, u_lighting_directional_dir: l3, u_lighting_directional_color: h2, u_ground_radiance: fr(l3, h2, c3) };
                })(o3, r4);
                i3.setLightsUniformValues(t3, s4);
              }
            }
          }
          uploadCommonUniforms(t3, i3, o3, r4, s4) {
            if (this.uploadCommonLightUniforms(t3, i3), this.terrain && this.terrain.renderingToTexture)
              return;
            const n3 = this.style.fog;
            if (n3) {
              const s5 = n3.getOpacity(this.transform.pitch), a3 = ((t4, i4, o4, r5, s6, n4, a4, l3, c3, h2, u3, d2) => {
                const _3 = t4.transform, p3 = i4.properties.get("color").toArray01();
                p3[3] = r5;
                const f2 = t4.frameCounter / 1e3 % 1, [m2, g3] = i4.properties.get("vertical-range");
                return { u_fog_matrix: o4 ? _3.calculateFogTileMatrix(o4) : d2 || t4.identityMat, u_fog_range: i4.getFovAdjustedRange(_3._fov), u_fog_color: p3, u_fog_horizon_blend: i4.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(m2, g3), g3], u_fog_temporal_offset: f2, u_frustum_tl: s6, u_frustum_tr: n4, u_frustum_br: a4, u_frustum_bl: l3, u_globe_pos: c3, u_globe_radius: h2, u_viewport: u3, u_globe_transition: e3.W(_3.zoom), u_is_globe: +("globe" === _3.projection.name) };
              })(this, n3, o3, s5, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e3.f.devicePixelRatio, this.transform.height * e3.f.devicePixelRatio], r4);
              i3.setFogUniformValues(t3, a3);
            }
            s4 && i3.setCutoffUniformValues(t3, s4.uniformValues);
          }
          setTileLoadedFlag(e4) {
            this.tileLoaded = e4;
          }
          saveCanvasCopy() {
            const e4 = this.canvasCopy();
            e4 && (this.frameCopies.push(e4), this.tileLoaded = false);
          }
          canvasCopy() {
            const e4 = this.context.gl, t3 = e4.createTexture();
            return e4.bindTexture(e4.TEXTURE_2D, t3), e4.copyTexImage2D(e4.TEXTURE_2D, 0, e4.RGBA, 0, 0, e4.drawingBufferWidth, e4.drawingBufferHeight, 0), t3;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation)
              return false;
            const e4 = this.style && this.style.fog;
            return !!e4 && 0 !== e4.getOpacity(this.transform.pitch);
          }
          getBackgroundTiles() {
            const e4 = this._backgroundTiles, t3 = this._backgroundTiles = {}, i3 = this.transform.coveringTiles({ tileSize: 512 });
            for (const o3 of i3)
              t3[o3.key] = e4[o3.key] || new Nt(o3, 512, this.transform.tileZoom, this);
            return t3;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
          layerUsedInConflation(e4, t3) {
            return !(!e4.is3D() || e4.minzoom && e4.minzoom > this.transform.zoom || "building" !== e4.sourceLayer && (!t3 || "batched-model" !== t3.type));
          }
          isTileAffectedByFog(e4) {
            if (!this.style || !this.style.fog)
              return false;
            if ("globe" === this.transform.projection.name)
              return true;
            let t3 = this._cachedTileFogOpacities[e4.key];
            return t3 || (this._cachedTileFogOpacities[e4.key] = t3 = this.style.fog.getOpacityForTile(e4)), t3[0] >= _e || t3[1] >= _e;
          }
        }
        function Js(e4, t3) {
          let i3 = false, o3 = null;
          const r4 = () => {
            o3 = null, i3 && (e4(), o3 = setTimeout(r4, t3), i3 = false);
          };
          return () => (i3 = true, o3 || r4(), o3);
        }
        class Ks {
          constructor(t3) {
            this._hashName = t3 && encodeURIComponent(t3), e3.a$(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Js(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(e4) {
            return this._map = e4, window.addEventListener("hashchange", this._onHashChange, false), e4.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const e4 = this._map;
            if (!e4)
              return "";
            const t3 = en(e4);
            if (this._hashName) {
              const e5 = this._hashName;
              let i3 = false;
              const o3 = location.hash.slice(1).split("&").map((o4) => {
                const r4 = o4.split("=")[0];
                return r4 === e5 ? (i3 = true, `${r4}=${t3}`) : o4;
              }).filter((e6) => e6);
              return i3 || o3.push(`${e5}=${t3}`), `#${o3.join("&")}`;
            }
            return `#${t3}`;
          }
          _getCurrentHash() {
            const e4 = location.hash.replace("#", "");
            if (this._hashName) {
              let t3;
              return e4.split("&").map((e5) => e5.split("=")).forEach((e5) => {
                e5[0] === this._hashName && (t3 = e5);
              }), (t3 && t3[1] || "").split("/");
            }
            return e4.split("/");
          }
          _onHashChange() {
            const e4 = this._map;
            if (!e4)
              return false;
            const t3 = this._getCurrentHash();
            if (t3.length >= 3 && !t3.some((e5) => isNaN(e5))) {
              const i3 = e4.dragRotate.isEnabled() && e4.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : e4.getBearing();
              return e4.jumpTo({ center: [+t3[2], +t3[1]], zoom: +t3[0], bearing: i3, pitch: +(t3[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
          }
        }
        function en(e4, t3) {
          const i3 = e4.getCenter(), o3 = Math.round(100 * e4.getZoom()) / 100, r4 = Math.ceil((o3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s4 = Math.pow(10, r4), n3 = Math.round(i3.lng * s4) / s4, a3 = Math.round(i3.lat * s4) / s4, l3 = e4.getBearing(), c3 = e4.getPitch();
          let h2 = t3 ? `/${n3}/${a3}/${o3}` : `${o3}/${a3}/${n3}`;
          return (l3 || c3) && (h2 += "/" + Math.round(10 * l3) / 10), c3 && (h2 += `/${Math.round(c3)}`), h2;
        }
        const tn = { linearity: 0.3, easing: e3.d6(0, 0, 0.3, 1) }, on = e3.e({ deceleration: 2500, maxSpeed: 1400 }, tn), rn = e3.e({ deceleration: 20, maxSpeed: 1400 }, tn), sn = e3.e({ deceleration: 1e3, maxSpeed: 360 }, tn), nn = e3.e({ deceleration: 1e3, maxSpeed: 90 }, tn);
        class an {
          constructor(e4) {
            this._map = e4, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t3) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e3.f.now(), settings: t3 });
          }
          _drainInertiaBuffer() {
            const t3 = this._inertiaBuffer, i3 = e3.f.now();
            for (; t3.length > 0 && i3 - t3[0].time > 160; )
              t3.shift();
          }
          _onMoveEnd(t3) {
            if (this._map._prefersReducedMotion())
              return;
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new e3.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e4 } of this._inertiaBuffer)
              i3.zoom += e4.zoomDelta || 0, i3.bearing += e4.bearingDelta || 0, i3.pitch += e4.pitchDelta || 0, e4.panDelta && i3.pan._add(e4.panDelta), e4.around && (i3.around = e4.around), e4.pinchAround && (i3.pinchAround = e4.pinchAround);
            const o3 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r4 = {};
            if (i3.pan.mag()) {
              const s4 = cn2(i3.pan.mag(), o3, e3.e({}, on, t3 || {}));
              r4.offset = i3.pan.mult(s4.amount / i3.pan.mag()), r4.center = this._map.transform.center, ln(r4, s4);
            }
            if (i3.zoom) {
              const e4 = cn2(i3.zoom, o3, rn);
              r4.zoom = this._map.transform.zoom + e4.amount, ln(r4, e4);
            }
            if (i3.bearing) {
              const t4 = cn2(i3.bearing, o3, sn);
              r4.bearing = this._map.transform.bearing + e3.ad(t4.amount, -179, 179), ln(r4, t4);
            }
            if (i3.pitch) {
              const e4 = cn2(i3.pitch, o3, nn);
              r4.pitch = this._map.transform.pitch + e4.amount, ln(r4, e4);
            }
            if (r4.zoom || r4.bearing) {
              const e4 = void 0 === i3.pinchAround ? i3.around : i3.pinchAround;
              r4.around = e4 ? this._map.unproject(e4) : this._map.getCenter();
            }
            return this.clear(), r4.noMoveStart = true, r4;
          }
        }
        function ln(e4, t3) {
          (!e4.duration || e4.duration < t3.duration) && (e4.duration = t3.duration, e4.easing = t3.easing);
        }
        function cn2(t3, i3, o3) {
          const { maxSpeed: r4, linearity: s4, deceleration: n3 } = o3, a3 = e3.ad(t3 * s4 / (i3 / 1e3), -r4, r4), l3 = Math.abs(a3) / (n3 * s4);
          return { easing: o3.easing, duration: 1e3 * l3, amount: a3 * (l3 / 2) };
        }
        class hn extends e3.b {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i3, o3, r4 = {}) {
            const s4 = p2(i3.getCanvasContainer(), o3), n3 = i3.unproject(s4);
            super(t3, e3.e({ point: s4, lngLat: n3, originalEvent: o3 }, r4)), this._defaultPrevented = false, this.target = i3;
          }
        }
        class un extends e3.b {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i3, o3) {
            const r4 = "touchend" === t3 ? o3.changedTouches : o3.touches, s4 = f(i3.getCanvasContainer(), r4), n3 = s4.map((e4) => i3.unproject(e4)), a3 = s4.reduce((e4, t4, i4, o4) => e4.add(t4.div(o4.length)), new e3.P(0, 0));
            super(t3, { points: s4, point: a3, lngLats: n3, lngLat: i3.unproject(a3), originalEvent: o3 }), this._defaultPrevented = false;
          }
        }
        class dn extends e3.b {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e4, t3, i3) {
            super(e4, { originalEvent: i3 }), this._defaultPrevented = false;
          }
        }
        class _n {
          constructor(e4, t3) {
            this._map = e4, this._clickTolerance = t3.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(e4) {
            return this._firePreventable(new dn(e4.type, this._map, e4));
          }
          mousedown(e4, t3) {
            return this._mousedownPos = t3, this._firePreventable(new hn(e4.type, this._map, e4));
          }
          mouseup(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          preclick(t3) {
            const i3 = e3.e({}, t3);
            i3.type = "preclick", this._map.fire(new hn(i3.type, this._map, i3));
          }
          click(e4, t3) {
            this._mousedownPos && this._mousedownPos.dist(t3) >= this._clickTolerance || (this.preclick(e4), this._map.fire(new hn(e4.type, this._map, e4)));
          }
          dblclick(e4) {
            return this._firePreventable(new hn(e4.type, this._map, e4));
          }
          mouseover(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          mouseout(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          touchstart(e4) {
            return this._firePreventable(new un(e4.type, this._map, e4));
          }
          touchmove(e4) {
            this._map.fire(new un(e4.type, this._map, e4));
          }
          touchend(e4) {
            this._map.fire(new un(e4.type, this._map, e4));
          }
          touchcancel(e4) {
            this._map.fire(new un(e4.type, this._map, e4));
          }
          _firePreventable(e4) {
            if (this._map.fire(e4), e4.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class pn {
          constructor(e4) {
            this._map = e4;
          }
          reset() {
            this._delayContextMenu = false, this._contextMenuEvent = void 0;
          }
          mousemove(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new hn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e4) {
            this._delayContextMenu ? this._contextMenuEvent = e4 : this._map.fire(new hn(e4.type, this._map, e4)), this._map.listens("contextmenu") && e4.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class fn {
          constructor(e4, t3) {
            this._map = e4, this._el = e4.getCanvasContainer(), this._container = e4.getContainer(), this._clickTolerance = t3.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e4, t3) {
            this.isEnabled() && e4.shiftKey && 0 === e4.button && (h(), this._startPos = this._lastPos = t3, this._active = true);
          }
          mousemoveWindow(e4, t3) {
            if (!this._active)
              return;
            const i3 = t3, o3 = this._startPos, r4 = this._lastPos;
            if (!o3 || !r4 || r4.equals(i3) || !this._box && i3.dist(o3) < this._clickTolerance)
              return;
            this._lastPos = i3, this._box || (this._box = s3("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e4));
            const n3 = Math.min(o3.x, i3.x), a3 = Math.max(o3.x, i3.x), l3 = Math.min(o3.y, i3.y), c3 = Math.max(o3.y, i3.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${n3}px,${l3}px)`, this._box.style.width = a3 - n3 + "px", this._box.style.height = c3 - l3 + "px");
            });
          }
          mouseupWindow(t3, i3) {
            if (!this._active)
              return;
            const o3 = this._startPos, r4 = i3;
            if (o3 && 0 === t3.button) {
              if (this.reset(), _2(), o3.x !== r4.x || o3.y !== r4.y)
                return this._map.fire(new e3.b("boxzoomend", { originalEvent: t3 })), { cameraAnimation: (e4) => e4.fitScreenCoordinates(o3, r4, this._map.getBearing(), { linear: false }) };
              this._fireEvent("boxzoomcancel", t3);
            }
          }
          keydown(e4) {
            this._active && 27 === e4.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e4));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u2(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t3, i3) {
            return this._map.fire(new e3.b(t3, { originalEvent: i3 }));
          }
        }
        function mn(e4, t3) {
          const i3 = {};
          for (let o3 = 0; o3 < e4.length; o3++)
            i3[e4[o3].identifier] = t3[o3];
          return i3;
        }
        class gn {
          constructor(e4) {
            this.reset(), this.numTouches = e4.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
          }
          touchstart(t3, i3, o3) {
            (this.centroid || o3.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t3.timeStamp), o3.length === this.numTouches && (this.centroid = function(t4) {
              const i4 = new e3.P(0, 0);
              for (const e4 of t4)
                i4._add(e4);
              return i4.div(t4.length);
            }(i3), this.touches = mn(o3, i3)));
          }
          touchmove(e4, t3, i3) {
            if (this.aborted || !this.centroid)
              return;
            const o3 = mn(i3, t3);
            for (const e5 in this.touches) {
              const t4 = o3[e5];
              (!t4 || t4.dist(this.touches[e5]) > 30) && (this.aborted = true);
            }
          }
          touchend(e4, t3, i3) {
            if ((!this.centroid || e4.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
              const e5 = !this.aborted && this.centroid;
              if (this.reset(), e5)
                return e5;
            }
          }
        }
        class vn {
          constructor(e4) {
            this.singleTap = new gn(e4), this.numTaps = e4.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(e4, t3, i3) {
            this.singleTap.touchstart(e4, t3, i3);
          }
          touchmove(e4, t3, i3) {
            this.singleTap.touchmove(e4, t3, i3);
          }
          touchend(e4, t3, i3) {
            const o3 = this.singleTap.touchend(e4, t3, i3);
            if (o3) {
              const t4 = e4.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(o3) < 30;
              if (t4 && i4 || this.reset(), this.count++, this.lastTime = e4.timeStamp, this.lastTap = o3, this.count === this.numTaps)
                return this.reset(), o3;
            }
          }
        }
        class xn {
          constructor() {
            this._zoomIn = new vn({ numTouches: 1, numTaps: 2 }), this._zoomOut = new vn({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e4, t3, i3) {
            this._zoomIn.touchstart(e4, t3, i3), this._zoomOut.touchstart(e4, t3, i3);
          }
          touchmove(e4, t3, i3) {
            this._zoomIn.touchmove(e4, t3, i3), this._zoomOut.touchmove(e4, t3, i3);
          }
          touchend(e4, t3, i3) {
            const o3 = this._zoomIn.touchend(e4, t3, i3), r4 = this._zoomOut.touchend(e4, t3, i3);
            return o3 ? (this._active = true, e4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() + 1, around: t4.unproject(o3) }, { originalEvent: e4 }) }) : r4 ? (this._active = true, e4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() - 1, around: t4.unproject(r4) }, { originalEvent: e4 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const yn = { 0: 1, 2: 2 };
        class bn {
          constructor(e4) {
            this.reset(), this._clickTolerance = e4.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(e4, t3) {
            return false;
          }
          _move(e4, t3) {
            return {};
          }
          mousedown(e4, t3) {
            if (this._lastPoint)
              return;
            const i3 = m(e4);
            this._correctButton(e4, i3) && (this._lastPoint = t3, this._eventButton = i3);
          }
          mousemoveWindow(e4, t3) {
            const i3 = this._lastPoint;
            if (i3) {
              if (e4.preventDefault(), null != this._eventButton && function(e5, t4) {
                const i4 = yn[t4];
                return void 0 === e5.buttons || (e5.buttons & i4) !== i4;
              }(e4, this._eventButton))
                this.reset();
              else if (this._moved || !(t3.dist(i3) < this._clickTolerance))
                return this._moved = true, this._lastPoint = t3, this._move(i3, t3);
            }
          }
          mouseupWindow(e4) {
            this._lastPoint && m(e4) === this._eventButton && (this._moved && _2(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class wn extends bn {
          mousedown(e4, t3) {
            super.mousedown(e4, t3), this._lastPoint && (this._active = true);
          }
          _correctButton(e4, t3) {
            return 0 === t3 && !e4.ctrlKey;
          }
          _move(e4, t3) {
            return { around: t3, panDelta: t3.sub(e4) };
          }
        }
        class Tn extends bn {
          _correctButton(e4, t3) {
            return 0 === t3 && e4.ctrlKey || 2 === t3;
          }
          _move(e4, t3) {
            const i3 = 0.8 * (t3.x - e4.x);
            if (i3)
              return this._active = true, { bearingDelta: i3 };
          }
          contextmenu(e4) {
            e4.preventDefault();
          }
        }
        class En extends bn {
          _correctButton(e4, t3) {
            return 0 === t3 && e4.ctrlKey || 2 === t3;
          }
          _move(e4, t3) {
            const i3 = -0.5 * (t3.y - e4.y);
            if (i3)
              return this._active = true, { pitchDelta: i3 };
          }
          contextmenu(e4) {
            e4.preventDefault();
          }
        }
        class Sn {
          constructor(t3, i3) {
            this._map = t3, this._el = t3.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i3.clickTolerance || 1, this.reset(), e3.a$(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e3.P(0, 0);
          }
          touchstart(e4, t3, i3) {
            return this._calculateTransform(e4, t3, i3);
          }
          touchmove(t3, i3, o3) {
            if (this._active && !(o3.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (1 === o3.length && !e3.d7())
                  return void this._showTouchPanBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t3.cancelable && t3.preventDefault(), this._calculateTransform(t3, i3, o3);
            }
          }
          touchend(e4, t3, i3) {
            this._calculateTransform(e4, t3, i3), this._active && i3.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t3, i3, o3) {
            o3.length > 0 && (this._active = true);
            const r4 = mn(o3, i3), s4 = new e3.P(0, 0), n3 = new e3.P(0, 0);
            let a3 = 0;
            for (const e4 in r4) {
              const t4 = r4[e4], i4 = this._touches[e4];
              i4 && (s4._add(t4), n3._add(t4.sub(i4)), a3++, r4[e4] = t4);
            }
            if (this._touches = r4, a3 < this._minTouches || !n3.mag())
              return;
            const l3 = n3.div(a3);
            return this._sum._add(l3), this._sum.mag() < this._clickTolerance ? void 0 : { around: s4.div(a3), panDelta: l3 };
          }
          enable() {
            this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = s3("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 500);
          }
        }
        class Cn {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, this._firstTwoTouches = void 0;
          }
          _start(e4) {
          }
          _move(e4, t3, i3) {
            return {};
          }
          touchstart(e4, t3, i3) {
            this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([t3[0], t3[1]]));
          }
          touchmove(e4, t3, i3) {
            const o3 = this._firstTwoTouches;
            if (!o3)
              return;
            e4.preventDefault();
            const [r4, s4] = o3, n3 = In(i3, t3, r4), a3 = In(i3, t3, s4);
            if (!n3 || !a3)
              return;
            const l3 = this._aroundCenter ? null : n3.add(a3).div(2);
            return this._move([n3, a3], l3, e4);
          }
          touchend(e4, t3, i3) {
            if (!this._firstTwoTouches)
              return;
            const [o3, r4] = this._firstTwoTouches, s4 = In(i3, t3, o3), n3 = In(i3, t3, r4);
            s4 && n3 || (this._active && _2(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e4) {
            this._enabled = true, this._aroundCenter = !!e4 && "center" === e4.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function In(e4, t3, i3) {
          for (let o3 = 0; o3 < e4.length; o3++)
            if (e4[o3].identifier === i3)
              return t3[o3];
        }
        function Dn(e4, t3) {
          return Math.log(e4 / t3) / Math.LN2;
        }
        class Rn extends Cn {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(e4) {
            this._startDistance = this._distance = e4[0].dist(e4[1]);
          }
          _move(e4, t3) {
            const i3 = this._distance;
            if (this._distance = e4[0].dist(e4[1]), this._active || !(Math.abs(Dn(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: Dn(this._distance, i3), pinchAround: t3 };
          }
        }
        function An(e4, t3) {
          return 180 * e4.angleWith(t3) / Math.PI;
        }
        class Pn extends Cn {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(e4) {
            this._startVector = this._vector = e4[0].sub(e4[1]), this._minDiameter = e4[0].dist(e4[1]);
          }
          _move(e4, t3) {
            const i3 = this._vector;
            if (this._vector = e4[0].sub(e4[1]), i3 && (this._active || !this._isBelowThreshold(this._vector)))
              return this._active = true, { bearingDelta: An(this._vector, i3), pinchAround: t3 };
          }
          _isBelowThreshold(e4) {
            this._minDiameter = Math.min(this._minDiameter, e4.mag());
            const t3 = 25 / (Math.PI * this._minDiameter) * 360, i3 = this._startVector;
            if (!i3)
              return false;
            const o3 = An(e4, i3);
            return Math.abs(o3) < t3;
          }
        }
        function Ln(e4) {
          return Math.abs(e4.y) > Math.abs(e4.x);
        }
        class Mn extends Cn {
          constructor(e4) {
            super(), this._map = e4;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(e4) {
            this._lastPoints = e4, Ln(e4[0].sub(e4[1])) && (this._valid = false);
          }
          _move(t3, i3, o3) {
            const r4 = this._lastPoints;
            if (!r4)
              return;
            const s4 = t3[0].sub(r4[0]), n3 = t3[1].sub(r4[1]);
            return this._map._cooperativeGestures && !e3.d7() && o3.touches.length < 3 || (this._valid = this.gestureBeginsVertically(s4, n3, o3.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t3, this._active = true, { pitchDelta: (s4.y + n3.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(e4, t3, i3) {
            if (void 0 !== this._valid)
              return this._valid;
            const o3 = e4.mag() >= 2, r4 = t3.mag() >= 2;
            if (!o3 && !r4)
              return;
            if (!o3 || !r4)
              return null == this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
            const s4 = e4.y > 0 == t3.y > 0;
            return Ln(e4) && Ln(t3) && s4;
          }
        }
        const zn = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class On {
          constructor() {
            const e4 = zn;
            this._panStep = e4.panStep, this._bearingStep = e4.bearingStep, this._pitchStep = e4.pitchStep, this._rotationDisabled = false;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          keydown(e4) {
            if (e4.altKey || e4.ctrlKey || e4.metaKey)
              return;
            let t3 = 0, i3 = 0, o3 = 0, r4 = 0, s4 = 0;
            switch (e4.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t3 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t3 = -1;
                break;
              case 37:
                e4.shiftKey ? i3 = -1 : (e4.preventDefault(), r4 = -1);
                break;
              case 39:
                e4.shiftKey ? i3 = 1 : (e4.preventDefault(), r4 = 1);
                break;
              case 38:
                e4.shiftKey ? o3 = 1 : (e4.preventDefault(), s4 = -1);
                break;
              case 40:
                e4.shiftKey ? o3 = -1 : (e4.preventDefault(), s4 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i3 = 0, o3 = 0), { cameraAnimation: (n3) => {
              const a3 = n3.getZoom();
              n3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Fn, zoom: t3 ? Math.round(a3) + t3 * (e4.shiftKey ? 2 : 1) : a3, bearing: n3.getBearing() + i3 * this._bearingStep, pitch: n3.getPitch() + o3 * this._pitchStep, offset: [-r4 * this._panStep, -s4 * this._panStep], center: n3.getCenter() }, { originalEvent: e4 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Fn(e4) {
          return e4 * (2 - e4);
        }
        const Bn = 4.000244140625, kn = 1 / 450;
        class Nn {
          constructor(t3, i3) {
            this._map = t3, this._el = t3.getCanvasContainer(), this._handler = i3, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = kn, e3.a$(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(e4) {
            this._defaultZoomRate = e4;
          }
          setWheelZoomRate(e4) {
            this._wheelZoomRate = e4;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e4) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e4 && "center" === e4.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t3) {
            if (!this.isEnabled())
              return;
            if (this._map._cooperativeGestures) {
              if (!(t3.ctrlKey || t3.metaKey || this.isZooming() || e3.d7()))
                return void this._showBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let i3 = t3.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t3.deltaY : t3.deltaY;
            const o3 = e3.f.now(), r4 = o3 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o3, 0 !== i3 && i3 % Bn == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : r4 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, t3)) : this._type || (this._type = Math.abs(r4 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), t3.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = t3, this._delta -= i3, this._active || this._start(t3)), t3.preventDefault();
          }
          _onTimeout(e4) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e4);
          }
          _start(e4) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const t3 = p2(this._el, e4);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t3, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const t3 = this._map.transform;
            "wheel" === this._type && t3.projection.wrap && (t3._center.lng >= 180 || t3._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const i3 = () => t3._terrainEnabled() && this._aroundCoord ? t3.computeZoomRelativeTo(this._aroundCoord) : t3.zoom;
            if (0 !== this._delta) {
              const e4 = "wheel" === this._type && Math.abs(this._delta) > Bn ? this._wheelZoomRate : this._defaultZoomRate;
              let o4 = 2 / (1 + Math.exp(-Math.abs(this._delta * e4)));
              this._delta < 0 && 0 !== o4 && (o4 = 1 / o4);
              const r5 = i3(), s5 = Math.pow(2, r5), n4 = "number" == typeof this._targetZoom ? t3.zoomScale(this._targetZoom) : s5;
              this._targetZoom = Math.min(t3.maxZoom, Math.max(t3.minZoom, t3.scaleZoom(n4 * o4))), "wheel" === this._type && (this._startZoom = r5, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
            }
            const o3 = "number" == typeof this._targetZoom ? this._targetZoom : i3(), r4 = this._startZoom, s4 = this._easing;
            let n3, a3 = false;
            if ("wheel" === this._type && r4 && s4) {
              const t4 = Math.min((e3.f.now() - this._lastWheelEventTime) / 200, 1), i4 = s4(t4);
              n3 = e3.X(r4, o3, i4), t4 < 1 ? this._frameId || (this._frameId = true) : a3 = true;
            } else
              n3 = o3, a3 = true;
            this._active = true, a3 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200));
            let l3 = n3 - i3();
            return l3 * this._lastDelta < 0 && (l3 = 0), { noInertia: true, needsRenderFrame: !a3, zoomDelta: l3, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t3) {
            let i3 = e3.d8;
            if (this._prevEase) {
              const t4 = this._prevEase, o3 = (e3.f.now() - t4.start) / t4.duration, r4 = t4.easing(o3 + 0.01) - t4.easing(o3), s4 = 0.27 / Math.sqrt(r4 * r4 + 1e-4) * 0.01, n3 = Math.sqrt(0.0729 - s4 * s4);
              i3 = e3.d6(s4, n3, 0.25, 1);
            }
            return this._prevEase = { start: e3.f.now(), duration: t3, easing: i3 }, i3;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = s3("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 200);
          }
        }
        class Un {
          constructor(e4, t3) {
            this._clickZoom = e4, this._tapZoom = t3;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Gn {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          blur() {
            this.reset();
          }
          dblclick(e4, t3) {
            return e4.preventDefault(), { cameraAnimation: (i3) => {
              i3.easeTo({ duration: 300, zoom: i3.getZoom() + (e4.shiftKey ? -1 : 1), around: i3.unproject(t3) }, { originalEvent: e4 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class jn {
          constructor() {
            this._tap = new vn({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(e4, t3, i3) {
            this._swipePoint || (this._tapTime && e4.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i3.length > 0 && (this._swipePoint = t3[0], this._swipeTouch = i3[0].identifier) : this._tap.touchstart(e4, t3, i3));
          }
          touchmove(e4, t3, i3) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i3[0].identifier !== this._swipeTouch)
                  return;
                const o3 = t3[0], r4 = o3.y - this._swipePoint.y;
                return this._swipePoint = o3, e4.preventDefault(), this._active = true, { zoomDelta: r4 / 128 };
              }
            } else
              this._tap.touchmove(e4, t3, i3);
          }
          touchend(e4, t3, i3) {
            this._tapTime ? this._swipePoint && 0 === i3.length && this.reset() : this._tap.touchend(e4, t3, i3) && (this._tapTime = e4.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Vn {
          constructor(e4, t3, i3) {
            this._el = e4, this._mousePan = t3, this._touchPan = i3;
          }
          enable(e4) {
            this._inertiaOptions = e4 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Zn {
          constructor(e4, t3, i3) {
            this._pitchWithRotate = e4.pitchWithRotate, this._mouseRotate = t3, this._mousePitch = i3;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class Wn {
          constructor(e4, t3, i3, o3) {
            this._el = e4, this._touchZoom = t3, this._touchRotate = i3, this._tapDragZoom = o3, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e4) {
            this._touchZoom.enable(e4), this._rotationDisabled || this._touchRotate.enable(e4), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const Hn = (e4) => e4.zoom || e4.drag || e4.pitch || e4.rotate;
        class qn extends e3.b {
        }
        class Qn {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t3, i3) {
            const o3 = e3.Q.sub([], i3, t3);
            this.radius = e3.Q.length(o3[2] < 0 ? e3.Q.div([], o3, this.constants) : [o3[0], o3[1], 0]);
          }
          projectRay(t3) {
            e3.Q.div(t3, t3, this.constants), e3.Q.normalize(t3, t3), e3.Q.mul(t3, t3, this.constants);
            const i3 = e3.Q.scale([], t3, this.radius);
            if (i3[2] > 0) {
              const t4 = e3.Q.scale([], [0, 0, 1], e3.Q.dot(i3, [0, 0, 1])), o3 = e3.Q.scale([], e3.Q.normalize([], [i3[0], i3[1], 0]), this.radius), r4 = e3.Q.add([], i3, e3.Q.scale([], e3.Q.sub([], e3.Q.add([], o3, t4), i3), 2));
              i3[0] = r4[0], i3[1] = r4[1];
            }
            return i3;
          }
        }
        function $n(e4) {
          return e4.panDelta && e4.panDelta.mag() || e4.zoomDelta || e4.bearingDelta || e4.pitchDelta;
        }
        class Xn {
          constructor(t3, i3) {
            this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new an(t3), this._bearingSnap = i3.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Qn(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i3), e3.a$(["handleEvent", "handleWindowEvent"], this);
            const o3 = this._el;
            this._listeners = [[o3, "touchstart", { passive: true }], [o3, "touchmove", { passive: false }], [o3, "touchend", void 0], [o3, "touchcancel", void 0], [o3, "mousedown", void 0], [o3, "mousemove", void 0], [o3, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o3, "mouseover", void 0], [o3, "mouseout", void 0], [o3, "dblclick", void 0], [o3, "click", void 0], [o3, "keydown", { capture: false }], [o3, "keyup", void 0], [o3, "wheel", { passive: false }], [o3, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [e4, t4, i4] of this._listeners) {
              const o4 = e4 === document ? this.handleWindowEvent : this.handleEvent;
              e4.addEventListener(t4, o4, i4);
            }
          }
          destroy() {
            for (const [e4, t3, i3] of this._listeners) {
              const o3 = e4 === document ? this.handleWindowEvent : this.handleEvent;
              e4.removeEventListener(t3, o3, i3);
            }
          }
          _addDefaultHandlers(e4) {
            const t3 = this._map, i3 = t3.getCanvasContainer();
            this._add("mapEvent", new _n(t3, e4));
            const o3 = t3.boxZoom = new fn(t3, e4);
            this._add("boxZoom", o3);
            const r4 = new xn(), s4 = new Gn();
            t3.doubleClickZoom = new Un(s4, r4), this._add("tapZoom", r4), this._add("clickZoom", s4);
            const n3 = new jn();
            this._add("tapDragZoom", n3);
            const a3 = t3.touchPitch = new Mn(t3);
            this._add("touchPitch", a3);
            const l3 = new Tn(e4), c3 = new En(e4);
            t3.dragRotate = new Zn(e4, l3, c3), this._add("mouseRotate", l3, ["mousePitch"]), this._add("mousePitch", c3, ["mouseRotate"]);
            const h2 = new wn(e4), u3 = new Sn(t3, e4);
            t3.dragPan = new Vn(i3, h2, u3), this._add("mousePan", h2), this._add("touchPan", u3, ["touchZoom", "touchRotate"]);
            const d2 = new Pn(), _3 = new Rn();
            t3.touchZoomRotate = new Wn(i3, _3, d2, n3), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", _3, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new pn(t3));
            const p3 = t3.scrollZoom = new Nn(t3, this);
            this._add("scrollZoom", p3, ["mousePan"]);
            const f2 = t3.keyboard = new On();
            this._add("keyboard", f2);
            for (const i4 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
              e4.interactive && e4[i4] && t3[i4].enable(e4[i4]);
          }
          _add(e4, t3, i3) {
            this._handlers.push({ handlerName: e4, handler: t3, allowed: i3 }), this._handlersById[e4] = t3;
          }
          stop(e4) {
            if (!this._updatingCamera) {
              for (const { handler: e5 } of this._handlers)
                e5.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e4), this._changes = [], this._originalZoom = void 0;
            }
          }
          isActive() {
            for (const { handler: e4 } of this._handlers)
              if (e4.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Hn(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(e4, t3, i3) {
            for (const o3 in e4)
              if (o3 !== i3 && (!t3 || t3.indexOf(o3) < 0))
                return true;
            return false;
          }
          handleWindowEvent(e4) {
            this.handleEvent(e4, `${e4.type}Window`);
          }
          _getMapTouches(e4) {
            const t3 = [];
            for (const i3 of e4)
              this._el.contains(i3.target) && t3.push(i3);
            return t3;
          }
          handleEvent(e4, t3) {
            this._updatingCamera = true;
            const i3 = "renderFrame" === e4.type, o3 = i3 ? void 0 : e4, r4 = { needsRenderFrame: false }, s4 = {}, n3 = {}, a3 = e4.touches ? this._getMapTouches(e4.touches) : void 0, l3 = a3 ? f(this._el, a3) : i3 ? void 0 : p2(this._el, e4);
            for (const { handlerName: i4, handler: c4, allowed: h3 } of this._handlers) {
              if (!c4.isEnabled())
                continue;
              let u3;
              this._blockedByActive(n3, h3, i4) ? c4.reset() : c4[t3 || e4.type] && (u3 = c4[t3 || e4.type](e4, l3, a3), this.mergeHandlerResult(r4, s4, u3, i4, o3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || c4.isActive()) && (n3[i4] = c4);
            }
            const c3 = {};
            for (const e5 in this._previousActiveHandlers)
              n3[e5] || (c3[e5] = o3);
            this._previousActiveHandlers = n3, (Object.keys(c3).length || $n(r4)) && (this._changes.push([r4, s4, c3]), this._triggerRenderFrame()), (Object.keys(n3).length || $n(r4)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: h2 } = r4;
            h2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h2(this._map));
          }
          mergeHandlerResult(t3, i3, o3, r4, s4) {
            if (!o3)
              return;
            e3.e(t3, o3);
            const n3 = { handlerName: r4, originalEvent: o3.originalEvent || s4 };
            void 0 !== o3.zoomDelta && (i3.zoom = n3), void 0 !== o3.panDelta && (i3.drag = n3), void 0 !== o3.pitchDelta && (i3.pitch = n3), void 0 !== o3.bearingDelta && (i3.rotate = n3);
          }
          _applyChanges() {
            const t3 = {}, i3 = {}, o3 = {};
            for (const [r4, s4, n3] of this._changes)
              r4.panDelta && (t3.panDelta = (t3.panDelta || new e3.P(0, 0))._add(r4.panDelta)), r4.zoomDelta && (t3.zoomDelta = (t3.zoomDelta || 0) + r4.zoomDelta), r4.bearingDelta && (t3.bearingDelta = (t3.bearingDelta || 0) + r4.bearingDelta), r4.pitchDelta && (t3.pitchDelta = (t3.pitchDelta || 0) + r4.pitchDelta), void 0 !== r4.around && (t3.around = r4.around), void 0 !== r4.aroundCoord && (t3.aroundCoord = r4.aroundCoord), void 0 !== r4.pinchAround && (t3.pinchAround = r4.pinchAround), r4.noInertia && (t3.noInertia = r4.noInertia), e3.e(i3, s4), e3.e(o3, n3);
            this._updateMapTransform(t3, i3, o3), this._changes = [];
          }
          _updateMapTransform(t3, i3, o3) {
            const r4 = this._map, s4 = r4.transform, n3 = (e4) => [e4.x, e4.y, e4.z];
            if (((e4) => {
              const t4 = this._eventsInProgress.drag;
              return t4 && !this._handlersById[t4.handlerName].isActive();
            })() && !$n(t3)) {
              const e4 = s4.zoom;
              s4.cameraElevationReference = "sea", null != this._originalZoom && s4._orthographicProjectionAtLowPitch && "globe" !== s4.projection.name && 0 === s4.pitch ? (s4.cameraElevationReference = "ground", s4.zoom = this._originalZoom) : (s4.recenterOnTerrain(), s4.cameraElevationReference = "ground"), e4 !== s4.zoom && this._map._update(true);
            }
            if (s4._isCameraConstrained && r4._stop(true), !$n(t3))
              return void this._fireEvents(i3, o3, true);
            let { panDelta: a3, zoomDelta: l3, bearingDelta: c3, pitchDelta: h2, around: u3, aroundCoord: d2, pinchAround: _3 } = t3;
            s4._isCameraConstrained && (l3 > 0 && (l3 = 0), s4._isCameraConstrained = false), void 0 !== _3 && (u3 = _3), (l3 || ((e4) => i3[e4] && !this._eventsInProgress[e4])("drag")) && u3 && (this._dragOrigin = n3(s4.pointCoordinate3D(u3)), this._originalZoom = s4.zoom, this._trackingEllipsoid.setup(s4._camera.position, this._dragOrigin)), s4.cameraElevationReference = "sea", r4._stop(true), u3 = u3 || r4.transform.centerPoint, c3 && (s4.bearing += c3), h2 && (s4.pitch += h2), s4._updateCameraState();
            const p3 = [0, 0, 0];
            if (a3)
              if ("mercator" === s4.projection.name) {
                const e4 = this._trackingEllipsoid.projectRay(s4.screenPointToMercatorRay(u3).dir), t4 = this._trackingEllipsoid.projectRay(s4.screenPointToMercatorRay(u3.sub(a3)).dir);
                p3[0] = t4[0] - e4[0], p3[1] = t4[1] - e4[1];
              } else {
                const t4 = s4.pointCoordinate(u3);
                if ("globe" === s4.projection.name) {
                  a3 = a3.rotate(-s4.angle);
                  const i4 = s4._pixelsPerMercatorPixel / s4.worldSize;
                  p3[0] = -a3.x * e3.d9(e3.ax(t4.y)) * i4, p3[1] = -a3.y * e3.d9(s4.center.lat) * i4;
                } else {
                  const e4 = s4.pointCoordinate(u3.sub(a3));
                  t4 && e4 && (p3[0] = e4.x - t4.x, p3[1] = e4.y - t4.y);
                }
              }
            const f2 = s4.zoom, m2 = [0, 0, 0];
            if (l3) {
              const t4 = n3(d2 || s4.pointCoordinate3D(u3)), i4 = { dir: e3.Q.normalize([], e3.Q.sub([], t4, s4._camera.position)) };
              if (i4.dir[2] < 0) {
                const o4 = s4.zoomDeltaToMovement(t4, l3);
                e3.Q.scale(m2, i4.dir, o4);
              }
            }
            const g3 = e3.Q.add(p3, p3, m2);
            s4._translateCameraConstrained(g3), l3 && Math.abs(s4.zoom - f2) > 1e-4 && s4.recenterOnTerrain(), s4.cameraElevationReference = "ground", this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(i3, o3, true);
          }
          _fireEvents(t3, i3, o3) {
            const r4 = Hn(this._eventsInProgress), s4 = Hn(t3), n3 = {};
            for (const e4 in t3) {
              const { originalEvent: i4 } = t3[e4];
              this._eventsInProgress[e4] || (n3[`${e4}start`] = i4), this._eventsInProgress[e4] = t3[e4];
            }
            !r4 && s4 && this._fireEvent("movestart", s4.originalEvent);
            for (const e4 in n3)
              this._fireEvent(e4, n3[e4]);
            s4 && this._fireEvent("move", s4.originalEvent);
            for (const e4 in t3) {
              const { originalEvent: i4 } = t3[e4];
              this._fireEvent(e4, i4);
            }
            const a3 = {};
            let l3;
            for (const e4 in this._eventsInProgress) {
              const { handlerName: t4, originalEvent: o4 } = this._eventsInProgress[e4];
              this._handlersById[t4].isActive() || (delete this._eventsInProgress[e4], l3 = i3[t4] || o4, a3[`${e4}end`] = l3);
            }
            for (const e4 in a3)
              this._fireEvent(e4, a3[e4]);
            const c3 = Hn(this._eventsInProgress);
            if (o3 && (r4 || s4) && !c3) {
              this._updatingCamera = true;
              const t4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i4 = (e4) => 0 !== e4 && -this._bearingSnap < e4 && e4 < this._bearingSnap;
              t4 ? (i4(t4.bearing || this._map.getBearing()) && (t4.bearing = 0), this._map.easeTo(t4, { originalEvent: l3 })) : (this._map.fire(new e3.b("moveend", { originalEvent: l3 })), i4(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(t3, i3) {
            this._map.fire(new e3.b(t3, i3 ? { originalEvent: i3 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e4) => {
              this._frameId = void 0, this.handleEvent(new qn("renderFrame", { timeStamp: e4 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        const Yn = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Jn extends e3.E {
          constructor(t3, i3) {
            super(), this._moving = false, this._zooming = false, this.transform = t3, this._bearingSnap = i3.bearingSnap, this._respectPrefersReducedMotion = false !== i3.respectPrefersReducedMotion, e3.a$(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new e3.bq(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e4, t3) {
            return this.jumpTo({ center: e4 }, t3);
          }
          panBy(t3, i3, o3) {
            return t3 = e3.P.convert(t3).mult(-1), this.panTo(this.transform.center, e3.e({ offset: t3 }, i3), o3);
          }
          panTo(t3, i3, o3) {
            return this.easeTo(e3.e({ center: t3 }, i3), o3);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e4, t3) {
            return this.jumpTo({ zoom: e4 }, t3), this;
          }
          zoomTo(t3, i3, o3) {
            return this.easeTo(e3.e({ zoom: t3 }, i3), o3);
          }
          zoomIn(e4, t3) {
            return this.zoomTo(this.getZoom() + 1, e4, t3), this;
          }
          zoomOut(e4, t3) {
            return this.zoomTo(this.getZoom() - 1, e4, t3), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e4, t3) {
            return this.jumpTo({ bearing: e4 }, t3), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e4, t3) {
            return this.jumpTo({ padding: e4 }, t3), this;
          }
          rotateTo(t3, i3, o3) {
            return this.easeTo(e3.e({ bearing: t3 }, i3), o3);
          }
          resetNorth(t3, i3) {
            return this.rotateTo(0, e3.e({ duration: 1e3 }, t3), i3), this;
          }
          resetNorthPitch(t3, i3) {
            return this.easeTo(e3.e({ bearing: 0, pitch: 0, duration: 1e3 }, t3), i3), this;
          }
          snapToNorth(e4, t3) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e4, t3) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e4, t3) {
            return this.jumpTo({ pitch: e4 }, t3), this;
          }
          cameraForBounds(t3, i3) {
            t3 = e3.ag.convert(t3);
            const o3 = i3 && i3.bearing || 0, r4 = i3 && i3.pitch || 0, s4 = t3.getNorthWest(), n3 = t3.getSouthEast();
            return this._cameraForBounds(this.transform, s4, n3, o3, r4, i3);
          }
          _extendPadding(t3) {
            const i3 = { top: 0, right: 0, bottom: 0, left: 0 };
            return null == t3 ? e3.e({}, i3, this.transform.padding) : "number" == typeof t3 ? { top: t3, bottom: t3, right: t3, left: t3 } : e3.e({}, i3, t3);
          }
          _extendCameraOptions(t3) {
            return (t3 = e3.e({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t3)).padding = this._extendPadding(t3.padding), t3;
          }
          _minimumAABBFrustumDistance(e4, t3) {
            const i3 = t3.max[0] - t3.min[0], o3 = t3.max[1] - t3.min[1];
            return i3 / o3 > e4.aspect ? i3 / (2 * Math.tan(0.5 * e4.fovX) * e4.aspect) : o3 / (2 * Math.tan(0.5 * e4.fovY) * e4.aspect);
          }
          _cameraForBoundsOnGlobe(t3, i3, o3, r4, s4, n3) {
            const a3 = t3.clone(), l3 = this._extendCameraOptions(n3);
            a3.bearing = r4, a3.pitch = s4;
            const c3 = e3.bq.convert(i3), h2 = e3.bq.convert(o3), u3 = 0.5 * (c3.lat + h2.lat), d2 = 0.5 * (c3.lng + h2.lng), _3 = e3.da(u3, d2), p3 = e3.Q.normalize([], _3), f2 = e3.Q.normalize([], e3.Q.cross([], p3, [0, 1, 0])), m2 = e3.Q.cross([], f2, p3), g3 = [f2[0], f2[1], f2[2], 0, m2[0], m2[1], m2[2], 0, p3[0], p3[1], p3[2], 0, 0, 0, 0, 1], v3 = [_3, e3.da(c3.lat, c3.lng), e3.da(h2.lat, c3.lng), e3.da(h2.lat, h2.lng), e3.da(c3.lat, h2.lng), e3.da(u3, c3.lng), e3.da(u3, h2.lng), e3.da(c3.lat, d2), e3.da(h2.lat, d2)];
            let x3 = e3.bV.fromPoints(v3.map((t4) => [e3.Q.dot(f2, t4), e3.Q.dot(m2, t4), e3.Q.dot(p3, t4)]));
            const y3 = e3.Q.transformMat4([], x3.center, g3);
            0 === e3.Q.squaredLength(y3) && e3.Q.set(y3, 0, 0, 1), e3.Q.normalize(y3, y3), e3.Q.scale(y3, y3, e3.ae), a3.center = e3.db(y3);
            const b2 = a3.getWorldToCameraMatrix(), w2 = e3.a9.invert(new Float64Array(16), b2);
            x3 = e3.bV.applyTransform(x3, e3.a9.multiply([], b2, g3));
            const T2 = this._extendAABB(x3, a3, l3, r4);
            if (!T2)
              return void e3.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            x3 = T2, e3.Q.transformMat4(y3, y3, b2);
            const E2 = 0.5 * (x3.max[2] - x3.min[2]), S2 = this._minimumAABBFrustumDistance(a3, x3), C2 = e3.Q.scale([], [0, 0, 1], E2), I2 = e3.Q.add(C2, y3, C2), D2 = S2 + (0 === a3.pitch ? 0 : e3.Q.distance(y3, I2)), R3 = a3.globeCenterInViewSpace, A2 = e3.Q.sub([], y3, [R3[0], R3[1], R3[2]]);
            e3.Q.normalize(A2, A2), e3.Q.scale(A2, A2, D2);
            const P2 = e3.Q.add([], y3, A2);
            e3.Q.transformMat4(P2, P2, w2);
            const L2 = e3.dc / e3.ae, M3 = e3.Q.length(P2), z3 = e3.bo(Math.max(M3 * L2 - e3.dc, Number.EPSILON), 0), O2 = Math.min(a3.zoomFromMercatorZAdjusted(z3), l3.maxZoom);
            return O2 > 0.5 * (e3.bJ + e3.bA) ? (a3.setProjection({ name: "mercator" }), a3.zoom = O2, this._cameraForBounds(a3, i3, o3, r4, s4, n3)) : { center: a3.center, zoom: O2, bearing: r4, pitch: s4 };
          }
          _extendAABB(t3, i3, o3, r4) {
            const s4 = 0.5 * ((o3.padding.left || 0) + (o3.padding.right || 0)), n3 = 0.5 * ((o3.padding.top || 0) + (o3.padding.bottom || 0)), a3 = n3, l3 = s4, c3 = s4, h2 = n3, u3 = i3.width - (l3 + c3), d2 = i3.height - (a3 + h2), _3 = e3.Q.sub([], t3.max, t3.min), p3 = Math.min(u3 / _3[0], d2 / _3[1]), f2 = Math.min(i3.scaleZoom(i3.scale * p3), o3.maxZoom);
            if (isNaN(f2))
              return null;
            const m2 = i3.scale / i3.zoomScale(f2), g3 = new e3.bV([t3.min[0] - l3 * m2, t3.min[1] - h2 * m2, t3.min[2]], [t3.max[0] + c3 * m2, t3.max[1] + a3 * m2, t3.max[2]]), v3 = ("number" == typeof o3.offset.x && "number" == typeof o3.offset.y ? new e3.P(o3.offset.x, o3.offset.y) : e3.P.convert(o3.offset)).rotate(-e3.bm(r4));
            return g3.center[0] -= v3.x * m2, g3.center[1] += v3.y * m2, g3;
          }
          queryTerrainElevation(t3, i3) {
            const o3 = this.transform.elevation;
            return o3 ? (i3 = e3.e({}, { exaggerated: true }, i3), o3.getAtPoint(e3.O.fromLngLat(t3), null, i3.exaggerated)) : null;
          }
          _cameraForBounds(t3, i3, o3, r4, s4, n3) {
            if ("globe" === t3.projection.name)
              return this._cameraForBoundsOnGlobe(t3, i3, o3, r4, s4, n3);
            const a3 = t3.clone(), l3 = this._extendCameraOptions(n3);
            a3.bearing = r4, a3.pitch = s4;
            const c3 = e3.bq.convert(i3), h2 = e3.bq.convert(o3), u3 = new e3.bq(c3.lng, h2.lat), d2 = new e3.bq(h2.lng, c3.lat), _3 = a3.project(c3), p3 = a3.project(h2), f2 = this.queryTerrainElevation(c3), m2 = this.queryTerrainElevation(h2), g3 = this.queryTerrainElevation(u3), v3 = this.queryTerrainElevation(d2), x3 = [[_3.x, _3.y, Math.min(f2 || 0, m2 || 0, g3 || 0, v3 || 0)], [p3.x, p3.y, Math.max(f2 || 0, m2 || 0, g3 || 0, v3 || 0)]];
            let y3 = e3.bV.fromPoints(x3);
            const b2 = a3.getWorldToCameraMatrix(), w2 = e3.a9.invert(new Float64Array(16), b2);
            y3 = e3.bV.applyTransform(y3, b2);
            const T2 = this._extendAABB(y3, a3, l3, r4);
            if (!T2)
              return void e3.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            y3 = T2;
            const E2 = 0.5 * e3.Q.sub([], y3.max, y3.min)[2], S2 = this._minimumAABBFrustumDistance(a3, y3), C2 = [0, 0, 1, 0];
            e3.aa.transformMat4(C2, C2, b2), e3.aa.normalize(C2, C2);
            const I2 = e3.Q.scale([], C2, S2 + E2), D2 = e3.Q.add([], y3.center, I2);
            e3.Q.transformMat4(y3.center, y3.center, w2), e3.Q.transformMat4(D2, D2, w2);
            const R3 = [y3.center[0], y3.center[1], D2[2] * a3.pixelsPerMeter];
            e3.Q.scale(R3, R3, 1 / a3.worldSize);
            const A2 = e3.aw(R3[0]), P2 = e3.ax(R3[1]), L2 = Math.min(a3._zoomFromMercatorZ(R3[2]), l3.maxZoom), M3 = new e3.bq(A2, P2);
            return a3.mercatorFromTransition && L2 < 0.5 * (e3.bJ + e3.bA) ? (a3.setProjection({ name: "globe" }), a3.zoom = L2, this._cameraForBounds(a3, i3, o3, r4, s4, n3)) : { center: M3, zoom: L2, bearing: r4, pitch: s4 };
          }
          fitBounds(e4, t3, i3) {
            const o3 = this.cameraForBounds(e4, t3);
            return this._fitInternal(o3, t3, i3);
          }
          fitScreenCoordinates(t3, i3, o3, r4, s4) {
            const n3 = e3.P.convert(t3), a3 = e3.P.convert(i3), l3 = new e3.P(Math.min(n3.x, a3.x), Math.min(n3.y, a3.y)), c3 = new e3.P(Math.max(n3.x, a3.x), Math.max(n3.y, a3.y));
            if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n3, a3))
              return this;
            const h2 = this.transform.pointLocation3D(l3), u3 = this.transform.pointLocation3D(c3), d2 = this.transform.pointLocation3D(new e3.P(l3.x, c3.y)), _3 = this.transform.pointLocation3D(new e3.P(c3.x, l3.y)), p3 = [Math.min(h2.lng, u3.lng, d2.lng, _3.lng), Math.min(h2.lat, u3.lat, d2.lat, _3.lat)], f2 = [Math.max(h2.lng, u3.lng, d2.lng, _3.lng), Math.max(h2.lat, u3.lat, d2.lat, _3.lat)], m2 = r4 && r4.pitch ? r4.pitch : this.getPitch(), g3 = this._cameraForBounds(this.transform, p3, f2, o3, m2, r4);
            return this._fitInternal(g3, r4, s4);
          }
          _fitInternal(t3, i3, o3) {
            return t3 ? (i3 = e3.e(t3, i3)).linear ? this.easeTo(i3, o3) : this.flyTo(i3, o3) : this;
          }
          jumpTo(t3, i3) {
            this.stop();
            const o3 = t3.preloadOnly ? this.transform.clone() : this.transform;
            let r4 = false, s4 = false, n3 = false;
            return "zoom" in t3 && o3.zoom !== +t3.zoom && (r4 = true, o3.zoom = +t3.zoom), void 0 !== t3.center && (o3.center = e3.bq.convert(t3.center)), "bearing" in t3 && o3.bearing !== +t3.bearing && (s4 = true, o3.bearing = +t3.bearing), "pitch" in t3 && o3.pitch !== +t3.pitch && (n3 = true, o3.pitch = +t3.pitch), null == t3.padding || o3.isPaddingEqual(t3.padding) || (o3.padding = t3.padding), t3.preloadOnly ? (this._preloadTiles(o3), this) : (this.fire(new e3.b("movestart", i3)).fire(new e3.b("move", i3)), r4 && this.fire(new e3.b("zoomstart", i3)).fire(new e3.b("zoom", i3)).fire(new e3.b("zoomend", i3)), s4 && this.fire(new e3.b("rotatestart", i3)).fire(new e3.b("rotate", i3)).fire(new e3.b("rotateend", i3)), n3 && this.fire(new e3.b("pitchstart", i3)).fire(new e3.b("pitch", i3)).fire(new e3.b("pitchend", i3)), this.fire(new e3.b("moveend", i3)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || e3.w(Yn), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t3, i3) {
            const o3 = this.transform;
            if (!o3.projection.supportsFreeCamera)
              return e3.w(Yn), this;
            this.stop();
            const r4 = o3.zoom, s4 = o3.pitch, n3 = o3.bearing;
            o3.setFreeCameraOptions(t3);
            const a3 = r4 !== o3.zoom, l3 = s4 !== o3.pitch, c3 = n3 !== o3.bearing;
            return this.fire(new e3.b("movestart", i3)).fire(new e3.b("move", i3)), a3 && this.fire(new e3.b("zoomstart", i3)).fire(new e3.b("zoom", i3)).fire(new e3.b("zoomend", i3)), c3 && this.fire(new e3.b("rotatestart", i3)).fire(new e3.b("rotate", i3)).fire(new e3.b("rotateend", i3)), l3 && this.fire(new e3.b("pitchstart", i3)).fire(new e3.b("pitch", i3)).fire(new e3.b("pitchend", i3)), this.fire(new e3.b("moveend", i3)), this;
          }
          easeTo(t3, i3) {
            this._stop(false, t3.easeId), (false === (t3 = e3.e({ offset: [0, 0], duration: 500, easing: e3.d8 }, t3)).animate || this._prefersReducedMotion(t3)) && (t3.duration = 0);
            const o3 = this.transform, r4 = this.getZoom(), s4 = this.getBearing(), n3 = this.getPitch(), a3 = this.getPadding(), l3 = "zoom" in t3 ? +t3.zoom : r4, c3 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, s4) : s4, h2 = "pitch" in t3 ? +t3.pitch : n3, u3 = this._extendPadding(t3.padding), d2 = e3.P.convert(t3.offset);
            let _3, p3, f2;
            if ("globe" === o3.projection.name) {
              const i4 = e3.O.fromLngLat(o3.center), r5 = d2.rotate(-o3.angle);
              i4.x += r5.x / o3.worldSize, i4.y += r5.y / o3.worldSize;
              const s5 = i4.toLngLat(), n4 = e3.bq.convert(t3.center || s5);
              this._normalizeCenter(n4), _3 = o3.centerPoint.add(r5), p3 = new e3.P(i4.x, i4.y).mult(o3.worldSize), f2 = new e3.P(e3.a8(n4.lng), e3.ah(n4.lat)).mult(o3.worldSize).sub(p3);
            } else {
              _3 = o3.centerPoint.add(d2);
              const i4 = o3.pointLocation(_3), r5 = e3.bq.convert(t3.center || i4);
              this._normalizeCenter(r5), p3 = o3.project(i4), f2 = o3.project(r5).sub(p3);
            }
            const m2 = o3.zoomScale(l3 - r4);
            let g3, v3;
            t3.around && (g3 = e3.bq.convert(t3.around), v3 = o3.locationPoint(g3));
            const x3 = this._zooming || l3 !== r4, y3 = this._rotating || s4 !== c3, b2 = this._pitching || h2 !== n3, w2 = !o3.isPaddingEqual(u3), T2 = (o4) => (T3) => {
              if (x3 && (o4.zoom = e3.X(r4, l3, T3)), y3 && (o4.bearing = e3.X(s4, c3, T3)), b2 && (o4.pitch = e3.X(n3, h2, T3)), w2 && (o4.interpolatePadding(a3, u3, T3), _3 = o4.centerPoint.add(d2)), g3)
                o4.setLocationAtPoint(g3, v3);
              else {
                const e4 = o4.zoomScale(o4.zoom - r4), t4 = l3 > r4 ? Math.min(2, m2) : Math.max(0.5, m2), i4 = Math.pow(t4, 1 - T3), s5 = o4.unproject(p3.add(f2.mult(T3 * i4)).mult(e4));
                o4.setLocationAtPoint(o4.renderWorldCopies ? s5.wrap() : s5, _3);
              }
              return t3.preloadOnly || this._fireMoveEvents(i3), o4;
            };
            if (t3.preloadOnly) {
              const e4 = this._emulate(T2, t3.duration, o3);
              return this._preloadTiles(e4), this;
            }
            const E2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = x3, this._rotating = y3, this._pitching = b2, this._padding = w2, this._easeId = t3.easeId, this._prepareEase(i3, t3.noMoveStart, E2), this._ease(T2(o3), (e4) => {
              "sea" === o3.cameraElevationReference && o3.recenterOnTerrain(), this._afterEase(i3, e4);
            }, t3), this;
          }
          _prepareEase(t3, i3, o3 = {}) {
            this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i3 || o3.moving || this.fire(new e3.b("movestart", t3)), this._zooming && !o3.zooming && this.fire(new e3.b("zoomstart", t3)), this._rotating && !o3.rotating && this.fire(new e3.b("rotatestart", t3)), this._pitching && !o3.pitching && this.fire(new e3.b("pitchstart", t3));
          }
          _fireMoveEvents(t3) {
            this.fire(new e3.b("move", t3)), this._zooming && this.fire(new e3.b("zoom", t3)), this._rotating && this.fire(new e3.b("rotate", t3)), this._pitching && this.fire(new e3.b("pitch", t3));
          }
          _afterEase(t3, i3) {
            if (this._easeId && i3 && this._easeId === i3)
              return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const o3 = this._zooming, r4 = this._rotating, s4 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o3 && this.fire(new e3.b("zoomend", t3)), r4 && this.fire(new e3.b("rotateend", t3)), s4 && this.fire(new e3.b("pitchend", t3)), this.fire(new e3.b("moveend", t3));
          }
          flyTo(t3, i3) {
            if (this._prefersReducedMotion(t3)) {
              const o4 = e3.af(t3, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o4, i3);
            }
            this.stop(), t3 = e3.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e3.d8 }, t3);
            const o3 = this.transform, r4 = this.getZoom(), s4 = this.getBearing(), n3 = this.getPitch(), a3 = this.getPadding(), l3 = "zoom" in t3 ? e3.ad(+t3.zoom, o3.minZoom, o3.maxZoom) : r4, c3 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, s4) : s4, h2 = "pitch" in t3 ? +t3.pitch : n3, u3 = this._extendPadding(t3.padding), d2 = o3.zoomScale(l3 - r4), _3 = e3.P.convert(t3.offset);
            let p3 = o3.centerPoint.add(_3);
            const f2 = o3.pointLocation(p3), m2 = e3.bq.convert(t3.center || f2);
            this._normalizeCenter(m2);
            const g3 = o3.project(f2), v3 = o3.project(m2).sub(g3);
            let x3 = t3.curve;
            const y3 = Math.max(o3.width, o3.height), b2 = y3 / d2, w2 = v3.mag();
            if ("minZoom" in t3) {
              const i4 = e3.ad(Math.min(t3.minZoom, r4, l3), o3.minZoom, o3.maxZoom), s5 = y3 / o3.zoomScale(i4 - r4);
              x3 = Math.sqrt(s5 / w2 * 2);
            }
            const T2 = x3 * x3;
            function E2(e4) {
              const t4 = (b2 * b2 - y3 * y3 + (e4 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e4 ? b2 : y3) * T2 * w2);
              return Math.log(Math.sqrt(t4 * t4 + 1) - t4);
            }
            function S2(e4) {
              return (Math.exp(e4) - Math.exp(-e4)) / 2;
            }
            function C2(e4) {
              return (Math.exp(e4) + Math.exp(-e4)) / 2;
            }
            const I2 = E2(0);
            let D2 = function(e4) {
              return C2(I2) / C2(I2 + x3 * e4);
            }, R3 = function(e4) {
              return y3 * ((C2(I2) * (S2(t4 = I2 + x3 * e4) / C2(t4)) - S2(I2)) / T2) / w2;
              var t4;
            }, A2 = (E2(1) - I2) / x3;
            if (Math.abs(w2) < 1e-6 || !isFinite(A2)) {
              if (Math.abs(y3 - b2) < 1e-6)
                return this.easeTo(t3, i3);
              const e4 = b2 < y3 ? -1 : 1;
              A2 = Math.abs(Math.log(b2 / y3)) / x3, R3 = function() {
                return 0;
              }, D2 = function(t4) {
                return Math.exp(e4 * x3 * t4);
              };
            }
            t3.duration = "duration" in t3 ? +t3.duration : 1e3 * A2 / ("screenSpeed" in t3 ? +t3.screenSpeed / x3 : +t3.speed), t3.maxDuration && t3.duration > t3.maxDuration && (t3.duration = 0);
            const P2 = s4 !== c3, L2 = h2 !== n3, M3 = !o3.isPaddingEqual(u3), z3 = (o4) => (d3) => {
              const f3 = d3 * A2, x4 = 1 / D2(f3);
              o4.zoom = 1 === d3 ? l3 : r4 + o4.scaleZoom(x4), P2 && (o4.bearing = e3.X(s4, c3, d3)), L2 && (o4.pitch = e3.X(n3, h2, d3)), M3 && (o4.interpolatePadding(a3, u3, d3), p3 = o4.centerPoint.add(_3));
              const y4 = 1 === d3 ? m2 : o4.unproject(g3.add(v3.mult(R3(f3))).mult(x4));
              return o4.setLocationAtPoint(o4.renderWorldCopies ? y4.wrap() : y4, p3), o4._updateCameraOnTerrain(), t3.preloadOnly || this._fireMoveEvents(i3), o4;
            };
            if (t3.preloadOnly) {
              const e4 = this._emulate(z3, t3.duration, o3);
              return this._preloadTiles(e4), this;
            }
            return this._zooming = true, this._rotating = P2, this._pitching = L2, this._padding = M3, this._prepareEase(i3, false), this._ease(z3(o3), () => this._afterEase(i3), t3), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _requestRenderFrame(e4) {
          }
          _cancelRenderFrame(e4) {
          }
          _stop(e4, t3) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const e5 = this._onEaseEnd;
              this._onEaseEnd = void 0, e5.call(this, t3);
            }
            if (!e4) {
              const e5 = this.handlers;
              e5 && e5.stop(false);
            }
            return this;
          }
          _ease(t3, i3, o3) {
            false === o3.animate || 0 === o3.duration ? (t3(1), i3()) : (this._easeStart = e3.f.now(), this._easeOptions = o3, this._onEaseFrame = t3, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t3 = Math.min((e3.f.now() - this._easeStart) / this._easeOptions.duration, 1), i3 = this._onEaseFrame;
            i3 && i3(this._easeOptions.easing(t3)), t3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t3, i3) {
            t3 = e3.bk(t3, -180, 180);
            const o3 = Math.abs(t3 - i3);
            return Math.abs(t3 - 360 - i3) < o3 && (t3 -= 360), Math.abs(t3 + 360 - i3) < o3 && (t3 += 360), t3;
          }
          _normalizeCenter(e4) {
            const t3 = this.transform;
            if (t3.maxBounds)
              return;
            if ("globe" !== t3.projection.name && !t3.renderWorldCopies)
              return;
            const i3 = e4.lng - t3.center.lng;
            e4.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
          }
          _prefersReducedMotion(t3) {
            return this._respectPrefersReducedMotion && e3.f.prefersReducedMotion && !(t3 && t3.essential);
          }
          _emulate(e4, t3, i3) {
            const o3 = Math.ceil(15 * t3 / 1e3), r4 = [], s4 = e4(i3.clone());
            for (let e5 = 0; e5 <= o3; e5++) {
              const t4 = s4(e5 / o3);
              r4.push(t4.clone());
            }
            return r4;
          }
          _preloadTiles(e4, t3) {
          }
        }
        class Kn {
          constructor(t3 = {}) {
            this.options = t3, e3.a$(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e4) {
            const t3 = this.options && this.options.compact;
            return this._map = e4, this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = s3("button", "mapboxgl-ctrl-attrib-button", this._container), s3("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = s3("div", "mapboxgl-ctrl-attrib-inner", this._container), t3 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t3 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e4, t3) {
            const i3 = this._map._getUIString(`AttributionControl.${t3}`);
            e4.removeAttribute("title"), e4.firstElementChild && e4.firstElementChild.setAttribute("title", i3);
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t3 = this._editLink;
            t3 || (t3 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const i3 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e3.dd.ACCESS_TOKEN }];
            if (t3) {
              const o3 = i3.reduce((e4, t4, o4) => (t4.value && (e4 += `${t4.key}=${t4.value}${o4 < i3.length - 1 ? "&" : ""}`), e4), "?");
              t3.href = `${e3.dd.FEEDBACK_URL}/${o3}#${en(this._map, true)}`, t3.rel = "noopener nofollow", this._setElementTitle(t3, "MapFeedback");
            }
          }
          _updateData(e4) {
            !e4 || "metadata" !== e4.sourceDataType && "visibility" !== e4.sourceDataType && "style" !== e4.dataType || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let e4 = [];
            if (this._map.style.stylesheet) {
              const e5 = this._map.style.stylesheet;
              this.styleOwner = e5.owner, this.styleId = e5.id;
            }
            const t3 = this._map.style._mergedSourceCaches;
            for (const i4 in t3) {
              const o3 = t3[i4];
              if (o3.used) {
                const t4 = o3.getSource();
                t4.attribution && e4.indexOf(t4.attribution) < 0 && e4.push(t4.attribution);
              }
            }
            e4.sort((e5, t4) => e5.length - t4.length), e4 = e4.filter((t4, i4) => {
              for (let o3 = i4 + 1; o3 < e4.length; o3++)
                if (e4[o3].indexOf(t4) >= 0)
                  return false;
              return true;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e4 = [...this.options.customAttribution, ...e4] : e4.unshift(this.options.customAttribution));
            const i3 = e4.join(" | ");
            i3 !== this._attribHTML && (this._attribHTML = i3, e4.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class ea {
          constructor() {
            e3.a$(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(e4) {
            this._map = e4, this._container = s3("div", "mapboxgl-ctrl");
            const t3 = s3("a", "mapboxgl-ctrl-logo");
            return t3.target = "_blank", t3.rel = "noopener nofollow", t3.href = "https://www.mapbox.com/", t3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t3), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(e4) {
            e4 && "metadata" !== e4.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style)
              return true;
            const e4 = this._map.style._sourceCaches;
            if (0 === Object.entries(e4).length)
              return true;
            for (const t3 in e4) {
              const i3 = e4[t3].getSource();
              if (i3.hasOwnProperty("mapbox_logo") && !i3.mapbox_logo)
                return false;
            }
            return true;
          }
          _updateCompact() {
            const e4 = this._container.children;
            if (e4.length) {
              const t3 = e4[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? t3.classList.add("mapboxgl-compact") : t3.classList.remove("mapboxgl-compact");
            }
          }
        }
        class ta {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e4) {
            const t3 = ++this._id;
            return this._queue.push({ callback: e4, id: t3, cancelled: false }), t3;
          }
          remove(e4) {
            const t3 = this._currentlyRunning, i3 = t3 ? this._queue.concat(t3) : this._queue;
            for (const t4 of i3)
              if (t4.id === e4)
                return void (t4.cancelled = true);
          }
          run(e4 = 0) {
            const t3 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i3 of t3)
              if (!i3.cancelled && (i3.callback(e4), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        function ia(t3, i3, o3) {
          if (t3 = new e3.bq(t3.lng, t3.lat), i3) {
            const r4 = new e3.bq(t3.lng - 360, t3.lat), s4 = new e3.bq(t3.lng + 360, t3.lat), n3 = 360 * Math.ceil(Math.abs(t3.lng - o3.center.lng) / 360), a3 = o3.locationPoint(t3).distSqr(i3), l3 = i3.x < 0 || i3.y < 0 || i3.x > o3.width || i3.y > o3.height;
            o3.locationPoint(r4).distSqr(i3) < a3 && (l3 || Math.abs(r4.lng - o3.center.lng) < n3) ? t3 = r4 : o3.locationPoint(s4).distSqr(i3) < a3 && (l3 || Math.abs(s4.lng - o3.center.lng) < n3) && (t3 = s4);
          }
          for (; Math.abs(t3.lng - o3.center.lng) > 180; ) {
            const e4 = o3.locationPoint(t3);
            if (e4.x >= 0 && e4.y >= 0 && e4.x <= o3.width && e4.y <= o3.height)
              break;
            t3.lng > o3.center.lng ? t3.lng -= 360 : t3.lng += 360;
          }
          return t3;
        }
        const oa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class ra extends e3.E {
          constructor(t3, i3) {
            if (super(), (t3 instanceof HTMLElement || i3) && (t3 = e3.e({ element: t3 }, i3)), e3.a$(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t3 && t3.anchor || "center", this._color = t3 && t3.color || "#3FB1CE", this._scale = t3 && t3.scale || 1, this._draggable = t3 && t3.draggable || false, this._clickTolerance = t3 && t3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t3 && t3.rotation || 0, this._rotationAlignment = t3 && t3.rotationAlignment || "auto", this._pitchAlignment = t3 && t3.pitchAlignment && t3.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t3 && t3.occludedOpacity || 0.2, t3 && t3.element)
              this._element = t3.element, this._offset = e3.P.convert(t3 && t3.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = s3("div");
              const i4 = 41, o4 = 27, r5 = n2("svg", { display: "block", height: i4 * this._scale + "px", width: o4 * this._scale + "px", viewBox: `0 0 ${o4} ${i4}` }, this._element), a3 = n2("radialGradient", { id: "shadowGradient" }, n2("defs", {}, r5));
              n2("stop", { offset: "10%", "stop-opacity": 0.4 }, a3), n2("stop", { offset: "100%", "stop-opacity": 0.05 }, a3), n2("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r5), n2("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r5), n2("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r5), n2("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r5), this._offset = e3.P.convert(t3 && t3.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e4) => {
              e4.preventDefault();
            }), this._element.addEventListener("mousedown", (e4) => {
              e4.preventDefault();
            });
            const o3 = this._element.classList;
            for (const e4 in oa)
              o3.remove(`mapboxgl-marker-anchor-${e4}`);
            o3.add(`mapboxgl-marker-anchor-${this._anchor}`);
            const r4 = t3 && t3.className ? t3.className.trim().split(/\s+/) : [];
            o3.add(...r4), this._popup = null;
          }
          addTo(e4) {
            return e4 === this._map || (this.remove(), this._map = e4, e4.getCanvasContainer().appendChild(this._element), e4.on("move", this._updateMoving), e4.on("moveend", this._update), e4.on("remove", this._clearFadeTimer), e4._addMarker(this), this.setDraggable(this._draggable), this._update(), e4.on("click", this._onMapClick)), this;
          }
          remove() {
            const e4 = this._map;
            return e4 && (e4.off("click", this._onMapClick), e4.off("move", this._updateMoving), e4.off("moveend", this._update), e4.off("mousedown", this._addDragHandler), e4.off("touchstart", this._addDragHandler), e4.off("mouseup", this._onUp), e4.off("touchend", this._onUp), e4.off("mousemove", this._onMove), e4.off("touchmove", this._onMove), e4.off("remove", this._clearFadeTimer), e4._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            return this._lngLat = e3.bq.convert(t3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e4) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e4) {
              if (!("offset" in e4.options)) {
                const t3 = 38.1, i3 = 13.5, o3 = Math.sqrt(Math.pow(i3, 2) / 2);
                e4.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t3], "bottom-left": [o3, -1 * (t3 - i3 + o3)], "bottom-right": [-o3, -1 * (t3 - i3 + o3)], left: [i3, -1 * (t3 - i3)], right: [-i3, -1 * (t3 - i3)] } : this._offset;
              }
              this._popup = e4, e4._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(e4) {
            const t3 = e4.code, i3 = e4.charCode || e4.keyCode;
            "Space" !== t3 && "Enter" !== t3 && 32 !== i3 && 13 !== i3 || this.togglePopup();
          }
          _onMapClick(e4) {
            const t3 = e4.originalEvent.target, i3 = this._element;
            this._popup && (t3 === i3 || i3.contains(t3)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e4 = this._popup;
            return e4 ? (e4.isOpen() ? (e4.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e4.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const e4 = this._map, t3 = this._pos;
            if (!e4 || !t3)
              return false;
            const i3 = e4.unproject(t3), o3 = e4.getFreeCameraOptions();
            if (!o3.position)
              return false;
            const r4 = o3.position.toLngLat();
            return r4.distanceTo(i3) < 0.9 * r4.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t3 = this._map;
            if (!t3)
              return;
            const i3 = this._pos;
            if (!i3 || i3.x < 0 || i3.x > t3.transform.width || i3.y < 0 || i3.y > t3.transform.height)
              return void this._clearFadeTimer();
            const o3 = t3.unproject(i3);
            let r4;
            t3._showingGlobe() && e3.de(t3.transform, this._lngLat) ? r4 = 0 : (r4 = 1 - t3._queryFogOpacity(o3), t3.transform._terrainEnabled() && t3.getTerrain() && this._behindTerrain() && (r4 *= this._occludedOpacity)), this._element.style.opacity = `${r4}`, this._element.style.pointerEvents = r4 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r4), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const e4 = this._pos;
            if (!e4 || !this._map)
              return;
            const t3 = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${e4.x}px,${e4.y}px)
            ${oa[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t3.x}px,${t3.y}px)
        `;
          }
          _calculateXYTransform() {
            const t3 = this._pos, i3 = this._map, o3 = this.getPitchAlignment();
            if (!i3 || !t3 || "map" !== o3)
              return "";
            if (!i3._showingGlobe()) {
              const e4 = i3.getPitch();
              return e4 ? `rotateX(${e4}deg)` : "";
            }
            const r4 = e3.bI(e3.df(i3.transform, this._lngLat)), s4 = t3.sub(e3.dg(i3.transform)), n3 = Math.abs(s4.x) + Math.abs(s4.y);
            if (0 === n3)
              return "";
            const a3 = r4 / n3;
            return `rotateX(${-s4.y * a3}deg) rotateY(${s4.x * a3}deg)`;
          }
          _calculateZTransform() {
            const t3 = this._pos, i3 = this._map;
            if (!i3 || !t3)
              return "";
            let o3 = 0;
            const r4 = this.getRotationAlignment();
            if ("map" === r4)
              if (i3._showingGlobe()) {
                const t4 = i3.project(new e3.bq(this._lngLat.lng, this._lngLat.lat + 1e-3)), r5 = i3.project(new e3.bq(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t4);
                o3 = e3.bI(Math.atan2(r5.y, r5.x)) - 90;
              } else
                o3 = -i3.getBearing();
            else if ("horizon" === r4) {
              const r5 = e3.S(4, 6, i3.getZoom()), s4 = e3.dg(i3.transform);
              s4.y += r5 * i3.transform.height;
              const n3 = t3.sub(s4), a3 = e3.bI(Math.atan2(n3.y, n3.x));
              o3 = (a3 > 90 ? a3 - 270 : a3 + 90) * (1 - r5);
            }
            return o3 += this._rotation, o3 ? `rotateZ(${o3}deg)` : "";
          }
          _update(e4) {
            cancelAnimationFrame(this._updateFrameId);
            const t3 = this._map;
            t3 && (t3.transform.renderWorldCopies && (this._lngLat = ia(this._lngLat, this._pos, t3.transform)), this._pos = t3.project(this._lngLat), true === e4 ? this._updateFrameId = requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), t3._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t3._showingGlobe() || t3.getTerrain() || t3.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t3) {
            return this._offset = e3.P.convert(t3), this._update(), this;
          }
          addClassName(e4) {
            return this._element.classList.add(e4), this;
          }
          removeClassName(e4) {
            return this._element.classList.remove(e4), this;
          }
          toggleClassName(e4) {
            return this._element.classList.toggle(e4);
          }
          _onMove(t3) {
            const i3 = this._map;
            if (!i3)
              return;
            const o3 = this._pointerdownPos, r4 = this._positionDelta;
            if (o3 && r4) {
              if (!this._isDragging) {
                const e4 = this._clickTolerance || i3._clickTolerance;
                if (t3.point.dist(o3) < e4)
                  return;
                this._isDragging = true;
              }
              this._pos = t3.point.sub(r4), this._lngLat = i3.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e3.b("dragstart"))), this.fire(new e3.b("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
            const t3 = this._map;
            t3 && (t3.off("mousemove", this._onMove), t3.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e3.b("dragend")), this._state = "inactive";
          }
          _addDragHandler(e4) {
            const t3 = this._map, i3 = this._pos;
            t3 && i3 && this._element.contains(e4.originalEvent.target) && (e4.preventDefault(), this._positionDelta = e4.point.sub(i3), this._pointerdownPos = e4.point, this._state = "pending", t3.on("mousemove", this._onMove), t3.on("touchmove", this._onMove), t3.once("mouseup", this._onUp), t3.once("touchend", this._onUp));
          }
          setDraggable(e4) {
            this._draggable = !!e4;
            const t3 = this._map;
            return t3 && (e4 ? (t3.on("mousedown", this._addDragHandler), t3.on("touchstart", this._addDragHandler)) : (t3.off("mousedown", this._addDragHandler), t3.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e4) {
            return this._rotation = e4 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e4) {
            return this._rotationAlignment = e4 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(e4) {
            return this._pitchAlignment = e4 || "auto", this._update(), this;
          }
          getPitchAlignment() {
            return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(e4) {
            return this._occludedOpacity = e4 || 0.2, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const sa = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, na = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function aa(t3 = new e3.P(0, 0), i3 = "bottom") {
          if ("number" == typeof t3) {
            const o3 = Math.round(Math.sqrt(0.5 * Math.pow(t3, 2)));
            switch (i3) {
              case "top":
                return new e3.P(0, t3);
              case "top-left":
                return new e3.P(o3, o3);
              case "top-right":
                return new e3.P(-o3, o3);
              case "bottom":
                return new e3.P(0, -t3);
              case "bottom-left":
                return new e3.P(o3, -o3);
              case "bottom-right":
                return new e3.P(-o3, -o3);
              case "left":
                return new e3.P(t3, 0);
              case "right":
                return new e3.P(-t3, 0);
            }
            return new e3.P(0, 0);
          }
          return t3 instanceof e3.P || Array.isArray(t3) ? e3.P.convert(t3) : e3.P.convert(t3[i3] || [0, 0]);
        }
        class la {
          constructor(e4) {
            this.jumpTo(e4);
          }
          getValue(t3) {
            if (t3 <= this._startTime)
              return this._start;
            if (t3 >= this._endTime)
              return this._end;
            const i3 = e3.ch((t3 - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - i3) + this._end * i3;
          }
          isEasing(e4) {
            return e4 >= this._startTime && e4 <= this._endTime;
          }
          jumpTo(e4) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e4, this._end = e4;
          }
          easeTo(e4, t3, i3) {
            this._start = this.getValue(t3), this._end = e4, this._startTime = t3, this._endTime = t3 + i3;
          }
        }
        class ca {
          registerParameter(e4, t3, i3, o3, r4) {
          }
          registerButton(e4, t3, i3) {
          }
          registerBinding(e4, t3, i3, o3) {
          }
          refreshUI() {
          }
        }
        const ha = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, ua = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false }, da = { showCompass: true, showZoom: true, visualizePitch: false };
        class _a {
          constructor(t3, i3, o3 = false) {
            this._clickTolerance = 10, this.element = i3, this.mouseRotate = new Tn({ clickTolerance: t3.dragRotate._mouseRotate._clickTolerance }), this.map = t3, o3 && (this.mousePitch = new En({ clickTolerance: t3.dragRotate._mousePitch._clickTolerance })), e3.a$(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i3.addEventListener("mousedown", this.mousedown), i3.addEventListener("touchstart", this.touchstart, { passive: false }), i3.addEventListener("touchmove", this.touchmove), i3.addEventListener("touchend", this.touchend), i3.addEventListener("touchcancel", this.reset);
          }
          down(e4, t3) {
            this.mouseRotate.mousedown(e4, t3), this.mousePitch && this.mousePitch.mousedown(e4, t3), h();
          }
          move(e4, t3) {
            const i3 = this.map, o3 = this.mouseRotate.mousemoveWindow(e4, t3), r4 = o3 && o3.bearingDelta;
            if (r4 && i3.setBearing(i3.getBearing() + r4), this.mousePitch) {
              const o4 = this.mousePitch.mousemoveWindow(e4, t3), r5 = o4 && o4.pitchDelta;
              r5 && i3.setPitch(i3.getPitch() + r5);
            }
          }
          off() {
            const e4 = this.element;
            e4.removeEventListener("mousedown", this.mousedown), e4.removeEventListener("touchstart", this.touchstart, { passive: false }), e4.removeEventListener("touchmove", this.touchmove), e4.removeEventListener("touchend", this.touchend), e4.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            u2(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t3) {
            this.down(e3.e({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), p2(this.element, t3)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(e4) {
            this.move(e4, p2(this.element, e4));
          }
          mouseup(e4) {
            this.mouseRotate.mouseupWindow(e4), this.mousePitch && this.mousePitch.mouseupWindow(e4), this.offTemp();
          }
          touchstart(e4) {
            1 !== e4.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = f(this.element, e4.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e4.preventDefault() }, this._startPos));
          }
          touchmove(e4) {
            1 !== e4.targetTouches.length ? this.reset() : (this._lastPos = f(this.element, e4.targetTouches)[0], this.move({ preventDefault: () => e4.preventDefault() }, this._lastPos));
          }
          touchend(e4) {
            0 === e4.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        const pa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, fa = { maxWidth: 100, unit: "metric" }, ma = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, ga = { version: e3.du, supported: i2, setRTLTextPlugin: e3.dw, getRTLTextPluginStatus: e3.dx, Map: class extends Jn {
          constructor(t3) {
            const i3 = t3;
            if (null != (t3 = e3.e({}, ua, t3)).minZoom && null != t3.maxZoom && t3.minZoom > t3.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t3.minPitch && null != t3.maxPitch && t3.minPitch > t3.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t3.minPitch && t3.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != t3.maxPitch && t3.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t3.antialias && e3.dh(window) && (t3.antialias = false, e3.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new po(t3.minZoom, t3.maxZoom, t3.minPitch, t3.maxPitch, t3.renderWorldCopies), t3), this._repaint = !!t3.repaint, this._interactive = t3.interactive, this._minTileCacheSize = t3.minTileCacheSize, this._maxTileCacheSize = t3.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t3.preserveDrawingBuffer, this._antialias = t3.antialias, this._trackResize = t3.trackResize, this._bearingSnap = t3.bearingSnap, this._refreshExpiredTiles = t3.refreshExpiredTiles, this._fadeDuration = t3.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t3.crossSourceCollisions, this._collectResourceTiming = t3.collectResourceTiming, this._language = this._parseLanguage(t3.language), this._worldview = t3.worldview, this._renderTaskQueue = new ta(), this._domRenderTaskQueue = new ta(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e3.aF(), this._locale = e3.e({}, ha, t3.locale), this._clickTolerance = t3.clickTolerance, this._cooperativeGestures = t3.cooperativeGestures, this._performanceMetricsCollection = t3.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = true, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new la(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e3.di(t3.transformRequest, t3.accessToken, t3.testMode), this._silenceAuthErrors = !!t3.testMode, this._contextCreateOptions = t3.contextCreateOptions ? { ...t3.contextCreateOptions } : {}, "string" == typeof t3.container) {
              const e4 = document.getElementById(t3.container);
              if (!e4)
                throw new Error(`Container '${t3.container.toString()}' not found.`);
              this._container = e4;
            } else {
              if (!(t3.container instanceof HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t3.container;
            }
            if (this._container.childNodes.length > 0 && e3.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t3.maxBounds && this.setMaxBounds(t3.maxBounds), e3.a$(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp = t3.devtools ? new ca(this) : new ca(), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: true }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: true }, () => {
              this._update();
            }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._setupPainter(), void 0 === this.painter)
              throw new Error("Failed to initialize WebGL.");
            if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new Xn(this, t3), this._localFontFamily = t3.localFontFamily, this._localIdeographFontFamily = t3.localIdeographFontFamily, (t3.style || !t3.testMode) && this.setStyle(t3.style || e3.dd.DEFAULT_STYLE, { config: t3.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t3.projection && this.setProjection(t3.projection), t3.hash && (this._hash = new Ks("string" == typeof t3.hash && t3.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
              null == i3.center && null == i3.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t3.center, zoom: t3.zoom, bearing: t3.bearing, pitch: t3.pitch });
              const o3 = t3.bounds;
              o3 && (this.resize(), this.fitBounds(o3, e3.e({}, t3.fitBoundsOptions, { duration: 0 })));
            }
            this.resize(), t3.attributionControl && this.addControl(new Kn({ customAttribution: t3.customAttribution })), this._logoControl = new ea(), this.addControl(this._logoControl, t3.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
            }), this.on("data", (t4) => {
              this._update("style" === t4.dataType), this.fire(new e3.b(`${t4.dataType}data`, t4));
            }), this.on("dataloading", (t4) => {
              this.fire(new e3.b(`${t4.dataType}dataloading`, t4));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t3, i3) {
            if (void 0 === i3 && (i3 = t3.getDefaultPosition ? t3.getDefaultPosition() : "top-right"), !t3 || !t3.onAdd)
              return this.fire(new e3.a(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o3 = t3.onAdd(this);
            this._controls.push(t3);
            const r4 = this._controlPositions[i3];
            return -1 !== i3.indexOf("bottom") ? r4.insertBefore(o3, r4.firstChild) : r4.appendChild(o3), this;
          }
          removeControl(t3) {
            if (!t3 || !t3.onRemove)
              return this.fire(new e3.a(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i3 = this._controls.indexOf(t3);
            return i3 > -1 && this._controls.splice(i3, 1), t3.onRemove(this), this;
          }
          hasControl(e4) {
            return this._controls.indexOf(e4) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(t3) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
              return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const i3 = !this._moving;
            return i3 && this.fire(new e3.b("movestart", t3)).fire(new e3.b("move", t3)), this.fire(new e3.b("resize", t3)), i3 && this.fire(new e3.b("moveend", t3)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(t3) {
            return this.transform.setMaxBounds(e3.ag.convert(t3)), this._update();
          }
          setMinZoom(t3) {
            if ((t3 = null == t3 ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom)
              return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 ? this.setZoom(t3) : this.fire(new e3.b("zoomstart")).fire(new e3.b("zoom")).fire(new e3.b("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t3) {
            if ((t3 = null == t3 ? 22 : t3) >= this.transform.minZoom)
              return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 ? this.setZoom(t3) : this.fire(new e3.b("zoomstart")).fire(new e3.b("zoom")).fire(new e3.b("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t3) {
            if ((t3 = null == t3 ? 0 : t3) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t3 >= 0 && t3 <= this.transform.maxPitch)
              return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 ? this.setPitch(t3) : this.fire(new e3.b("pitchstart")).fire(new e3.b("pitch")).fire(new e3.b("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t3) {
            if ((t3 = null == t3 ? 85 : t3) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t3 >= this.transform.minPitch)
              return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 ? this.setPitch(t3) : this.fire(new e3.b("pitchstart")).fire(new e3.b("pitch")).fire(new e3.b("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e4) {
            return this.transform.renderWorldCopies = e4, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(e4) {
            return "auto" === e4 ? navigator.language : Array.isArray(e4) ? 0 === e4.length ? void 0 : e4.map((e5) => "auto" === e5 ? navigator.language : e5) : e4;
          }
          setLanguage(e4) {
            const t3 = this._parseLanguage(e4);
            if (!this.style || t3 === this._language)
              return this;
            this._language = t3, this.style.reloadSources();
            for (const e5 of this._controls)
              e5._setLanguage && e5._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(e4) {
            return this.style && e4 !== this._worldview ? (this._worldview = e4, this.style.reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return "globe" === this.transform.projection.name;
          }
          setProjection(e4) {
            return this._lazyInitEmptyStyle(), e4 ? "string" == typeof e4 && (e4 = { name: e4 }) : e4 = null, this._useExplicitProjection = !!e4, this._prioritizeAndUpdateProjection(e4, this.style.projection);
          }
          _updateProjectionTransition() {
            if ("globe" !== this.getProjection().name)
              return;
            const t3 = this.transform, i3 = t3.projection.name;
            let o3;
            "globe" === i3 && t3.zoom >= e3.bA ? (t3.setMercatorFromTransition(), o3 = true) : "mercator" === i3 && t3.zoom < e3.bA && (t3.setProjection({ name: "globe" }), o3 = true), o3 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
          }
          _prioritizeAndUpdateProjection(e4, t3) {
            return this._updateProjection(e4 || t3 || { name: "mercator" });
          }
          _updateProjection(t3) {
            let i3;
            return i3 = "globe" === t3.name && this.transform.zoom >= e3.bA ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t3), this.style.applyProjectionUpdate(), i3 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
          }
          project(t3) {
            return this.transform.locationPoint3D(e3.bq.convert(t3));
          }
          unproject(t3) {
            return this.transform.pointLocation3D(e3.P.convert(t3));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || false;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || false;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || false;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || false;
          }
          _createDelegatedListener(e4, t3, i3) {
            if ("mouseenter" === e4 || "mouseover" === e4) {
              let o3 = false;
              const r4 = (r5) => {
                const s5 = t3.filter((e5) => this.getLayer(e5)), n3 = s5.length ? this.queryRenderedFeatures(r5.point, { layers: s5 }) : [];
                n3.length ? o3 || (o3 = true, i3.call(this, new hn(e4, this, r5.originalEvent, { features: n3 }))) : o3 = false;
              }, s4 = () => {
                o3 = false;
              };
              return { layers: new Set(t3), listener: i3, delegates: { mousemove: r4, mouseout: s4 } };
            }
            if ("mouseleave" === e4 || "mouseout" === e4) {
              let o3 = false;
              const r4 = (r5) => {
                const s5 = t3.filter((e5) => this.getLayer(e5));
                (s5.length ? this.queryRenderedFeatures(r5.point, { layers: s5 }) : []).length ? o3 = true : o3 && (o3 = false, i3.call(this, new hn(e4, this, r5.originalEvent)));
              }, s4 = (t4) => {
                o3 && (o3 = false, i3.call(this, new hn(e4, this, t4.originalEvent)));
              };
              return { layers: new Set(t3), listener: i3, delegates: { mousemove: r4, mouseout: s4 } };
            }
            {
              const o3 = (e5) => {
                const o4 = t3.filter((e6) => this.getLayer(e6)), r4 = o4.length ? this.queryRenderedFeatures(e5.point, { layers: o4 }) : [];
                r4.length && (e5.features = r4, i3.call(this, e5), delete e5.features);
              };
              return { layers: new Set(t3), listener: i3, delegates: { [e4]: o3 } };
            }
          }
          on(e4, t3, i3) {
            if (void 0 === i3)
              return super.on(e4, t3);
            if (Array.isArray(t3) || (t3 = [t3]), t3) {
              for (const e5 of t3)
                if (!this._isValidId(e5))
                  return this;
            }
            const o3 = this._createDelegatedListener(e4, t3, i3);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e4] = this._delegatedListeners[e4] || [], this._delegatedListeners[e4].push(o3);
            for (const e5 in o3.delegates)
              this.on(e5, o3.delegates[e5]);
            return this;
          }
          once(e4, t3, i3) {
            if (void 0 === i3)
              return super.once(e4, t3);
            if (Array.isArray(t3) || (t3 = [t3]), t3) {
              for (const e5 of t3)
                if (!this._isValidId(e5))
                  return this;
            }
            const o3 = this._createDelegatedListener(e4, t3, i3);
            for (const e5 in o3.delegates)
              this.once(e5, o3.delegates[e5]);
            return this;
          }
          off(e4, t3, i3) {
            if (void 0 === i3)
              return super.off(e4, t3);
            t3 = new Set(Array.isArray(t3) ? t3 : [t3]);
            for (const e5 of t3)
              if (!this._isValidId(e5))
                return this;
            const o3 = (e5, t4) => {
              if (e5.size !== t4.size)
                return false;
              for (const i4 of e5)
                if (!t4.has(i4))
                  return false;
              return true;
            }, r4 = this._delegatedListeners ? this._delegatedListeners[e4] : void 0;
            return r4 && ((e5) => {
              for (let r5 = 0; r5 < e5.length; r5++) {
                const s4 = e5[r5];
                if (s4.listener === i3 && o3(s4.layers, t3)) {
                  for (const e6 in s4.delegates)
                    this.off(e6, s4.delegates[e6]);
                  return e5.splice(r5, 1), this;
                }
              }
            })(r4), this;
          }
          queryRenderedFeatures(t3, i3) {
            if (!this.style)
              return [];
            if (void 0 !== i3 || void 0 === t3 || t3 instanceof e3.P || Array.isArray(t3) || (i3 = t3, t3 = void 0), t3 = t3 || [[0, 0], [this.transform.width, this.transform.height]], (i3 = i3 || {}).layers && Array.isArray(i3.layers)) {
              for (const e4 of i3.layers)
                if (!this._isValidId(e4))
                  return [];
            }
            return this.style.queryRenderedFeatures(t3, i3, this.transform);
          }
          querySourceFeatures(e4, t3) {
            return this._isValidId(e4) ? this.style.querySourceFeatures(e4, t3) : [];
          }
          isPointOnSurface(t3) {
            const { name: i3 } = this.transform.projection;
            return "globe" !== i3 && "mercator" !== i3 && e3.w(`${i3} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e3.P.convert(t3));
          }
          setStyle(t3, i3) {
            return i3 = e3.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i3), this.style && t3 && false !== i3.diff && i3.localFontFamily === this._localFontFamily && i3.localIdeographFontFamily === this._localIdeographFontFamily && !i3.config ? (this.style._diffStyle(t3, (o3, r4) => {
              o3 ? (e3.w(`Unable to perform style diff: ${String(o3.message || o3.error || o3)}. Rebuilding the style from scratch.`), this._updateStyle(t3, i3)) : r4 && this._update(true);
            }, () => {
              this._postStyleLoadEvent();
            }), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._localFontFamily = i3.localFontFamily, this._updateStyle(t3, i3));
          }
          _getUIString(e4) {
            const t3 = this._locale[e4];
            if (null == t3)
              throw new Error(`Missing UI string '${e4}'`);
            return t3;
          }
          _updateStyle(t3, i3) {
            if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t3) {
              const o3 = e3.e({}, i3);
              i3 && i3.config && (o3.initialConfig = i3.config, delete o3.config), this.style = new Ao(this, o3).setEventedParent(this, { style: this.style }).load(t3);
            }
            return this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ao(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (e3.w("There is no style added to the map."), false);
          }
          _isValidId(t3) {
            return null == t3 ? (this.fire(new e3.a(new Error("IDs can't be empty."))), false) : !e3.c9(t3) || (this.fire(new e3.a(new Error(`IDs can't contain special symbols: "${t3}".`))), false);
          }
          addSource(e4, t3) {
            return this._isValidId(e4) ? (this._lazyInitEmptyStyle(), this.style.addSource(e4, t3), this._update(true)) : this;
          }
          isSourceLoaded(e4) {
            return !!this._isValidId(e4) && !!this.style && this.style._isSourceCacheLoaded(e4);
          }
          areTilesLoaded() {
            return this.style.areTilesLoaded();
          }
          addSourceType(e4, t3, i3) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(e4, t3, i3);
          }
          removeSource(e4) {
            return this._isValidId(e4) ? (this.style.removeSource(e4), this._updateTerrain(), this._update(true)) : this;
          }
          getSource(e4) {
            return this._isValidId(e4) ? this.style.getOwnSource(e4) : null;
          }
          addImage(t3, i3, { pixelRatio: o3 = 1, sdf: r4 = false, stretchX: s4, stretchY: n3, content: a3 } = {}) {
            if (this._lazyInitEmptyStyle(), i3 instanceof HTMLImageElement || ImageBitmap && i3 instanceof ImageBitmap) {
              const { width: l3, height: c3, data: h2 } = e3.f.getImageData(i3);
              this.style.addImage(t3, { data: new e3.h({ width: l3, height: c3 }, h2), pixelRatio: o3, stretchX: s4, stretchY: n3, content: a3, sdf: r4, version: 0 });
            } else if (void 0 === i3.width || void 0 === i3.height)
              this.fire(new e3.a(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: l3, height: c3 } = i3, h2 = i3;
              this.style.addImage(t3, { data: new e3.h({ width: l3, height: c3 }, new Uint8Array(h2.data)), pixelRatio: o3, stretchX: s4, stretchY: n3, content: a3, sdf: r4, version: 0, userImage: h2 }), h2.onAdd && h2.onAdd(this, t3);
            }
          }
          updateImage(t3, i3) {
            this._lazyInitEmptyStyle();
            const o3 = this.style.getImage(t3);
            if (!o3)
              return void this.fire(new e3.a(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r4 = i3 instanceof HTMLImageElement || ImageBitmap && i3 instanceof ImageBitmap ? e3.f.getImageData(i3) : i3, { width: s4, height: n3 } = r4, a3 = r4.data;
            if (void 0 === s4 || void 0 === n3)
              return void this.fire(new e3.a(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (s4 !== o3.data.width || n3 !== o3.data.height)
              return void this.fire(new e3.a(new Error(`The width and height of the updated image (${s4}, ${n3})
                must be that same as the previous version of the image
                (${o3.data.width}, ${o3.data.height})`)));
            const l3 = !(i3 instanceof HTMLImageElement || ImageBitmap && i3 instanceof ImageBitmap);
            o3.data.replace(a3, l3), this.style.updateImage(t3, o3);
          }
          hasImage(t3) {
            return t3 ? !!this.style && !!this.style.getImage(t3) : (this.fire(new e3.a(new Error("Missing required image id"))), false);
          }
          removeImage(e4) {
            this.style.removeImage(e4);
          }
          loadImage(t3, i3) {
            e3.d(this._requestManager.transformRequest(t3, e3.R.Image), (t4, o3) => {
              i3(t4, o3 instanceof HTMLImageElement ? e3.f.getImageData(o3) : o3);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addModel(e4, t3) {
            this._lazyInitEmptyStyle(), this.style.addModel(e4, t3);
          }
          hasModel(t3) {
            return t3 ? this.style.hasModel(t3) : (this.fire(new e3.a(new Error("Missing required model id"))), false);
          }
          removeModel(e4) {
            this.style.removeModel(e4);
          }
          listModels() {
            return this.style.listModels();
          }
          addLayer(e4, t3) {
            return this._isValidId(e4.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e4, t3), this._update(true)) : this;
          }
          getSlot(e4) {
            const t3 = this.getLayer(e4);
            return t3 && t3.slot || null;
          }
          setSlot(e4, t3) {
            return this.style.setSlot(e4, t3), this.style.mergeLayers(), this._update(true);
          }
          addImport(e4, t3) {
            return this.style.addImport(e4, t3), this;
          }
          updateImport(e4, t3) {
            return "string" != typeof t3 && t3.id !== e4 ? (this.removeImport(e4), this.addImport(t3)) : (this.style.updateImport(e4, t3), this._update(true));
          }
          removeImport(e4) {
            return this.style.removeImport(e4), this;
          }
          moveImport(e4, t3) {
            return this.style.moveImport(e4, t3), this._update(true);
          }
          moveLayer(e4, t3) {
            return this._isValidId(e4) ? (this.style.moveLayer(e4, t3), this._update(true)) : this;
          }
          removeLayer(e4) {
            return this._isValidId(e4) ? (this.style.removeLayer(e4), this._update(true)) : this;
          }
          getLayer(e4) {
            return this._isValidId(e4) ? this.style.getOwnLayer(e4) : null;
          }
          setLayerZoomRange(e4, t3, i3) {
            return this._isValidId(e4) ? (this.style.setLayerZoomRange(e4, t3, i3), this._update(true)) : this;
          }
          setFilter(e4, t3, i3 = {}) {
            return this._isValidId(e4) ? (this.style.setFilter(e4, t3, i3), this._update(true)) : this;
          }
          getFilter(e4) {
            return this._isValidId(e4) ? this.style.getFilter(e4) : null;
          }
          setPaintProperty(e4, t3, i3, o3 = {}) {
            return this._isValidId(e4) ? (this.style.setPaintProperty(e4, t3, i3, o3), this._update(true)) : this;
          }
          getPaintProperty(e4, t3) {
            return this._isValidId(e4) ? this.style.getPaintProperty(e4, t3) : null;
          }
          setLayoutProperty(e4, t3, i3, o3 = {}) {
            return this._isValidId(e4) ? (this.style.setLayoutProperty(e4, t3, i3, o3), this._update(true)) : this;
          }
          getLayoutProperty(e4, t3) {
            return this._isValidId(e4) ? this.style.getLayoutProperty(e4, t3) : null;
          }
          getSchema(e4) {
            return this.style.getSchema(e4);
          }
          setSchema(e4, t3) {
            return this.style.setSchema(e4, t3), this._update(true);
          }
          getConfig(e4) {
            return this.style.getConfig(e4);
          }
          setConfig(e4, t3) {
            return this.style.setConfig(e4, t3), this._update(true);
          }
          getConfigProperty(e4, t3) {
            return this.style.getConfigProperty(e4, t3);
          }
          setConfigProperty(e4, t3, i3) {
            return this.style.setConfigProperty(e4, t3, i3), this._update(true);
          }
          setLights(e4) {
            if (this._lazyInitEmptyStyle(), e4 && 1 === e4.length && "flat" === e4[0].type) {
              const t3 = e4[0];
              t3.properties ? this.style.setFlatLight(t3.properties, t3.id, {}) : this.style.setFlatLight({}, "flat");
            } else
              this.style.setLights(e4), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
            return this._update(true);
          }
          getLights() {
            const e4 = this.style.getLights() || [];
            return 0 === e4.length && e4.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e4;
          }
          setLight(e4, t3 = {}) {
            return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e4 }]);
          }
          getLight() {
            return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
          }
          setTerrain(e4) {
            return this._lazyInitEmptyStyle(), !e4 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e4), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(e4) {
            return this._lazyInitEmptyStyle(), this.style.setFog(e4), this._update(true);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          setCamera(e4) {
            return this.style.setCamera(e4), this._triggerCameraUpdate(e4);
          }
          _triggerCameraUpdate(e4) {
            return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e4["camera-projection"]));
          }
          getCamera() {
            return this.style.camera;
          }
          _queryFogOpacity(t3) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e3.bq.convert(t3), this.transform) : 0;
          }
          setFeatureState(e4, t3) {
            return this._isValidId(e4.source) ? (this.style.setFeatureState(e4, t3), this._update()) : this;
          }
          removeFeatureState(e4, t3) {
            return this._isValidId(e4.source) ? (this.style.removeFeatureState(e4, t3), this._update()) : this;
          }
          getFeatureState(e4) {
            return this._isValidId(e4.source) ? this.style.getFeatureState(e4) : null;
          }
          _updateContainerDimensions() {
            if (!this._container)
              return;
            const e4 = this._container.getBoundingClientRect().width || 400, t3 = this._container.getBoundingClientRect().height || 300;
            let i3, o3, r4, s4 = this._container;
            for (; s4 && (!o3 || !r4); ) {
              const e5 = window.getComputedStyle(s4).transform;
              e5 && "none" !== e5 && (i3 = e5.match(/matrix.*\((.+)\)/)[1].split(", "), i3[0] && "0" !== i3[0] && "1" !== i3[0] && (o3 = i3[0]), i3[3] && "0" !== i3[3] && "1" !== i3[3] && (r4 = i3[3])), s4 = s4.parentElement;
            }
            this._containerWidth = o3 ? Math.abs(e4 / o3) : e4, this._containerHeight = r4 ? Math.abs(t3 / r4) : t3;
          }
          _detectMissingCSS() {
            "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e3.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const e4 = this._container;
            e4.classList.add("mapboxgl-map"), (this._missingCSSCanary = s3("div", "mapboxgl-canary", e4)).style.visibility = "hidden", this._detectMissingCSS();
            const t3 = this._canvasContainer = s3("div", "mapboxgl-canvas-container", e4);
            this._canvas = s3("canvas", "mapboxgl-canvas", t3), this._interactive && (t3.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const i3 = this._controlContainer = s3("div", "mapboxgl-control-container", e4), o3 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e5) => {
              o3[e5] = s3("div", `mapboxgl-ctrl-${e5}`, i3);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t3, i3) {
            const o3 = e3.f.devicePixelRatio || 1;
            this._canvas.width = o3 * Math.ceil(t3), this._canvas.height = o3 * Math.ceil(i3), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${i3}px`;
          }
          _addMarker(e4) {
            this._markers.push(e4);
          }
          _removeMarker(e4) {
            const t3 = this._markers.indexOf(e4);
            -1 !== t3 && this._markers.splice(t3, 1);
          }
          _addPopup(e4) {
            this._popups.push(e4);
          }
          _removePopup(e4) {
            const t3 = this._popups.indexOf(e4);
            -1 !== t3 && this._popups.splice(t3, 1);
          }
          _setupPainter() {
            const t3 = e3.e({}, i2.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o3 = this._canvas.getContext("webgl2", t3);
            o3 ? (e3.dj(o3, true), this.painter = new Ys(o3, this._contextCreateOptions, this.transform, this._tp), this.on("data", (e4) => {
              "source" === e4.dataType && this.painter.setTileLoadedFlag(true);
            }), e3.dk.testSupport(o3)) : this.fire(new e3.a(new Error("Failed to initialize WebGL")));
          }
          _contextLost(t3) {
            t3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e3.b("webglcontextlost", { originalEvent: t3 }));
          }
          _contextRestored(t3) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e3.b("webglcontextrestored", { originalEvent: t3 }));
          }
          _onMapScroll(e4) {
            if (e4.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e4) {
            return this.style ? (this._styleDirty = this._styleDirty || e4, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e4) {
            return this._update(), this._renderTaskQueue.add(e4);
          }
          _cancelRenderFrame(e4) {
            this._renderTaskQueue.remove(e4);
          }
          _requestDomTask(e4) {
            !this.loaded() || this.loaded() && !this.isMoving() ? e4() : this._domRenderTaskQueue.add(e4);
          }
          _render(t3) {
            let i3;
            this.fire(new e3.b("renderstart"));
            const o3 = this.painter.context.extTimerQuery, r4 = e3.f.now(), s4 = this.painter.context.gl;
            if (this.listens("gpu-timing-frame") && (i3 = s4.createQuery(), s4.beginQuery(o3.TIME_ELAPSED_EXT, i3)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t3), this._domRenderTaskQueue.run(t3), this._removed)
              return;
            this._updateProjectionTransition();
            const n3 = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t4 = this.transform.zoom, i4 = this.transform.pitch, o4 = e3.f.now(), r5 = new e3.N(t4, { now: o4, fadeDuration: n3, pitch: i4, transition: this.style.transition });
              this.style.update(r5);
            }
            this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
            let a3 = false;
            if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), a3 = this._updateAverageElevation(r4), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : a3 = this._updateAverageElevation(r4), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n3, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n3, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e3.b("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e3.b("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i3) {
              const t4 = e3.f.now() - r4;
              s4.endQuery(o3.TIME_ELAPSED_EXT), setTimeout(() => {
                const o4 = s4.getQueryParameter(i3, s4.QUERY_RESULT) / 1e6;
                s4.deleteQuery(i3), this.fire(new e3.b("gpu-timing-frame", { cpuTime: t4, gpuTime: o4 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const t4 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i4 = this.painter.queryGpuTimers(t4);
                this.fire(new e3.b("gpu-timing-layer", { layerTimes: i4 }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const t4 = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const i4 = this.painter.queryGpuTimeDeferredRender(t4);
                this.fire(new e3.b("gpu-timing-deferred-render", { gpuTime: i4 }));
              }, 50);
            }
            const l3 = this._sourcesDirty || this._styleDirty || this._placementDirty || a3;
            if (l3 || this._repaint)
              this.triggerRepaint();
            else {
              const t4 = !this.isMoving() && this.loaded();
              if (t4 && (a3 = this._updateAverageElevation(r4, true)), a3)
                this.triggerRepaint();
              else if (this._triggerFrame(false), t4 && (this.fire(new e3.b("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                const t5 = this._calculateSpeedIndex();
                this.fire(new e3.b("speedindexcompleted", { speedIndex: t5 })), this.speedIndexTiming = false;
              }
            }
            !this._loaded || this._fullyLoaded || l3 || (this._fullyLoaded = true, this._performanceMetricsCollection && e3.dl(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(e4) {
            for (const t3 of this._markers)
              e4 && !this.getRenderWorldCopies() && (t3._lngLat = t3._lngLat.wrap()), t3._update();
            for (const t3 of this._popups)
              !e4 || this.getRenderWorldCopies() || t3._trackPointer || (t3._lngLat = t3._lngLat.wrap()), t3._update();
          }
          _updateAverageElevation(e4, t3 = false) {
            const i3 = (e5) => (this.transform.averageElevation = e5, this._update(false), true);
            if (!this.painter.averageElevationNeedsEasing())
              return 0 !== this.transform.averageElevation && i3(0);
            const o3 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
            if (o3 || (t3 || e4 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e4)) {
              const t4 = this.transform.averageElevation;
              let r4 = this.transform.sampleAverageElevation();
              this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r4) ? r4 = 0 : this._averageElevationLastSampledAt = e4;
              const s4 = Math.abs(t4 - r4);
              if (s4 > 1) {
                if (this._isInitialLoad || o3)
                  return this._averageElevation.jumpTo(r4), i3(r4);
                this._averageElevation.easeTo(r4, e4, 300);
              } else if (s4 > 1e-4)
                return this._averageElevation.jumpTo(r4), i3(r4);
            }
            return !!this._averageElevation.isEasing(e4) && i3(this._averageElevation.getValue(e4));
          }
          _authenticate() {
            e3.dm(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t3) => {
              if (t3 && (t3.message === e3.dn || 401 === t3.status)) {
                const t4 = this.painter.context.gl;
                e3.dj(t4, false), this._logoControl instanceof ea && this._logoControl._updateLogo(), t4 && t4.clear(t4.DEPTH_BUFFER_BIT | t4.COLOR_BUFFER_BIT | t4.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e3.a(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), e3.dp(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _postStyleLoadEvent() {
            this.style.globalId && e3.dq(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
          }
          _updateTerrain() {
            const e4 = this._isDragging();
            this.painter.updateTerrain(this.style, e4);
          }
          _calculateSpeedIndex() {
            const e4 = this.painter.canvasCopy(), t3 = this.painter.getCanvasCopiesAndTimestamps();
            t3.timeStamps.push(performance.now());
            const i3 = this.painter.context.gl, o3 = i3.createFramebuffer();
            function r4(e5) {
              i3.framebufferTexture2D(i3.FRAMEBUFFER, i3.COLOR_ATTACHMENT0, i3.TEXTURE_2D, e5, 0);
              const t4 = new Uint8Array(i3.drawingBufferWidth * i3.drawingBufferHeight * 4);
              return i3.readPixels(0, 0, i3.drawingBufferWidth, i3.drawingBufferHeight, i3.RGBA, i3.UNSIGNED_BYTE, t4), t4;
            }
            return i3.bindFramebuffer(i3.FRAMEBUFFER, o3), this._canvasPixelComparison(r4(e4), t3.canvasCopies.map(r4), t3.timeStamps);
          }
          _canvasPixelComparison(e4, t3, i3) {
            let o3 = i3[1] - i3[0];
            const r4 = e4.length / 4;
            for (let s4 = 0; s4 < t3.length; s4++) {
              const n3 = t3[s4];
              let a3 = 0;
              for (let t4 = 0; t4 < n3.length; t4 += 4)
                n3[t4] === e4[t4] && n3[t4 + 1] === e4[t4 + 1] && n3[t4 + 2] === e4[t4 + 2] && n3[t4 + 3] === e4[t4 + 3] && (a3 += 1);
              o3 += (i3[s4 + 2] - i3[s4 + 1]) * (1 - a3 / r4);
            }
            return o3;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const e4 of this._controls)
              e4.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
            const t3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t3 && t3.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e3.dr(this.painter.context.gl), e3.ds.remove(), e3.dt.remove(), this._removed = true, this.fire(new e3.b("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(true);
          }
          _triggerFrame(t3) {
            this._renderNextFrame = this._renderNextFrame || t3, this.style && !this._frame && (this._frame = e3.f.frame((e4) => {
              const t4 = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, t4 && this._render(e4);
            }));
          }
          _preloadTiles(t3) {
            const i3 = this.style ? this.style.getSourceCaches() : [];
            return e3.b4(i3, (e4, i4) => e4._preloadTiles(t3, i4), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(e4) {
            this._trackResize && this.resize({ originalEvent: e4 })._update();
          }
          _onVisibilityChange() {
            "hidden" === document.visibilityState && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e4) {
            this._showTileBoundaries !== e4 && (this._showTileBoundaries = e4, this._tp.refreshUI(), this._update());
          }
          get showParseStatus() {
            return !!this._showParseStatus;
          }
          set showParseStatus(e4) {
            this._showParseStatus !== e4 && (this._showParseStatus = e4, this._tp.refreshUI(), this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(e4) {
            this._showTerrainWireframe !== e4 && (this._showTerrainWireframe = e4, this._tp.refreshUI(), this._update());
          }
          get showLayers2DWireframe() {
            return !!this._showLayers2DWireframe;
          }
          set showLayers2DWireframe(e4) {
            this._showLayers2DWireframe !== e4 && (this._showLayers2DWireframe = e4, this._tp.refreshUI(), this._update());
          }
          get showLayers3DWireframe() {
            return !!this._showLayers3DWireframe;
          }
          set showLayers3DWireframe(e4) {
            this._showLayers3DWireframe !== e4 && (this._showLayers3DWireframe = e4, this._tp.refreshUI(), this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(e4) {
            this._speedIndexTiming !== e4 && (this._speedIndexTiming = e4, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e4) {
            this._showPadding !== e4 && (this._showPadding = e4, this._tp.refreshUI(), this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e4) {
            this._showCollisionBoxes !== e4 && (this._showCollisionBoxes = e4, this._tp.refreshUI(), e4 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e4) {
            this._showOverdrawInspector !== e4 && (this._showOverdrawInspector = e4, this._tp.refreshUI(), this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e4) {
            this._repaint !== e4 && (this._repaint = e4, this._tp.refreshUI(), this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e4) {
            this._vertices = e4, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(e4) {
            this._showTileAABBs !== e4 && (this._showTileAABBs = e4, this._tp.refreshUI(), e4 && this._update());
          }
          _setCacheLimits(t3, i3) {
            e3.dv(t3, i3);
          }
          get version() {
            return e3.du;
          }
        }, NavigationControl: class {
          constructor(t3) {
            this.options = e3.e({}, da, t3), this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e4) => e4.preventDefault()), this.options.showZoom && (e3.a$(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e4) => {
              this._map && this._map.zoomIn({}, { originalEvent: e4 });
            }), s3("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e4) => {
              this._map && this._map.zoomOut({}, { originalEvent: e4 });
            }), s3("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e3.a$(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e4) => {
              const t4 = this._map;
              t4 && (this.options.visualizePitch ? t4.resetNorthPitch({}, { originalEvent: e4 }) : t4.resetNorth({}, { originalEvent: e4 }));
            }), this._compassIcon = s3("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const e4 = this._map;
            if (!e4)
              return;
            const t3 = e4.getZoom(), i3 = t3 === e4.getMaxZoom(), o3 = t3 === e4.getMinZoom();
            this._zoomInButton.disabled = i3, this._zoomOutButton.disabled = o3, this._zoomInButton.setAttribute("aria-disabled", i3.toString()), this._zoomOutButton.setAttribute("aria-disabled", o3.toString());
          }
          _rotateCompassArrow() {
            const e4 = this._map;
            if (!e4)
              return;
            const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e4.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e4.transform.pitch}deg) rotateZ(${e4.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e4.transform.angle * (180 / Math.PI)}deg)`;
            e4._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t3);
            });
          }
          onAdd(e4) {
            return this._map = e4, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e4.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e4.on("pitch", this._rotateCompassArrow), e4.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new _a(e4, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const e4 = this._map;
            e4 && (this._container.remove(), this.options.showZoom && e4.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e4.off("pitch", this._rotateCompassArrow), e4.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(e4, t3) {
            const i3 = s3("button", e4, this._container);
            return i3.type = "button", i3.addEventListener("click", t3), i3;
          }
          _setButtonTitle(e4, t3) {
            if (!this._map)
              return;
            const i3 = this._map._getUIString(`NavigationControl.${t3}`);
            e4.setAttribute("aria-label", i3), e4.firstElementChild && e4.firstElementChild.setAttribute("title", i3);
          }
        }, GeolocateControl: class extends e3.E {
          constructor(t3) {
            super();
            const i3 = navigator.geolocation;
            this.options = e3.e({ geolocation: i3 }, pa, t3), e3.a$(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Js(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(e4) {
            return this._map = e4, this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
          }
          _checkGeolocationSupport(e4) {
            const t3 = (t4 = !!this.options.geolocation) => {
              this._supportsGeolocation = t4, e4(t4);
            };
            void 0 !== this._supportsGeolocation ? e4(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e5) => t3("denied" !== e5.state)).catch(() => t3()) : t3();
          }
          _isOutOfMapMaxBounds(e4) {
            const t3 = this._map.getMaxBounds(), i3 = e4.coords;
            return !!t3 && (i3.longitude < t3.getWest() || i3.longitude > t3.getEast() || i3.latitude < t3.getSouth() || i3.latitude > t3.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(t3) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t3))
                return this._setErrorState(), this.fire(new e3.b("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = t3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t3), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e3.b("geolocate", t3)), this._finish();
            }
          }
          _updateCamera(t3) {
            const i3 = new e3.bq(t3.coords.longitude, t3.coords.latitude), o3 = t3.coords.accuracy, r4 = this._map.getBearing(), s4 = e3.e({ bearing: r4 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i3.toBounds(o3), s4, { geolocateSource: true });
          }
          _updateMarker(t3) {
            if (t3) {
              const i3 = new e3.bq(t3.coords.longitude, t3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const t3 = this._map.transform, i3 = e3.bo(1, t3._center.lat) * t3.worldSize, o3 = Math.ceil(2 * this._accuracy * i3);
            this._circleElement.style.width = `${o3}px`, this._circleElement.style.height = `${o3}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(t3) {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (1 === t3.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.setAttribute("aria-label", e4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e4), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === t3.code && this._noTimeout)
                    return;
                  this._setErrorState();
                }
              "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e3.b("error", t3)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(t3) {
            if (void 0 !== this._map) {
              if (this._container.addEventListener("contextmenu", (e4) => e4.preventDefault()), this._geolocateButton = s3("button", "mapboxgl-ctrl-geolocate", this._container), s3("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t3) {
                e3.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t4);
              } else {
                const e4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", e4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e4);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = s3("div", "mapboxgl-user-location"), this._dotElement.appendChild(s3("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(s3("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new ra({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = s3("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ra({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
                t4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t4.originalEvent && "resize" === t4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e3.b("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(e4) {
            this._userLocationDotMarker && (e4.webkitCompassHeading ? this._heading = e4.webkitCompassHeading : true === e4.absolute && (this._heading = -1 * e4.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup)
              return e3.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e3.b("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e3.b("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e3.b("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e4;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e4 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e4 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e4), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else
              this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _addDeviceOrientationListener() {
            const e4 = () => {
              "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
            };
            "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t3) => {
              "granted" === t3 && e4();
            }).catch(console.error) : e4();
          }
          _clearWatch() {
            this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Kn, ScaleControl: class {
          constructor(t3) {
            this.options = e3.e({}, fa, t3), this._isNumberFormatSupported = function() {
              try {
                return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
              } catch (e4) {
                return false;
              }
            }(), e3.a$(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const e4 = this.options.maxWidth || 100, t3 = this._map, i3 = t3._containerHeight / 2, o3 = t3._containerWidth / 2 - e4 / 2, r4 = t3.unproject([o3, i3]), s4 = t3.unproject([o3 + e4, i3]), n3 = r4.distanceTo(s4);
            if ("imperial" === this.options.unit) {
              const t4 = 3.2808 * n3;
              t4 > 5280 ? this._setScale(e4, t4 / 5280, "mile") : this._setScale(e4, t4, "foot");
            } else
              "nautical" === this.options.unit ? this._setScale(e4, n3 / 1852, "nautical-mile") : n3 >= 1e3 ? this._setScale(e4, n3 / 1e3, "kilometer") : this._setScale(e4, n3, "meter");
          }
          _setScale(e4, t3, i3) {
            this._map._requestDomTask(() => {
              const o3 = function(e5) {
                const t4 = Math.pow(10, `${Math.floor(e5)}`.length - 1);
                let i4 = e5 / t4;
                return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(e6) {
                  const t5 = Math.pow(10, Math.ceil(-Math.log(e6) / Math.LN10));
                  return Math.round(e6 * t5) / t5;
                }(i4), t4 * i4;
              }(t3), r4 = o3 / t3;
              this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i3 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i3 }).format(o3) : `${o3}&nbsp;${ma[i3]}`, this._container.style.width = e4 * r4 + "px";
            });
          }
          onAdd(e4) {
            return this._map = e4, this._language = e4.getLanguage(), this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e4.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(e4) {
            this._language = e4, this._update();
          }
          setUnit(e4) {
            this.options.unit = e4, this._update();
          }
        }, FullscreenControl: class {
          constructor(t3) {
            this._fullscreen = false, t3 && t3.container && (t3.container instanceof HTMLElement ? this._container = t3.container : e3.w("Full screen control 'container' must be a DOM element.")), e3.a$(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(t3) {
            return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e3.w("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const e4 = this._fullscreenButton = s3("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            s3("span", "mapboxgl-ctrl-icon", e4).setAttribute("aria-hidden", "true"), e4.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e4 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e4), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e4);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends e3.E {
          constructor(t3) {
            super(), this.options = e3.e(Object.create(sa), t3), e3.a$(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t3 && t3.className ? t3.className.trim().split(/\s+/) : []);
          }
          addTo(t3) {
            return this._map && this.remove(), this._map = t3, this.options.closeOnClick && t3.on("preclick", this._onClose), this.options.closeOnMove && t3.on("move", this._onClose), t3.on("remove", this.remove), this._update(), t3._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t3.on("mousemove", this._onMouseEvent), t3.on("mouseup", this._onMouseEvent), t3._canvasContainer.classList.add("mapboxgl-track-pointer")) : t3.on("move", this._update), this.fire(new e3.b("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const t3 = this._map;
            return t3 && (t3.off("move", this._update), t3.off("move", this._onClose), t3.off("preclick", this._onClose), t3.off("click", this._onClose), t3.off("remove", this.remove), t3.off("mousemove", this._onMouseEvent), t3.off("mouseup", this._onMouseEvent), t3.off("drag", this._onMouseEvent), t3._canvasContainer && t3._canvasContainer.classList.remove("mapboxgl-track-pointer"), t3._removePopup(this), this._map = void 0), this.fire(new e3.b("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            this._lngLat = e3.bq.convert(t3), this._pos = null, this._trackPointer = false, this._update();
            const i3 = this._map;
            return i3 && (i3.on("move", this._update), i3.off("mousemove", this._onMouseEvent), i3._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            this._trackPointer = true, this._pos = null, this._update();
            const e4 = this._map;
            return e4 && (e4.off("move", this._update), e4.on("mousemove", this._onMouseEvent), e4.on("drag", this._onMouseEvent), e4._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(e4) {
            return this.setDOMContent(document.createTextNode(e4));
          }
          setHTML(e4) {
            const t3 = document.createDocumentFragment(), i3 = document.createElement("body");
            let o3;
            for (i3.innerHTML = e4; o3 = i3.firstChild, o3; )
              t3.appendChild(o3);
            return this.setDOMContent(t3);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e4) {
            return this.options.maxWidth = e4, this._update(), this;
          }
          setDOMContent(e4) {
            let t3 = this._content;
            if (t3)
              for (; t3.hasChildNodes(); )
                t3.firstChild && t3.removeChild(t3.firstChild);
            else
              t3 = this._content = s3("div", "mapboxgl-popup-content", this._container || void 0);
            if (t3.appendChild(e4), this.options.closeButton) {
              const e5 = this._closeButton = s3("button", "mapboxgl-popup-close-button", t3);
              e5.type = "button", e5.setAttribute("aria-label", "Close popup"), e5.setAttribute("aria-hidden", "true"), e5.innerHTML = "&#215;", e5.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(e4) {
            return this._classList.add(e4), this._updateClassList(), this;
          }
          removeClassName(e4) {
            return this._classList.delete(e4), this._updateClassList(), this;
          }
          setOffset(e4) {
            return this.options.offset = e4, this._update(), this;
          }
          toggleClassName(e4) {
            let t3;
            return this._classList.delete(e4) ? t3 = false : (this._classList.add(e4), t3 = true), this._updateClassList(), t3;
          }
          _onMouseEvent(e4) {
            this._update(e4.point);
          }
          _getAnchor(e4) {
            if (this.options.anchor)
              return this.options.anchor;
            const t3 = this._map, i3 = this._container, o3 = this._pos;
            if (!t3 || !i3 || !o3)
              return "bottom";
            const r4 = i3.offsetWidth, s4 = i3.offsetHeight, n3 = o3.x < r4 / 2, a3 = o3.x > t3.transform.width - r4 / 2;
            if (o3.y + e4 < s4)
              return n3 ? "top-left" : a3 ? "top-right" : "top";
            if (o3.y > t3.transform.height - s4) {
              if (n3)
                return "bottom-left";
              if (a3)
                return "bottom-right";
            }
            return n3 ? "left" : a3 ? "right" : "bottom";
          }
          _updateClassList() {
            const e4 = this._container;
            if (!e4)
              return;
            const t3 = [...this._classList];
            t3.push("mapboxgl-popup"), this._anchor && t3.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t3.push("mapboxgl-popup-track-pointer"), e4.className = t3.join(" ");
          }
          _update(t3) {
            const i3 = this._map, o3 = this._content;
            if (!i3 || !this._lngLat && !this._trackPointer || !o3)
              return;
            let r4 = this._container;
            if (r4 || (r4 = this._container = s3("div", "mapboxgl-popup", i3.getContainer()), this._tip = s3("div", "mapboxgl-popup-tip", r4), r4.appendChild(o3)), this.options.maxWidth && r4.style.maxWidth !== this.options.maxWidth && (r4.style.maxWidth = this.options.maxWidth), i3.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ia(this._lngLat, this._pos, i3.transform)), !this._trackPointer || t3) {
              const e4 = this._pos = this._trackPointer && t3 ? t3 : i3.project(this._lngLat), o4 = aa(this.options.offset), r5 = this._anchor = this._getAnchor(o4.y), s4 = aa(this.options.offset, r5), n3 = e4.add(s4).round();
              i3._requestDomTask(() => {
                this._container && r5 && (this._container.style.transform = `${oa[r5]} translate(${n3.x}px,${n3.y}px)`);
              });
            }
            if (!this._marker && i3._showingGlobe()) {
              const t4 = e3.de(i3.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(t4);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const e4 = this._container.querySelector(na);
            e4 && e4.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e4) {
            this._container && (this._container.style.opacity = `${e4}`), this._content && (this._content.style.pointerEvents = e4 ? "auto" : "none");
          }
        }, Marker: ra, Style: Ao, LngLat: e3.bq, LngLatBounds: e3.ag, Point: e3.P, MercatorCoordinate: e3.O, FreeCameraOptions: co, Evented: e3.E, config: e3.dd, prewarm: e3.dy, clearPrewarmedResources: e3.dz, get accessToken() {
          return e3.dd.ACCESS_TOKEN;
        }, set accessToken(t3) {
          e3.dd.ACCESS_TOKEN = t3;
        }, get baseApiUrl() {
          return e3.dd.API_URL;
        }, set baseApiUrl(t3) {
          e3.dd.API_URL = t3;
        }, get workerCount() {
          return e3.dA.workerCount;
        }, set workerCount(t3) {
          e3.dA.workerCount = t3;
        }, get maxParallelImageRequests() {
          return e3.dd.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(t3) {
          e3.dd.MAX_PARALLEL_IMAGE_REQUESTS = t3;
        }, clearStorage(t3) {
          e3.dB(t3);
        }, get workerUrl() {
          return e3.dC.workerUrl;
        }, set workerUrl(t3) {
          e3.dC.workerUrl = t3;
        }, get workerClass() {
          return e3.dC.workerClass;
        }, set workerClass(t3) {
          e3.dC.workerClass = t3;
        }, get workerParams() {
          return e3.dC.workerParams;
        }, set workerParams(t3) {
          e3.dC.workerParams = t3;
        }, get dracoUrl() {
          return e3.dD();
        }, set dracoUrl(t3) {
          e3.dE(t3);
        }, get meshoptUrl() {
          return e3.dF();
        }, set meshoptUrl(t3) {
          e3.dG(t3);
        }, setNow: e3.f.setNow, restoreNow: e3.f.restoreNow };
        return ga;
      });
      var mapboxgl$1 = mapboxgl;
      return mapboxgl$1;
    });
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacies/new/_page.svelte.js
var page_svelte_exports7 = {};
__export(page_svelte_exports7, {
  default: () => _page7
});
function MapBox($$payload, $$props) {
  push();
  let { formData = void 0 } = $$props;
  $$payload.out += `<div class="h-[400px] w-full rounded-md shadow-md" id="map"></div>`;
  bind_props($$props, { formData });
  pop();
}
function CreatePharmacyForm($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  let toastState = getContext(CONTEXT_KEYS.TOAST);
  const countryList = ["Cameroon"];
  let creatingPharmacy = false;
  let form = superForm(data.createPharmacyForm, {
    validators: zodClient(createPharmacySchema),
    resetForm: true,
    onSubmit: () => {
      creatingPharmacy = true;
    },
    onError: ({ result }) => {
      creatingPharmacy = false;
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Pharmacy Creation Failed",
          duration: 3e3
        });
      }
    },
    onResult: ({ result }) => {
      creatingPharmacy = false;
      if (result.type === "success") {
        toastState.addToast({
          type: "success",
          message: result.data?.message,
          title: "Operation Successful",
          duration: 3e3
        });
        goto();
      }
    }
  });
  let tmp = form, formData = tmp.form;
  tmp.enhance;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<h1 class="text-xl md:text-2xl lg:text-3xl">Create A New Pharmacy</h1> <form method="POST" class="grid gap-4 py-4"><!--[-->`;
    Form_field($$payload2, {
      form,
      name: "name",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Pharmacy Name`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                placeholder: "pharma1",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).name;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).name = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "country",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Pharmacy Country`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Root4($$payload4, spread_props([
              attrs,
              {
                onSelectedChange: (v2) => {
                  if (!v2)
                    return;
                  formData.update(($prev) => {
                    return { ...$prev, country: v2.value };
                  });
                },
                children: ($$payload5, $$slotProps3) => {
                  $$payload5.out += `<!--[-->`;
                  Select_trigger($$payload5, {
                    class: "w-full",
                    children: ($$payload6, $$slotProps4) => {
                      $$payload6.out += `<!--[-->`;
                      Value($$payload6, { placeholder: "Select Country" });
                      $$payload6.out += `<!--]-->`;
                    },
                    $$slots: { default: true }
                  });
                  $$payload5.out += `<!--]--> <!--[-->`;
                  Select_content($$payload5, {
                    children: ($$payload6, $$slotProps4) => {
                      const each_array = ensure_array_like(countryList);
                      $$payload6.out += `<!--[-->`;
                      for (let $$index = 0; $$index < each_array.length; $$index++) {
                        const country = each_array[$$index];
                        $$payload6.out += "<!--[-->";
                        $$payload6.out += `<!--[-->`;
                        Select_item($$payload6, {
                          value: country,
                          children: ($$payload7, $$slotProps5) => {
                            $$payload7.out += `${escape_html(country)}`;
                          },
                          $$slots: { default: true }
                        });
                        $$payload6.out += `<!--]-->`;
                        $$payload6.out += "<!--]-->";
                      }
                      $$payload6.out += "<!--]-->";
                    },
                    $$slots: { default: true }
                  });
                  $$payload5.out += `<!--]-->`;
                },
                $$slots: { default: true }
              }
            ]));
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, {
              hidden: true,
              get value() {
                return store_get($$store_subs ??= {}, "$formData", formData).country;
              },
              set value($$value) {
                mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).country = $$value);
                $$settled = false;
              },
              name: attrs.name,
              class: "hidden"
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "organisationId",
      class: "gap-2 hidden",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Input($$payload4, {
              hidden: true,
              class: "hidden",
              get value() {
                return store_get($$store_subs ??= {}, "$formData", formData).organisationId;
              },
              set value($$value) {
                mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).organisationId = $$value);
                $$settled = false;
              },
              name: attrs.name
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "latitude",
      class: "gap-2 hidden",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Input($$payload4, {
              hidden: true,
              class: "hidden",
              get value() {
                return store_get($$store_subs ??= {}, "$formData", formData).latitude;
              },
              set value($$value) {
                mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).latitude = $$value);
                $$settled = false;
              },
              name: attrs.name
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "longitude",
      class: "gap-2 hidden",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Input($$payload4, {
              hidden: true,
              class: "hidden",
              get value() {
                return store_get($$store_subs ??= {}, "$formData", formData).longitude;
              },
              set value($$value) {
                mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).longitude = $$value);
                $$settled = false;
              },
              name: attrs.name
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "region",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Pharmacy State`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Root4($$payload4, spread_props([
              attrs,
              {
                onSelectedChange: (v2) => {
                  if (!v2)
                    return;
                  formData.update(($prev) => {
                    return { ...$prev, region: v2.value };
                  });
                },
                children: ($$payload5, $$slotProps3) => {
                  $$payload5.out += `<!--[-->`;
                  Select_trigger($$payload5, {
                    class: "w-full",
                    get value() {
                      return store_get($$store_subs ??= {}, "$formData", formData).region;
                    },
                    set value($$value) {
                      mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).region = $$value);
                      $$settled = false;
                    },
                    children: ($$payload6, $$slotProps4) => {
                      $$payload6.out += `<!--[-->`;
                      Value($$payload6, { placeholder: "Select State" });
                      $$payload6.out += `<!--]-->`;
                    },
                    $$slots: { default: true }
                  });
                  $$payload5.out += `<!--]--> <!--[-->`;
                  Select_content($$payload5, {
                    children: ($$payload6, $$slotProps4) => {
                      const states = COUNTRY_STATES_MAP[store_get($$store_subs ??= {}, "$formData", formData).country] || COUNTRY_STATES_MAP["Cameroon"];
                      $$payload6.out += `<!--[-->`;
                      if (!states.length) {
                        $$payload6.out += `<!--[-->`;
                        Select_item($$payload6, {
                          value: "N/A",
                          children: ($$payload7, $$slotProps5) => {
                            $$payload7.out += `N/A`;
                          },
                          $$slots: { default: true }
                        });
                        $$payload6.out += `<!--]-->`;
                        $$payload6.out += "<!--]-->";
                      } else {
                        const each_array_1 = ensure_array_like(states);
                        $$payload6.out += `<!--[-->`;
                        for (let $$index_1 = 0; $$index_1 < each_array_1.length; $$index_1++) {
                          const state = each_array_1[$$index_1];
                          $$payload6.out += "<!--[-->";
                          $$payload6.out += `<!--[-->`;
                          Select_item($$payload6, {
                            value: state,
                            children: ($$payload7, $$slotProps5) => {
                              $$payload7.out += `${escape_html(state)}`;
                            },
                            $$slots: { default: true }
                          });
                          $$payload6.out += `<!--]-->`;
                          $$payload6.out += "<!--]-->";
                        }
                        $$payload6.out += "<!--]-->";
                        $$payload6.out += "<!--]!-->";
                      }
                    },
                    $$slots: { default: true }
                  });
                  $$payload5.out += `<!--]-->`;
                },
                $$slots: { default: true }
              }
            ]));
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, {
              hidden: true,
              get value() {
                return store_get($$store_subs ??= {}, "$formData", formData).region;
              },
              set value($$value) {
                mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).region = $$value);
                $$settled = false;
              },
              name: attrs.name,
              class: "hidden"
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "city",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `City`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                placeholder: "Buea",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).city;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).city = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "address",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Pharmacy Address`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                placeholder: "Molyko",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).address;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).address = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    MapBox($$payload2, {
      get formData() {
        return formData;
      },
      set formData($$value) {
        formData = $$value;
        $$settled = false;
      }
    });
    $$payload2.out += `<!--]--> <div class="container flex w-full items-center justify-center py-2"><!--[-->`;
    Form_button($$payload2, {
      type: "submit",
      class: "md:w-[200px]",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        if (creatingPharmacy) {
          $$payload3.out += `<!--[-->`;
          Spinner($$payload3);
          $$payload3.out += `<!--]-->`;
          $$payload3.out += "<!--]-->";
        } else {
          $$payload3.out += "<!--]!-->";
        }
        $$payload3.out += ` ${escape_html(creatingPharmacy ? "Creating..." : "Create")}`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--></div></form>`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function _page7($$payload, $$props) {
  push();
  let { data } = $$props;
  $$payload.out += `<!--[-->`;
  CreatePharmacyForm($$payload, { data });
  $$payload.out += `<!--]-->`;
  pop();
}
var import_mapbox_gl, COUNTRY_STATES_MAP;
var init_page_svelte7 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacies/new/_page.svelte.js"() {
    init_index3();
    init_Spinner();
    init_client();
    init_compile();
    init_chunks();
    init_pharmacy_form();
    init_input();
    init_index7();
    import_mapbox_gl = __toESM(require_mapbox_gl(), 1);
    init_context_keys();
    init_form_field_errors();
    COUNTRY_STATES_MAP = {
      "Cameroon": [
        "Far North",
        "North",
        "Adamawa",
        "Centre",
        "East",
        "South",
        "West",
        "South West",
        "North West",
        "Litorral"
      ]
    };
  }
});

// .svelte-kit/output/server/nodes/12.js
var __exports13 = {};
__export(__exports13, {
  component: () => component13,
  fonts: () => fonts13,
  imports: () => imports13,
  index: () => index13,
  server: () => page_server_ts_exports,
  server_id: () => server_id4,
  stylesheets: () => stylesheets13
});
var index13, component_cache13, component13, server_id4, imports13, stylesheets13, fonts13;
var init__13 = __esm({
  ".svelte-kit/output/server/nodes/12.js"() {
    init_page_server_ts();
    index13 = 12;
    component13 = async () => component_cache13 ??= (await Promise.resolve().then(() => (init_page_svelte7(), page_svelte_exports7))).default;
    server_id4 = "src/routes/app/pharmacies/new/+page.server.ts";
    imports13 = ["_app/immutable/nodes/12.BYh09U6b.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/index.DajlKRcw.js", "_app/immutable/chunks/Icon.JZj92Q4v.js", "_app/immutable/chunks/transitions.Bmz1fhPf.js", "_app/immutable/chunks/index.DkWdW2MU.js", "_app/immutable/chunks/helpers.DNOQU4WG.js", "_app/immutable/chunks/form-field-errors.B-iUYCtK.js"];
    stylesheets13 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts13 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacists/_page.server.ts.js
var page_server_ts_exports2 = {};
__export(page_server_ts_exports2, {
  actions: () => actions2
});
var actions2;
var init_page_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacists/_page.server.ts.js"() {
    init_urls();
    init_pharmacist_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    actions2 = {
      deletePharmacist: async ({ request, locals, fetch: fetch2, cookies }) => {
        const form = await superValidate(request, zod(deletePharmacistSchema));
        if (!form.valid) {
          return fail2(400, { form });
        }
        const deletePharmacistResponse = await deleteRequest({
          url: `pharmacist/delete/${form.data.pharmacistId}`,
          fetcher: fetch2,
          baseURL: locals.baseURL,
          options: {
            headers: {
              Authorization: cookies.get(COOKIE_KEYS.SESSION_KEY) || ""
            }
          }
        });
        if (!deletePharmacistResponse.ok) {
          error(deletePharmacistResponse.status, {
            message: deletePharmacistResponse.message,
            status: deletePharmacistResponse.status
          });
        }
        return {
          message: deletePharmacistResponse.message
        };
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacists/_page.svelte.js
var page_svelte_exports8 = {};
__export(page_svelte_exports8, {
  default: () => _page8
});
function Create_pharmacist_trigger($$payload, $$props) {
  push();
  $$payload.out += `<div class="container mx-auto mt-5 flex items-center justify-center rounded-md border-2 border-dashed py-6"><!--[-->`;
  Button($$payload, {
    variant: "outline",
    href: "/app/pharmacists/new",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `Add New Pharmacist to Pharmacy <!--[-->`;
      Circle_plus($$payload2, { class: "ml-2 h-4 w-4" });
      $$payload2.out += `<!--]-->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!--]--></div>`;
  pop();
}
function _page8($$payload, $$props) {
  push();
  $$payload.out += `<div class="flex flex-col gap-5"><!--[-->`;
  Create_pharmacist_trigger($$payload);
  $$payload.out += `<!--]--> <!--[-->`;
  Pharmacist_table_wrapper($$payload);
  $$payload.out += `<!--]--></div>`;
  pop();
}
var init_page_svelte8 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacists/_page.svelte.js"() {
    init_index3();
    init_index4();
    init_table_row();
    init_pharmacist_table_wrapper();
  }
});

// .svelte-kit/output/server/nodes/13.js
var __exports14 = {};
__export(__exports14, {
  component: () => component14,
  fonts: () => fonts14,
  imports: () => imports14,
  index: () => index14,
  server: () => page_server_ts_exports2,
  server_id: () => server_id5,
  stylesheets: () => stylesheets14
});
var index14, component_cache14, component14, server_id5, imports14, stylesheets14, fonts14;
var init__14 = __esm({
  ".svelte-kit/output/server/nodes/13.js"() {
    init_page_server_ts2();
    index14 = 13;
    component14 = async () => component_cache14 ??= (await Promise.resolve().then(() => (init_page_svelte8(), page_svelte_exports8))).default;
    server_id5 = "src/routes/app/pharmacists/+page.server.ts";
    imports14 = ["_app/immutable/nodes/13.DZn7X1_R.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/table-row.B1j5B89g.js", "_app/immutable/chunks/Icon.JZj92Q4v.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/svelte-component.DG8WHjyG.js", "_app/immutable/chunks/pharmacist-table-wrapper.D9myEyLS.js", "_app/immutable/chunks/queryOptions.mHeyUsN7.js", "_app/immutable/chunks/context.C9dpIilQ.js", "_app/immutable/chunks/index.Cn0Hvpco.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/transitions.Bmz1fhPf.js", "_app/immutable/chunks/helpers.DNOQU4WG.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/pharmacist.form.f4vWm665.js"];
    stylesheets14 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts14 = [];
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacists/new/_page.server.ts.js
var page_server_ts_exports3 = {};
__export(page_server_ts_exports3, {
  actions: () => actions3,
  load: () => load6
});
var load6, actions3;
var init_page_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacists/new/_page.server.ts.js"() {
    init_urls();
    init_pharmacist_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    load6 = async ({ locals }) => {
      if (locals.tholaApp !== "thola-org") {
        redirect(302, "/app");
      }
      const createPharmacistForm = await superValidate(zod(createPharmacistSchema));
      return { createPharmacistForm };
    };
    actions3 = {
      default: async ({ request, locals, fetch: fetch2, cookies }) => {
        const form = await superValidate(request, zod(createPharmacistSchema));
        console.log("formData: ", form.data);
        if (!form.valid) {
          fail2(400, { form });
        }
        const createPharmacistResponse = await post({
          url: `pharmacist/create/${form.data.pharmacyId}`,
          input: {
            firstName: form.data.firstName,
            lastName: form.data.lastName,
            email: form.data.email,
            username: form.data.username,
            phoneNumber: form.data.phoneNumber
          },
          fetcher: fetch2,
          baseURL: locals.baseURL,
          options: {
            headers: {
              Authorization: cookies.get(COOKIE_KEYS.SESSION_KEY) || ""
            }
          }
        });
        if (!createPharmacistResponse.ok) {
          error(createPharmacistResponse.status, {
            message: createPharmacistResponse.message,
            status: createPharmacistResponse.status
          });
        }
        redirect(302, "/app/pharmacists");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/app/pharmacists/new/_page.svelte.js
var page_svelte_exports9 = {};
__export(page_svelte_exports9, {
  default: () => _page9
});
function Square_activity($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push();
  const iconNode = [
    [
      "rect",
      {
        "width": "18",
        "height": "18",
        "x": "3",
        "y": "3",
        "rx": "2"
      }
    ],
    [
      "path",
      { "d": "M17 12h-2l-2 5-2-10-2 5H7" }
    ]
  ];
  $$payload.out += `<!--[-->`;
  Icon($$payload, spread_props([
    { name: "square-activity" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        slot($$payload2, default_slot($$props), {}, null);
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  pop();
}
function Create_pharmacist_form($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  let toastState = getContext(CONTEXT_KEYS.TOAST);
  let creatingPharmacist = false;
  let form = superForm(data.createPharmacistForm, {
    validators: zodClient(createPharmacistSchema),
    resetForm: true,
    onSubmit: () => {
      creatingPharmacist = true;
    },
    onError: ({ result }) => {
      creatingPharmacist = false;
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Pharmacist Creation Failed",
          duration: 3e3
        });
      }
    },
    onResult: ({ result }) => {
      creatingPharmacist = false;
      if (result.type === "redirect") {
        toastState.addToast({
          type: "success",
          message: "Pharmacist created successfully",
          title: "Operation Successful",
          duration: 3e3
        });
        goto(result.location);
      }
      if (result.type === "success") {
        toastState.addToast({
          type: "success",
          message: result.data?.message,
          title: "Operation Successful",
          duration: 3e3
        });
        goto();
        return;
      }
    }
  });
  let pharmacyListStream = getContext(CONTEXT_KEYS.PHARMACY_LIST_STREAM);
  let tmp = form, formData = tmp.form;
  tmp.enhance;
  let pharmacyListQuery = createQuery(pharmacyListOptions(pharmacyListStream));
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<h1 class="text-xl md:text-2xl lg:text-3xl">Create A New Pharmacist</h1> <form method="POST" class="grid gap-4 py-4"><!--[-->`;
    Form_field($$payload2, {
      form,
      name: "firstName",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `First Name`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                placeholder: "John",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).firstName;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).firstName = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "lastName",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Last Name`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                placeholder: "Doe",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).lastName;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).lastName = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "username",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Username`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                placeholder: "Doe",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).username;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).username = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "email",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Email`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                type: "email",
                placeholder: "johndoe@email.com",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).email;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).email = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "phoneNumber",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Phone Number`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, spread_props([
              attrs,
              {
                placeholder: "1234567890",
                get value() {
                  return store_get($$store_subs ??= {}, "$formData", formData).phoneNumber;
                },
                set value($$value) {
                  mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).phoneNumber = $$value);
                  $$settled = false;
                }
              }
            ]));
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <!--[-->`;
    Form_field($$payload2, {
      form,
      name: "pharmacyId",
      class: "grid gap-2",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Control($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            const attrs = $$slotProps2.attrs;
            $$payload4.out += `<!--[-->`;
            Form_label($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Select Pharmacy`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Root4($$payload4, spread_props([
              attrs,
              {
                onSelectedChange: (v2) => {
                  if (!v2)
                    return;
                  formData.update(($prev) => {
                    return { ...$prev, pharmacyId: v2.value };
                  });
                },
                children: ($$payload5, $$slotProps3) => {
                  $$payload5.out += `<!--[-->`;
                  Select_trigger($$payload5, {
                    class: "w-full",
                    children: ($$payload6, $$slotProps4) => {
                      $$payload6.out += `<!--[-->`;
                      Value($$payload6, { placeholder: "Select Pharmacy" });
                      $$payload6.out += `<!--]-->`;
                    },
                    $$slots: { default: true }
                  });
                  $$payload5.out += `<!--]--> <!--[-->`;
                  if (store_get($$store_subs ??= {}, "$pharmacyListQuery", pharmacyListQuery).data && store_get($$store_subs ??= {}, "$pharmacyListQuery", pharmacyListQuery).data.ok) {
                    const pharmacies = store_get($$store_subs ??= {}, "$pharmacyListQuery", pharmacyListQuery).data.pharmacies;
                    $$payload5.out += `<!--[-->`;
                    Select_content($$payload5, {
                      children: ($$payload6, $$slotProps4) => {
                        const each_array = ensure_array_like(pharmacies);
                        $$payload6.out += `<!--[-->`;
                        for (let $$index = 0; $$index < each_array.length; $$index++) {
                          const pharmacy = each_array[$$index];
                          $$payload6.out += "<!--[-->";
                          $$payload6.out += `<!--[-->`;
                          Select_item($$payload6, {
                            value: pharmacy.pharmacyId,
                            children: ($$payload7, $$slotProps5) => {
                              $$payload7.out += `<!--[-->`;
                              Square_activity($$payload7, {});
                              $$payload7.out += `<!--]--> \xA0
								${escape_html(pharmacy.name)}`;
                            },
                            $$slots: { default: true }
                          });
                          $$payload6.out += `<!--]-->`;
                          $$payload6.out += "<!--]-->";
                        }
                        $$payload6.out += "<!--]-->";
                      },
                      $$slots: { default: true }
                    });
                    $$payload5.out += `<!--]-->`;
                    $$payload5.out += "<!--]-->";
                  } else {
                    $$payload5.out += "<!--]!-->";
                  }
                },
                $$slots: { default: true }
              }
            ]));
            $$payload4.out += `<!--]--> <!--[-->`;
            Input($$payload4, {
              hidden: true,
              get value() {
                return store_get($$store_subs ??= {}, "$formData", formData).pharmacyId;
              },
              set value($$value) {
                mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).pharmacyId = $$value);
                $$settled = false;
              },
              name: attrs.name,
              class: "hidden"
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--> <div class="container flex w-full items-center justify-center py-2"><!--[-->`;
    Form_button($$payload2, {
      type: "submit",
      class: "md:w-[200px]",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        if (creatingPharmacist) {
          $$payload3.out += `<!--[-->`;
          Spinner($$payload3);
          $$payload3.out += `<!--]-->`;
          $$payload3.out += "<!--]-->";
        } else {
          $$payload3.out += "<!--]!-->";
        }
        $$payload3.out += ` ${escape_html(creatingPharmacist ? "Creating..." : "Create")}`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]--></div></form>`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
function _page9($$payload, $$props) {
  push();
  let { data } = $$props;
  $$payload.out += `<!--[-->`;
  Create_pharmacist_form($$payload, { data });
  $$payload.out += `<!--]-->`;
  pop();
}
var init_page_svelte9 = __esm({
  ".svelte-kit/output/server/entries/pages/app/pharmacists/new/_page.svelte.js"() {
    init_index3();
    init_Spinner();
    init_client();
    init_compile();
    init_chunks();
    init_input();
    init_index7();
    init_context_keys();
    init_pharmacist_form();
    init_pharmacy_query();
    init_queryOptions();
    init_form_field_errors();
    init_Icon();
    init_misc();
  }
});

// .svelte-kit/output/server/nodes/14.js
var __exports15 = {};
__export(__exports15, {
  component: () => component15,
  fonts: () => fonts15,
  imports: () => imports15,
  index: () => index15,
  server: () => page_server_ts_exports3,
  server_id: () => server_id6,
  stylesheets: () => stylesheets15
});
var index15, component_cache15, component15, server_id6, imports15, stylesheets15, fonts15;
var init__15 = __esm({
  ".svelte-kit/output/server/nodes/14.js"() {
    init_page_server_ts3();
    index15 = 14;
    component15 = async () => component_cache15 ??= (await Promise.resolve().then(() => (init_page_svelte9(), page_svelte_exports9))).default;
    server_id6 = "src/routes/app/pharmacists/new/+page.server.ts";
    imports15 = ["_app/immutable/nodes/14.I9YPJG4s.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/index.DajlKRcw.js", "_app/immutable/chunks/Icon.JZj92Q4v.js", "_app/immutable/chunks/transitions.Bmz1fhPf.js", "_app/immutable/chunks/index.DkWdW2MU.js", "_app/immutable/chunks/helpers.DNOQU4WG.js", "_app/immutable/chunks/form-field-errors.B-iUYCtK.js", "_app/immutable/chunks/pharmacist.form.f4vWm665.js", "_app/immutable/chunks/pharmacy.query.BZHZ1xYY.js", "_app/immutable/chunks/queryOptions.mHeyUsN7.js", "_app/immutable/chunks/context.C9dpIilQ.js"];
    stylesheets15 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts15 = [];
  }
});

// .svelte-kit/output/server/chunks/auth.form.js
var verifyEmailSchema, forgotPasswordSchema, resetPasswordSchema, loginSchema, signupSchema;
var init_auth_form = __esm({
  ".svelte-kit/output/server/chunks/auth.form.js"() {
    init_lib();
    verifyEmailSchema = z.object({
      email: z.string({ required_error: "Email is required" }).email({ message: "Invalid email address" })
    });
    forgotPasswordSchema = z.object({
      email: z.string({ required_error: "Email is required" }).email({ message: "Invalid email address" })
    });
    resetPasswordSchema = z.object({
      email: z.string({ required_error: "Email is required" }).email({ message: "Invalid email address" }),
      newPassword: z.string({ required_error: "Password is required" }).min(5, { message: "Password must be at least 6 characters" }),
      confirmPassword: z.string({ required_error: "Password is required" }).min(5, { message: "Password must be at least 6 characters" }),
      confirmationCode: z.string({ required_error: "Reset confirmation code is required" }).length(6)
    }).superRefine((fields, ctx) => {
      if (fields.newPassword !== fields.confirmPassword) {
        ctx.addIssue({
          path: ["confirmPassword"],
          code: "custom",
          message: "Passwords do not match"
        });
      }
    });
    loginSchema = z.object({
      email: z.string({ required_error: "Email is required" }).email({ message: "Invalid email address" }),
      password: z.string({ required_error: "Password is required" }).min(5, { message: "Password must be at least 6 characters" })
    });
    signupSchema = z.object({
      firstName: z.string({ required_error: "First name is required" }),
      lastName: z.string({ required_error: "Last name is required" }),
      username: z.string({ required_error: "Username is required" }).min(3, { message: "Username must be at least 3 characters" }),
      password: z.string({ required_error: "Password is required" }).min(5, { message: "Password must be at least 6 characters" }),
      confirmPassword: z.string({ required_error: "Confirm password is required" }),
      confirmationCode: z.string({ required_error: "Confirmation code is required" }).regex(/^[0-9]{6}$/)
    }).superRefine((fields, ctx) => {
      if (fields.password !== fields.confirmPassword) {
        ctx.addIssue({
          path: ["confirmPassword"],
          code: "custom",
          message: "Passwords do not match"
        });
      }
      if (fields.username.includes(" ")) {
        ctx.addIssue({
          path: ["username"],
          code: "custom",
          message: "Username cannot contain spaces"
        });
      }
      const specialChars = /[^a-zA-Z0-9_-]/g;
      if (fields.username.match(specialChars)) {
        ctx.addIssue({
          path: ["username"],
          code: "custom",
          message: "Username cannot contain special characters"
        });
      }
    });
  }
});

// .svelte-kit/output/server/entries/pages/auth/forgot-password/_page.server.ts.js
var page_server_ts_exports4 = {};
__export(page_server_ts_exports4, {
  actions: () => actions4,
  load: () => load7
});
var load7, actions4;
var init_page_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/forgot-password/_page.server.ts.js"() {
    init_auth_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    init_urls();
    load7 = async () => {
      const forgotPasswordForm = await superValidate(zod(forgotPasswordSchema));
      return {
        forgotPasswordForm
      };
    };
    actions4 = {
      default: async ({ request, locals, cookies, fetch: fetch2 }) => {
        const baseURL = locals.baseURL;
        const userRole = locals.userRole;
        const forgotPasswordForm = await superValidate(request, zod(forgotPasswordSchema));
        if (!forgotPasswordForm.valid) {
          fail2(400, {
            forgotPasswordForm
          });
        }
        const forgotPasswordResponse = await post({
          url: "forgot-password",
          input: {
            email: forgotPasswordForm.data.email,
            role: userRole
          },
          fetcher: fetch2,
          baseURL
        });
        if (!forgotPasswordResponse.ok) {
          error(forgotPasswordResponse.status, {
            message: forgotPasswordResponse.message,
            status: forgotPasswordResponse.status
          });
        }
        cookies.set(COOKIE_KEYS.FORGOT_PASSWORD_EMAIL, forgotPasswordForm.data.email, {
          path: "/"
        });
        const redirectURL = "/auth/reset-password";
        redirect(302, redirectURL);
      }
    };
  }
});

// .svelte-kit/output/server/chunks/card-title.js
function Card($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<div${spread_attributes({
    class: cn("rounded-lg border bg-card text-card-foreground shadow-sm", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<div${spread_attributes({
    class: cn("p-6 pt-0", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_description($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<p${spread_attributes({
    class: cn("text-sm text-muted-foreground", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></p>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_header($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<div${spread_attributes({
    class: cn("flex flex-col space-y-1.5 p-6", className),
    ...$$restProps
  })}><!--[-->`;
  slot($$payload, default_slot($$props), {}, null);
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_title($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "tag"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  let tag = value_or_fallback($$props["tag"], () => "h3");
  $$payload.out += `<!--[-->`;
  if (tag)
    element(
      $$payload,
      tag,
      () => {
        $$payload.out += `${spread_attributes({
          class: cn("text-lg font-semibold leading-none tracking-tight", className),
          ...$$restProps
        })}`;
      },
      () => {
        $$payload.out += `<!--[-->`;
        slot($$payload, default_slot($$props), {}, null);
        $$payload.out += `<!--]-->`;
      }
    );
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className, tag });
  pop();
}
var init_card_title = __esm({
  ".svelte-kit/output/server/chunks/card-title.js"() {
    init_index3();
    init_index4();
    init_misc();
  }
});

// .svelte-kit/output/server/chunks/form-description.js
function Description($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["id", "asChild", "el"]);
  push();
  var $$store_subs;
  let descriptionAttrs;
  const { descriptionId, errors } = getFormField();
  let id = value_or_fallback($$props["id"], generateId3);
  let asChild = value_or_fallback($$props["asChild"], () => false);
  let el = value_or_fallback($$props["el"], () => void 0);
  descriptionId.set(id);
  descriptionAttrs = {
    id: store_get($$store_subs ??= {}, "$descriptionId", descriptionId),
    "data-fs-error": getDataFsError(store_get($$store_subs ??= {}, "$errors", errors)),
    "data-fs-description": "",
    ...$$restProps
  };
  $$payload.out += `<!--[-->`;
  if (asChild) {
    $$payload.out += `<!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get descriptionAttrs() {
          return descriptionAttrs;
        }
      },
      null
    );
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<div${spread_attributes({ ...descriptionAttrs })}><!--[-->`;
    slot(
      $$payload,
      default_slot($$props),
      {
        get descriptionAttrs() {
          return descriptionAttrs;
        }
      },
      null
    );
    $$payload.out += `<!--]--></div>`;
    $$payload.out += "<!--]!-->";
  }
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { id, asChild, el });
  pop();
}
function Form_description($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = value_or_fallback($$props["class"], () => void 0);
  $$payload.out += `<!--[-->`;
  Description($$payload, spread_props([
    {
      class: cn("text-sm text-muted-foreground", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        const descriptionAttrs = $$slotProps.descriptionAttrs;
        $$payload2.out += `<!--[-->`;
        slot(
          $$payload2,
          default_slot($$props),
          {
            get descriptionAttrs() {
              return descriptionAttrs;
            }
          },
          null
        );
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    }
  ]));
  $$payload.out += `<!--]-->`;
  bind_props($$props, { class: className });
  pop();
}
var init_form_description = __esm({
  ".svelte-kit/output/server/chunks/form-description.js"() {
    init_index3();
    init_Spinner();
    init_misc();
    init_index4();
  }
});

// .svelte-kit/output/server/entries/pages/auth/forgot-password/_page.svelte.js
var page_svelte_exports10 = {};
__export(page_svelte_exports10, {
  default: () => _page10
});
function _page10($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  const toastState = getContext(CONTEXT_KEYS.TOAST);
  let sendingResetEmail = false;
  const form = superForm(data.forgotPasswordForm, {
    validators: zodClient(forgotPasswordSchema),
    onSubmit: () => {
      sendingResetEmail = true;
    },
    onError: ({ result }) => {
      sendingResetEmail = false;
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Login failed"
        });
        return;
      }
    },
    onResult: ({ result }) => {
      sendingResetEmail = false;
      if (result.type === "failure") {
        const errors = result.data?.form.errors;
        for (const key2 in errors) {
          toastState.addToast({ type: "error", message: errors[key2][0] });
        }
        return;
      }
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Login failed"
        });
        return;
      }
      if (result.type === "redirect") {
        toastState.addToast({
          type: "success",
          message: "Login successful",
          title: "Login successful"
        });
        goto(result.location);
      }
    }
  });
  let { form: formData, enhance: enhance2 } = form;
  let emailPlaceholder = (() => {
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client") {
      return "johnddoe@gmail.com";
    }
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org") {
      return "pharma-org@thola.com";
    }
    return "pharmacy.myorg@thola.com";
  })();
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    Card($$payload2, {
      class: "mx-auto max-md:flex max-md:h-full max-md:w-full max-md:flex-col max-md:justify-center",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Card_header($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<!--[-->`;
            Card_title($$payload4, {
              class: "text-2xl",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Login`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Card_description($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Enter your email below to login to your account`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Card_content($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<form class="grid gap-4" method="POST"><!--[-->`;
            Form_field($$payload4, {
              form,
              name: "email",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Email`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        placeholder: emailPlaceholder,
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).email;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).email = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_description($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `This is your login email.`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Button($$payload4, {
              type: "submit",
              class: "w-full",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                if (sendingResetEmail) {
                  $$payload5.out += `<!--[-->`;
                  Spinner($$payload5);
                  $$payload5.out += `<!--]-->`;
                  $$payload5.out += "<!--]-->";
                } else {
                  $$payload5.out += "<!--]!-->";
                }
                $$payload5.out += ` ${escape_html(sendingResetEmail ? "Sending Recovery Email..." : "Send Password Recovery Email")}`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></form> <div class="mt-4 text-center text-sm">Already have an account? <a href="login" class="underline">Login Instead</a></div>`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]-->`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_page_svelte10 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/forgot-password/_page.svelte.js"() {
    init_index3();
    init_index4();
    init_card_title();
    init_clsx();
    init_Spinner();
    init_input();
    init_stores2();
    init_compile();
    init_chunks();
    init_context_keys();
    init_client();
    init_auth_form();
    init_form_description();
    init_form_field_errors();
  }
});

// .svelte-kit/output/server/nodes/15.js
var __exports16 = {};
__export(__exports16, {
  component: () => component16,
  fonts: () => fonts16,
  imports: () => imports16,
  index: () => index16,
  server: () => page_server_ts_exports4,
  server_id: () => server_id7,
  stylesheets: () => stylesheets16
});
var index16, component_cache16, component16, server_id7, imports16, stylesheets16, fonts16;
var init__16 = __esm({
  ".svelte-kit/output/server/nodes/15.js"() {
    init_page_server_ts4();
    index16 = 15;
    component16 = async () => component_cache16 ??= (await Promise.resolve().then(() => (init_page_svelte10(), page_svelte_exports10))).default;
    server_id7 = "src/routes/auth/forgot-password/+page.server.ts";
    imports16 = ["_app/immutable/nodes/15.Bh5Xmn2-.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/auth.form.D-S-JF0T.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/form-description.BdAn6Wpy.js", "_app/immutable/chunks/form-field-errors.B-iUYCtK.js"];
    stylesheets16 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts16 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/login/_page.server.ts.js
var page_server_ts_exports5 = {};
__export(page_server_ts_exports5, {
  actions: () => actions5,
  load: () => load8
});
var load8, actions5;
var init_page_server_ts5 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/login/_page.server.ts.js"() {
    init_auth_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    init_urls();
    load8 = async () => {
      const loginForm = await superValidate(zod(loginSchema));
      return {
        loginForm
      };
    };
    actions5 = {
      login: async ({ request, locals, url, cookies, fetch: fetch2 }) => {
        const baseURL = locals.baseURL;
        const loginForm = await superValidate(request, zod(loginSchema));
        if (!loginForm.valid) {
          fail2(400, {
            loginForm
          });
        }
        const loginUser = await post({
          url: "login",
          input: {
            email: loginForm.data.email,
            password: loginForm.data.password,
            role: locals.userRole
          },
          fetcher: fetch2,
          baseURL
        });
        if (!loginUser.ok) {
          error(loginUser.status, {
            message: loginUser.message,
            status: loginUser.status
          });
        }
        cookies.set(COOKIE_KEYS.SESSION_KEY, loginUser.sessionKey, {
          path: "/"
        });
        const redirectURL = url.searchParams.has("redirectTo") ? url.searchParams.get("redirectTo") : "/app";
        redirect(302, redirectURL);
      },
      logout: async ({ cookies }) => {
        cookies.delete(COOKIE_KEYS.SESSION_KEY, {
          path: "/"
        });
        redirect(302, "/auth/login");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/login/_page.svelte.js
var page_svelte_exports11 = {};
__export(page_svelte_exports11, {
  default: () => _page11
});
function _page11($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  const toastState = getContext(CONTEXT_KEYS.TOAST);
  let signingIn = false;
  const form = superForm(data.loginForm, {
    validators: zodClient(loginSchema),
    onSubmit: () => {
      signingIn = true;
    },
    onError: ({ result }) => {
      signingIn = false;
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Login failed"
        });
        return;
      }
    },
    onResult: ({ result }) => {
      signingIn = false;
      if (result.type === "failure") {
        const errors = result.data?.form.errors;
        for (const key2 in errors) {
          toastState.addToast({ type: "error", message: errors[key2][0] });
        }
        return;
      }
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Login failed"
        });
        return;
      }
      if (result.type === "redirect") {
        toastState.addToast({
          type: "success",
          message: "Login successful",
          title: "Login successful"
        });
        goto(result.location);
      }
    }
  });
  let { form: formData, enhance: enhance2 } = form;
  let emailPlaceholder = (() => {
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client") {
      return "johnddoe@gmail.com";
    }
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org") {
      return "pharma-org@thola.com";
    }
    return "pharmacy.myorg@thola.com";
  })();
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    Card($$payload2, {
      class: "mx-auto max-md:flex max-md:h-full max-md:w-full max-md:flex-col max-md:justify-center",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Card_header($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<!--[-->`;
            Card_title($$payload4, {
              class: "text-2xl",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Login`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Card_description($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Enter your email below to login to your account`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Card_content($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<form class="grid gap-4" method="POST" action="?/login"><!--[-->`;
            Form_field($$payload4, {
              form,
              name: "email",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Email`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        placeholder: emailPlaceholder,
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).email;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).email = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_description($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `This is your login email.`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Form_field($$payload4, {
              form,
              name: "password",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Password`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "password",
                        placeholder: "password",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).password;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).password = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_description($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `Enter your password`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Button($$payload4, {
              type: "submit",
              class: "w-full",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                if (signingIn) {
                  $$payload5.out += `<!--[-->`;
                  Spinner($$payload5);
                  $$payload5.out += `<!--]-->`;
                  $$payload5.out += "<!--]-->";
                } else {
                  $$payload5.out += "<!--]!-->";
                }
                $$payload5.out += ` ${escape_html(signingIn ? "Signing in..." : "Sign in")}`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></form> <!--[-->`;
            if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client") {
              $$payload4.out += `<div class="mt-4 text-center text-sm">Don't have an account? <a href="signup" class="underline">Sign up</a></div>`;
              $$payload4.out += "<!--]-->";
            } else {
              $$payload4.out += "<!--]!-->";
            }
            $$payload4.out += ` <div class="mt-4 text-center text-sm">Forgot your password? <a href="forgot-password" class="underline">Reset Password here</a></div>`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]-->`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_page_svelte11 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/login/_page.svelte.js"() {
    init_index3();
    init_index4();
    init_card_title();
    init_clsx();
    init_Spinner();
    init_input();
    init_stores2();
    init_compile();
    init_chunks();
    init_context_keys();
    init_client();
    init_auth_form();
    init_form_description();
    init_form_field_errors();
  }
});

// .svelte-kit/output/server/nodes/16.js
var __exports17 = {};
__export(__exports17, {
  component: () => component17,
  fonts: () => fonts17,
  imports: () => imports17,
  index: () => index17,
  server: () => page_server_ts_exports5,
  server_id: () => server_id8,
  stylesheets: () => stylesheets17
});
var index17, component_cache17, component17, server_id8, imports17, stylesheets17, fonts17;
var init__17 = __esm({
  ".svelte-kit/output/server/nodes/16.js"() {
    init_page_server_ts5();
    index17 = 16;
    component17 = async () => component_cache17 ??= (await Promise.resolve().then(() => (init_page_svelte11(), page_svelte_exports11))).default;
    server_id8 = "src/routes/auth/login/+page.server.ts";
    imports17 = ["_app/immutable/nodes/16.B31TKGV4.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/auth.form.D-S-JF0T.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/form-description.BdAn6Wpy.js", "_app/immutable/chunks/form-field-errors.B-iUYCtK.js"];
    stylesheets17 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts17 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/reset-password/_page.server.ts.js
var page_server_ts_exports6 = {};
__export(page_server_ts_exports6, {
  actions: () => actions6,
  load: () => load9
});
var load9, actions6;
var init_page_server_ts6 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/reset-password/_page.server.ts.js"() {
    init_urls();
    init_auth_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    load9 = async ({ cookies }) => {
      const forgotPasswordEmail = cookies.get(COOKIE_KEYS.FORGOT_PASSWORD_EMAIL);
      if (!forgotPasswordEmail) {
        redirect(302, `/auth/forgot-password`);
      }
      forgotPasswordSchema.parseAsync({ email: forgotPasswordEmail }).catch(() => {
        redirect(302, "/auth/forgot-password");
      });
      const resetPasswordForm = await superValidate(zod(resetPasswordSchema));
      return {
        resetPasswordForm,
        forgotPasswordEmail
      };
    };
    actions6 = {
      default: async ({ request, locals, cookies, fetch: fetch2 }) => {
        const baseURL = locals.baseURL;
        const userRole = locals.userRole;
        const email = cookies.get(COOKIE_KEYS.FORGOT_PASSWORD_EMAIL);
        if (!email) {
          redirect(302, "/auth/forgot-password");
        }
        const resetPasswordForm = await superValidate(request, zod(resetPasswordSchema));
        if (!resetPasswordForm.valid) {
          fail2(400, {
            resetPasswordForm
          });
        }
        const resetPasswordResponse = await post({
          url: "reset-password",
          input: {
            email: resetPasswordForm.data.email || email,
            password: resetPasswordForm.data.newPassword,
            confirmationCode: resetPasswordForm.data.confirmationCode,
            role: userRole
          },
          fetcher: fetch2,
          baseURL
        });
        if (!resetPasswordResponse.ok) {
          error(resetPasswordResponse.status, {
            message: resetPasswordResponse.message,
            status: resetPasswordResponse.status
          });
        }
        cookies.delete(COOKIE_KEYS.FORGOT_PASSWORD_EMAIL, {
          path: "/"
        });
        redirect(302, "/auth/login");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/reset-password/_page.svelte.js
var page_svelte_exports12 = {};
__export(page_svelte_exports12, {
  default: () => _page12
});
function _page12($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  const toastState = getContext(CONTEXT_KEYS.TOAST);
  let resettingPassword = false;
  let form = superForm(data.resetPasswordForm, {
    validators: zodClient(resetPasswordSchema),
    resetForm: true,
    onSubmit: () => {
      toastState.addToast({
        type: "info",
        message: "Password reset in progress...",
        duration: 5
      });
      resettingPassword = true;
    },
    onError: ({ result }) => {
      resettingPassword = false;
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Login failed"
        });
        return;
      }
    },
    onResult: ({ result }) => {
      if (result.type === "failure") {
        const errors2 = result.data?.form.errors;
        for (const key2 in errors2) {
          toastState.addToast({ type: "error", message: errors2[key2][0] });
        }
        return;
      }
      if (result.type === "redirect") {
        goto(result.location);
      }
    }
  });
  let { form: formData, enhance: enhance2, errors } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    Card($$payload2, {
      class: "mx-auto max-md:flex max-md:min-h-full max-md:w-full max-md:flex-col max-md:justify-center",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Card_header($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<!--[-->`;
            Card_title($$payload4, {
              class: "text-2xl",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Reset Password`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Card_description($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Reset your <strong>Thola Kimonganga</strong> Password`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Card_content($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<form class="grid gap-4" method="POST"><h1 class="font-bold">Your Email</h1> <p class="w-full cursor-not-allowed rounded-md border-2 border-secondary p-2">${escape_html(data.forgotPasswordEmail)}</p> <!--[-->`;
            Form_field($$payload4, {
              form,
              name: "newPassword",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `New Password`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "password",
                        placeholder: "password",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).newPassword;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).newPassword = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Form_field($$payload4, {
              form,
              name: "confirmPassword",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Confirm Password`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "password",
                        placeholder: "password",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).confirmPassword;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).confirmPassword = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Form_field($$payload4, {
              form,
              name: "confirmationCode",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Confirmation Code`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "text",
                        placeholder: "123456",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).confirmationCode;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).confirmationCode = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Button($$payload4, {
              type: "submit",
              class: "w-full",
              disabled: Object.keys(store_get($$store_subs ??= {}, "$errors", errors)).length > 0,
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                if (resettingPassword) {
                  $$payload5.out += `<!--[-->`;
                  Spinner($$payload5);
                  $$payload5.out += `<!--]-->`;
                  $$payload5.out += "<!--]-->";
                } else {
                  $$payload5.out += "<!--]!-->";
                }
                $$payload5.out += ` ${escape_html(resettingPassword ? "Changing Password..." : "Reset Password")}`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></form> <!--[-->`;
            if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client") {
              $$payload4.out += `<div class="mt-4 text-center text-sm">Already have an account? <a href="login" class="underline">Login Instead</a></div>`;
              $$payload4.out += "<!--]-->";
            } else {
              $$payload4.out += "<!--]!-->";
            }
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]-->`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_page_svelte12 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/reset-password/_page.svelte.js"() {
    init_index3();
    init_stores2();
    init_compile();
    init_chunks();
    init_auth_form();
    init_context_keys();
    init_client();
    init_index4();
    init_card_title();
    init_clsx();
    init_Spinner();
    init_input();
    init_form_field_errors();
  }
});

// .svelte-kit/output/server/nodes/17.js
var __exports18 = {};
__export(__exports18, {
  component: () => component18,
  fonts: () => fonts18,
  imports: () => imports18,
  index: () => index18,
  server: () => page_server_ts_exports6,
  server_id: () => server_id9,
  stylesheets: () => stylesheets18
});
var index18, component_cache18, component18, server_id9, imports18, stylesheets18, fonts18;
var init__18 = __esm({
  ".svelte-kit/output/server/nodes/17.js"() {
    init_page_server_ts6();
    index18 = 17;
    component18 = async () => component_cache18 ??= (await Promise.resolve().then(() => (init_page_svelte12(), page_svelte_exports12))).default;
    server_id9 = "src/routes/auth/reset-password/+page.server.ts";
    imports18 = ["_app/immutable/nodes/17.fUOPI0Ew.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/auth.form.D-S-JF0T.js", "_app/immutable/chunks/form-field-errors.B-iUYCtK.js"];
    stylesheets18 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts18 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/signup/_page.server.ts.js
var page_server_ts_exports7 = {};
__export(page_server_ts_exports7, {
  actions: () => actions7,
  load: () => load10
});
var ROLES, load10, actions7;
var init_page_server_ts7 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/signup/_page.server.ts.js"() {
    init_auth_form();
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    init_urls();
    ROLES = {
      USER: "user",
      PHARMACY: "pharmacy",
      ORGANISATION: "organisation",
      ADMIN: "admin"
    };
    load10 = async ({ locals, cookies }) => {
      const signupEmail = cookies.get(COOKIE_KEYS.SIGNUP_EMAIL);
      if (!signupEmail) {
        redirect(302, "/auth/verify-email");
      }
      verifyEmailSchema.parseAsync({ email: signupEmail }).catch(() => {
        redirect(302, "/auth/verify-email");
      });
      if (locals.tholaApp !== "thola-client") {
        redirect(302, "/");
      }
      const signupForm = await superValidate(zod(signupSchema));
      return {
        signupForm,
        signupEmail
      };
    };
    actions7 = {
      default: async ({ request, locals, cookies, fetch: fetch2 }) => {
        const signupEmail = cookies.get(COOKIE_KEYS.SIGNUP_EMAIL);
        const baseURL = locals.baseURL;
        const signupForm = await superValidate(request, zod(signupSchema));
        if (!signupForm.valid) {
          fail2(400, {
            signupForm
          });
        }
        const signupResponse = await post({
          url: "create",
          input: {
            firstName: signupForm.data.firstName,
            lastName: signupForm.data.lastName,
            username: signupForm.data.username,
            password: signupForm.data.password,
            email: signupEmail,
            confirmationCode: signupForm.data.confirmationCode,
            role: ROLES.USER
          },
          fetcher: fetch2,
          baseURL
        });
        if (!signupResponse.ok) {
          error(signupResponse.status, {
            message: signupResponse.message,
            status: signupResponse.status
          });
        }
        cookies.delete(COOKIE_KEYS.SIGNUP_EMAIL, {
          path: "/"
        });
        redirect(302, "/auth/login");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/signup/_page.svelte.js
var page_svelte_exports13 = {};
__export(page_svelte_exports13, {
  default: () => _page13
});
function _page13($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  const toastState = getContext(CONTEXT_KEYS.TOAST);
  let signingUp = false;
  const form = superForm(data.signupForm, {
    validators: zodClient(signupSchema),
    onSubmit: () => {
      signingUp = true;
    },
    onError: ({ result }) => {
      signingUp = false;
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Operation failed"
        });
        return;
      }
    },
    onResult: ({ result }) => {
      signingUp = false;
      if (result.type === "failure") {
        for (const key2 in result.data?.form.errors) {
          toastState.addToast({
            type: "error",
            message: result.data?.form.errors[key2][0]
          });
        }
        return;
      }
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Account creation failed"
        });
        return;
      }
      if (result.type === "redirect") {
        toastState.addToast({
          type: "success",
          message: "Account created successfully",
          title: "Operation successful"
        });
        goto(result.location);
      }
    }
  });
  let { form: formData, enhance: enhance2 } = form;
  (() => {
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client") {
      return "johnddoe@gmail.com";
    }
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org") {
      return "pharma-org@thola.com";
    }
    return "pharmacy.myorg@thola.com";
  })();
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    Card($$payload2, {
      class: "mx-auto max-md:flex max-md:min-h-full max-md:w-full max-md:flex-col max-md:justify-center",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Card_header($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<!--[-->`;
            Card_title($$payload4, {
              class: "text-2xl",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Sign Up`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Card_description($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Create your <strong>Thola Kimonganga</strong> Account`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Card_content($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<form class="grid gap-4" method="POST"><h1 class="font-bold">Signup Email</h1> <p class="w-full border-2 border-secondary rounded-md p-2 cursor-not-allowed">${escape_html(data.signupEmail)}</p> <div class="flex w-full flex-col gap-2 py-2 md:flex-row"><!--[-->`;
            Form_field($$payload4, {
              form,
              name: "firstName",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `First Name`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "text",
                        placeholder: "John",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).firstName;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).firstName = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Form_field($$payload4, {
              form,
              name: "lastName",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Last Name`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "text",
                        placeholder: "Doe",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).lastName;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).lastName = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></div> <div class="flex w-full flex-col gap-2 py-2 md:flex-row"><!--[-->`;
            Form_field($$payload4, {
              form,
              name: "username",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Username`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "text",
                        placeholder: "john-doe",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).username;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).username = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Form_field($$payload4, {
              form,
              name: "password",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Password`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "password",
                        placeholder: "password123",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).password;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).password = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></div> <div class="flex w-full flex-col gap-2 py-2 md:flex-row"><!--[-->`;
            Form_field($$payload4, {
              form,
              name: "confirmPassword",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Confirm Password`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "password",
                        placeholder: "password",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).confirmPassword;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).confirmPassword = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Form_field($$payload4, {
              form,
              name: "confirmationCode",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Confirmation Code`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        type: "text",
                        placeholder: "123456",
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).confirmationCode;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).confirmationCode = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></div> <!--[-->`;
            Button($$payload4, {
              type: "submit",
              class: "w-full",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                if (signingUp) {
                  $$payload5.out += `<!--[-->`;
                  Spinner($$payload5);
                  $$payload5.out += `<!--]-->`;
                  $$payload5.out += "<!--]-->";
                } else {
                  $$payload5.out += "<!--]!-->";
                }
                $$payload5.out += ` ${escape_html(signingUp ? "Creating account..." : "Sign Up")}`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></form> <!--[-->`;
            if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client") {
              $$payload4.out += `<div class="mt-4 text-center text-sm">Already have an account? <a href="signup" class="underline">Login Instead</a></div>`;
              $$payload4.out += "<!--]-->";
            } else {
              $$payload4.out += "<!--]!-->";
            }
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]-->`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_page_svelte13 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/signup/_page.svelte.js"() {
    init_index3();
    init_index4();
    init_card_title();
    init_clsx();
    init_Spinner();
    init_input();
    init_stores2();
    init_compile();
    init_chunks();
    init_context_keys();
    init_client();
    init_auth_form();
    init_form_field_errors();
  }
});

// .svelte-kit/output/server/nodes/18.js
var __exports19 = {};
__export(__exports19, {
  component: () => component19,
  fonts: () => fonts19,
  imports: () => imports19,
  index: () => index19,
  server: () => page_server_ts_exports7,
  server_id: () => server_id10,
  stylesheets: () => stylesheets19
});
var index19, component_cache19, component19, server_id10, imports19, stylesheets19, fonts19;
var init__19 = __esm({
  ".svelte-kit/output/server/nodes/18.js"() {
    init_page_server_ts7();
    index19 = 18;
    component19 = async () => component_cache19 ??= (await Promise.resolve().then(() => (init_page_svelte13(), page_svelte_exports13))).default;
    server_id10 = "src/routes/auth/signup/+page.server.ts";
    imports19 = ["_app/immutable/nodes/18.JimDCjKx.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/auth.form.D-S-JF0T.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/form-field-errors.B-iUYCtK.js"];
    stylesheets19 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts19 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/verify-email/_page.server.ts.js
var page_server_ts_exports8 = {};
__export(page_server_ts_exports8, {
  actions: () => actions8,
  load: () => load11
});
var load11, actions8;
var init_page_server_ts8 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/verify-email/_page.server.ts.js"() {
    init_chunks();
    init_client();
    init_compile();
    init_superValidate();
    init_urls();
    init_auth_form();
    load11 = async ({ locals }) => {
      const verifyEmailForm = await superValidate(zod(verifyEmailSchema));
      if (locals.tholaApp !== "thola-client") {
        redirect(302, "/auth/login");
      }
      return {
        verifyEmailForm
      };
    };
    actions8 = {
      default: async ({ request, locals, cookies, fetch: fetch2 }) => {
        const baseURL = locals.baseURL;
        const userRole = locals.userRole;
        const verifyEmailForm = await superValidate(request, zod(verifyEmailSchema));
        if (!verifyEmailForm.valid) {
          fail2(400, {
            verifyEmailForm
          });
        }
        const verifyEmailResponse = await post({
          url: "email-verification",
          input: {
            email: verifyEmailForm.data.email,
            role: userRole
          },
          fetcher: fetch2,
          baseURL
        });
        if (!verifyEmailResponse.ok) {
          error(verifyEmailResponse.status, {
            message: verifyEmailResponse.message,
            status: verifyEmailResponse.status
          });
        }
        cookies.set(COOKIE_KEYS.SIGNUP_EMAIL, verifyEmailForm.data.email, {
          path: "/"
        });
        const redirectURL = "/auth/signup";
        redirect(302, redirectURL);
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/verify-email/_page.svelte.js
var page_svelte_exports14 = {};
__export(page_svelte_exports14, {
  default: () => _page14
});
function _page14($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  const toastState = getContext(CONTEXT_KEYS.TOAST);
  let sendingVerificationEmail = false;
  const form = superForm(data.verifyEmailForm, {
    validators: zodClient(verifyEmailSchema),
    resetForm: true,
    onSubmit: () => {
      sendingVerificationEmail = true;
    },
    onError: ({ result }) => {
      sendingVerificationEmail = false;
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Login failed"
        });
        return;
      }
    },
    onResult: ({ result }) => {
      sendingVerificationEmail = false;
      if (result.type === "failure") {
        const errors = result.data?.form.errors;
        for (const key2 in errors) {
          toastState.addToast({ type: "error", message: errors[key2][0] });
        }
        return;
      }
      if (result.type === "error") {
        toastState.addToast({
          type: "error",
          message: result.error.message,
          title: "Login failed"
        });
        return;
      }
      if (result.type === "redirect") {
        toastState.addToast({
          type: "success",
          message: "Login successful",
          title: "Login successful"
        });
        goto(result.location);
      }
    }
  });
  let { form: formData, enhance: enhance2 } = form;
  let emailPlaceholder = (() => {
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-client") {
      return "johnddoe@gmail.com";
    }
    if (store_get($$store_subs ??= {}, "$page", page).data.tholaApp === "thola-org") {
      return "pharma-org@thola.com";
    }
    return "pharmacy.myorg@thola.com";
  })();
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<!--[-->`;
    Card($$payload2, {
      class: "mx-auto max-md:flex max-md:h-full max-md:w-full max-md:flex-col max-md:justify-center",
      children: ($$payload3, $$slotProps) => {
        $$payload3.out += `<!--[-->`;
        Card_header($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<!--[-->`;
            Card_title($$payload4, {
              class: "text-2xl",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Verify Email`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Card_description($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `Enter your email below for verification`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]-->`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]--> <!--[-->`;
        Card_content($$payload3, {
          children: ($$payload4, $$slotProps2) => {
            $$payload4.out += `<form class="grid gap-4" method="POST"><!--[-->`;
            Form_field($$payload4, {
              form,
              name: "email",
              class: "grid gap-2",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                Control($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    const attrs = $$slotProps4.attrs;
                    $$payload6.out += `<!--[-->`;
                    Form_label($$payload6, {
                      children: ($$payload7, $$slotProps5) => {
                        $$payload7.out += `Email`;
                      },
                      $$slots: { default: true }
                    });
                    $$payload6.out += `<!--]--> <!--[-->`;
                    Input($$payload6, spread_props([
                      attrs,
                      {
                        placeholder: emailPlaceholder,
                        get value() {
                          return store_get($$store_subs ??= {}, "$formData", formData).email;
                        },
                        set value($$value) {
                          mutate_store($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).email = $$value);
                          $$settled = false;
                        }
                      }
                    ]));
                    $$payload6.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_description($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `This is your login email.`;
                  },
                  $$slots: { default: true }
                });
                $$payload5.out += `<!--]--> <!--[-->`;
                Form_field_errors($$payload5, {});
                $$payload5.out += `<!--]-->`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--> <!--[-->`;
            Button($$payload4, {
              type: "submit",
              class: "w-full",
              children: ($$payload5, $$slotProps3) => {
                $$payload5.out += `<!--[-->`;
                if (sendingVerificationEmail) {
                  $$payload5.out += `<!--[-->`;
                  Spinner($$payload5);
                  $$payload5.out += `<!--]-->`;
                  $$payload5.out += "<!--]-->";
                } else {
                  $$payload5.out += "<!--]!-->";
                }
                $$payload5.out += ` ${escape_html(sendingVerificationEmail ? "Sending Verification Email..." : "Verify Email")}`;
              },
              $$slots: { default: true }
            });
            $$payload4.out += `<!--]--></form> <div class="mt-4 text-center text-sm">Already have an account? <a href="login" class="underline">Login Instead</a></div>`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!--]-->`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
var init_page_svelte14 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/verify-email/_page.svelte.js"() {
    init_index3();
    init_index4();
    init_card_title();
    init_clsx();
    init_Spinner();
    init_input();
    init_stores2();
    init_compile();
    init_chunks();
    init_context_keys();
    init_client();
    init_auth_form();
    init_form_description();
    init_form_field_errors();
  }
});

// .svelte-kit/output/server/nodes/19.js
var __exports20 = {};
__export(__exports20, {
  component: () => component20,
  fonts: () => fonts20,
  imports: () => imports20,
  index: () => index20,
  server: () => page_server_ts_exports8,
  server_id: () => server_id11,
  stylesheets: () => stylesheets20
});
var index20, component_cache20, component20, server_id11, imports20, stylesheets20, fonts20;
var init__20 = __esm({
  ".svelte-kit/output/server/nodes/19.js"() {
    init_page_server_ts8();
    index20 = 19;
    component20 = async () => component_cache20 ??= (await Promise.resolve().then(() => (init_page_svelte14(), page_svelte_exports14))).default;
    server_id11 = "src/routes/auth/verify-email/+page.server.ts";
    imports20 = ["_app/immutable/nodes/19.C5Z99Gfp.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/index.a1X_XThw.js", "_app/immutable/chunks/lifecycle.DZh9mCpd.js", "_app/immutable/chunks/misc.w05JabWi.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/stores.DIo9Tikq.js", "_app/immutable/chunks/auth.form.D-S-JF0T.js", "_app/immutable/chunks/Spinner.DyHiHqsm.js", "_app/immutable/chunks/forms.Dw1eFhPY.js", "_app/immutable/chunks/context-keys.CLavAaLf.js", "_app/immutable/chunks/input.CTzRl_8u.js", "_app/immutable/chunks/form-description.BdAn6Wpy.js", "_app/immutable/chunks/form-field-errors.B-iUYCtK.js"];
    stylesheets20 = ["_app/immutable/assets/Spinner.CrupbAX6.css"];
    fonts20 = [];
  }
});

// .svelte-kit/output/server/index.js
init_stringify();

// .svelte-kit/output/server/chunks/internal.js
init_index3();
var base = "";
var assets = base;
var initial = { base, assets };
function override(paths) {
  base = paths.base;
  assets = paths.assets;
}
function reset() {
  base = initial.base;
  assets = initial.assets;
}
var public_env = {};
var safe_public_env = {};
function set_private_env(environment) {
}
function set_public_env(environment) {
  public_env = environment;
}
function set_safe_public_env(environment) {
  safe_public_env = environment;
}
var is_array = Array.isArray;
var array_from = Array.from;
var is_frozen = Object.isFrozen;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var UNOWNED = 1 << 7;
var CLEAN = 1 << 8;
var DIRTY = 1 << 9;
var MAYBE_DIRTY = 1 << 10;
var INERT = 1 << 11;
var DESTROYED = 1 << 12;
var EFFECT_RAN = 1 << 13;
var STATE_SYMBOL = Symbol("$state");
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a2, b) {
  return a2 != a2 ? b == b : a2 !== b || a2 !== null && typeof a2 === "object" || typeof a2 === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
function effect_in_unowned_derived() {
  {
    throw new Error("effect_in_unowned_derived");
  }
}
function effect_update_depth_exceeded() {
  {
    throw new Error("effect_update_depth_exceeded");
  }
}
function hydration_failed() {
  {
    throw new Error("hydration_failed");
  }
}
function state_unsafe_mutation() {
  {
    throw new Error("state_unsafe_mutation");
  }
}
// @__NO_SIDE_EFFECTS__
function source(value) {
  const source2 = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    reactions: null,
    equals,
    v: value,
    version: 0
  };
  return source2;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value) {
  const s3 = /* @__PURE__ */ source(initial_value);
  s3.equals = safe_equals;
  if (current_component_context !== null && current_component_context.l !== null) {
    (current_component_context.l.s ??= []).push(s3);
  }
  return s3;
}
function set(signal, value) {
  var initialized = signal.v !== UNINITIALIZED;
  if (!current_untracking && initialized && current_reaction !== null && is_runes() && (current_reaction.f & DERIVED) !== 0) {
    state_unsafe_mutation();
  }
  if (!signal.equals(value)) {
    signal.v = value;
    signal.version++;
    if (is_runes() && initialized && current_effect !== null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & BRANCH_EFFECT) === 0) {
      if (current_dependencies !== null && current_dependencies.includes(signal)) {
        set_signal_status(current_effect, DIRTY);
        schedule_effect(current_effect);
      } else {
        if (current_untracked_writes === null) {
          set_current_untracked_writes([signal]);
        } else {
          current_untracked_writes.push(signal);
        }
      }
    }
    mark_reactions(signal, DIRTY, true);
  }
  return value;
}
function remove(current) {
  if (is_array(current)) {
    for (var i2 = 0; i2 < current.length; i2++) {
      var node = current[i2];
      if (node.isConnected) {
        node.remove();
      }
    }
  } else if (current.isConnected) {
    current.remove();
  }
}
function push_effect(effect22, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect22;
  } else {
    parent_last.next = effect22;
    effect22.prev = parent_last;
    parent_effect.last = effect22;
  }
}
function create_effect(type, fn, sync) {
  var is_root = (type & ROOT_EFFECT) !== 0;
  var effect22 = {
    ctx: current_component_context,
    deps: null,
    dom: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent: is_root ? null : current_effect,
    prev: null,
    teardown: null,
    transitions: null
  };
  if (current_reaction !== null && !is_root) {
    var flags = current_reaction.f;
    if ((flags & DERIVED) !== 0) {
      if ((flags & UNOWNED) !== 0) {
        effect_in_unowned_derived();
      }
      if (current_effect !== null) {
        push_effect(effect22, current_effect);
      }
    }
    push_effect(effect22, current_reaction);
  }
  if (sync) {
    var previously_flushing_effect = is_flushing_effect;
    try {
      set_is_flushing_effect(true);
      execute_effect(effect22);
      effect22.f |= EFFECT_RAN;
    } finally {
      set_is_flushing_effect(previously_flushing_effect);
    }
  } else {
    schedule_effect(effect22);
  }
  return effect22;
}
function effect_root(fn) {
  const effect22 = create_effect(ROOT_EFFECT, fn, true);
  return () => {
    destroy_effect(effect22);
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function branch(fn) {
  return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true);
}
function execute_effect_teardown(effect22) {
  var teardown = effect22.teardown;
  if (teardown !== null) {
    const previous_untracking = current_untracking;
    set_untracking(true);
    try {
      teardown.call(null);
    } finally {
      set_untracking(previous_untracking);
    }
  }
}
function destroy_effect(effect22) {
  var dom = effect22.dom;
  if (dom !== null) {
    remove(dom);
  }
  destroy_effect_children(effect22);
  remove_reactions(effect22, 0);
  set_signal_status(effect22, DESTROYED);
  if (effect22.transitions) {
    for (const transition of effect22.transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect22);
  var parent2 = effect22.parent;
  if (parent2 !== null && (effect22.f & BRANCH_EFFECT) !== 0 && parent2.first !== null) {
    var previous = effect22.prev;
    var next2 = effect22.next;
    if (previous !== null) {
      if (next2 !== null) {
        previous.next = next2;
        next2.prev = previous;
      } else {
        previous.next = null;
        parent2.last = previous;
      }
    } else if (next2 !== null) {
      next2.prev = null;
      parent2.first = next2;
    } else {
      parent2.first = null;
      parent2.last = null;
    }
  }
  effect22.next = effect22.prev = effect22.teardown = effect22.ctx = effect22.dom = effect22.deps = effect22.parent = // @ts-expect-error
  effect22.fn = null;
}
function flush_tasks() {
}
function hydration_mismatch(location2) {
  {
    console.warn("hydration_mismatch");
  }
}
function destroy_derived_children(signal) {
  destroy_effect_children(signal);
  var deriveds = signal.deriveds;
  if (deriveds !== null) {
    signal.deriveds = null;
    for (var i2 = 0; i2 < deriveds.length; i2 += 1) {
      destroy_derived(deriveds[i2]);
    }
  }
}
function update_derived(derived2, force_schedule) {
  destroy_derived_children(derived2);
  var value = execute_reaction_fn(derived2);
  var status = (current_skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(derived2, status);
  var is_equal = derived2.equals(value);
  if (!is_equal) {
    derived2.v = value;
    mark_reactions(derived2, DIRTY, force_schedule);
  }
  return is_equal;
}
function destroy_derived(signal) {
  destroy_derived_children(signal);
  remove_reactions(signal, 0);
  set_signal_status(signal, DESTROYED);
  signal.first = signal.last = signal.deps = signal.reactions = // @ts-expect-error `signal.fn` cannot be `null` while the signal is alive
  signal.fn = null;
}
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var FLUSH_YIELD = 2;
var current_scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued = false;
var is_yield_task_queued = false;
var is_flushing_effect = false;
function set_is_flushing_effect(value) {
  is_flushing_effect = value;
}
function set_untracking(value) {
  current_untracking = value;
}
var current_queued_root_effects = [];
var flush_count = 0;
var current_reaction = null;
var current_effect = null;
var current_dependencies = null;
var current_dependencies_index = 0;
var current_untracked_writes = null;
function set_current_untracked_writes(value) {
  current_untracked_writes = value;
}
var current_untracking = false;
var current_skip_reaction = false;
var current_component_context = null;
function is_runes() {
  return current_component_context !== null && current_component_context.l === null;
}
function check_dirtiness(reaction) {
  var flags = reaction.f;
  var is_dirty = (flags & DIRTY) !== 0;
  var is_unowned = (flags & UNOWNED) !== 0;
  if (is_dirty && !is_unowned) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0 || is_dirty && is_unowned) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length = dependencies.length;
      var is_equal;
      for (var i2 = 0; i2 < length; i2++) {
        var dependency = dependencies[i2];
        if (!is_dirty && check_dirtiness(
          /** @type {import('#client').Derived} */
          dependency
        )) {
          is_equal = update_derived(
            /** @type {import('#client').Derived} **/
            dependency,
            true
          );
        }
        if (is_unowned) {
          var version = dependency.version;
          if (version > /** @type {import('#client').Derived} */
          reaction.version) {
            reaction.version = version;
            return !is_equal;
          }
          if (!current_skip_reaction && !dependency?.reactions?.includes(reaction)) {
            var reactions = dependency.reactions;
            if (reactions === null) {
              dependency.reactions = [reaction];
            } else {
              reactions.push(reaction);
            }
          }
        } else if ((reaction.f & DIRTY) !== 0) {
          return true;
        }
      }
    }
    if (!is_unowned) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return is_dirty;
}
function handle_error(error2, effect22, component_context) {
  {
    throw error2;
  }
}
function execute_reaction_fn(signal) {
  const previous_dependencies = current_dependencies;
  const previous_dependencies_index = current_dependencies_index;
  const previous_untracked_writes = current_untracked_writes;
  const previous_reaction = current_reaction;
  const previous_skip_reaction = current_skip_reaction;
  const previous_untracking = current_untracking;
  current_dependencies = /** @type {null | import('#client').Value[]} */
  null;
  current_dependencies_index = 0;
  current_untracked_writes = null;
  current_reaction = signal;
  current_skip_reaction = !is_flushing_effect && (signal.f & UNOWNED) !== 0;
  current_untracking = false;
  try {
    let res = (0, signal.fn)();
    let dependencies = (
      /** @type {import('#client').Value<unknown>[]} **/
      signal.deps
    );
    if (current_dependencies !== null) {
      let i2;
      if (dependencies !== null) {
        const deps_length = dependencies.length;
        const full_current_dependencies = current_dependencies_index === 0 ? current_dependencies : dependencies.slice(0, current_dependencies_index).concat(current_dependencies);
        const current_dep_length = full_current_dependencies.length;
        const full_current_dependencies_set = current_dep_length > 16 && deps_length - current_dependencies_index > 1 ? new Set(full_current_dependencies) : null;
        for (i2 = current_dependencies_index; i2 < deps_length; i2++) {
          const dependency = dependencies[i2];
          if (full_current_dependencies_set !== null ? !full_current_dependencies_set.has(dependency) : !full_current_dependencies.includes(dependency)) {
            remove_reaction(signal, dependency);
          }
        }
      }
      if (dependencies !== null && current_dependencies_index > 0) {
        dependencies.length = current_dependencies_index + current_dependencies.length;
        for (i2 = 0; i2 < current_dependencies.length; i2++) {
          dependencies[current_dependencies_index + i2] = current_dependencies[i2];
        }
      } else {
        signal.deps = /** @type {import('#client').Value<V>[]} **/
        dependencies = current_dependencies;
      }
      if (!current_skip_reaction) {
        for (i2 = current_dependencies_index; i2 < dependencies.length; i2++) {
          const dependency = dependencies[i2];
          const reactions = dependency.reactions;
          if (reactions === null) {
            dependency.reactions = [signal];
          } else if (reactions[reactions.length - 1] !== signal) {
            reactions.push(signal);
          }
        }
      }
    } else if (dependencies !== null && current_dependencies_index < dependencies.length) {
      remove_reactions(signal, current_dependencies_index);
      dependencies.length = current_dependencies_index;
    }
    return res;
  } finally {
    current_dependencies = previous_dependencies;
    current_dependencies_index = previous_dependencies_index;
    current_untracked_writes = previous_untracked_writes;
    current_reaction = previous_reaction;
    current_skip_reaction = previous_skip_reaction;
    current_untracking = previous_untracking;
  }
}
function remove_reaction(signal, dependency) {
  const reactions = dependency.reactions;
  let reactions_length = 0;
  if (reactions !== null) {
    reactions_length = reactions.length - 1;
    const index21 = reactions.indexOf(signal);
    if (index21 !== -1) {
      if (reactions_length === 0) {
        dependency.reactions = null;
      } else {
        reactions[index21] = reactions[reactions_length];
        reactions.pop();
      }
    }
  }
  if (reactions_length === 0 && (dependency.f & UNOWNED) !== 0) {
    set_signal_status(dependency, MAYBE_DIRTY);
    remove_reactions(
      /** @type {import('#client').Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  const dependencies = signal.deps;
  if (dependencies !== null) {
    const active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);
    let i2;
    for (i2 = start_index; i2 < dependencies.length; i2++) {
      const dependency = dependencies[i2];
      if (active_dependencies === null || !active_dependencies.includes(dependency)) {
        remove_reaction(signal, dependency);
      }
    }
  }
}
function destroy_effect_children(signal) {
  let effect22 = signal.first;
  signal.first = null;
  signal.last = null;
  var sibling;
  while (effect22 !== null) {
    sibling = effect22.next;
    destroy_effect(effect22);
    effect22 = sibling;
  }
}
function execute_effect(effect22) {
  var flags = effect22.f;
  if ((flags & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect22, CLEAN);
  var component_context = effect22.ctx;
  var previous_effect = current_effect;
  var previous_component_context = current_component_context;
  current_effect = effect22;
  current_component_context = component_context;
  try {
    if ((flags & BLOCK_EFFECT) === 0) {
      destroy_effect_children(effect22);
    }
    execute_effect_teardown(effect22);
    var teardown = execute_reaction_fn(effect22);
    effect22.teardown = typeof teardown === "function" ? teardown : null;
  } catch (error2) {
    handle_error(
      /** @type {Error} */
      error2
    );
  } finally {
    current_effect = previous_effect;
    current_component_context = previous_component_context;
  }
}
function infinite_loop_guard() {
  if (flush_count > 1e3) {
    flush_count = 0;
    effect_update_depth_exceeded();
  }
  flush_count++;
}
function flush_queued_root_effects(root_effects) {
  const length = root_effects.length;
  if (length === 0) {
    return;
  }
  infinite_loop_guard();
  var previously_flushing_effect = is_flushing_effect;
  is_flushing_effect = true;
  try {
    for (var i2 = 0; i2 < length; i2++) {
      var effect22 = root_effects[i2];
      if (effect22.first === null && (effect22.f & BRANCH_EFFECT) === 0) {
        flush_queued_effects([effect22]);
      } else {
        var collected_effects = [];
        process_effects(effect22, collected_effects);
        flush_queued_effects(collected_effects);
      }
    }
  } finally {
    is_flushing_effect = previously_flushing_effect;
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0)
    return;
  for (var i2 = 0; i2 < length; i2++) {
    var effect22 = effects[i2];
    if ((effect22.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect22)) {
      execute_effect(effect22);
    }
  }
}
function process_deferred() {
  is_micro_task_queued = false;
  is_yield_task_queued = false;
  if (flush_count > 101) {
    return;
  }
  const previous_queued_root_effects = current_queued_root_effects;
  current_queued_root_effects = [];
  flush_queued_root_effects(previous_queued_root_effects);
  if (!is_micro_task_queued && !is_yield_task_queued) {
    flush_count = 0;
  }
}
async function yield_tick() {
  await new Promise((fulfil) => {
    requestAnimationFrame(() => {
      setTimeout(fulfil, 0);
    });
    setTimeout(fulfil, 100);
  });
}
function schedule_effect(signal) {
  if (current_scheduler_mode === FLUSH_MICROTASK) {
    if (!is_micro_task_queued) {
      is_micro_task_queued = true;
      queueMicrotask(process_deferred);
    }
  } else if (current_scheduler_mode === FLUSH_YIELD) {
    if (!is_yield_task_queued) {
      is_yield_task_queued = true;
      yield_tick().then(process_deferred);
    }
  }
  var effect22 = signal;
  while (effect22.parent !== null) {
    effect22 = effect22.parent;
    var flags = effect22.f;
    if ((flags & BRANCH_EFFECT) !== 0) {
      if ((flags & CLEAN) === 0)
        return;
      set_signal_status(effect22, MAYBE_DIRTY);
    }
  }
  current_queued_root_effects.push(effect22);
}
function process_effects(effect22, collected_effects) {
  var current_effect2 = effect22.first;
  var effects = [];
  main_loop:
    while (current_effect2 !== null) {
      var flags = current_effect2.f;
      var is_active = (flags & (DESTROYED | INERT)) === 0;
      var is_branch = flags & BRANCH_EFFECT;
      var is_clean = (flags & CLEAN) !== 0;
      var child = current_effect2.first;
      if (is_active && (!is_branch || !is_clean)) {
        if (is_branch) {
          set_signal_status(current_effect2, CLEAN);
        }
        if ((flags & RENDER_EFFECT) !== 0) {
          if (!is_branch && check_dirtiness(current_effect2)) {
            execute_effect(current_effect2);
            child = current_effect2.first;
          }
          if (child !== null) {
            current_effect2 = child;
            continue;
          }
        } else if ((flags & EFFECT) !== 0) {
          if (is_branch || is_clean) {
            if (child !== null) {
              current_effect2 = child;
              continue;
            }
          } else {
            effects.push(current_effect2);
          }
        }
      }
      var sibling = current_effect2.next;
      if (sibling === null) {
        let parent2 = current_effect2.parent;
        while (parent2 !== null) {
          if (effect22 === parent2) {
            break main_loop;
          }
          var parent_sibling = parent2.next;
          if (parent_sibling !== null) {
            current_effect2 = parent_sibling;
            continue main_loop;
          }
          parent2 = parent2.parent;
        }
      }
      current_effect2 = sibling;
    }
  for (var i2 = 0; i2 < effects.length; i2++) {
    child = effects[i2];
    collected_effects.push(child);
    process_effects(child, collected_effects);
  }
}
function yield_updates(fn) {
  const previous_scheduler_mode = current_scheduler_mode;
  try {
    current_scheduler_mode = FLUSH_YIELD;
    return fn();
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
  }
}
function flush_sync(fn, flush_previous = true) {
  var previous_scheduler_mode = current_scheduler_mode;
  var previous_queued_root_effects = current_queued_root_effects;
  try {
    infinite_loop_guard();
    const root_effects = [];
    current_scheduler_mode = FLUSH_SYNC;
    current_queued_root_effects = root_effects;
    if (flush_previous) {
      flush_queued_root_effects(previous_queued_root_effects);
    }
    var result = fn?.();
    flush_tasks();
    if (current_queued_root_effects.length > 0 || root_effects.length > 0) {
      flush_sync();
    }
    flush_count = 0;
    return result;
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
    current_queued_root_effects = previous_queued_root_effects;
  }
}
function get2(signal) {
  const flags = signal.f;
  if ((flags & DESTROYED) !== 0) {
    return signal.v;
  }
  if (current_reaction !== null && (current_reaction.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 && !current_untracking) {
    const unowned = (current_reaction.f & UNOWNED) !== 0;
    const dependencies = current_reaction.deps;
    if (current_dependencies === null && dependencies !== null && dependencies[current_dependencies_index] === signal && !(unowned && current_effect !== null)) {
      current_dependencies_index++;
    } else if (dependencies === null || current_dependencies_index === 0 || dependencies[current_dependencies_index - 1] !== signal) {
      if (current_dependencies === null) {
        current_dependencies = [signal];
      } else {
        current_dependencies.push(signal);
      }
    }
    if (current_untracked_writes !== null && current_effect !== null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & BRANCH_EFFECT) === 0 && current_untracked_writes.includes(signal)) {
      set_signal_status(current_effect, DIRTY);
      schedule_effect(current_effect);
    }
  }
  if ((flags & DERIVED) !== 0 && check_dirtiness(
    /** @type {import('#client').Derived} */
    signal
  )) {
    {
      update_derived(
        /** @type {import('#client').Derived} **/
        signal,
        false
      );
    }
  }
  return signal.v;
}
function mark_reactions(signal, to_status, force_schedule) {
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i2 = 0; i2 < length; i2++) {
    var reaction = reactions[i2];
    var flags = reaction.f;
    if ((flags & DIRTY) !== 0 || (!force_schedule || !runes) && reaction === current_effect) {
      continue;
    }
    set_signal_status(reaction, to_status);
    var maybe_dirty = (flags & MAYBE_DIRTY) !== 0;
    var unowned = (flags & UNOWNED) !== 0;
    if ((flags & CLEAN) !== 0 || maybe_dirty && unowned) {
      if ((reaction.f & DERIVED) !== 0) {
        mark_reactions(
          /** @type {import('#client').Derived} */
          reaction,
          MAYBE_DIRTY,
          force_schedule
        );
      } else {
        schedule_effect(
          /** @type {import('#client').Effect} */
          reaction
        );
      }
    }
  }
}
function untrack(fn) {
  const previous_untracking = current_untracking;
  try {
    current_untracking = true;
    return fn();
  } finally {
    current_untracking = previous_untracking;
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function push2(props, runes = false, fn) {
  current_component_context = {
    p: current_component_context,
    c: null,
    e: null,
    m: false,
    s: props,
    x: null,
    l: null
  };
  if (!runes) {
    current_component_context.l = {
      s: null,
      u: null,
      r1: [],
      r2: /* @__PURE__ */ source(false)
    };
  }
}
function pop2(component21) {
  const context_stack_item = current_component_context;
  if (context_stack_item !== null) {
    if (component21 !== void 0) {
      context_stack_item.x = component21;
    }
    const effects = context_stack_item.e;
    if (effects !== null) {
      context_stack_item.e = null;
      for (var i2 = 0; i2 < effects.length; i2++) {
        effect(effects[i2]);
      }
    }
    current_component_context = context_stack_item.p;
    context_stack_item.m = true;
  }
  return component21 || /** @type {T} */
  {};
}
function proxy(value, immutable2 = true, parent2 = null) {
  if (typeof value === "object" && value != null && !is_frozen(value)) {
    if (STATE_SYMBOL in value) {
      const metadata = (
        /** @type {import('#client').ProxyMetadata<T>} */
        value[STATE_SYMBOL]
      );
      if (metadata.t === value || metadata.p === value) {
        return metadata.p;
      }
    }
    const prototype = get_prototype_of(value);
    if (prototype === object_prototype || prototype === array_prototype) {
      const proxy2 = new Proxy(value, state_proxy_handler);
      define_property(value, STATE_SYMBOL, {
        value: (
          /** @type {import('#client').ProxyMetadata} */
          {
            s: /* @__PURE__ */ new Map(),
            v: /* @__PURE__ */ source(0),
            a: is_array(value),
            i: immutable2,
            p: proxy2,
            t: value
          }
        ),
        writable: true,
        enumerable: false
      });
      return proxy2;
    }
  }
  return value;
}
function update_version(signal, d = 1) {
  set(signal, signal.v + d);
}
var state_proxy_handler = {
  defineProperty(target, prop, descriptor) {
    if (descriptor.value) {
      const metadata = target[STATE_SYMBOL];
      const s3 = metadata.s.get(prop);
      if (s3 !== void 0)
        set(s3, proxy(descriptor.value, metadata.i, metadata));
    }
    return Reflect.defineProperty(target, prop, descriptor);
  },
  deleteProperty(target, prop) {
    const metadata = target[STATE_SYMBOL];
    const s3 = metadata.s.get(prop);
    const is_array2 = metadata.a;
    const boolean = delete target[prop];
    if (is_array2 && boolean) {
      const ls = metadata.s.get("length");
      const length = target.length - 1;
      if (ls !== void 0 && ls.v !== length) {
        set(ls, length);
      }
    }
    if (s3 !== void 0)
      set(s3, UNINITIALIZED);
    if (boolean) {
      update_version(metadata.v);
    }
    return boolean;
  },
  get(target, prop, receiver) {
    if (prop === STATE_SYMBOL) {
      return Reflect.get(target, STATE_SYMBOL);
    }
    const metadata = target[STATE_SYMBOL];
    let s3 = metadata.s.get(prop);
    if (s3 === void 0 && (!(prop in target) || get_descriptor(target, prop)?.writable)) {
      s3 = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata));
      metadata.s.set(prop, s3);
    }
    if (s3 !== void 0) {
      const value = get2(s3);
      return value === UNINITIALIZED ? void 0 : value;
    }
    return Reflect.get(target, prop, receiver);
  },
  getOwnPropertyDescriptor(target, prop) {
    const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
    if (descriptor && "value" in descriptor) {
      const metadata = target[STATE_SYMBOL];
      const s3 = metadata.s.get(prop);
      if (s3) {
        descriptor.value = get2(s3);
      }
    }
    return descriptor;
  },
  has(target, prop) {
    if (prop === STATE_SYMBOL) {
      return true;
    }
    const metadata = target[STATE_SYMBOL];
    const has3 = Reflect.has(target, prop);
    let s3 = metadata.s.get(prop);
    if (s3 !== void 0 || current_effect !== null && (!has3 || get_descriptor(target, prop)?.writable)) {
      if (s3 === void 0) {
        s3 = (metadata.i ? source : mutable_source)(
          has3 ? proxy(target[prop], metadata.i, metadata) : UNINITIALIZED
        );
        metadata.s.set(prop, s3);
      }
      const value = get2(s3);
      if (value === UNINITIALIZED) {
        return false;
      }
    }
    return has3;
  },
  set(target, prop, value, receiver) {
    const metadata = target[STATE_SYMBOL];
    let s3 = metadata.s.get(prop);
    if (s3 === void 0) {
      untrack(() => receiver[prop]);
      s3 = metadata.s.get(prop);
    }
    if (s3 !== void 0) {
      set(s3, proxy(value, metadata.i, metadata));
    }
    const is_array2 = metadata.a;
    const not_has = !(prop in target);
    if (is_array2 && prop === "length") {
      for (let i2 = value; i2 < target.length; i2 += 1) {
        const s22 = metadata.s.get(i2 + "");
        if (s22 !== void 0)
          set(s22, UNINITIALIZED);
      }
    }
    target[prop] = value;
    if (not_has) {
      if (is_array2) {
        const ls = metadata.s.get("length");
        const length = target.length;
        if (ls !== void 0 && ls.v !== length) {
          set(ls, length);
        }
      }
      update_version(metadata.v);
    }
    return true;
  },
  ownKeys(target) {
    const metadata = target[STATE_SYMBOL];
    get2(metadata.v);
    return Reflect.ownKeys(target);
  }
};
function set_hydrating(value) {
}
function hydrate_anchor(node) {
  if (node.nodeType !== 8) {
    return node;
  }
  var current = (
    /** @type {Node | null} */
    node
  );
  if (
    /** @type {Comment} */
    current.data !== HYDRATION_START
  ) {
    return node;
  }
  var nodes = [];
  var depth = 0;
  while ((current = /** @type {Node} */
  current.nextSibling) !== null) {
    if (current.nodeType === 8) {
      var data = (
        /** @type {Comment} */
        current.data
      );
      if (data === HYDRATION_START) {
        depth += 1;
      } else if (data[0] === HYDRATION_END) {
        if (depth === 0) {
          return current;
        }
        depth -= 1;
      }
    }
    nodes.push(current);
  }
  hydration_mismatch();
  throw HYDRATION_ERROR;
}
var node_prototype;
var element_prototype;
var text_prototype;
function init_operations() {
  if (node_prototype !== void 0) {
    return;
  }
  node_prototype = Node.prototype;
  element_prototype = Element.prototype;
  text_prototype = Text.prototype;
  element_prototype.__click = void 0;
  text_prototype.__nodeValue = " ";
  element_prototype.__className = "";
  element_prototype.__attributes = null;
  element_prototype.__e = void 0;
}
function empty() {
  return document.createTextNode("");
}
function clear_text_content(node) {
  node.textContent = "";
}
function handle_event_propagation(handler_element, event) {
  var owner_document = handler_element.ownerDocument;
  var event_name = event.type;
  var path = event.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event.target
  );
  if (event.target !== current_target) {
    define_property(event, "target", {
      configurable: true,
      value: current_target
    });
  }
  var path_idx = 0;
  var handled_at = event.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx + 1;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event.target;
  define_property(event, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  function next2(next_target) {
    current_target = next_target;
    var parent_element = next_target.parentNode || /** @type {any} */
    next_target.host || null;
    try {
      var delegated = next_target["__" + event_name];
      if (delegated !== void 0 && !/** @type {any} */
      next_target.disabled) {
        if (is_array(delegated)) {
          var [fn, ...data] = delegated;
          fn.apply(next_target, [event, ...data]);
        } else {
          delegated.call(next_target, event);
        }
      }
    } finally {
      if (!event.cancelBubble && parent_element !== handler_element && parent_element !== null && next_target !== handler_element) {
        next2(parent_element);
      }
    }
  }
  try {
    yield_updates(() => next2(
      /** @type {Element} */
      current_target
    ));
  } finally {
    event.__root = handler_element;
    current_target = handler_element;
  }
}
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function mount(component21, options2) {
  const anchor = options2.anchor ?? options2.target.appendChild(empty());
  return flush_sync(() => _mount(component21, { ...options2, anchor }), false);
}
function hydrate(component21, options2) {
  const target = options2.target;
  let hydrated = false;
  try {
    return flush_sync(() => {
      set_hydrating(true);
      var node = target.firstChild;
      while (node && (node.nodeType !== 8 || /** @type {Comment} */
      node.data !== HYDRATION_START)) {
        node = node.nextSibling;
      }
      if (!node) {
        throw HYDRATION_ERROR;
      }
      const anchor = hydrate_anchor(node);
      const instance = _mount(component21, { ...options2, anchor });
      set_hydrating(false);
      hydrated = true;
      return instance;
    }, false);
  } catch (error2) {
    if (error2 === HYDRATION_ERROR) {
      if (options2.recover === false) {
        hydration_failed();
      }
      init_operations();
      clear_text_content(target);
      return mount(component21, options2);
    }
    throw error2;
  } finally {
  }
}
function _mount(Component, { target, anchor, props = {}, events, context, intro = false }) {
  init_operations();
  const registered_events = /* @__PURE__ */ new Set();
  const bound_event_listener = handle_event_propagation.bind(null, target);
  const bound_document_event_listener = handle_event_propagation.bind(null, document);
  const event_handle = (events2) => {
    for (let i2 = 0; i2 < events2.length; i2++) {
      const event_name = events2[i2];
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        target.addEventListener(
          event_name,
          bound_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
        document.addEventListener(
          event_name,
          bound_document_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  let component21 = void 0;
  const unmount2 = effect_root(() => {
    branch(() => {
      if (context) {
        push2({});
        var ctx = (
          /** @type {import('#client').ComponentContext} */
          current_component_context
        );
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      component21 = Component(anchor, props) || {};
      if (context) {
        pop2();
      }
    });
    return () => {
      for (const event_name of registered_events) {
        target.removeEventListener(event_name, bound_event_listener);
      }
      root_event_handles.delete(event_handle);
      mounted_components.delete(component21);
    };
  });
  mounted_components.set(component21, unmount2);
  return component21;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component21) {
  const fn = mounted_components.get(component21);
  fn?.();
}
function asClassComponent$1(component21) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options2) {
      super({
        component: component21,
        ...options2
      });
    }
  };
}
var Svelte4Component = class {
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {import('svelte').ComponentConstructorOptions & {
   *  component: any;
   * 	immutable?: boolean;
   * 	hydrate?: boolean;
   * 	recover?: false;
   * }} options
   */
  constructor(options2) {
    const props = proxy({ ...options2.props || {}, $$events: {} }, false);
    this.#instance = (options2.hydrate ? hydrate : mount)(options2.component, {
      target: options2.target,
      props,
      context: options2.context,
      intro: options2.intro,
      recover: options2.recover
    });
    this.#events = props.$$events;
    for (const key2 of Object.keys(this.#instance)) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on")
        continue;
      define_property(this, key2, {
        get() {
          return this.#instance[key2];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key2] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event, callback) {
    this.#events[event] = this.#events[event] || [];
    const cb = (...args) => callback.call(this, ...args);
    this.#events[event].push(cb);
    return () => {
      this.#events[event] = this.#events[event].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
};
function asClassComponent(component21) {
  const component_constructor = asClassComponent$1(component21);
  const _render = (props, { context } = {}) => {
    const result = render(component21, { props, context });
    return {
      css: { code: "", map: null },
      head: result.head,
      html: result.html
    };
  };
  component_constructor.render = _render;
  return component_constructor;
}
var prerendering = false;
function Root($$payload, $$props) {
  push();
  let {
    stores,
    page: page2,
    constructors,
    components = [],
    form,
    data_0 = null,
    data_1 = null,
    data_2 = null,
    data_3 = null
  } = $$props;
  {
    setContext("__svelte__", stores);
  }
  {
    stores.page.set(page2);
  }
  $$payload.out += `<!--[-->`;
  if (constructors[1]) {
    $$payload.out += `<!--[-->`;
    constructors[0]?.($$payload, {
      data: data_0,
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<!--[-->`;
        if (constructors[2]) {
          $$payload2.out += `<!--[-->`;
          constructors[1]?.($$payload2, {
            data: data_1,
            children: ($$payload3, $$slotProps2) => {
              $$payload3.out += `<!--[-->`;
              if (constructors[3]) {
                $$payload3.out += `<!--[-->`;
                constructors[2]?.($$payload3, {
                  data: data_2,
                  children: ($$payload4, $$slotProps3) => {
                    $$payload4.out += `<!--[-->`;
                    constructors[3]?.($$payload4, { data: data_3, form });
                    $$payload4.out += `<!--]-->`;
                  },
                  $$slots: { default: true }
                });
                $$payload3.out += `<!--]-->`;
                $$payload3.out += "<!--]-->";
              } else {
                $$payload3.out += `<!--[-->`;
                constructors[2]?.($$payload3, { data: data_2, form });
                $$payload3.out += `<!--]-->`;
                $$payload3.out += "<!--]!-->";
              }
            },
            $$slots: { default: true }
          });
          $$payload2.out += `<!--]-->`;
          $$payload2.out += "<!--]-->";
        } else {
          $$payload2.out += `<!--[-->`;
          constructors[1]?.($$payload2, { data: data_1, form });
          $$payload2.out += `<!--]-->`;
          $$payload2.out += "<!--]!-->";
        }
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]-->";
  } else {
    $$payload.out += `<!--[-->`;
    constructors[0]?.($$payload, { data: data_0, form });
    $$payload.out += `<!--]-->`;
    $$payload.out += "<!--]!-->";
  }
  $$payload.out += ` <!--[-->`;
  {
    $$payload.out += "<!--]!-->";
  }
  pop();
}
var root = asClassComponent(Root);
var options = {
  app_dir: "_app",
  app_template_contains_nonce: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root,
  service_worker: false,
  templates: {
    app: ({ head: head2, body: body2, assets: assets2, nonce, env }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="' + assets2 + `/favicon.png" />
		<link href='https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.css' rel='stylesheet' />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		` + head2 + '\n	</head>\n	<body data-sveltekit-preload-data="hover">\n		<div style="display: contents">' + body2 + "</div>\n	</body>\n</html>\n",
    error: ({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n"
  },
  version_hash: "dklqt7"
};
async function get_hooks() {
  return {
    ...await Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports))
  };
}

// .svelte-kit/output/server/index.js
init_chunks();
init_exports();
init_index2();
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i2) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q2 = "1"] = match;
      parts.push({ type, subtype, q: +q2, i: i2 });
    }
  });
  parts.sort((a2, b) => {
    if (a2.q !== b.q) {
      return b.q - a2.q;
    }
    if (a2.subtype === "*" !== (b.subtype === "*")) {
      return a2.subtype === "*" ? 1 : -1;
    }
    if (a2.type === "*" !== (b.type === "*")) {
      return a2.type === "*" ? 1 : -1;
    }
    return a2.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
function normalize_error(error2) {
  return (
    /** @type {import('../runtime/control.js').Redirect | HttpError | SvelteKitError | Error} */
    error2
  );
}
function get_status(error2) {
  return error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : 500;
}
function get_message(error2) {
  return error2 instanceof SvelteKitError ? error2.text : "Internal Error";
}
function method_not_allowed(mod, method) {
  return text(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod || "HEAD" in mod)
    allowed.push("HEAD");
  return allowed;
}
function static_error_page(options2, status, message) {
  let page2 = options2.templates.error({ status, message });
  return text(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
async function handle_fatal_error(event, options2, error2) {
  error2 = error2 instanceof HttpError ? error2 : coalesce_to_error(error2);
  const status = get_status(error2);
  const body2 = await handle_error_and_jsonify(event, options2, error2);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body2, {
      status
    });
  }
  return static_error_page(options2, status, body2.message);
}
async function handle_error_and_jsonify(event, options2, error2) {
  if (error2 instanceof HttpError) {
    return error2.body;
  }
  const status = get_status(error2);
  const message = get_message(error2);
  return await options2.hooks.handleError({ error: error2, event, status, message }) ?? { message };
}
function redirect_response(status, location2) {
  const response = new Response(void 0, {
    status,
    headers: { location: location2 }
  });
  return response;
}
function clarify_devalue_error(event, error2) {
  if (error2.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error2.message} (data${error2.path})`;
  }
  if (error2.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error2.message;
}
function stringify_uses(node) {
  const uses = [];
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.push(`"dependencies":${JSON.stringify(Array.from(node.uses.dependencies))}`);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.push(`"search_params":${JSON.stringify(Array.from(node.uses.search_params))}`);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.push(`"params":${JSON.stringify(Array.from(node.uses.params))}`);
  }
  if (node.uses?.parent)
    uses.push('"parent":1');
  if (node.uses?.route)
    uses.push('"route":1');
  if (node.uses?.url)
    uses.push('"url":1');
  return `"uses":{${uses.join(",")}}`;
}
async function render_endpoint(event, mod, state) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && mod.GET && !mod.HEAD) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state.prerendering && !prerender) {
    if (state.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  try {
    let response = await handler(
      /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
      event
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state.prerendering) {
      response = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      response.headers.set("x-sveltekit-prerender", String(prerender));
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return new Response(void 0, {
        status: e3.status,
        headers: { location: e3.location }
      });
    }
    throw e3;
  }
}
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true")
    return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing);
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach((value2, i2) => {
            keys.push(`[${i2}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive2(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(`.${key2}`);
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a2, b) => b[1] - a2[1]).forEach((entry, i2) => {
    names.set(entry[0], get_name(i2));
  });
  function stringify22(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive2(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify22(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v2, i2) => i2 in thing ? stringify22(v2) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify22).join(",")}])`;
      default:
        const obj = `{${Object.keys(thing).map((key2) => `${safe_key(key2)}:${stringify22(thing[key2])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  const str = stringify22(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name2, thing) => {
      params.push(name2);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive2(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify22(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v2, i2) => {
            statements.push(`${name2}[${i2}]=${stringify22(v2)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name2}.${Array.from(thing).map((v2) => `add(${stringify22(v2)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name2}.${Array.from(thing).map(([k, v2]) => `set(${stringify22(k)}, ${stringify22(v2)})`).join(".")}`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name2}${safe_prop(key2)}=${stringify22(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name2 = "";
  do {
    name2 = chars$1[num % chars$1.length] + name2;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name2) ? `${name2}0` : name2;
}
function escape_unsafe_char(c2) {
  return escaped[c2] || c2;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
function stringify_primitive2(thing) {
  if (typeof thing === "string")
    return stringify_string(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  const str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint")
    return thing + "n";
  return str;
}
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
async function handle_action_json_request(event, options2, server2) {
  const actions9 = server2?.actions;
  if (!actions9) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      "POST method not allowed. No actions exist for this page"
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions9);
  try {
    const data = await call_action(event, actions9);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id
        )
      });
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, check_incorrect_fail_use(err))
      },
      {
        status: get_status(err)
      }
    );
  }
}
function check_incorrect_fail_use(error2) {
  return error2 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error2;
}
function action_json_redirect(redirect2) {
  return action_json({
    type: "redirect",
    status: redirect2.status,
    location: redirect2.location
  });
}
function action_json(data, init2) {
  return json(data, init2);
}
function is_action_request(event) {
  return event.request.method === "POST";
}
async function handle_action_request(event, server2) {
  const actions9 = server2?.actions;
  if (!actions9) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        "POST method not allowed. No actions exist for this page"
      )
    };
  }
  check_named_default_separate(actions9);
  try {
    const data = await call_action(event, actions9);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
function check_named_default_separate(actions9) {
  if (actions9.default && Object.keys(actions9).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://kit.svelte.dev/docs/form-actions#named-actions"
    );
  }
}
async function call_action(event, actions9) {
  const url = new URL(event.request.url);
  let name2 = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name2 = param[0].slice(1);
      if (name2 === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions9[name2];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name2}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return action(event);
}
function uneval_action_response(data, route_id) {
  return try_deserialize(data, uneval, route_id);
}
function stringify_action_response(data, route_id) {
  return try_deserialize(data, stringify, route_id);
}
function try_deserialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e3) {
    const error2 = (
      /** @type {any} */
      e3
    );
    if ("path" in error2) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error2.message}`;
      if (error2.path !== "")
        message += ` (data.${error2.path})`;
      throw new Error(message);
    }
    throw error2;
  }
}
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function b64_encode(buffer) {
  if (globalThis.Buffer) {
    return Buffer.from(buffer).toString("base64");
  }
  const little_endian = new Uint8Array(new Uint16Array([1]).buffer)[0] > 0;
  return btoa(
    new TextDecoder(little_endian ? "utf-16le" : "utf-16be").decode(
      new Uint16Array(new Uint8Array(buffer))
    )
  );
}
async function load_server_data({ event, state, node, parent: parent2 }) {
  if (!node?.server)
    return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state.prerendering) {
    disable_search(url);
  }
  const result = await node.server.load?.call(null, {
    ...event,
    fetch: (info, init2) => {
      new URL(info instanceof Request ? info.url : info, event.url);
      return event.fetch(info, init2);
    },
    /** @param {string[]} deps */
    depends: (...deps) => {
      for (const dep of deps) {
        const { href } = new URL(dep, event.url);
        uses.dependencies.add(href);
      }
    },
    params: new Proxy(event.params, {
      get: (target, key2) => {
        if (is_tracking) {
          uses.params.add(key2);
        }
        return target[
          /** @type {string} */
          key2
        ];
      }
    }),
    parent: async () => {
      if (is_tracking) {
        uses.parent = true;
      }
      return parent2();
    },
    route: new Proxy(event.route, {
      get: (target, key2) => {
        if (is_tracking) {
          uses.route = true;
        }
        return target[
          /** @type {'id'} */
          key2
        ];
      }
    }),
    url,
    untrack(fn) {
      is_tracking = false;
      try {
        return fn();
      } finally {
        is_tracking = true;
      }
    }
  });
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash: node.server.trailingSlash
  };
}
async function load_data({
  event,
  fetched,
  node,
  parent: parent2,
  server_data_promise,
  state,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  if (!node?.universal?.load) {
    return server_data_node?.data ?? null;
  }
  const result = await node.universal.load.call(null, {
    url: event.url,
    params: event.params,
    data: server_data_node?.data ?? null,
    route: event.route,
    fetch: create_universal_fetch(event, state, fetched, csr, resolve_opts),
    setHeaders: event.setHeaders,
    depends: () => {
    },
    parent: parent2,
    untrack: (fn) => fn()
  });
  return result ?? null;
}
function create_universal_fetch(event, state, fetched, csr, resolve_opts) {
  const universal_fetch = async (input, init2) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init2?.headers;
    let response = await event.fetch(input, init2);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state.prerendering) {
        dependency = { response, body: null };
        state.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else {
      const mode = input instanceof Request ? input.mode : init2?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    const proxy2 = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init2?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            if (dependency) {
              dependency.body = new Uint8Array(buffer);
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(b64_encode(buffer), true);
            }
            return buffer;
          };
        }
        async function text2() {
          const body2 = await response2.text();
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        if (key2 === "text") {
          return text2;
        }
        if (key2 === "json") {
          return async () => {
            return JSON.parse(await text2());
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get5 = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get5.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy2;
  };
  return (input, init2) => {
    const response = universal_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += decoder.decode(value);
  }
  return result;
}
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i2 = value.length;
      while (i2)
        hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i2 = buffer.length;
      while (i2)
        hash2 = hash2 * 33 ^ buffer[--i2];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(
  // special characters
  `[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`,
  "g"
);
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var replacements = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering2 = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter(key2, value)) {
      headers2[key2] = value;
    }
    if (key2 === "cache-control")
      cache_control = value;
    else if (key2 === "age")
      age = value;
    else if (key2 === "vary" && value.trim() === "*")
      varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url=${escape_html_attr(fetched.url)}`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering2 && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
var s = JSON.stringify;
var encoder$2 = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array2 = encode$1(data);
  for (let i2 = 0; i2 < array2.length; i2 += 16) {
    const w = array2.subarray(i2, i2 + 16);
    let tmp;
    let a2;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a2 = w[i22 + 1 & 15];
        b = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a2 >>> 7 ^ a2 >>> 18 ^ a2 >>> 3 ^ a2 << 25 ^ a2 << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x2) {
    return (x2 - Math.floor(x2)) * 4294967296;
  }
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2 += 4) {
    const a2 = bytes[i2 + 0];
    const b = bytes[i2 + 1];
    const c2 = bytes[i2 + 2];
    const d = bytes[i2 + 3];
    bytes[i2 + 0] = d;
    bytes[i2 + 1] = c2;
    bytes[i2 + 2] = b;
    bytes[i2 + 3] = a2;
  }
}
function encode$1(str) {
  const encoded = encoder$2.encode(str);
  const length = encoded.length * 8;
  const size2 = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size2 / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l2 = bytes.length;
  let result = "";
  let i2;
  for (i2 = 2; i2 < l2; i2 += 3) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2 | bytes[i2] >> 6];
    result += chars[bytes[i2] & 63];
  }
  if (i2 === l2 + 1) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === l2) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return base64(array);
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const script_src_elem = d["script-src-elem"];
    const effective_style_src = d["style-src"] || d["default-src"];
    const style_src_attr = d["style-src-attr"];
    const style_src_elem = d["style-src-elem"];
    this.#script_needs_csp = !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0 || !!script_src_elem && script_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.#style_needs_csp = !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_attr && style_src_attr.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_elem && style_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (this.#script_needs_csp) {
      const d = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha256(content);
        this.#script_src.push(`sha256-${hash2}`);
        if (d["script-src-elem"]?.length) {
          this.#script_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#script_src.length === 0) {
          this.#script_src.push(`nonce-${this.#nonce}`);
        }
        if (d["script-src-elem"]?.length) {
          this.#script_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (this.#style_needs_csp) {
      const empty_comment_hash = "9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha256(content);
        this.#style_src.push(`sha256-${hash2}`);
        if (d["style-src-attr"]?.length) {
          this.#style_src_attr.push(`sha256-${hash2}`);
        }
        if (d["style-src-elem"]?.length) {
          if (hash2 !== empty_comment_hash && !d["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#style_src.length === 0 && !d["style-src"]?.includes("unsafe-inline")) {
          this.#style_src.push(`nonce-${this.#nonce}`);
        }
        if (d["style-src-attr"]?.length) {
          this.#style_src_attr.push(`nonce-${this.#nonce}`);
        }
        if (d["style-src-elem"]?.length) {
          if (!d["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content=${escape_html_attr(content)}>`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v2) => !!v2).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function defer() {
  let fulfil;
  let reject;
  const promise = new Promise((f, r3) => {
    fulfil = f;
    reject = r3;
  });
  return { promise, fulfil, reject };
}
function create_async_iterator() {
  const deferred = [defer()];
  return {
    iterator: {
      [Symbol.asyncIterator]() {
        return {
          next: async () => {
            const next2 = await deferred[0].promise;
            if (!next2.done)
              deferred.shift();
            return next2;
          }
        };
      }
    },
    push: (value) => {
      deferred[deferred.length - 1].fulfil({
        value,
        done: false
      });
      deferred.push(defer());
    },
    done: () => {
      deferred[deferred.length - 1].fulfil({ done: true });
    }
  };
}
var updated = {
  ...readable(false),
  check: () => false
};
var encoder$1 = new TextEncoder();
async function render_response({
  branch: branch2,
  fetched,
  options: options2,
  manifest: manifest2,
  state,
  page_config,
  status,
  error: error2 = null,
  event,
  resolve_opts,
  action_result
}) {
  if (state.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets21 = new Set(client.stylesheets);
  const fonts21 = new Set(client.fonts);
  const link_header_preloads = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  if (!state.prerendering?.fallback) {
    const segments = event.url.pathname.slice(base.length).split("/").slice(2);
    base$1 = segments.map(() => "..").join("/") || ".";
    base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
    if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
      assets$1 = base$1;
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(branch2.map(({ node }) => node.component())),
      form: form_value
    };
    let data2 = {};
    for (let i2 = 0; i2 < branch2.length; i2 += 1) {
      data2 = { ...data2, ...branch2[i2].data };
      props[`data_${i2}`] = data2;
    }
    props.page = {
      error: error2,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value,
      state: {}
    };
    override({ base: base$1, assets: assets$1 });
    {
      try {
        rendered = options2.root.render(props);
      } finally {
        reset();
      }
    }
    for (const { node } of branch2) {
      for (const url of node.imports)
        modulepreloads.add(url);
      for (const url of node.stylesheets)
        stylesheets21.add(url);
      for (const url of node.fonts)
        fonts21.add(url);
      if (node.inline_styles) {
        Object.entries(await node.inline_styles()).forEach(([k, v2]) => inline_styles.set(k, v2));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head2 = "";
  let body2 = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state.prerendering
  });
  const prefixed = (path) => {
    if (path.startsWith("/")) {
      return base + path;
    }
    return `${assets$1}/${path}`;
  };
  if (inline_styles.size > 0) {
    const content = Array.from(inline_styles.values()).join("\n");
    const attributes = [];
    if (csp.style_needs_nonce)
      attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(content);
    head2 += `
	<style${attributes.join("")}>${content}</style>`;
  }
  for (const dep of stylesheets21) {
    const path = prefixed(dep);
    const attributes = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path })) {
        const preload_atts = ['rel="preload"', 'as="style"'];
        link_header_preloads.add(`<${encodeURI(path)}>; ${preload_atts.join(";")}; nopush`);
      }
    }
    head2 += `
		<link href="${path}" ${attributes.join(" ")}>`;
  }
  for (const dep of fonts21) {
    const path = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      const attributes = [
        'rel="preload"',
        'as="font"',
        `type="font/${ext}"`,
        `href="${path}"`,
        "crossorigin"
      ];
      head2 += `
		<link ${attributes.join(" ")}>`;
    }
  }
  const global = `__sveltekit_${options2.version_hash}`;
  const { data, chunks } = get_data(
    event,
    options2,
    branch2.map((b) => b.server_data),
    global
  );
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    if (client.uses_env_dynamic_public && state.prerendering) {
      modulepreloads.add(`${options2.app_dir}/env.js`);
    }
    const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
      (path) => resolve_opts.preload({ type: "js", path })
    );
    for (const path of included_modulepreloads) {
      link_header_preloads.add(`<${encodeURI(path)}>; rel="modulepreload"; nopush`);
      if (options2.preload_strategy !== "modulepreload") {
        head2 += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path}">`;
      } else if (state.prerendering) {
        head2 += `
		<link rel="modulepreload" href="${path}">`;
      }
    }
    const blocks = [];
    const load_env_eagerly = client.uses_env_dynamic_public && state.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      properties.push(`resolve: ({ id, data, error }) => {
							const { fulfil, reject } = deferred.get(id);
							deferred.delete(id);

							if (error) reject(error);
							else fulfil(data);
						}`);
    }
    blocks.push(`${global} = {
						${properties.join(",\n						")}
					};`);
    const args = ["app", "element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      blocks.push(`const data = ${data};`);
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id
        );
      }
      if (error2) {
        serialized.error = uneval(error2);
      }
      const hydrate2 = [
        `node_ids: [${branch2.map(({ node }) => node.index).join(", ")}]`,
        "data",
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate2.push(`status: ${status}`);
      }
      if (options2.embedded) {
        hydrate2.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate2.join(`,
${indent}	`)}
${indent}}`);
    }
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${options2.app_dir}/env.js`)}).then(({ env }) => {
						${global}.env = env;

						Promise.all([
							import(${s(prefixed(client.start))}),
							import(${s(prefixed(client.app))})
						]).then(([kit, app]) => {
							kit.start(${args.join(", ")});
						});
					});`);
    } else {
      blocks.push(`Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						kit.start(${args.join(", ")});
					});`);
    }
    if (options2.service_worker) {
      const opts = "";
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head2 = http_equiv.join("\n") + head2;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_header_preloads.size) {
      headers2.set("link", Array.from(link_header_preloads).join(", "));
    }
  }
  head2 += rendered.head;
  const html = options2.templates.app({
    head: head2,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: safe_public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller) {
        controller.enqueue(encoder$1.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller.enqueue(encoder$1.encode(chunk));
        }
        controller.close();
      },
      type: "bytes"
    }),
    {
      headers: {
        "content-type": "text/html"
      }
    }
  );
}
function get_data(event, options2, nodes, global) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push: push3, done } = create_async_iterator();
  function replacer(thing) {
    if (typeof thing?.then === "function") {
      const id = promise_id++;
      count += 1;
      thing.then(
        /** @param {any} data */
        (data) => ({ data })
      ).catch(
        /** @param {any} error */
        async (error2) => ({
          error: await handle_error_and_jsonify(event, options2, error2)
        })
      ).then(
        /**
         * @param {{data: any; error: any}} result
         */
        async ({ data, error: error2 }) => {
          count -= 1;
          let str;
          try {
            str = uneval({ id, data, error: error2 }, replacer);
          } catch (e3) {
            error2 = await handle_error_and_jsonify(
              event,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            data = void 0;
            str = uneval({ id, data, error: error2 }, replacer);
          }
          push3(`<script>${global}.resolve(${str})<\/script>
`);
          if (count === 0)
            done();
        }
      );
      return `${global}.defer(${id})`;
    }
  }
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      return `{"type":"data","data":${uneval(node.data, replacer)},${stringify_uses(node)}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `[${strings.join(",")}]`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
function get_option(nodes, option) {
  return nodes.reduce(
    (value, node) => {
      return (
        /** @type {Value} TypeScript's too dumb to understand this */
        node?.universal?.[option] ?? node?.server?.[option] ?? value
      );
    },
    /** @type {Value | undefined} */
    void 0
  );
}
async function respond_with_error({
  event,
  options: options2,
  manifest: manifest2,
  state,
  status,
  error: error2,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error2.message
    );
  }
  const fetched = [];
  try {
    const branch2 = [];
    const default_layout = await manifest2._.nodes[0]();
    const ssr = get_option([default_layout], "ssr") ?? true;
    const csr = get_option([default_layout], "csr") ?? true;
    if (ssr) {
      state.error = true;
      const server_data_promise = load_server_data({
        event,
        state,
        node: default_layout,
        parent: async () => ({})
      });
      const server_data = await server_data_promise;
      const data = await load_data({
        event,
        fetched,
        node: default_layout,
        parent: async () => ({}),
        resolve_opts,
        server_data_promise,
        state,
        csr
      });
      branch2.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state,
      page_config: {
        ssr,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, options2, error2),
      branch: branch2,
      fetched,
      event,
      resolve_opts
    });
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return redirect_response(e3.status, e3.location);
    }
    return static_error_page(
      options2,
      get_status(e3),
      (await handle_error_and_jsonify(event, options2, e3)).message
    );
  }
}
function once(fn) {
  let done = false;
  let result;
  return () => {
    if (done)
      return result;
    done = true;
    return result = fn();
  };
}
var encoder2 = new TextEncoder();
async function render_data(event, route, options2, manifest2, state, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions2 = node_ids.map((n2, i2) => {
      return once(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n2 == void 0 ? n2 : await manifest2._.nodes[n2]();
          return load_server_data({
            event: new_event,
            state,
            node,
            parent: async () => {
              const data2 = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                const parent2 = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions2[j2]()
                );
                if (parent2) {
                  Object.assign(data2, parent2.data);
                }
              }
              return data2;
            }
          });
        } catch (e3) {
          aborted = true;
          throw e3;
        }
      });
    });
    const promises = functions2.map(async (fn, i2) => {
      if (!invalidated[i2]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p2, i2) => p2.catch(async (error2) => {
          if (error2 instanceof Redirect) {
            throw error2;
          }
          length = Math.min(length, i2 + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, options2, error2),
              status: error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : void 0
            }
          );
        })
      )
    );
    const { data, chunks } = get_data_json(event, options2, nodes);
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller) {
          controller.enqueue(encoder2.encode(data));
          for await (const chunk of chunks) {
            controller.enqueue(encoder2.encode(chunk));
          }
          controller.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e3) {
    const error2 = normalize_error(e3);
    if (error2 instanceof Redirect) {
      return redirect_json_response(error2);
    } else {
      return json_response(await handle_error_and_jsonify(event, options2, error2), 500);
    }
  }
}
function json_response(json2, status = 200) {
  return text(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
function redirect_json_response(redirect2) {
  return json_response({
    type: "redirect",
    location: redirect2.location
  });
}
function get_data_json(event, options2, nodes) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push: push3, done } = create_async_iterator();
  const reducers = {
    /** @param {any} thing */
    Promise: (thing) => {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        count += 1;
        let key2 = "data";
        thing.catch(
          /** @param {any} e */
          async (e3) => {
            key2 = "error";
            return handle_error_and_jsonify(
              event,
              options2,
              /** @type {any} */
              e3
            );
          }
        ).then(
          /** @param {any} value */
          async (value) => {
            let str;
            try {
              str = stringify(value, reducers);
            } catch (e3) {
              const error2 = await handle_error_and_jsonify(
                event,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              key2 = "error";
              str = stringify(error2, reducers);
            }
            count -= 1;
            push3(`{"type":"chunk","id":${id},"${key2}":${str}}
`);
            if (count === 0)
              done();
          }
        );
        return id;
      }
    }
  };
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      if (node.type === "error" || node.type === "skip") {
        return JSON.stringify(node);
      }
      return `{"type":"data","data":${stringify(node.data, reducers)},${stringify_uses(
        node
      )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
function load_page_nodes(page2, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page2.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
    manifest2._.nodes[page2.leaf]()
  ]);
}
var MAX_DEPTH = 10;
async function render_page(event, page2, options2, manifest2, state, resolve_opts) {
  if (state.depth > MAX_DEPTH) {
    return text(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, options2, node?.server);
  }
  try {
    const nodes = await load_page_nodes(page2, manifest2);
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.at(-1)
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      action_result = await handle_action_request(event, leaf_node.server);
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender_data = nodes.some((node) => node?.server?.load);
    const data_pathname = add_data_suffix(event.url.pathname);
    const should_prerender = get_option(nodes, "prerender") ?? false;
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state.prerender_default = should_prerender;
    const fetched = [];
    if (get_option(nodes, "ssr") === false && !(state.prerendering && should_prerender_data)) {
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr: get_option(nodes, "csr") ?? true
        },
        status,
        error: null,
        event,
        options: options2,
        manifest: manifest2,
        state,
        resolve_opts
      });
    }
    const branch2 = [];
    let load_error = null;
    const server_promises = nodes.map((node, i2) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          return await load_server_data({
            event,
            state,
            node,
            parent: async () => {
              const data = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                const parent2 = await server_promises[j2];
                if (parent2)
                  Object.assign(data, await parent2.data);
              }
              return data;
            }
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    const csr = get_option(nodes, "csr") ?? true;
    const load_promises = nodes.map((node, i2) => {
      if (load_error)
        throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            fetched,
            node,
            parent: async () => {
              const data = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                Object.assign(data, await load_promises[j2]);
              }
              return data;
            },
            resolve_opts,
            server_data_promise: server_promises[i2],
            state,
            csr
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    for (const p2 of server_promises)
      p2.catch(() => {
      });
    for (const p2 of load_promises)
      p2.catch(() => {
      });
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const node = nodes[i2];
      if (node) {
        try {
          const server_data = await server_promises[i2];
          const data = await load_promises[i2];
          branch2.push({ node, server_data, data });
        } catch (e3) {
          const err = normalize_error(e3);
          if (err instanceof Redirect) {
            if (state.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state.prerendering.dependencies.set(data_pathname, {
                response: text(body2),
                body: body2
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = get_status(err);
          const error2 = await handle_error_and_jsonify(event, options2, err);
          while (i2--) {
            if (page2.errors[i2]) {
              const index21 = (
                /** @type {number} */
                page2.errors[i2]
              );
              const node2 = await manifest2._.nodes[index21]();
              let j2 = i2;
              while (!branch2[j2])
                j2 -= 1;
              return await render_response({
                event,
                options: options2,
                manifest: manifest2,
                state,
                resolve_opts,
                page_config: { ssr: true, csr: true },
                status: status2,
                error: error2,
                branch: compact(branch2.slice(0, j2 + 1)).concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched
              });
            }
          }
          return static_error_page(options2, status2, error2.message);
        }
      } else {
        branch2.push(null);
      }
    }
    if (state.prerendering && should_prerender_data) {
      let { data, chunks } = get_data_json(
        event,
        options2,
        branch2.map((node) => node?.server_data)
      );
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state.prerendering.dependencies.set(data_pathname, {
        response: text(data),
        body: data
      });
    }
    const ssr = get_option(nodes, "ssr") ?? true;
    return await render_response({
      event,
      options: options2,
      manifest: manifest2,
      state,
      resolve_opts,
      page_config: {
        csr: get_option(nodes, "csr") ?? true,
        ssr
      },
      status,
      error: null,
      branch: ssr === false ? [] : compact(branch2),
      action_result,
      fetched
    });
  } catch (e3) {
    return await respond_with_error({
      event,
      options: options2,
      manifest: manifest2,
      state,
      status: 500,
      error: e3,
      resolve_opts
    });
  }
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i2 = 0; i2 < params.length; i2 += 1) {
    const param = params[i2];
    let value = values[i2 - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i2 - buffered, i2 + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i2 + 1];
      const next_value = values[i2 + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
var parse_1 = parse$1;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var dec = opt.decode || decode;
  var index21 = 0;
  while (index21 < str.length) {
    var eqIdx = str.indexOf("=", index21);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index21);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index21 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key2 = str.slice(index21, eqIdx).trim();
    if (void 0 === obj[key2]) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key2] = tryDecode(val, dec);
    }
    index21 = endIdx + 1;
  }
  return obj;
}
function serialize(name2, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name2 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode(val) {
  return encodeURIComponent(val);
}
function isDate(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e3) {
    return str;
  }
}
function validate_options(options2) {
  if (options2?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
function get_cookies(request, url, trailing_slash) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = parse_1(header, { decode: (value) => value });
  const normalized_url = normalize_path(url.pathname, trailing_slash);
  const new_cookies = {};
  const defaults6 = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} opts
     */
    get(name2, opts) {
      const c2 = new_cookies[name2];
      if (c2 && domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
        return c2.value;
      }
      const decoder = opts?.decode || decodeURIComponent;
      const req_cookies = parse_1(header, { decode: decoder });
      const cookie = req_cookies[name2];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} opts
     */
    getAll(opts) {
      const decoder = opts?.decode || decodeURIComponent;
      const cookies2 = parse_1(header, { decode: decoder });
      for (const c2 of Object.values(new_cookies)) {
        if (domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
          cookies2[c2.name] = c2.value;
        }
      }
      return Object.entries(cookies2).map(([name2, value]) => ({ name: name2, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name2, value, options2) {
      validate_options(options2);
      set_internal(name2, value, { ...defaults6, ...options2 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name2, options2) {
      validate_options(options2);
      cookies.set(name2, "", { ...options2, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name2, value, options2) {
      validate_options(options2);
      let path = options2.path;
      if (!options2.domain || options2.domain === url.hostname) {
        path = resolve(normalized_url, path);
      }
      return serialize_1(name2, value, { ...defaults6, ...options2, path });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const key2 in new_cookies) {
      const cookie = new_cookies[key2];
      if (!domain_matches(destination.hostname, cookie.options.domain))
        continue;
      if (!path_matches(destination.pathname, cookie.options.path))
        continue;
      const encoder22 = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder22(cookie.value);
    }
    if (header2) {
      const parsed = parse_1(header2, { decode: (value) => value });
      for (const name2 in parsed) {
        combined_cookies[name2] = parsed[name2];
      }
    }
    return Object.entries(combined_cookies).map(([name2, value]) => `${name2}=${value}`).join("; ");
  }
  function set_internal(name2, value, options2) {
    let path = options2.path;
    if (!options2.domain || options2.domain === url.hostname) {
      path = resolve(normalized_url, path);
    }
    new_cookies[name2] = { name: name2, value, options: { ...options2, path } };
  }
  return { cookies, new_cookies, get_cookie_header, set_internal };
}
function domain_matches(hostname, constraint2) {
  if (!constraint2)
    return true;
  const normalized = constraint2[0] === "." ? constraint2.slice(1) : constraint2;
  if (hostname === normalized)
    return true;
  return hostname.endsWith("." + normalized);
}
function path_matches(path, constraint2) {
  if (!constraint2)
    return true;
  const normalized = constraint2.endsWith("/") ? constraint2.slice(0, -1) : constraint2;
  if (path === normalized)
    return true;
  return path.startsWith(normalized + "/");
}
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name: name2, value, options: options2 } = new_cookie;
    headers2.append("set-cookie", serialize_1(name2, value, options2));
    if (options2.path.endsWith(".html")) {
      const path = add_data_suffix(options2.path);
      headers2.append("set-cookie", serialize_1(name2, value, { ...options2, path }));
    }
  }
}
var setCookie = { exports: {} };
var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
function parseString(setCookieValue, options2) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name2 = parsed.name;
  var value = parsed.value;
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  try {
    value = options2.decodeValues ? decodeURIComponent(value) : value;
  } catch (e3) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
      e3
    );
  }
  var cookie = {
    name: name2,
    value
  };
  parts.forEach(function(part) {
    var sides = part.split("=");
    var key2 = sides.shift().trimLeft().toLowerCase();
    var value2 = sides.join("=");
    if (key2 === "expires") {
      cookie.expires = new Date(value2);
    } else if (key2 === "max-age") {
      cookie.maxAge = parseInt(value2, 10);
    } else if (key2 === "secure") {
      cookie.secure = true;
    } else if (key2 === "httponly") {
      cookie.httpOnly = true;
    } else if (key2 === "samesite") {
      cookie.sameSite = value2;
    } else {
      cookie[key2] = value2;
    }
  });
  return cookie;
}
function parseNameValuePair(nameValuePairStr) {
  var name2 = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name2 = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name: name2, value };
}
function parse(input, options2) {
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  if (!input) {
    if (!options2.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      input = input.headers["set-cookie"];
    } else {
      var sch = input.headers[Object.keys(input.headers).find(function(key2) {
        return key2.toLowerCase() === "set-cookie";
      })];
      if (!sch && input.headers.cookie && !options2.silent) {
        console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        );
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  if (!options2.map) {
    return input.filter(isNonEmptyString).map(function(str) {
      return parseString(str, options2);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
      var cookie = parseString(str, options2);
      cookies2[cookie.name] = cookie;
      return cookies2;
    }, cookies);
  }
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
setCookie.exports = parse;
setCookie.exports.parse = parse;
var parseString_1 = setCookie.exports.parseString = parseString;
var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
function create_fetch({ event, options: options2, manifest: manifest2, state, get_cookie_header, set_internal }) {
  const server_fetch = async (info, init2) => {
    const original_request = normalize_fetch_input(info, init2, event.url);
    let mode = (info instanceof Request ? info.mode : init2?.mode) ?? "cors";
    let credentials = (info instanceof Request ? info.credentials : init2?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: async (info2, init3) => {
        const request = normalize_fetch_input(info2, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info2 !== original_request) {
          mode = (info2 instanceof Request ? info2.mode : init3?.mode) ?? "cors";
          credentials = (info2 instanceof Request ? info2.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie)
              request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename);
        const is_asset_html = manifest2.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          }
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await respond(request, options2, manifest2, {
          ...state,
          depth: state.depth + 1
        });
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of splitCookiesString_1(set_cookie)) {
            const { name: name2, value, ...options3 } = parseString_1(str, {
              decodeValues: false
            });
            const path = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name2, value, {
              path,
              encode: (value2) => value2,
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }
    });
  };
  return (input, init2) => {
    const response = server_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
function normalize_fetch_input(info, init2, url) {
  if (info instanceof Request) {
    return info;
  }
  return new Request(typeof info === "string" ? new URL(info, url) : info, init2);
}
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
function get_page_config(nodes) {
  let current = {};
  for (const node of nodes) {
    if (!node?.universal?.config && !node?.server?.config)
      continue;
    current = {
      ...current,
      ...node?.universal?.config,
      ...node?.server?.config
    };
  }
  return Object.keys(current).length ? current : void 0;
}
var default_transform = ({ html }) => html;
var default_filter = () => false;
var default_preload = ({ type }) => type === "js" || type === "css";
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
async function respond(request, options2, manifest2, state) {
  const url = new URL(request.url);
  if (options2.csrf_check_origin) {
    const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url.origin;
    if (forbidden) {
      const csrf_error = new HttpError(
        403,
        `Cross-site ${request.method} form submissions are forbidden`
      );
      if (request.headers.get("accept") === "application/json") {
        return json(csrf_error.body, { status: csrf_error.status });
      }
      return text(csrf_error.body.message, { status: csrf_error.status });
    }
  }
  let rerouted_path;
  try {
    rerouted_path = options2.hooks.reroute({ url: new URL(url) }) ?? url.pathname;
  } catch (e3) {
    return text("Internal Server Error", {
      status: 500
    });
  }
  let decoded;
  try {
    decoded = decode_pathname(rerouted_path);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  let route = null;
  let params = {};
  if (base && !state.prerendering?.fallback) {
    if (!decoded.startsWith(base)) {
      return text("Not found", { status: 404 });
    }
    decoded = decoded.slice(base.length) || "/";
  }
  if (decoded === `/${options2.app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (decoded.startsWith(`/${options2.app_dir}`)) {
    return text("Not found", { status: 404 });
  }
  const is_data_request = has_data_suffix(decoded);
  let invalidated_data_nodes;
  if (is_data_request) {
    decoded = strip_data_suffix(decoded) || "/";
    url.pathname = strip_data_suffix(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  }
  if (!state.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  let trailing_slash = void 0;
  const headers2 = {};
  let cookies_to_add = {};
  const event = {
    // @ts-expect-error `cookies` and `fetch` need to be created after the `event` itself
    cookies: null,
    // @ts-expect-error
    fetch: null,
    getClientAddress: state.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params,
    platform: state.platform,
    request,
    route: { id: route?.id ?? null },
    setHeaders: (new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state.prerendering && lower === "cache-control") {
            state.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    },
    url,
    isDataRequest: is_data_request,
    isSubRequest: state.depth > 0
  };
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  try {
    if (route) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (route.page) {
        const nodes = await load_page_nodes(route.page, manifest2);
        if (DEV)
          ;
        trailing_slash = get_option(nodes, "trailingSlash");
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash;
        if (DEV)
          ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash ?? "never");
        if (normalized !== url.pathname && !state.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state.before_handle || state.emulator?.platform) {
        let config = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config = node.config ?? config;
          prerender = node.prerender ?? prerender;
        } else if (route.page) {
          const nodes = await load_page_nodes(route.page, manifest2);
          config = get_page_config(nodes) ?? config;
          prerender = get_option(nodes, "prerender") ?? false;
        }
        if (state.before_handle) {
          state.before_handle(event, config, prerender);
        }
        if (state.emulator?.platform) {
          event.platform = await state.emulator.platform({ config, prerender });
        }
      }
    }
    const { cookies, new_cookies, get_cookie_header, set_internal } = get_cookies(
      request,
      url,
      trailing_slash ?? "never"
    );
    cookies_to_add = new_cookies;
    event.cookies = cookies;
    event.fetch = create_fetch({
      event,
      options: options2,
      manifest: manifest2,
      state,
      get_cookie_header,
      set_internal
    });
    if (state.prerendering && !state.prerendering.fallback)
      disable_search(url);
    const response = await options2.hooks.handle({
      event,
      resolve: (event2, opts) => resolve2(event2, opts).then((response2) => {
        for (const key2 in headers2) {
          const value = headers2[key2];
          response2.headers.set(
            key2,
            /** @type {string} */
            value
          );
        }
        add_cookies_to_headers(response2.headers, Object.values(cookies_to_add));
        if (state.prerendering && event2.route.id !== null) {
          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
        }
        return response2;
      })
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value)
            headers22.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location2 = response.headers.get("location");
      if (location2) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location2
        ));
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      const response = is_data_request ? redirect_json_response(e3) : route?.page && is_action_json_request(event) ? action_json_redirect(e3) : redirect_response(e3.status, e3.location);
      add_cookies_to_headers(response.headers, Object.values(cookies_to_add));
      return response;
    }
    return await handle_fatal_error(event, options2, e3);
  }
  async function resolve2(event2, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (state.prerendering?.fallback) {
        return await render_response({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts
        });
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response;
        if (is_data_request) {
          response = await render_data(
            event2,
            route,
            options2,
            manifest2,
            state,
            invalidated_data_nodes,
            trailing_slash ?? "never"
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response = await render_endpoint(event2, await route.endpoint(), state);
        } else if (route.page) {
          if (page_methods.has(method)) {
            response = await render_page(event2, route.page, options2, manifest2, state, resolve_opts);
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response.headers.get("vary")?.split(",")?.map((v2) => v2.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response = new Response(response.body, {
              status: response.status,
              statusText: response.statusText,
              headers: new Headers(response.headers)
            });
            response.headers.append("Vary", "Accept");
          }
        }
        return response;
      }
      if (state.error && event2.isSubRequest) {
        return await fetch(request, {
          headers: {
            "x-sveltekit-error": "true"
          }
        });
      }
      if (state.error) {
        return text("Internal Server Error", {
          status: 500
        });
      }
      if (state.depth === 0) {
        return await respond_with_error({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state.prerendering) {
        return text("not found", { status: 404 });
      }
      return await fetch(request);
    } catch (e3) {
      return await handle_fatal_error(event2, options2, e3);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function filter_private_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(private_prefix) && (public_prefix === "" || !k.startsWith(public_prefix))
    )
  );
}
function filter_public_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(public_prefix) && (private_prefix === "" || !k.startsWith(private_prefix))
    )
  );
}
var prerender_env_handler = {
  get({ type }, prop) {
    throw new Error(
      `Cannot read values from $env/dynamic/${type} while prerendering (attempted to read env.${prop.toString()}). Use $env/static/${type} instead`
    );
  }
};
var Server = class {
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
  }
  /**
   * @param {{
   *   env: Record<string, string>;
   *   read?: (file: string) => ReadableStream;
   * }} opts
   */
  async init({ env, read }) {
    const prefixes = {
      public_prefix: this.#options.env_public_prefix,
      private_prefix: this.#options.env_private_prefix
    };
    const private_env = filter_private_env(env, prefixes);
    const public_env2 = filter_public_env(env, prefixes);
    set_private_env(
      prerendering ? new Proxy({ type: "private" }, prerender_env_handler) : private_env
    );
    set_public_env(
      prerendering ? new Proxy({ type: "public" }, prerender_env_handler) : public_env2
    );
    set_safe_public_env(public_env2);
    if (!this.#options.hooks) {
      try {
        const module = await get_hooks();
        this.#options.hooks = {
          handle: module.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module.handleError || (({ error: error2 }) => console.error(error2)),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request)),
          reroute: module.reroute || (() => {
          })
        };
      } catch (error2) {
        {
          throw error2;
        }
      }
    }
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.png", "images/placeholder-user.webp"]),
    mimeTypes: { ".png": "image/png", ".webp": "image/webp" },
    _: {
      client: { "start": "_app/immutable/entry/start.BQKu8JTU.js", "app": "_app/immutable/entry/app.5EJvniNT.js", "imports": ["_app/immutable/entry/start.BQKu8JTU.js", "_app/immutable/chunks/entry.DX3ARJt5.js", "_app/immutable/chunks/index-client.CnoYmsF-.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/entry/app.5EJvniNT.js", "_app/immutable/chunks/runtime.Bhf-vxpv.js", "_app/immutable/chunks/render.DPGttwyb.js", "_app/immutable/chunks/disclose-version.DtR1NMXz.js", "_app/immutable/chunks/props.D_dd-OEt.js", "_app/immutable/chunks/svelte-component.DG8WHjyG.js", "_app/immutable/chunks/this.2d3mUT6l.js", "_app/immutable/chunks/index-client.CnoYmsF-.js"], "stylesheets": [], "fonts": [], "uses_env_dynamic_public": false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7))),
        __memo(() => Promise.resolve().then(() => (init__8(), __exports8))),
        __memo(() => Promise.resolve().then(() => (init__9(), __exports9))),
        __memo(() => Promise.resolve().then(() => (init__10(), __exports10))),
        __memo(() => Promise.resolve().then(() => (init__11(), __exports11))),
        __memo(() => Promise.resolve().then(() => (init__12(), __exports12))),
        __memo(() => Promise.resolve().then(() => (init__13(), __exports13))),
        __memo(() => Promise.resolve().then(() => (init__14(), __exports14))),
        __memo(() => Promise.resolve().then(() => (init__15(), __exports15))),
        __memo(() => Promise.resolve().then(() => (init__16(), __exports16))),
        __memo(() => Promise.resolve().then(() => (init__17(), __exports17))),
        __memo(() => Promise.resolve().then(() => (init__18(), __exports18))),
        __memo(() => Promise.resolve().then(() => (init__19(), __exports19))),
        __memo(() => Promise.resolve().then(() => (init__20(), __exports20)))
      ],
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 6 },
          endpoint: null
        },
        {
          id: "/app",
          pattern: /^\/app\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 7 },
          endpoint: null
        },
        {
          id: "/app/pharmacies",
          pattern: /^\/app\/pharmacies\/?$/,
          params: [],
          page: { layouts: [0, 2, 3], errors: [1, , ,], leaf: 8 },
          endpoint: null
        },
        {
          id: "/app/pharmacies/new",
          pattern: /^\/app\/pharmacies\/new\/?$/,
          params: [],
          page: { layouts: [0, 2, 3], errors: [1, , ,], leaf: 12 },
          endpoint: null
        },
        {
          id: "/app/pharmacies/[pharmacyId]",
          pattern: /^\/app\/pharmacies\/([^/]+?)\/?$/,
          params: [{ "name": "pharmacyId", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2, 3], errors: [1, , ,], leaf: 9 },
          endpoint: null
        },
        {
          id: "/app/pharmacies/[pharmacyId]/edit",
          pattern: /^\/app\/pharmacies\/([^/]+?)\/edit\/?$/,
          params: [{ "name": "pharmacyId", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2, 3], errors: [1, , ,], leaf: 10 },
          endpoint: null
        },
        {
          id: "/app/pharmacies/[pharmacyId]/pharmacists",
          pattern: /^\/app\/pharmacies\/([^/]+?)\/pharmacists\/?$/,
          params: [{ "name": "pharmacyId", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2, 3], errors: [1, , ,], leaf: 11 },
          endpoint: null
        },
        {
          id: "/app/pharmacists",
          pattern: /^\/app\/pharmacists\/?$/,
          params: [],
          page: { layouts: [0, 2, 4], errors: [1, , ,], leaf: 13 },
          endpoint: null
        },
        {
          id: "/app/pharmacists/new",
          pattern: /^\/app\/pharmacists\/new\/?$/,
          params: [],
          page: { layouts: [0, 2, 4], errors: [1, , ,], leaf: 14 },
          endpoint: null
        },
        {
          id: "/auth/forgot-password",
          pattern: /^\/auth\/forgot-password\/?$/,
          params: [],
          page: { layouts: [0, 5], errors: [1, ,], leaf: 15 },
          endpoint: null
        },
        {
          id: "/auth/login",
          pattern: /^\/auth\/login\/?$/,
          params: [],
          page: { layouts: [0, 5], errors: [1, ,], leaf: 16 },
          endpoint: null
        },
        {
          id: "/auth/reset-password",
          pattern: /^\/auth\/reset-password\/?$/,
          params: [],
          page: { layouts: [0, 5], errors: [1, ,], leaf: 17 },
          endpoint: null
        },
        {
          id: "/auth/signup",
          pattern: /^\/auth\/signup\/?$/,
          params: [],
          page: { layouts: [0, 5], errors: [1, ,], leaf: 18 },
          endpoint: null
        },
        {
          id: "/auth/verify-email",
          pattern: /^\/auth\/verify-email\/?$/,
          params: [],
          page: { layouts: [0, 5], errors: [1, ,], leaf: 19 },
          endpoint: null
        }
      ],
      matchers: async () => {
        return {};
      },
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var app_path = "_app";

// .svelte-kit/cloudflare-tmp/_worker.js
async function e(e3, t2) {
  let n2 = "string" != typeof t2 && "HEAD" === t2.method;
  n2 && (t2 = new Request(t2, { method: "GET" }));
  let r3 = await e3.match(t2);
  return n2 && r3 && (r3 = new Response(null, r3)), r3;
}
function t(e3, t2, n2, o2) {
  return ("string" == typeof t2 || "GET" === t2.method) && r2(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t2, n2.clone()))), n2;
}
var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r2(e3) {
  if (!n.has(e3.status))
    return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*"))
    return false;
  let t2 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t2);
}
function o(n2) {
  return async function(r3, o2) {
    let a2 = await e(n2, r3);
    if (a2)
      return a2;
    o2.defer((e3) => {
      t(n2, r3, e3, o2);
    });
  };
}
var s2 = caches.default;
var c = t.bind(0, s2);
var r22 = e.bind(0, s2);
var e2 = o.bind(0, s2);
var server = new Server(manifest);
var immutable = `/${app_path}/immutable/`;
var version_file = `/${app_path}/version.json`;
var worker = {
  async fetch(req, env, context) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res)
      return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.substring(1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html");
    }
    let location2 = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env.ASSETS.fetch(req);
    } else if (location2 && prerendered.has(location2)) {
      if (search)
        location2 += search;
      res = new Response("", {
        status: 308,
        headers: {
          location: location2
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c(req, res, context) : res;
  }
};
var worker_default = worker;
export {
  worker_default as default
};
/**
 * @license lucide-svelte v0.378.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
/*!
* focus-trap 7.5.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! Bundled license information:

mapbox-gl/dist/mapbox-gl.js:
  (**
   * tiny-lru
   *
   * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 11.2.6
   *)
*/
//# sourceMappingURL=_worker.js.map
